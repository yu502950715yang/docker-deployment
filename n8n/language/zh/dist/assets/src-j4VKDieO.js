const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/en-BD3FHSTF.js","assets/en-b3uD8cvU.js"])))=>i.map(i=>d[i]);
import { a as __toCommonJS, n as __esmMin, o as __toESM, r as __export, t as __commonJSMin } from "./chunk-6z4oVpB-.js";
import { $ as onUpdated, $t as hasOwn$1, A as createStaticVNode, Bt as toRaw, C as computed, Cn as toDisplayString, D as createElementBlock, Dt as getCurrentScope, E as createCommentVNode, Et as effectScope, F as getCurrentInstance, Ft as readonly, G as nextTick, Gt as unref, H as mergeDefaults, Ht as toRefs, I as guardReactiveProps, It as ref, J as onBeforeUnmount, Jt as NOOP, L as h, M as createVNode, Mt as markRaw, Nt as onScopeDispose, P as defineComponent, Pt as reactive, Q as onUnmounted, Rt as shallowReadonly, S as cloneVNode, T as createBlock, Tn as toRawType, Tt as customRef, U as mergeModels, Ut as toValue$1, V as isVNode, Vt as toRef, W as mergeProps, Wt as triggerRef, Y as onDeactivated, Yt as camelize, Z as onMounted, _ as Fragment, _t as watch, an as isFunction$2, at as renderSlot, b as Teleport, bn as normalizeStyle, bt as withCtx, c as useCssModule, cn as isObject$2, ct as resolveDynamicComponent, dn as isPromise, dt as useId$2, et as openBlock, f as vModelText, ft as useModel, g as Comment, h as withModifiers, it as renderList, j as createTextVNode, jt as isRef, k as createSlots, lt as toHandlers, m as withKeys, mn as isString$2, mt as useTemplateRef, n as Transition, nn as isArray, nt as provide, ot as resolveComponent, p as vShow, pt as useSlots, q as onBeforeMount, rt as pushScopeId, st as resolveDirective, t as vue_runtime_esm_bundler_exports, tn as init_shared_esm_bundler, tt as popScopeId, u as vModelCheckbox, ut as useAttrs, vn as normalizeClass, vt as watchEffect, w as createBaseVNode, wn as toHandlerKey, x as Text, xt as withDirectives, yn as normalizeProps, yt as watchPostEffect, z as inject, zt as shallowRef } from "./vue.runtime.esm-bundler-tP5dCd7J.js";
import { E as useElementSize, N as useResizeObserver, O as useFavicon, Y as reactivePick, g as onClickOutside, it as useThrottleFn } from "./_MapCache-DZpzsuCB.js";
import { t as en_default } from "./en-b3uD8cvU.js";
import { t as __vitePreload } from "./preload-helper-CR0ecmWK.js";
import { t as __plugin_vue_export_helper_default } from "./_plugin-vue_export-helper-BwBpWJRZ.js";
import { $ as arrow_left_default, $t as _getNative_default, A as useGlobalSize, B as withInstall, Bt as get_default, Cn as useTimeoutFn$1, Ct as addUnit, D as _export_sfc, Dt as debugWarn, E as ElIcon, Et as removeClass, F as useNamespace, Gt as _Map_default, Ht as _toKey_default, I as useLocale$1, It as isNumber, J as iconPropType, Kt as _ListCache_default, L as componentSizeMap, Lt as isUndefined, M as useZIndex, Mt as escapeStringRegexp, Nt as isBoolean, Ot as throwError, P as useGetDerivedNamespace, Pt as isElement, Q as arrow_down_default, Qt as _defineProperty_default, R as componentSizes, Rt as _baseSet_default, S as isToolMessage, Sn as tryOnScopeDispose$1, St as addClass, T as createEventBus, Tt as hasClass, U as withNoopInstall, Ut as _castPath_default, V as withInstallDirective, Vt as _baseGet_default, Wt as _MapCache_default, X as buildProps, Y as buildProp, Yt as eq_default, Z as definePropType, Zt as _isIndex_default, _t as picture_filled_default, an as isSymbol_default, at as circle_close_default, b as isTaskAbortedMessage, bn as isClient$1, cn as _Symbol_default, ct as d_arrow_left_default, dn as isFirefox, en as _toSource_default, et as arrow_right_default, f as RouterLink, fn as onClickOutside$1, ft as hide_default, gn as useResizeObserver$2, gt as more_filled_default, hn as useEventListener$1, ht as more_default, j as useSizeProp, k as useGlobalConfig, ln as _root_default, lt as d_arrow_right_default, mt as minus_default, nn as isObject_default, on as isObjectLike_default, pn as unrefElement$1, pt as loading_default, q as ValidateComponentsMap, qt as _isKey_default, r as require_get, rn as isArray_default, sn as _baseGetTag_default, st as close_default, t as truncate, tn as isFunction_default, tt as arrow_up_default, un as _freeGlobal_default, vt as plus_default, w as require_lib$1, x as isThinkingGroupMessage, xn as isIOS$1, yt as view_default, z as EVENT_CODE, zt as fromPairs_default } from "./truncate-BlCeUq7F.js";
import { r as require_punycode, t as require_sanitize_html } from "./sanitize-html-Cft-jOcY.js";
import { S as $2b4dce13dd5a17fa$export$842a2cf37af977e1, _ as $3b62074eb05584b2$export$4475b7e617eb123c, a as $11d87f3f76e88657$export$b4a036af3fc0b032, b as $3b62074eb05584b2$export$c36e0ecb2d4fa69d, c as $14e0f24ef4ac5c92$export$5a8da0c44a3afdf2, d as $14e0f24ef4ac5c92$export$a18c89cbd24170ff, f as $14e0f24ef4ac5c92$export$a2258d9c4118825c, g as $14e0f24ef4ac5c92$export$ea39ec197993aef0, h as $14e0f24ef4ac5c92$export$d0bdf45af03a6ea3, l as $14e0f24ef4ac5c92$export$629b0a497aa65267, m as $14e0f24ef4ac5c92$export$aa8b41735afcabd2, n as $35ea8db9cb2ccb90$export$ca871e8dbb80966f, o as $14e0f24ef4ac5c92$export$2061056d06d7cdf7, p as $14e0f24ef4ac5c92$export$a5a3b454ada2268e, r as $35ea8db9cb2ccb90$export$d3b7288e7994edea, t as $35ea8db9cb2ccb90$export$99faa760c7908e4f, u as $14e0f24ef4ac5c92$export$91b62ebf2ba703ee, v as $3b62074eb05584b2$export$553d7fa8e3805fc0, x as $3b62074eb05584b2$export$f297eb839006d339, y as $3b62074eb05584b2$export$80ee6245ec4f29ec } from "./CalendarDate-B-JEhNYg.js";
var RE_NARGS = /(%|)\{([0-9a-zA-Z_]+)\}/g;
function format_default() {
	const isReplacementGroup = (target$1, key$2) => key$2 in target$1;
	function template(value, ...args) {
		if (typeof value === "function") return value(args);
		const str = value;
		let replacements = args;
		if (args.length === 1 && typeof args[0] === "object") replacements = args[0];
		if (!replacements?.hasOwnProperty) replacements = {};
		return str.replace(RE_NARGS, (match, _, group, index) => {
			let result;
			if (str[index - 1] === "{" && str[index + match.length] === "}") return `${group}`;
			else {
				result = isReplacementGroup(replacements, group) ? `${replacements[group]}` : null;
				if (result === null || result === void 0) return "";
				return result;
			}
		});
	}
	return template;
}
var __rolldown_dynamic_import_helper_default = (glob, path, segments) => {
	const query = path.lastIndexOf("?");
	const v$1 = glob[query === -1 || query < path.lastIndexOf("/") ? path : path.slice(0, query)];
	if (v$1) return typeof v$1 === "function" ? v$1() : Promise.resolve(v$1);
	return new Promise((_, reject) => {
		(typeof queueMicrotask === "function" ? queueMicrotask : setTimeout)(reject.bind(null, /* @__PURE__ */ new Error("Unknown variable dynamic import: " + path + (path.split("/").length !== segments ? ". Note that variables only represent file names one level deep." : ""))));
	});
};
var format = format_default();
var lang$1 = en_default;
var i18nHandler;
const t = function(path, options$1) {
	if (typeof i18nHandler === "function") {
		const value = i18nHandler(path, options$1);
		if (value !== null && value !== void 0 && value !== path) return String(value);
	}
	if (lang$1[path] !== void 0) return format(lang$1[path], ...options$1 ? [options$1] : []);
	return "";
};
async function use(l) {
	try {
		lang$1 = (await __rolldown_dynamic_import_helper_default({ "./lang/en.ts": () => __vitePreload(() => import("./en-BD3FHSTF.js"), __vite__mapDeps([0,1])) }, `./lang/${l}.ts`, 3)).default;
	} catch (e) {}
}
var _hoisted_1$292 = {
	xmlns: "http://www.w3.org/2000/svg",
	"xml:space": "preserve",
	id: "Layer_1",
	x: "0",
	y: "0",
	version: "1.1",
	viewBox: "0 0 92.2 65"
};
function render$230(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$292, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		d: "M66.5 0H52.4l25.7 65h14.1zM25.7 0 0 65h14.4l5.3-13.6h26.9L51.8 65h14.4L40.5 0zm-1.4 39.3 8.8-22.8 8.8 22.8z",
		style: { "fill": "#181818" }
	}, null, -1)]));
}
var anthropic_default = { render: render$230 };
var _hoisted_1$291 = {
	xmlns: "http://www.w3.org/2000/svg",
	viewBox: "0 0 12 12"
};
function render$229(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$291, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "currentColor",
		d: "M1 .643C1 .288 1.275 0 1.614 0h2.454c.34 0 .614.288.614.643V4.5c0 .355-.275.643-.614.643H1.614C1.274 5.143 1 4.855 1 4.5zm1.227.643v2.571h1.228V1.286zM6.318.643c0-.355.275-.643.614-.643h1.227c.339 0 .614.288.614.643v3.214h.613c.34 0 .614.288.614.643s-.275.643-.614.643H6.932c-.34 0-.614-.288-.614-.643s.275-.643.614-.643h.613V1.286h-.613c-.34 0-.614-.288-.614-.643M1 7.5c0-.355.275-.643.614-.643H2.84c.339 0 .614.288.614.643v3.214h.613c.34 0 .614.288.614.643S4.407 12 4.068 12H1.614c-.34 0-.614-.288-.614-.643s.275-.643.614-.643h.613V8.143h-.613C1.274 8.143 1 7.855 1 7.5m5.318 0c0-.355.275-.643.614-.643h2.454c.34 0 .614.288.614.643v3.857c0 .355-.275.643-.614.643H6.932c-.34 0-.614-.288-.614-.643zm1.227.643v2.571h1.228V8.143z"
	}, null, -1)]));
}
var binary_default = { render: render$229 };
var _hoisted_1$290 = {
	xmlns: "http://www.w3.org/2000/svg",
	fill: "none",
	viewBox: "0 0 24 24"
};
function render$228(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$290, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "currentColor",
		"fill-opacity": ".9",
		d: "M13.225 1.023a1.5 1.5 0 0 1 .866.096l.115.056.109.065a1.5 1.5 0 0 1 .506.551l.055.115.045.119a1.5 1.5 0 0 1 .023.87l-.01.039-1.92 6.02-.018.046H20a2 2 0 0 1 1.556 3.26l-.059.066-9.9 10.2a1.5 1.5 0 0 1-1.803.3 1.5 1.5 0 0 1-.738-1.721l.01-.04 1.92-6.019.017-.046H4a2.002 2.002 0 0 1-1.555-3.26l.058-.067 9.9-10.2c.22-.233.507-.392.823-.45",
		style: {
			"fill": "currentColor",
			"fill-opacity": ".9"
		}
	}, null, -1)]));
}
var bolt_filled_default = { render: render$228 };
var _hoisted_1$289 = {
	xmlns: "http://www.w3.org/2000/svg",
	fill: "none",
	viewBox: "0 0 512 512"
};
function render$227(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$289, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "currentColor",
		d: "M224.975 49.429c17.138-17.139 44.919-17.139 62.057 0l175.546 175.546a43.8 43.8 0 0 1 9.347 13.817l.146.349q.125.298.243.598.1.25.197.5l.147.388q.133.356.261.716l.09.257q.141.407.275.818l.044.136a39 39 0 0 1 .306.988 43.9 43.9 0 0 1 1.802 12.473c0 12.497-5.225 23.774-13.608 31.767L287.032 462.578c-17.138 17.138-44.919 17.138-62.057 0s-17.139-44.92 0-62.059l100.618-100.618H80.458c-24.238 0-43.887-19.649-43.887-43.886s19.65-43.887 43.887-43.887h245.158L224.975 111.486c-17.139-17.138-17.139-44.919 0-62.057"
	}, null, -1)]));
}
var continue_default = { render: render$227 };
var _hoisted_1$288 = {
	xmlns: "http://www.w3.org/2000/svg",
	fill: "none",
	viewBox: "0 0 512 512"
};
function render$226(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$288, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "currentColor",
		d: "M209.675 387.718c20.945 10.711 30.794 35.749 22.073 58.141-9.306 23.886-36.221 35.695-60.107 26.389-29.106-11.34-56.354-28.746-79.744-52.137-20.47-20.47-36.356-43.894-47.607-68.932l-4.53-10.812-1.517-4.508c-6.284-22.673 5.511-46.874 27.906-55.599 22.392-8.721 47.431 1.129 58.141 22.073l1.945 4.338 2.735 6.453c6.714 14.943 16.204 28.982 28.568 41.346 14.132 14.132 30.44 24.54 47.799 31.304zM91.897 91.905c23.39-23.39 50.638-40.796 79.744-52.137l4.508-1.517c22.673-6.284 46.874 5.512 55.599 27.906 9.303 23.885-2.526 50.781-26.411 60.086-17.359 6.763-33.667 17.171-47.799 31.303-12.364 12.364-21.854 26.403-28.568 41.347l-2.735 6.453-1.945 4.337c-10.71 20.945-35.75 30.794-58.141 22.073-23.886-9.306-35.695-36.221-26.39-60.107 11.341-29.106 28.747-56.353 52.138-79.744M354.462 354.47c12.364-12.364 21.854-26.403 28.568-41.346l2.735-6.453 1.945-4.338c10.71-20.944 35.749-30.794 58.141-22.073 22.394 8.725 34.19 32.926 27.906 55.599l-1.517 4.508-4.53 10.812c-11.251 25.038-27.137 48.462-47.607 68.932-23.39 23.391-50.638 40.797-79.744 52.137-23.886 9.306-50.801-2.503-60.107-26.389-9.303-23.885 2.526-50.78 26.411-60.085l6.453-2.735c14.943-6.715 28.982-16.205 41.346-28.569m65.641-262.565c23.391 23.391 40.796 50.638 52.137 79.744 9.306 23.886-2.503 50.801-26.389 60.107-22.392 8.721-47.431-1.128-58.141-22.073l-1.945-4.337-2.735-6.453c-6.714-14.944-16.204-28.983-28.568-41.347-14.132-14.132-30.44-24.54-47.799-31.303-23.885-9.305-35.714-36.201-26.411-60.086 9.306-23.886 36.221-35.694 60.107-26.389l10.812 4.53c25.038 11.25 48.462 27.137 68.932 47.607"
	}, null, -1)]));
}
var empty_output_default = { render: render$226 };
var _hoisted_1$287 = {
	xmlns: "http://www.w3.org/2000/svg",
	fill: "currentColor",
	overflow: "hidden",
	viewBox: "0 0 10 10"
};
function render$225(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$287, _cache[0] || (_cache[0] = [createBaseVNode("rect", {
		width: "10",
		height: "10",
		rx: "2",
		ry: "2"
	}, null, -1)]));
}
var filled_square_default = { render: render$225 };
var _hoisted_1$286 = {
	xmlns: "http://www.w3.org/2000/svg",
	fill: "none",
	viewBox: "0 0 24 24"
};
function render$224(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$286, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "M9 3v18M15 3v18",
		style: { "stroke-opacity": "1" }
	}, null, -1)]));
}
var grip_lines_vertical_default = { render: render$224 };
var _hoisted_1$285 = {
	xmlns: "http://www.w3.org/2000/svg",
	width: "121",
	height: "122",
	fill: "none",
	viewBox: "0 0 121 122"
};
function render$223(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$285, _cache[0] || (_cache[0] = [createStaticVNode("<mask id=\"mask0_572_319\" width=\"121\" height=\"122\" x=\"0\" y=\"0\" maskUnits=\"userSpaceOnUse\" style=\"mask-type:alpha;\"><path fill=\"url(#paint0_linear_572_319)\" fill-rule=\"evenodd\" d=\"M36.069 0c19.92 0 36.068 16.155 36.068 36.084v13.713h12.004c19.92 0 36.069 16.156 36.069 36.084s-16.149 36.083-36.069 36.083H0v-85.88C0 16.155 16.148 0 36.069 0\" clip-rule=\"evenodd\"></path></mask><g mask=\"url(#mask0_572_319)\"><g filter=\"url(#filter0_f_572_319)\"><ellipse cx=\"52.738\" cy=\"65.101\" fill=\"#4B73FF\" rx=\"81.373\" ry=\"81.192\"></ellipse></g><g filter=\"url(#filter1_f_572_319)\"><ellipse cx=\"61.673\" cy=\"20.547\" fill=\"#FF66F4\" rx=\"104.216\" ry=\"81.192\"></ellipse></g><g filter=\"url(#filter2_f_572_319)\"><ellipse cx=\"78.666\" cy=\"5.268\" fill=\"#FF0105\" rx=\"81.373\" ry=\"71.304\"></ellipse></g><g filter=\"url(#filter3_f_572_319)\"><ellipse cx=\"63.121\" cy=\"20.527\" fill=\"#FE7B02\" rx=\"48.937\" ry=\"48.829\"></ellipse></g></g><defs><filter id=\"filter0_f_572_319\" width=\"235.52\" height=\"235.159\" x=\"-65.022\" y=\"-52.478\" color-interpolation-filters=\"sRGB\" filterUnits=\"userSpaceOnUse\"><feFlood flood-opacity=\"0\" result=\"BackgroundImageFix\"></feFlood><feBlend in=\"SourceGraphic\" in2=\"BackgroundImageFix\" result=\"shape\"></feBlend><feGaussianBlur result=\"effect1_foregroundBlur_572_319\" stdDeviation=\"18.194\"></feGaussianBlur></filter><filter id=\"filter1_f_572_319\" width=\"281.208\" height=\"235.159\" x=\"-78.93\" y=\"-97.032\" color-interpolation-filters=\"sRGB\" filterUnits=\"userSpaceOnUse\"><feFlood flood-opacity=\"0\" result=\"BackgroundImageFix\"></feFlood><feBlend in=\"SourceGraphic\" in2=\"BackgroundImageFix\" result=\"shape\"></feBlend><feGaussianBlur result=\"effect1_foregroundBlur_572_319\" stdDeviation=\"18.194\"></feGaussianBlur></filter><filter id=\"filter2_f_572_319\" width=\"235.52\" height=\"215.383\" x=\"-39.094\" y=\"-102.423\" color-interpolation-filters=\"sRGB\" filterUnits=\"userSpaceOnUse\"><feFlood flood-opacity=\"0\" result=\"BackgroundImageFix\"></feFlood><feBlend in=\"SourceGraphic\" in2=\"BackgroundImageFix\" result=\"shape\"></feBlend><feGaussianBlur result=\"effect1_foregroundBlur_572_319\" stdDeviation=\"18.194\"></feGaussianBlur></filter><filter id=\"filter3_f_572_319\" width=\"170.649\" height=\"170.432\" x=\"-22.204\" y=\"-64.688\" color-interpolation-filters=\"sRGB\" filterUnits=\"userSpaceOnUse\"><feFlood flood-opacity=\"0\" result=\"BackgroundImageFix\"></feFlood><feBlend in=\"SourceGraphic\" in2=\"BackgroundImageFix\" result=\"shape\"></feBlend><feGaussianBlur result=\"effect1_foregroundBlur_572_319\" stdDeviation=\"18.194\"></feGaussianBlur></filter><linearGradient id=\"paint0_linear_572_319\" x1=\"40.453\" x2=\"76.933\" y1=\"21.433\" y2=\"121.971\" gradientUnits=\"userSpaceOnUse\"><stop offset=\".025\" stop-color=\"#FF8E63\"></stop><stop offset=\".56\" stop-color=\"#FF7EB0\"></stop><stop offset=\".95\" stop-color=\"#4B73FF\"></stop></linearGradient></defs>", 3)]));
}
var lovable_default = { render: render$223 };
var _hoisted_1$284 = {
	xmlns: "http://www.w3.org/2000/svg",
	width: "1em",
	height: "1em",
	fill: "currentColor",
	"fill-rule": "evenodd",
	style: {
		"flex": "none",
		"line-height": "1"
	},
	viewBox: "0 0 24 24"
};
function render$222(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$284, _cache[0] || (_cache[0] = [createBaseVNode("path", { d: "M15.688 2.343a2.59 2.59 0 0 0-3.61 0l-9.626 9.44a.863.863 0 0 1-1.203 0 .823.823 0 0 1 0-1.18l9.626-9.44a4.313 4.313 0 0 1 6.016 0 4.12 4.12 0 0 1 1.204 3.54 4.3 4.3 0 0 1 3.609 1.18l.05.05a4.115 4.115 0 0 1 0 5.9l-8.706 8.537a.274.274 0 0 0 0 .393l1.788 1.754a.823.823 0 0 1 0 1.18.863.863 0 0 1-1.203 0l-1.788-1.753a1.92 1.92 0 0 1 0-2.754l8.706-8.538a2.47 2.47 0 0 0 0-3.54l-.05-.049a2.59 2.59 0 0 0-3.607-.003l-7.172 7.034-.002.002-.098.097a.863.863 0 0 1-1.204 0 .823.823 0 0 1 0-1.18l7.273-7.133a2.47 2.47 0 0 0-.003-3.537" }, null, -1), createBaseVNode("path", { d: "M14.485 4.703a.823.823 0 0 0 0-1.18.863.863 0 0 0-1.204 0l-7.119 6.982a4.115 4.115 0 0 0 0 5.9 4.314 4.314 0 0 0 6.016 0l7.12-6.982a.823.823 0 0 0 0-1.18.863.863 0 0 0-1.204 0l-7.119 6.982a2.59 2.59 0 0 1-3.61 0 2.47 2.47 0 0 1 0-3.54z" }, null, -1)]));
}
var mcp_default = { render: render$222 };
var _hoisted_1$283 = {
	xmlns: "http://www.w3.org/2000/svg",
	width: "24",
	height: "24",
	fill: "none",
	viewBox: "0 0 24 24"
};
function render$221(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$283, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "currentColor",
		d: "M10.12 3.3c.911-1.395 3.012-1.349 3.844.14l8.222 14.712c.838 1.5-.246 3.348-1.964 3.348H3.778c-1.718 0-2.802-1.848-1.964-3.348L10.036 3.44zM5.057 18.5h13.886L12 6.073z"
	}, null, -1)]));
}
var node_dirty_default = { render: render$221 };
var _hoisted_1$282 = {
	xmlns: "http://www.w3.org/2000/svg",
	width: "24",
	height: "24",
	fill: "none",
	viewBox: "0 0 24 24"
};
function render$220(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$282, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "currentColor",
		d: "M4.5 9.5a2.5 2.5 0 1 1 0 5 2.5 2.5 0 0 1 0-5m7.5 0a2.5 2.5 0 1 1 0 5 2.5 2.5 0 0 1 0-5m7.5 0a2.5 2.5 0 1 1 0 5 2.5 2.5 0 0 1 0-5"
	}, null, -1)]));
}
var node_ellipsis_default = { render: render$220 };
var _hoisted_1$281 = {
	xmlns: "http://www.w3.org/2000/svg",
	width: "24",
	height: "24",
	fill: "none",
	viewBox: "0 0 24 24"
};
function render$219(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$281, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "currentColor",
		"fill-rule": "evenodd",
		d: "M12 1c6.075 0 11 4.925 11 11s-4.925 11-11 11S1 18.075 1 12 5.925 1 12 1m5.56 5.44a1.5 1.5 0 0 0-2.12 0L12 9.878l-3.44-3.44A1.5 1.5 0 1 0 6.44 8.56L9.878 12l-3.44 3.44a1.5 1.5 0 1 0 2.122 2.12L12 14.122l3.44 3.44.114.103a1.5 1.5 0 0 0 2.11-2.11l-.104-.114L14.122 12l3.44-3.44a1.5 1.5 0 0 0 0-2.12",
		"clip-rule": "evenodd"
	}, null, -1)]));
}
var node_execution_error_default = { render: render$219 };
var _hoisted_1$280 = {
	xmlns: "http://www.w3.org/2000/svg",
	width: "24",
	height: "24",
	fill: "none",
	viewBox: "0 0 24 24"
};
function render$218(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$280, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "currentColor",
		d: "M16.297 2.515A3 3 0 0 1 16 8.5v2.26l.01.138a1 1 0 0 0 .545.756l.006.003 1.774.898.184.1A3 3 0 0 1 20 15.238V16a2 2 0 0 1-2 2h-4.5v4a1.5 1.5 0 0 1-3 0v-4H6a2 2 0 0 1-1.99-1.803L4 16v-.76l.008-.209a3 3 0 0 1 1.657-2.476l1.773-.898.007-.003a1 1 0 0 0 .545-.756L8 10.76V8.5a3 3 0 0 1 0-6h8z"
	}, null, -1)]));
}
var node_pin_default = { render: render$218 };
var _hoisted_1$279 = {
	xmlns: "http://www.w3.org/2000/svg",
	width: "24",
	height: "24",
	fill: "none",
	viewBox: "0 0 24 24"
};
function render$217(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$279, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "currentColor",
		d: "M5.52 2.122c.322-.175.713-.16 1.021.037l14 9a1 1 0 0 1 0 1.682l-14 9A1.001 1.001 0 0 1 5 21V3a1 1 0 0 1 .52-.878"
	}, null, -1)]));
}
var node_play_default = { render: render$217 };
var _hoisted_1$278 = {
	xmlns: "http://www.w3.org/2000/svg",
	width: "24",
	height: "24",
	fill: "none",
	viewBox: "0 0 24 24"
};
function render$216(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$278, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "currentColor",
		d: "M16.645 5.907a1.5 1.5 0 0 1 2.122.028 9.77 9.77 0 0 1 2.585 4.953 9.9 9.9 0 0 1-.53 5.579 9.66 9.66 0 0 1-3.476 4.357 9.36 9.36 0 0 1-5.28 1.657 9.36 9.36 0 0 1-5.292-1.623 9.66 9.66 0 0 1-3.504-4.335 9.9 9.9 0 0 1-.564-5.576 9.77 9.77 0 0 1 2.556-4.97l.11-.105a1.501 1.501 0 0 1 2.05 2.187l-.166.178a6.8 6.8 0 0 0-1.602 3.266 6.9 6.9 0 0 0 .393 3.884 6.66 6.66 0 0 0 2.413 2.989 6.36 6.36 0 0 0 3.595 1.105 6.36 6.36 0 0 0 3.59-1.128 6.66 6.66 0 0 0 2.394-3.005 6.9 6.9 0 0 0 .37-3.887 6.77 6.77 0 0 0-1.79-3.433 1.5 1.5 0 0 1 .026-2.12"
	}, null, -1), createBaseVNode("path", {
		fill: "currentColor",
		d: "M12.035 1.481a1.5 1.5 0 0 1 1.5 1.5v9a1.5 1.5 0 0 1-3 0v-9a1.5 1.5 0 0 1 1.5-1.5"
	}, null, -1)]));
}
var node_power_default = { render: render$216 };
var _hoisted_1$277 = {
	xmlns: "http://www.w3.org/2000/svg",
	width: "24",
	height: "24",
	fill: "none",
	viewBox: "0 0 24 24"
};
function render$215(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$277, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "currentColor",
		d: "M19.94 5.502a1.5 1.5 0 1 1 2.12 2.12L9.687 19.999a1.5 1.5 0 0 1-2.122 0L1.94 14.373a1.5 1.5 0 0 1 2.007-2.225l.115.104 4.564 4.564z"
	}, null, -1)]));
}
var node_success_default = { render: render$215 };
var _hoisted_1$276 = {
	xmlns: "http://www.w3.org/2000/svg",
	width: "24",
	height: "24",
	fill: "none",
	viewBox: "0 0 24 24"
};
function render$214(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$276, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "currentColor",
		d: "M21 6a1 1 0 1 1 0 2h-1v12.125c0 .817-.424 1.534-.941 2.019-.522.488-1.256.856-2.059.856H7c-.803 0-1.537-.368-2.059-.856C4.424 21.659 4 20.943 4 20.125V8H3a1 1 0 0 1 0-2zm-7-5a3 3 0 0 1 3 3H7a3 3 0 0 1 3-3z"
	}, null, -1)]));
}
var node_trash_default = { render: render$214 };
var _hoisted_1$275 = {
	xmlns: "http://www.w3.org/2000/svg",
	width: "24",
	height: "24",
	fill: "none",
	viewBox: "0 0 24 24"
};
function render$213(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$275, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "currentColor",
		d: "M10.05 2.385c.866-1.503 3.034-1.503 3.9 0l9.357 16.242c.864 1.5-.219 3.373-1.95 3.373H2.642C.912 22-.17 20.127.693 18.627zM12 16a1.5 1.5 0 1 0 0 3 1.5 1.5 0 0 0 0-3m0-8.5A1.5 1.5 0 0 0 10.5 9v3.5a1.5 1.5 0 0 0 3 0V9A1.5 1.5 0 0 0 12 7.5"
	}, null, -1)]));
}
var node_validation_error_default = { render: render$213 };
var _hoisted_1$274 = {
	xmlns: "http://www.w3.org/2000/svg",
	viewBox: "0 0 16 16"
};
function render$212(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$274, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "currentColor",
		d: "M13.333 12.553v-.104a2.48 2.48 0 0 0 1.524-2.286V3.62a2.476 2.476 0 0 0-2.476-2.476H5.905a2.48 2.48 0 0 0-2.357 1.714h-.153c-.695 0-1.286.245-1.693.727-.395.467-.56 1.09-.56 1.75V12c0 .808.293 1.535.847 2.057.553.52 1.32.797 2.201.797h2.987l3.106.003h.001c.744.004 1.48-.152 2.052-.518.594-.38.997-.987.997-1.787M3.395 4h.034v6.163a2.476 2.476 0 0 0 2.476 2.476h6.282c-.024.318-.184.556-.467.737-.33.212-.83.341-1.431.338h-.003l-3.11-.003H4.19c-.642 0-1.112-.199-1.417-.486-.303-.285-.487-.7-.487-1.225V5.334c0-.484.122-.813.29-1.013.155-.184.405-.32.819-.32m4.622-.19h3.602a.57.57 0 0 1 .571.571v3.603a.572.572 0 0 1-1.142 0V5.76L7.07 9.737a.572.572 0 1 1-.807-.808l3.977-3.976H8.017a.571.571 0 1 1 0-1.143"
	}, null, -1)]));
}
var pop_out_default = { render: render$212 };
var _hoisted_1$273 = {
	xmlns: "http://www.w3.org/2000/svg",
	width: "28",
	height: "28",
	fill: "none",
	viewBox: "0 0 28 28"
};
function render$211(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$273, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "currentColor",
		d: "M23.088 0h-9.094l2.81 8.758h9.094l-7.357 5.223 2.811 8.807c4.736-3.45 6.283-8.67 4.547-14.03zM2.09 8.758h9.093L13.994 0H4.902zc-1.737 5.36-.19 10.58 4.546 14.03l2.81-8.808zm4.546 14.03L13.994 28l7.358-5.212-7.358-5.298z"
	}, null, -1)]));
}
var resolver_default = { render: render$211 };
var _hoisted_1$272 = {
	xmlns: "http://www.w3.org/2000/svg",
	viewBox: "0 0 512 512"
};
function render$210(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$272, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "currentColor",
		d: "M416.648 227.85c23.324 0 42.232 18.908 42.232 42.232v84.462c0 38.872-31.513 70.384-70.385 70.385H191.423v36.402c0 12.541-15.163 18.822-24.031 9.954l-78.63-78.631c-5.498-5.497-5.498-14.411 0-19.908l78.63-78.631c8.868-8.868 24.031-2.587 24.031 9.954v36.398h182.995v-70.385c0-23.324 18.907-42.231 42.23-42.232M304.028 50.669c0-12.541 15.163-18.822 24.031-9.954l78.63 78.631c5.498 5.497 5.498 14.41 0 19.908l-78.63 78.631c-8.868 8.867-24.031 2.587-24.031-9.954v-36.38H121.033v70.385c0 23.324-18.908 42.231-42.231 42.231s-42.23-18.907-42.23-42.231v-84.462c0-38.872 31.512-70.385 70.384-70.385h197.072z"
	}, null, -1)]));
}
var retry_default = { render: render$210 };
var _hoisted_1$271 = {
	xmlns: "http://www.w3.org/2000/svg",
	fill: "none",
	viewBox: "0 0 512 512"
};
function render$209(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$271, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "currentColor",
		d: "M275.114 36.8c22.13 2.247 39.401 20.934 39.401 43.657v307.204h73.142c24.237 0 43.886 19.648 43.886 43.885s-19.648 43.886-43.886 43.886H153.6c-24.238-.001-43.886-19.649-43.886-43.886s19.648-43.885 43.886-43.885h73.143V124.343H153.6c-24.238 0-43.886-19.649-43.886-43.886s19.648-43.885 43.886-43.886h117.029z"
	}, null, -1)]));
}
var run_once_default = { render: render$209 };
var _hoisted_1$270 = {
	xmlns: "http://www.w3.org/2000/svg",
	viewBox: "0 -1 14 14"
};
function render$208(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$270, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "currentColor",
		d: "M1.636 0h6.546a1.636 1.636 0 1 1 0 3.273H1.636a1.636 1.636 0 0 1 0-3.273m0 1.09a.545.545 0 0 0 0 1.092h6.546a.545.545 0 0 0 0-1.091zm5.455 3.274h4.363a1.636 1.636 0 1 1 0 3.272H7.091a1.636 1.636 0 1 1 0-3.272m0 1.09a.545.545 0 1 0 0 1.091h4.363a.545.545 0 1 0 0-1.09zm0 3.273h4.363a1.636 1.636 0 1 1 0 3.273H7.091a1.636 1.636 0 1 1 0-3.273m0 1.091a.545.545 0 0 0 0 1.091h4.363a.545.545 0 1 0 0-1.09z"
	}, null, -1)]));
}
var schema_default = { render: render$208 };
var _hoisted_1$269 = {
	xmlns: "http://www.w3.org/2000/svg",
	fill: "none",
	viewBox: "0 0 24 24"
};
function render$207(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$269, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-width": "2",
		d: "M12 2v3M12 19v3M12 2v3M12 19v3M22.005 11.995h-3M5.005 11.995h-3M19.08 19.068l-2.122-2.122M7.059 7.047 4.938 4.926M4.938 19.068l2.12-2.122M16.958 7.047l2.122-2.121",
		style: {
			"stroke": "currentColor",
			"stroke-opacity": "1"
		}
	}, null, -1)]));
}
var spinner_default = { render: render$207 };
var _hoisted_1$268 = {
	xmlns: "http://www.w3.org/2000/svg",
	viewBox: "0 0 14 14"
};
function render$206(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$268, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "currentColor",
		d: "M14 7A7 7 0 1 1 0 7a7 7 0 0 1 14 0m-2.757-1H2.758v2h8.485z"
	}, null, -1)]));
}
var status_canceled_default = { render: render$206 };
var _hoisted_1$267 = {
	xmlns: "http://www.w3.org/2000/svg",
	viewBox: "0 0 14 14"
};
function render$205(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$267, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "currentColor",
		d: "M14 7A7 7 0 1 1 0 7a7 7 0 0 1 14 0m-11.425.728 3.207 3.207 5.707-5.707-1.414-1.414-4.293 4.293-1.793-1.793z"
	}, null, -1)]));
}
var status_completed_default = { render: render$205 };
var _hoisted_1$266 = {
	xmlns: "http://www.w3.org/2000/svg",
	viewBox: "0 0 14 14"
};
function render$204(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$266, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "currentColor",
		d: "M4.207 2.793 7 5.586l2.793-2.793 1.414 1.414L8.414 7l2.793 2.793-1.414 1.414L7 8.414l-2.793 2.793-1.414-1.414L5.586 7 2.793 4.207zM7 0a7 7 0 1 0 0 14A7 7 0 0 0 7 0"
	}, null, -1)]));
}
var status_error_default = { render: render$204 };
var _hoisted_1$265 = {
	xmlns: "http://www.w3.org/2000/svg",
	viewBox: "0 0 14 14"
};
function render$203(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$265, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "currentColor",
		d: "M14 7.006c0 1.861-.838 3.738-2.05 4.95s-3.089 2.05-4.95 2.05-3.738-.838-4.95-2.05S0 8.867 0 7.006s.838-3.738 2.05-4.95S5.139.006 7 .006s3.738.838 4.95 2.05S14 5.145 14 7.006M10.536 3.47C9.576 2.511 8.453 2.006 7 2.006s-2.576.505-3.536 1.464C2.505 4.43 2 5.553 2 7.006s.505 2.576 1.464 3.536c.96.959 2.083 1.464 3.536 1.464s2.576-.505 3.536-1.464C11.495 9.582 12 8.459 12 7.006s-.505-2.576-1.464-3.536"
	}, null, -1)]));
}
var status_new_default = { render: render$203 };
var _hoisted_1$264 = {
	xmlns: "http://www.w3.org/2000/svg",
	viewBox: "0 0 14 14"
};
function render$202(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$264, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "currentColor",
		d: "m13.867 8.366-1.962-.388a5 5 0 0 0 0-1.956l1.962-.388a7 7 0 0 1 0 2.732M12.82 3.111l-1.662 1.112a5 5 0 0 0-1.382-1.382l1.112-1.662a7 7 0 0 1 1.932 1.932M8.366.133l-.388 1.962a5 5 0 0 0-1.956 0L5.634.133a7 7 0 0 1 2.732 0M3.111 1.18l1.112 1.662a5 5 0 0 0-1.382 1.382L1.179 3.111a7 7 0 0 1 1.932-1.932M.133 5.634a7 7 0 0 0 0 2.732l1.962-.388a5 5 0 0 1 0-1.956zm1.046 5.255 1.662-1.112a5 5 0 0 0 1.382 1.382l-1.112 1.662a7 7 0 0 1-1.932-1.932m4.455 2.978.388-1.962a5 5 0 0 0 1.956 0l.388 1.962a7 7 0 0 1-2.732 0m5.255-1.046-1.112-1.662a5 5 0 0 0 1.382-1.382l1.662 1.112a7 7 0 0 1-1.932 1.932"
	}, null, -1)]));
}
var status_unknown_default = { render: render$202 };
var _hoisted_1$263 = {
	xmlns: "http://www.w3.org/2000/svg",
	viewBox: "0 0 14 14"
};
function render$201(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$263, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "currentColor",
		d: "M7 14A7 7 0 1 0 7 0a7 7 0 0 0 0 14m0-2A5 5 0 1 1 7 2a5 5 0 0 1 0 10M6 3v5h5a5 5 0 0 0-5-5"
	}, null, -1)]));
}
var status_waiting_default = { render: render$201 };
var _hoisted_1$262 = {
	xmlns: "http://www.w3.org/2000/svg",
	viewBox: "0 0 14 14"
};
function render$200(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$262, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "currentColor",
		d: "M14 7A7 7 0 1 1 0 7a7 7 0 0 1 14 0M6.5 9a.5.5 0 0 0-.5.5v1a.5.5 0 0 0 .5.5h1a.5.5 0 0 0 .5-.5v-1a.5.5 0 0 0-.5-.5zm0-6a.5.5 0 0 0-.5.5v4a.5.5 0 0 0 .5.5h1a.5.5 0 0 0 .5-.5v-4a.5.5 0 0 0-.5-.5z"
	}, null, -1)]));
}
var status_warning_default = { render: render$200 };
var _hoisted_1$261 = {
	xmlns: "http://www.w3.org/2000/svg",
	viewBox: "0 0 12 12"
};
function render$199(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$261, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "currentColor",
		d: "M0 .667C0 .298.298 0 .667 0h10.666a.667.667 0 1 1 0 1.333H.667A.667.667 0 0 1 0 .667M0 3.63c0-.369.298-.667.667-.667h10.666a.667.667 0 1 1 0 1.333H.667A.667.667 0 0 1 0 3.63m0 2.963c0-.369.298-.667.667-.667h10.666a.667.667 0 1 1 0 1.333H.667A.667.667 0 0 1 0 6.593m0 2.963c0-.369.298-.667.667-.667h8a.667.667 0 0 1 0 1.333h-8A.667.667 0 0 1 0 9.556"
	}, null, -1)]));
}
var text_default = { render: render$199 };
var _hoisted_1$260 = {
	xmlns: "http://www.w3.org/2000/svg",
	fill: "none",
	"aria-hidden": "true",
	viewBox: "0 0 24 24"
};
function render$198(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$260, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-width": "2",
		d: "M8 8V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v4m6 12V10a2 2 0 0 0-2-2H4a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2ZM8 13v4m8-4v4M2 15h20",
		style: {
			"stroke": "currentColor",
			"stroke-opacity": "1"
		}
	}, null, -1)]));
}
var toolbox_default = { render: render$198 };
var _hoisted_1$259 = {
	xmlns: "http://www.w3.org/2000/svg",
	viewBox: "0 0 512 512"
};
function render$197(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$259, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "currentColor",
		d: "M214.433 56c18.475-32 64.663-32 83.138 0l180.133 312c18.476 32-4.619 72-41.569 72H75.869c-36.951 0-60.045-40-41.57-72zm41.569 88L131.294 360h249.415z"
	}, null, -1)]));
}
var triangle_default = { render: render$197 };
var _hoisted_1$258 = {
	xmlns: "http://www.w3.org/2000/svg",
	fill: "none",
	viewBox: "0 0 24 24"
};
function render$196(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$258, _cache[0] || (_cache[0] = [createStaticVNode("<rect width=\"5\" height=\"5\" x=\"2\" y=\"2\" stroke=\"currentColor\" stroke-width=\"2\" rx=\"1\" style=\"stroke:currentColor;stroke-opacity:1;\"></rect><rect width=\"5\" height=\"5\" x=\"17\" y=\"2\" stroke=\"currentColor\" stroke-width=\"2\" rx=\"1\" style=\"stroke:currentColor;stroke-opacity:1;\"></rect><rect width=\"5\" height=\"5\" x=\"17\" y=\"17\" stroke=\"currentColor\" stroke-width=\"2\" rx=\"1\" style=\"stroke:currentColor;stroke-opacity:1;\"></rect><rect width=\"5\" height=\"5\" x=\"2\" y=\"17\" stroke=\"currentColor\" stroke-width=\"2\" rx=\"1\" style=\"stroke:currentColor;stroke-opacity:1;\"></rect><path fill=\"currentColor\" d=\"M7 3h10v2H7zM7 19h10v2H7zM3 7h2v10H3zM19 7h2v10h-2z\" style=\"fill:currentColor;fill-opacity:1;\"></path>", 5)]));
}
var vector_square_default = { render: render$196 };
var _hoisted_1$257 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$195(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$257, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "M21 12H9m12 6H7M21 6H3"
	}, null, -1)]));
}
var align_right_default = {
	name: "lucide-align-right",
	render: render$195
};
var _hoisted_1$256 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$194(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$256, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("rect", {
		width: "20",
		height: "5",
		x: "2",
		y: "3",
		rx: "1"
	}), createBaseVNode("path", { d: "M4 8v11a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8m-10 4h4" })], -1)]));
}
var archive_default = {
	name: "lucide-archive",
	render: render$194
};
var _hoisted_1$255 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$193(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$255, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("rect", {
		width: "20",
		height: "5",
		x: "2",
		y: "3",
		rx: "1"
	}), createBaseVNode("path", { d: "M4 8v11a2 2 0 0 0 2 2h2M20 8v11a2 2 0 0 1-2 2h-2m-7-6l3-3l3 3m-3-3v9" })], -1)]));
}
var archive_restore_default = {
	name: "lucide-archive-restore",
	render: render$193
};
var _hoisted_1$254 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$192(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$254, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "M12 5v14m7-7l-7 7l-7-7"
	}, null, -1)]));
}
var arrow_down_default$1 = {
	name: "lucide-arrow-down",
	render: render$192
};
var _hoisted_1$253 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$191(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$253, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "m12 19l-7-7l7-7m7 7H5"
	}, null, -1)]));
}
var arrow_left_default$1 = {
	name: "lucide-arrow-left",
	render: render$191
};
var _hoisted_1$252 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$190(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$252, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "M8 3L4 7l4 4M4 7h16m-4 14l4-4l-4-4m4 4H4"
	}, null, -1)]));
}
var arrow_left_right_default = {
	name: "lucide-arrow-left-right",
	render: render$190
};
var _hoisted_1$251 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$189(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$251, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "M5 12h14m-7-7l7 7l-7 7"
	}, null, -1)]));
}
var arrow_right_default$1 = {
	name: "lucide-arrow-right",
	render: render$189
};
var _hoisted_1$250 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$188(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$250, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "M3 5v14m18-7H7m8 6l6-6l-6-6"
	}, null, -1)]));
}
var arrow_right_from_line_default = {
	name: "lucide-arrow-right-from-line",
	render: render$188
};
var _hoisted_1$249 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$187(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$249, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "M17 12H3m8 6l6-6l-6-6m10-1v14"
	}, null, -1)]));
}
var arrow_right_to_line_default = {
	name: "lucide-arrow-right-to-line",
	render: render$187
};
var _hoisted_1$248 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$186(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$248, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "m5 12l7-7l7 7m-7 7V5"
	}, null, -1)]));
}
var arrow_up_default$1 = {
	name: "lucide-arrow-up",
	render: render$186
};
var _hoisted_1$247 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$185(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$247, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "M7 7h10v10M7 17L17 7"
	}, null, -1)]));
}
var arrow_up_right_default = {
	name: "lucide-arrow-up-right",
	render: render$185
};
var _hoisted_1$246 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$184(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$246, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("circle", {
		cx: "12",
		cy: "12",
		r: "4"
	}), createBaseVNode("path", { d: "M16 8v5a3 3 0 0 0 6 0v-1a10 10 0 1 0-4 8" })], -1)]));
}
var at_sign_default = {
	name: "lucide-at-sign",
	render: render$184
};
var _hoisted_1$245 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$183(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$245, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("circle", {
		cx: "12",
		cy: "12",
		r: "10"
	}), createBaseVNode("path", { d: "m4.9 4.9l14.2 14.2" })], -1)]));
}
var ban_default = {
	name: "lucide-ban",
	render: render$183
};
var _hoisted_1$244 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$182(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$244, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "M10.268 21a2 2 0 0 0 3.464 0m-10.47-5.674A1 1 0 0 0 4 17h16a1 1 0 0 0 .74-1.673C19.41 13.956 18 12.499 18 8A6 6 0 0 0 6 8c0 4.499-1.411 5.956-2.738 7.326"
	}, null, -1)]));
}
var bell_default = {
	name: "lucide-bell",
	render: render$182
};
var _hoisted_1$243 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$181(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$243, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "M4 19.5v-15A2.5 2.5 0 0 1 6.5 2H19a1 1 0 0 1 1 1v18a1 1 0 0 1-1 1H6.5a1 1 0 0 1 0-5H20"
	}, null, -1)]));
}
var book_default = {
	name: "lucide-book",
	render: render$181
};
var _hoisted_1$242 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$180(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$242, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "M12 7v14m-9-3a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h5a4 4 0 0 1 4 4a4 4 0 0 1 4-4h5a1 1 0 0 1 1 1v13a1 1 0 0 1-1 1h-6a3 3 0 0 0-3 3a3 3 0 0 0-3-3z"
	}, null, -1)]));
}
var book_open_default = {
	name: "lucide-book-open",
	render: render$180
};
var _hoisted_1$241 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$179(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$241, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [
		createBaseVNode("path", { d: "M12 8V4H8" }),
		createBaseVNode("rect", {
			width: "16",
			height: "12",
			x: "4",
			y: "8",
			rx: "2"
		}),
		createBaseVNode("path", { d: "M2 14h2m16 0h2m-7-1v2m-6-2v2" })
	], -1)]));
}
var bot_default = {
	name: "lucide-bot",
	render: render$179
};
var _hoisted_1$240 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$178(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$240, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("path", { d: "M21 8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16Z" }), createBaseVNode("path", { d: "m3.3 7l8.7 5l8.7-5M12 22V12" })], -1)]));
}
var box_default = {
	name: "lucide-box",
	render: render$178
};
var _hoisted_1$239 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$177(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$239, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "M8 3H7a2 2 0 0 0-2 2v5a2 2 0 0 1-2 2a2 2 0 0 1 2 2v5c0 1.1.9 2 2 2h1m8 0h1a2 2 0 0 0 2-2v-5c0-1.1.9-2 2-2a2 2 0 0 1-2-2V5a2 2 0 0 0-2-2h-1"
	}, null, -1)]));
}
var braces_default = {
	name: "lucide-braces",
	render: render$177
};
var _hoisted_1$238 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$176(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$238, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [
		createBaseVNode("path", { d: "M12 5a3 3 0 1 0-5.997.125a4 4 0 0 0-2.526 5.77a4 4 0 0 0 .556 6.588A4 4 0 1 0 12 18Z" }),
		createBaseVNode("path", { d: "M12 5a3 3 0 1 1 5.997.125a4 4 0 0 1 2.526 5.77a4 4 0 0 1-.556 6.588A4 4 0 1 1 12 18Z" }),
		createBaseVNode("path", { d: "M15 13a4.5 4.5 0 0 1-3-4a4.5 4.5 0 0 1-3 4m8.599-6.5a3 3 0 0 0 .399-1.375m-11.995 0A3 3 0 0 0 6.401 6.5m-2.924 4.396a4 4 0 0 1 .585-.396m15.876 0a4 4 0 0 1 .585.396M6 18a4 4 0 0 1-1.967-.516m15.934 0A4 4 0 0 1 18 18" })
	], -1)]));
}
var brain_default = {
	name: "lucide-brain",
	render: render$176
};
var _hoisted_1$237 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$175(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$237, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [
		createBaseVNode("path", { d: "m8 2l1.88 1.88m4.24 0L16 2M9 7.13v-1a3.003 3.003 0 1 1 6 0v1" }),
		createBaseVNode("path", { d: "M12 20c-3.3 0-6-2.7-6-6v-3a4 4 0 0 1 4-4h4a4 4 0 0 1 4 4v3c0 3.3-2.7 6-6 6m0 0v-9" }),
		createBaseVNode("path", { d: "M6.53 9C4.6 8.8 3 7.1 3 5m3 8H2m1 8c0-2.1 1.7-3.9 3.8-4M20.97 5c0 2.1-1.6 3.8-3.5 4M22 13h-4m-.8 4c2.1.1 3.8 1.9 3.8 4" })
	], -1)]));
}
var bug_default = {
	name: "lucide-bug",
	render: render$175
};
var _hoisted_1$236 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$174(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$236, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("rect", {
		width: "16",
		height: "20",
		x: "4",
		y: "2",
		rx: "2"
	}), createBaseVNode("path", { d: "M8 6h8m0 8v4m0-8h.01M12 10h.01M8 10h.01M12 14h.01M8 14h.01M12 18h.01M8 18h.01" })], -1)]));
}
var calculator_default = {
	name: "lucide-calculator",
	render: render$174
};
var _hoisted_1$235 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$173(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$235, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [
		createBaseVNode("path", { d: "M8 2v4m8-4v4" }),
		createBaseVNode("rect", {
			width: "18",
			height: "18",
			x: "3",
			y: "4",
			rx: "2"
		}),
		createBaseVNode("path", { d: "M3 10h18" })
	], -1)]));
}
var calendar_default = {
	name: "lucide-calendar",
	render: render$173
};
var _hoisted_1$234 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$172(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$234, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "m3 15l4-8l4 8m-7-2h6m5-2h4.5a2 2 0 0 1 0 4H15V7h4a2 2 0 0 1 0 4"
	}, null, -1)]));
}
var case_upper_default = {
	name: "lucide-case-upper",
	render: render$172
};
var _hoisted_1$233 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$171(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$233, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "M13 17V9m5 8v-3M3 3v16a2 2 0 0 0 2 2h16M8 17V5"
	}, null, -1)]));
}
var chart_column_decreasing_default = {
	name: "lucide-chart-column-decreasing",
	render: render$171
};
var _hoisted_1$232 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$170(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$232, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "M20 6L9 17l-5-5"
	}, null, -1)]));
}
var check_default = {
	name: "lucide-check",
	render: render$170
};
var _hoisted_1$231 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$169(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$231, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "M18 6L7 17l-5-5m20-2l-7.5 7.5L13 16"
	}, null, -1)]));
}
var check_check_default = {
	name: "lucide-check-check",
	render: render$169
};
var _hoisted_1$230 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$168(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$230, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "m6 9l6 6l6-6"
	}, null, -1)]));
}
var chevron_down_default = {
	name: "lucide-chevron-down",
	render: render$168
};
var _hoisted_1$229 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$167(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$229, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "m15 18l-6-6l6-6"
	}, null, -1)]));
}
var chevron_left_default = {
	name: "lucide-chevron-left",
	render: render$167
};
var _hoisted_1$228 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$166(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$228, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "m9 18l6-6l-6-6"
	}, null, -1)]));
}
var chevron_right_default = {
	name: "lucide-chevron-right",
	render: render$166
};
var _hoisted_1$227 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$165(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$227, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "m18 15l-6-6l-6 6"
	}, null, -1)]));
}
var chevron_up_default = {
	name: "lucide-chevron-up",
	render: render$165
};
var _hoisted_1$226 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$164(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$226, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "m7 20l5-5l5 5M7 4l5 5l5-5"
	}, null, -1)]));
}
var chevrons_down_up_default = {
	name: "lucide-chevrons-down-up",
	render: render$164
};
var _hoisted_1$225 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$163(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$225, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "m11 17l-5-5l5-5m7 10l-5-5l5-5"
	}, null, -1)]));
}
var chevrons_left_default = {
	name: "lucide-chevrons-left",
	render: render$163
};
var _hoisted_1$224 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$162(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$224, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "m7 15l5 5l5-5M7 9l5-5l5 5"
	}, null, -1)]));
}
var chevrons_up_down_default = {
	name: "lucide-chevrons-up-down",
	render: render$162
};
var _hoisted_1$223 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$161(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$223, _cache[0] || (_cache[0] = [createBaseVNode("circle", {
		cx: "12",
		cy: "12",
		r: "10",
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, null, -1)]));
}
var circle_default = {
	name: "lucide-circle",
	render: render$161
};
var _hoisted_1$222 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$160(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$222, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("circle", {
		cx: "12",
		cy: "12",
		r: "10"
	}), createBaseVNode("path", { d: "M12 8v4m0 4h.01" })], -1)]));
}
var circle_alert_default = {
	name: "lucide-circle-alert",
	render: render$160
};
var _hoisted_1$221 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$159(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$221, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("circle", {
		cx: "12",
		cy: "12",
		r: "10"
	}), createBaseVNode("path", { d: "m9 12l2 2l4-4" })], -1)]));
}
var circle_check_default = {
	name: "lucide-circle-check",
	render: render$159
};
var _hoisted_1$220 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$158(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$220, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("circle", {
		cx: "12",
		cy: "12",
		r: "10"
	}), createBaseVNode("circle", {
		cx: "12",
		cy: "12",
		r: "1"
	})], -1)]));
}
var circle_dot_default = {
	name: "lucide-circle-dot",
	render: render$158
};
var _hoisted_1$219 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$157(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$219, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("circle", {
		cx: "12",
		cy: "12",
		r: "10"
	}), createBaseVNode("path", { d: "M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3m.08 4h.01" })], -1)]));
}
var circle_help_default = {
	name: "lucide-circle-help",
	render: render$157
};
var _hoisted_1$218 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$156(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$218, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("circle", {
		cx: "12",
		cy: "12",
		r: "10"
	}), createBaseVNode("path", { d: "M8 12h8" })], -1)]));
}
var circle_minus_default = {
	name: "lucide-circle-minus",
	render: render$156
};
var _hoisted_1$217 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$155(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$217, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("circle", {
		cx: "12",
		cy: "12",
		r: "10"
	}), createBaseVNode("path", { d: "M10 15V9m4 6V9" })], -1)]));
}
var circle_pause_default = {
	name: "lucide-circle-pause",
	render: render$155
};
var _hoisted_1$216 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$154(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$216, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("circle", {
		cx: "12",
		cy: "12",
		r: "10"
	}), createBaseVNode("path", { d: "m10 8l6 4l-6 4z" })], -1)]));
}
var circle_play_default = {
	name: "lucide-circle-play",
	render: render$154
};
var _hoisted_1$215 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$153(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$215, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("circle", {
		cx: "12",
		cy: "12",
		r: "10"
	}), createBaseVNode("path", { d: "M8 12h8m-4-4v8" })], -1)]));
}
var circle_plus_default = {
	name: "lucide-circle-plus",
	render: render$153
};
var _hoisted_1$214 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$152(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$214, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [
		createBaseVNode("path", { d: "M18 20a6 6 0 0 0-12 0" }),
		createBaseVNode("circle", {
			cx: "12",
			cy: "10",
			r: "4"
		}),
		createBaseVNode("circle", {
			cx: "12",
			cy: "12",
			r: "10"
		})
	], -1)]));
}
var circle_user_round_default = {
	name: "lucide-circle-user-round",
	render: render$152
};
var _hoisted_1$213 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$151(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$213, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("circle", {
		cx: "12",
		cy: "12",
		r: "10"
	}), createBaseVNode("path", { d: "m15 9l-6 6m0-6l6 6" })], -1)]));
}
var circle_x_default = {
	name: "lucide-circle-x",
	render: render$151
};
var _hoisted_1$212 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$150(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$212, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("rect", {
		width: "8",
		height: "4",
		x: "8",
		y: "2",
		rx: "1",
		ry: "1"
	}), createBaseVNode("path", { d: "M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2" })], -1)]));
}
var clipboard_default = {
	name: "lucide-clipboard",
	render: render$150
};
var _hoisted_1$211 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$149(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$211, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [
		createBaseVNode("rect", {
			width: "8",
			height: "4",
			x: "8",
			y: "2",
			rx: "1",
			ry: "1"
		}),
		createBaseVNode("path", { d: "M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2" }),
		createBaseVNode("path", { d: "m9 14l2 2l4-4" })
	], -1)]));
}
var clipboard_check_default = {
	name: "lucide-clipboard-check",
	render: render$149
};
var _hoisted_1$210 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$148(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$210, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("rect", {
		width: "8",
		height: "4",
		x: "8",
		y: "2",
		rx: "1",
		ry: "1"
	}), createBaseVNode("path", { d: "M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2m4 7h4m-4 5h4m-8-5h.01M8 16h.01" })], -1)]));
}
var clipboard_list_default = {
	name: "lucide-clipboard-list",
	render: render$148
};
var _hoisted_1$209 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$147(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$209, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("path", { d: "M12 6v6l4 2" }), createBaseVNode("circle", {
		cx: "12",
		cy: "12",
		r: "10"
	})], -1)]));
}
var clock_default = {
	name: "lucide-clock",
	render: render$147
};
var _hoisted_1$208 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$146(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$208, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "M17.5 19H9a7 7 0 1 1 6.71-9h1.79a4.5 4.5 0 1 1 0 9"
	}, null, -1)]));
}
var cloud_default = {
	name: "lucide-cloud",
	render: render$146
};
var _hoisted_1$207 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$145(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$207, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("path", { d: "M12 13v8l-4-4m4 4l4-4" }), createBaseVNode("path", { d: "M4.393 15.269A7 7 0 1 1 15.71 8h1.79a4.5 4.5 0 0 1 2.436 8.284" })], -1)]));
}
var cloud_download_default = {
	name: "lucide-cloud-download",
	render: render$145
};
var _hoisted_1$206 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$144(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$206, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "m16 18l6-6l-6-6M8 6l-6 6l6 6"
	}, null, -1)]));
}
var code_default = {
	name: "lucide-code",
	render: render$144
};
var _hoisted_1$205 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$143(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$205, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("path", { d: "M12 20a8 8 0 1 0 0-16a8 8 0 0 0 0 16" }), createBaseVNode("path", { d: "M12 14a2 2 0 1 0 0-4a2 2 0 0 0 0 4m0-12v2m0 18v-2m5 .66l-1-1.73m-5-8.66L7 3.34M20.66 17l-1.73-1M3.34 7l1.73 1M14 12h8M2 12h2m16.66-5l-1.73 1M3.34 17l1.73-1M17 3.34l-1 1.73m-5 8.66l-4 6.93" })], -1)]));
}
var cog_default = {
	name: "lucide-cog",
	render: render$143
};
var _hoisted_1$204 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$142(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$204, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("path", { d: "M10.5 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2v5.5m-6.7 9.1l1-.4M15 3v7.5m.2 6.4l-.9-.3m2.3 5.1l.3-.9m-.1-5.5l-.4-1m2.7.9l.3-.9m.2 7.4l-.4-1m1.5-3.9l1-.4m0 3l-.9-.3M9 3v18" }), createBaseVNode("circle", {
		cx: "18",
		cy: "18",
		r: "3"
	})], -1)]));
}
var columns_3_cog_default = {
	name: "lucide-columns-3-cog",
	render: render$142
};
var _hoisted_1$203 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$141(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$203, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("circle", {
		cx: "12",
		cy: "12",
		r: "10"
	}), createBaseVNode("path", { d: "M12 18a6 6 0 0 0 0-12z" })], -1)]));
}
var contrast_default = {
	name: "lucide-contrast",
	render: render$141
};
var _hoisted_1$202 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$140(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$202, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("rect", {
		width: "14",
		height: "14",
		x: "8",
		y: "8",
		rx: "2",
		ry: "2"
	}), createBaseVNode("path", { d: "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2" })], -1)]));
}
var copy_default = {
	name: "lucide-copy",
	render: render$140
};
var _hoisted_1$201 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$139(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$201, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("circle", {
		cx: "12",
		cy: "12",
		r: "10"
	}), createBaseVNode("path", { d: "M22 12h-4M6 12H2m10-6V2m0 20v-4" })], -1)]));
}
var crosshair_default = {
	name: "lucide-crosshair",
	render: render$139
};
var _hoisted_1$200 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$138(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$200, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [
		createBaseVNode("ellipse", {
			cx: "12",
			cy: "5",
			rx: "9",
			ry: "3"
		}),
		createBaseVNode("path", { d: "M3 5v14a9 3 0 0 0 18 0V5" }),
		createBaseVNode("path", { d: "M3 12a9 3 0 0 0 18 0" })
	], -1)]));
}
var database_default = {
	name: "lucide-database",
	render: render$138
};
var _hoisted_1$199 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$137(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$199, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "M11 20H2m9-15.438v16.157a1 1 0 0 0 1.242.97L19 20V5.562a2 2 0 0 0-1.515-1.94l-4-1A2 2 0 0 0 11 4.561zM11 4H8a2 2 0 0 0-2 2v14m8-8h.01M22 20h-3"
	}, null, -1)]));
}
var door_open_default = {
	name: "lucide-door-open",
	render: render$137
};
var _hoisted_1$198 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$136(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$198, _cache[0] || (_cache[0] = [createBaseVNode("circle", {
		cx: "12.1",
		cy: "12.1",
		r: "1",
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, null, -1)]));
}
var dot_default = {
	name: "lucide-dot",
	render: render$136
};
var _hoisted_1$197 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$135(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$197, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("path", { d: "M21.54 15H17a2 2 0 0 0-2 2v4.54M7 3.34V5a3 3 0 0 0 3 3a2 2 0 0 1 2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2c0-1.1.9-2 2-2h3.17M11 21.95V18a2 2 0 0 0-2-2a2 2 0 0 1-2-2v-1a2 2 0 0 0-2-2H2.05" }), createBaseVNode("circle", {
		cx: "12",
		cy: "12",
		r: "10"
	})], -1)]));
}
var earth_default = {
	name: "lucide-earth",
	render: render$135
};
var _hoisted_1$196 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$134(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$196, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [
		createBaseVNode("circle", {
			cx: "12",
			cy: "12",
			r: "1"
		}),
		createBaseVNode("circle", {
			cx: "19",
			cy: "12",
			r: "1"
		}),
		createBaseVNode("circle", {
			cx: "5",
			cy: "12",
			r: "1"
		})
	], -1)]));
}
var ellipsis_default = {
	name: "lucide-ellipsis",
	render: render$134
};
var _hoisted_1$195 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$133(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$195, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [
		createBaseVNode("circle", {
			cx: "12",
			cy: "12",
			r: "1"
		}),
		createBaseVNode("circle", {
			cx: "12",
			cy: "5",
			r: "1"
		}),
		createBaseVNode("circle", {
			cx: "12",
			cy: "19",
			r: "1"
		})
	], -1)]));
}
var ellipsis_vertical_default = {
	name: "lucide-ellipsis-vertical",
	render: render$133
};
var _hoisted_1$194 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$132(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$194, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "M5 9h14M5 15h14"
	}, null, -1)]));
}
var equal_default = {
	name: "lucide-equal",
	render: render$132
};
var _hoisted_1$193 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$131(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$193, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "m15 15l6 6M15 9l6-6m0 13v5h-5m5-13V3h-5M3 16v5h5m-5 0l6-6M3 8V3h5m1 6L3 3"
	}, null, -1)]));
}
var expand_default = {
	name: "lucide-expand",
	render: render$131
};
var _hoisted_1$192 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$130(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$192, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "M15 3h6v6m-11 5L21 3m-3 10v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"
	}, null, -1)]));
}
var external_link_default = {
	name: "lucide-external-link",
	render: render$130
};
var _hoisted_1$191 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$129(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$191, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("path", { d: "M2.062 12.348a1 1 0 0 1 0-.696a10.75 10.75 0 0 1 19.876 0a1 1 0 0 1 0 .696a10.75 10.75 0 0 1-19.876 0" }), createBaseVNode("circle", {
		cx: "12",
		cy: "12",
		r: "3"
	})], -1)]));
}
var eye_default = {
	name: "lucide-eye",
	render: render$129
};
var _hoisted_1$190 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$128(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$190, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("path", { d: "M10.733 5.076a10.744 10.744 0 0 1 11.205 6.575a1 1 0 0 1 0 .696a10.8 10.8 0 0 1-1.444 2.49m-6.41-.679a3 3 0 0 1-4.242-4.242" }), createBaseVNode("path", { d: "M17.479 17.499a10.75 10.75 0 0 1-15.417-5.151a1 1 0 0 1 0-.696a10.75 10.75 0 0 1 4.446-5.143M2 2l20 20" })], -1)]));
}
var eye_off_default = {
	name: "lucide-eye-off",
	render: render$128
};
var _hoisted_1$189 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$127(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$189, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z" }), createBaseVNode("path", { d: "M14 2v4a2 2 0 0 0 2 2h4" })], -1)]));
}
var file_default = {
	name: "lucide-file",
	render: render$127
};
var _hoisted_1$188 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$126(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$188, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [
		createBaseVNode("path", { d: "M10 12v-1m0 7v-2m0-9V6m4-4v4a2 2 0 0 0 2 2h4" }),
		createBaseVNode("path", { d: "M15.5 22H18a2 2 0 0 0 2-2V7l-5-5H6a2 2 0 0 0-2 2v16a2 2 0 0 0 .274 1.01" }),
		createBaseVNode("circle", {
			cx: "10",
			cy: "20",
			r: "2"
		})
	], -1)]));
}
var file_archive_default = {
	name: "lucide-file-archive",
	render: render$126
};
var _hoisted_1$187 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$125(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$187, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("path", { d: "M10 12.5L8 15l2 2.5m4-5l2 2.5l-2 2.5M14 2v4a2 2 0 0 0 2 2h4" }), createBaseVNode("path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7z" })], -1)]));
}
var file_code_default = {
	name: "lucide-file-code",
	render: render$125
};
var _hoisted_1$186 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$124(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$186, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Zm-6 8h6m-3 3V7M9 17h6"
	}, null, -1)]));
}
var file_diff_default = {
	name: "lucide-file-diff",
	render: render$124
};
var _hoisted_1$185 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$123(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$185, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z" }), createBaseVNode("path", { d: "M14 2v4a2 2 0 0 0 2 2h4m-8 10v-6m-3 3l3 3l3-3" })], -1)]));
}
var file_down_default = {
	name: "lucide-file-down",
	render: render$123
};
var _hoisted_1$184 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$122(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$184, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("path", { d: "M4 22h14a2 2 0 0 0 2-2V7l-5-5H6a2 2 0 0 0-2 2v4" }), createBaseVNode("path", { d: "M14 2v4a2 2 0 0 0 2 2h4M2 15h10m-3 3l3-3l-3-3" })], -1)]));
}
var file_input_default = {
	name: "lucide-file-input",
	render: render$122
};
var _hoisted_1$183 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$121(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$183, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [
		createBaseVNode("path", { d: "M14 2v4a2 2 0 0 0 2 2h4M4 7V4a2 2 0 0 1 2-2a2 2 0 0 0-2 2" }),
		createBaseVNode("path", { d: "M4.063 20.999a2 2 0 0 0 2 1L18 22a2 2 0 0 0 2-2V7l-5-5H6m-1 9l-3 3" }),
		createBaseVNode("path", { d: "m5 17l-3-3h10" })
	], -1)]));
}
var file_output_default = {
	name: "lucide-file-output",
	render: render$121
};
var _hoisted_1$182 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$120(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$182, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z" }), createBaseVNode("path", { d: "M14 2v4a2 2 0 0 0 2 2h4M10 9H8m8 4H8m8 4H8" })], -1)]));
}
var file_text_default = {
	name: "lucide-file-text",
	render: render$120
};
var _hoisted_1$181 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$119(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$181, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [
		createBaseVNode("path", { d: "M20 7h-3a2 2 0 0 1-2-2V2" }),
		createBaseVNode("path", { d: "M9 18a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h7l4 4v10a2 2 0 0 1-2 2Z" }),
		createBaseVNode("path", { d: "M3 7.6v12.8A1.6 1.6 0 0 0 4.6 22h9.8" })
	], -1)]));
}
var files_default = {
	name: "lucide-files",
	render: render$119
};
var _hoisted_1$180 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$118(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$180, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("path", { d: "M12 10a2 2 0 0 0-2 2c0 1.02-.1 2.51-.26 4M14 13.12c0 2.38 0 6.38-1 8.88m4.29-.98c.12-.6.43-2.3.5-3.02M2 12a10 10 0 0 1 18-6M2 16h.01m19.79 0c.2-2 .131-5.354 0-6" }), createBaseVNode("path", { d: "M5 19.5C5.5 18 6 15 6 12a6 6 0 0 1 .34-2m2.31 12c.21-.66.45-1.32.57-2M9 6.8a6 6 0 0 1 9 5.2v2" })], -1)]));
}
var fingerprint_default = {
	name: "lucide-fingerprint",
	render: render$118
};
var _hoisted_1$179 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$117(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$179, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "M14 2v6a2 2 0 0 0 .245.96l5.51 10.08A2 2 0 0 1 18 22H6a2 2 0 0 1-1.755-2.96l5.51-10.08A2 2 0 0 0 10 8V2M6.453 15h11.094M8.5 2h7"
	}, null, -1)]));
}
var flask_conical_default = {
	name: "lucide-flask-conical",
	render: render$117
};
var _hoisted_1$178 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$116(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$178, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "M20 20a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.9a2 2 0 0 1-1.69-.9L9.6 3.9A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13a2 2 0 0 0 2 2Z"
	}, null, -1)]));
}
var folder_default = {
	name: "lucide-folder",
	render: render$116
};
var _hoisted_1$177 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$115(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$177, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "m6 14l1.5-2.9A2 2 0 0 1 9.24 10H20a2 2 0 0 1 1.94 2.5l-1.54 6a2 2 0 0 1-1.95 1.5H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h3.9a2 2 0 0 1 1.69.9l.81 1.2a2 2 0 0 0 1.67.9H18a2 2 0 0 1 2 2v2"
	}, null, -1)]));
}
var folder_open_default = {
	name: "lucide-folder-open",
	render: render$115
};
var _hoisted_1$176 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$114(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$176, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "M12 10v6m-3-3h6m5 7a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.9a2 2 0 0 1-1.69-.9L9.6 3.9A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13a2 2 0 0 0 2 2Z"
	}, null, -1)]));
}
var folder_plus_default = {
	name: "lucide-folder-plus",
	render: render$114
};
var _hoisted_1$175 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$113(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$175, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "M10 20a1 1 0 0 0 .553.895l2 1A1 1 0 0 0 14 21v-7a2 2 0 0 1 .517-1.341L21.74 4.67A1 1 0 0 0 21 3H3a1 1 0 0 0-.742 1.67l7.225 7.989A2 2 0 0 1 10 14z"
	}, null, -1)]));
}
var funnel_default = {
	name: "lucide-funnel",
	render: render$113
};
var _hoisted_1$174 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$112(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$174, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("path", { d: "M6 3h12l4 6l-10 13L2 9Z" }), createBaseVNode("path", { d: "M11 3L8 9l4 13l4-13l-3-6M2 9h20" })], -1)]));
}
var gem_default = {
	name: "lucide-gem",
	render: render$112
};
var _hoisted_1$173 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$111(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$173, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("rect", {
		width: "18",
		height: "4",
		x: "3",
		y: "8",
		rx: "1"
	}), createBaseVNode("path", { d: "M12 8v13m7-9v7a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2v-7m2.5-4a2.5 2.5 0 0 1 0-5A4.8 8 0 0 1 12 8a4.8 8 0 0 1 4.5-5a2.5 2.5 0 0 1 0 5" })], -1)]));
}
var gift_default = {
	name: "lucide-gift",
	render: render$111
};
var _hoisted_1$172 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$110(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$172, _cache[0] || (_cache[0] = [createStaticVNode("<g fill=\"none\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\"><path d=\"M6 3v12\"></path><circle cx=\"18\" cy=\"6\" r=\"3\"></circle><circle cx=\"6\" cy=\"18\" r=\"3\"></circle><path d=\"M18 9a9 9 0 0 1-9 9\"></path></g>", 1)]));
}
var git_branch_default = {
	name: "lucide-git-branch",
	render: render$110
};
var _hoisted_1$171 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$109(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$171, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("circle", {
		cx: "12",
		cy: "12",
		r: "10"
	}), createBaseVNode("path", { d: "M12 2a14.5 14.5 0 0 0 0 20a14.5 14.5 0 0 0 0-20M2 12h20" })], -1)]));
}
var globe_default = {
	name: "lucide-globe",
	render: render$109
};
var _hoisted_1$170 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$108(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$170, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("path", { d: "M21.42 10.922a1 1 0 0 0-.019-1.838L12.83 5.18a2 2 0 0 0-1.66 0L2.6 9.08a1 1 0 0 0 0 1.832l8.57 3.908a2 2 0 0 0 1.66 0zM22 10v6" }), createBaseVNode("path", { d: "M6 12.5V16a6 3 0 0 0 12 0v-3.5" })], -1)]));
}
var graduation_cap_default = {
	name: "lucide-graduation-cap",
	render: render$108
};
var _hoisted_1$169 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$107(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$169, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("path", { d: "M12 3v18m-9-9h18" }), createBaseVNode("rect", {
		width: "18",
		height: "18",
		x: "3",
		y: "3",
		rx: "2"
	})], -1)]));
}
var grid_2x2_default = {
	name: "lucide-grid-2x2",
	render: render$107
};
var _hoisted_1$168 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$106(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$168, _cache[0] || (_cache[0] = [createStaticVNode("<g fill=\"none\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\"><circle cx=\"9\" cy=\"12\" r=\"1\"></circle><circle cx=\"9\" cy=\"5\" r=\"1\"></circle><circle cx=\"9\" cy=\"19\" r=\"1\"></circle><circle cx=\"15\" cy=\"12\" r=\"1\"></circle><circle cx=\"15\" cy=\"5\" r=\"1\"></circle><circle cx=\"15\" cy=\"19\" r=\"1\"></circle></g>", 1)]));
}
var grip_vertical_default = {
	name: "lucide-grip-vertical",
	render: render$106
};
var _hoisted_1$167 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$105(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$167, _cache[0] || (_cache[0] = [createStaticVNode("<g fill=\"none\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\"><path d=\"M11 15h2a2 2 0 1 0 0-4h-3c-.6 0-1.1.2-1.4.6L3 17\"></path><path d=\"m7 21l1.6-1.4c.3-.4.8-.6 1.4-.6h4c1.1 0 2.1-.4 2.8-1.2l4.6-4.4a2 2 0 0 0-2.75-2.91l-4.2 3.9M2 16l6 6\"></path><circle cx=\"16\" cy=\"9\" r=\"2.9\"></circle><circle cx=\"6\" cy=\"5\" r=\"3\"></circle></g>", 1)]));
}
var hand_coins_default = {
	name: "lucide-hand-coins",
	render: render$105
};
var _hoisted_1$166 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$104(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$166, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [
		createBaseVNode("path", { d: "m11 17l2 2a1 1 0 1 0 3-3" }),
		createBaseVNode("path", { d: "m14 14l2.5 2.5a1 1 0 1 0 3-3l-3.88-3.88a3 3 0 0 0-4.24 0l-.88.88a1 1 0 1 1-3-3l2.81-2.81a5.79 5.79 0 0 1 7.06-.87l.47.28a2 2 0 0 0 1.42.25L21 4" }),
		createBaseVNode("path", { d: "m21 3l1 11h-2M3 3L2 14l6.5 6.5a1 1 0 1 0 3-3M3 4h8" })
	], -1)]));
}
var handshake_default = {
	name: "lucide-handshake",
	render: render$104
};
var _hoisted_1$165 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$103(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$165, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "M22 12H2m3.45-6.89L2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11M6 16h.01M10 16h.01"
	}, null, -1)]));
}
var hard_drive_default = {
	name: "lucide-hard-drive",
	render: render$103
};
var _hoisted_1$164 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$102(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$164, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [
		createBaseVNode("path", { d: "M12 2v8m4-4l-4 4l-4-4" }),
		createBaseVNode("rect", {
			width: "20",
			height: "8",
			x: "2",
			y: "14",
			rx: "2"
		}),
		createBaseVNode("path", { d: "M6 18h.01M10 18h.01" })
	], -1)]));
}
var hard_drive_download_default = {
	name: "lucide-hard-drive-download",
	render: render$102
};
var _hoisted_1$163 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$101(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$163, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "M4 9h16M4 15h16M10 3L8 21m8-18l-2 18"
	}, null, -1)]));
}
var hash_default = {
	name: "lucide-hash",
	render: render$101
};
var _hoisted_1$162 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$100(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$162, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("path", { d: "M3 12a9 9 0 1 0 9-9a9.75 9.75 0 0 0-6.74 2.74L3 8" }), createBaseVNode("path", { d: "M3 3v5h5m4-1v5l4 2" })], -1)]));
}
var history_default = {
	name: "lucide-history",
	render: render$100
};
var _hoisted_1$161 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$99(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$161, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "M5 22h14M5 2h14m-2 20v-4.172a2 2 0 0 0-.586-1.414L12 12l-4.414 4.414A2 2 0 0 0 7 17.828V22M7 2v4.172a2 2 0 0 0 .586 1.414L12 12l4.414-4.414A2 2 0 0 0 17 6.172V2"
	}, null, -1)]));
}
var hourglass_default = {
	name: "lucide-hourglass",
	render: render$99
};
var _hoisted_1$160 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$98(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$160, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("path", { d: "M15 21v-8a1 1 0 0 0-1-1h-4a1 1 0 0 0-1 1v8" }), createBaseVNode("path", { d: "M3 10a2 2 0 0 1 .709-1.528l7-5.999a2 2 0 0 1 2.582 0l7 5.999A2 2 0 0 1 21 10v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z" })], -1)]));
}
var house_default = {
	name: "lucide-house",
	render: render$98
};
var _hoisted_1$159 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$97(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$159, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [
		createBaseVNode("rect", {
			width: "18",
			height: "18",
			x: "3",
			y: "3",
			rx: "2",
			ry: "2"
		}),
		createBaseVNode("circle", {
			cx: "9",
			cy: "9",
			r: "2"
		}),
		createBaseVNode("path", { d: "m21 15l-3.086-3.086a2 2 0 0 0-2.828 0L6 21" })
	], -1)]));
}
var image_default = {
	name: "lucide-image",
	render: render$97
};
var _hoisted_1$158 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$96(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$158, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("path", { d: "M22 12h-6l-2 3h-4l-2-3H2" }), createBaseVNode("path", { d: "M5.45 5.11L2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11" })], -1)]));
}
var inbox_default = {
	name: "lucide-inbox",
	render: render$96
};
var _hoisted_1$157 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$95(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$157, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("circle", {
		cx: "12",
		cy: "12",
		r: "10"
	}), createBaseVNode("path", { d: "M12 16v-4m0-4h.01" })], -1)]));
}
var info_default = {
	name: "lucide-info",
	render: render$95
};
var _hoisted_1$156 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$94(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$156, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("path", { d: "M2.586 17.414A2 2 0 0 0 2 18.828V21a1 1 0 0 0 1 1h3a1 1 0 0 0 1-1v-1a1 1 0 0 1 1-1h1a1 1 0 0 0 1-1v-1a1 1 0 0 1 1-1h.172a2 2 0 0 0 1.414-.586l.814-.814a6.5 6.5 0 1 0-4-4z" }), createBaseVNode("circle", {
		cx: "16.5",
		cy: "7.5",
		r: ".5",
		fill: "currentColor"
	})], -1)]));
}
var key_round_default = {
	name: "lucide-key-round",
	render: render$94
};
var _hoisted_1$155 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$93(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$155, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "m5 8l6 6m-7 0l6-6l2-3M2 5h12M7 2h1m14 20l-5-10l-5 10m2-4h6"
	}, null, -1)]));
}
var languages_default = {
	name: "lucide-languages",
	render: render$93
};
var _hoisted_1$154 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$92(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$154, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [
		createBaseVNode("path", { d: "M12.83 2.18a2 2 0 0 0-1.66 0L2.6 6.08a1 1 0 0 0 0 1.83l8.58 3.91a2 2 0 0 0 1.66 0l8.58-3.9a1 1 0 0 0 0-1.83z" }),
		createBaseVNode("path", { d: "M2 12a1 1 0 0 0 .58.91l8.6 3.91a2 2 0 0 0 1.65 0l8.58-3.9A1 1 0 0 0 22 12" }),
		createBaseVNode("path", { d: "M2 17a1 1 0 0 0 .58.91l8.6 3.91a2 2 0 0 0 1.65 0l8.58-3.9A1 1 0 0 0 22 17" })
	], -1)]));
}
var layers_default = {
	name: "lucide-layers",
	render: render$92
};
var _hoisted_1$153 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$91(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$153, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "M15 14c.2-1 .7-1.7 1.5-2.5c1-.9 1.5-2.2 1.5-3.5A6 6 0 0 0 6 8c0 1 .2 2.2 1.5 3.5c.7.7 1.3 1.5 1.5 2.5m0 4h6m-5 4h4"
	}, null, -1)]));
}
var lightbulb_default = {
	name: "lucide-lightbulb",
	render: render$91
};
var _hoisted_1$152 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$90(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$152, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("path", { d: "M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" }), createBaseVNode("path", { d: "M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" })], -1)]));
}
var link_default = {
	name: "lucide-link",
	render: render$90
};
var _hoisted_1$151 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$89(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$151, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "M3 12h.01M3 18h.01M3 6h.01M8 12h13M8 18h13M8 6h13"
	}, null, -1)]));
}
var list_default = {
	name: "lucide-list",
	render: render$89
};
var _hoisted_1$150 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$88(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$150, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "m3 17l2 2l4-4M3 7l2 2l4-4m4 1h8m-8 6h8m-8 6h8"
	}, null, -1)]));
}
var list_checks_default = {
	name: "lucide-list-checks",
	render: render$88
};
var _hoisted_1$149 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$87(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$149, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("rect", {
		width: "18",
		height: "11",
		x: "3",
		y: "11",
		rx: "2",
		ry: "2"
	}), createBaseVNode("path", { d: "M7 11V7a5 5 0 0 1 10 0v4" })], -1)]));
}
var lock_default = {
	name: "lucide-lock",
	render: render$87
};
var _hoisted_1$148 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$86(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$148, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "m10 17l5-5l-5-5m5 5H3m12-9h4a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-4"
	}, null, -1)]));
}
var log_in_default = {
	name: "lucide-log-in",
	render: render$86
};
var _hoisted_1$147 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$85(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$147, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "m16 17l5-5l-5-5m5 5H9m0 9H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"
	}, null, -1)]));
}
var log_out_default = {
	name: "lucide-log-out",
	render: render$85
};
var _hoisted_1$146 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$84(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$146, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("path", { d: "m22 7l-8.991 5.727a2 2 0 0 1-2.009 0L2 7" }), createBaseVNode("rect", {
		width: "20",
		height: "16",
		x: "2",
		y: "4",
		rx: "2"
	})], -1)]));
}
var mail_default = {
	name: "lucide-mail",
	render: render$84
};
var _hoisted_1$145 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$83(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$145, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3M3 16v3a2 2 0 0 0 2 2h3m8 0h3a2 2 0 0 0 2-2v-3"
	}, null, -1)]));
}
var maximize_default = {
	name: "lucide-maximize",
	render: render$83
};
var _hoisted_1$144 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$82(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$144, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "M15 3h6v6m0-6l-7 7M3 21l7-7m-1 7H3v-6"
	}, null, -1)]));
}
var maximize_2_default = {
	name: "lucide-maximize-2",
	render: render$82
};
var _hoisted_1$143 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$81(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$143, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "M4 12h16M4 18h16M4 6h16"
	}, null, -1)]));
}
var menu_default = {
	name: "lucide-menu",
	render: render$81
};
var _hoisted_1$142 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$80(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$142, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "M7.9 20A9 9 0 1 0 4 16.1L2 22Z"
	}, null, -1)]));
}
var message_circle_default = {
	name: "lucide-message-circle",
	render: render$80
};
var _hoisted_1$141 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$79(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$141, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"
	}, null, -1)]));
}
var message_square_default = {
	name: "lucide-message-square",
	render: render$79
};
var _hoisted_1$140 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$78(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$140, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "M14 9a2 2 0 0 1-2 2H6l-4 4V4a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2zm4 0h2a2 2 0 0 1 2 2v11l-4-4h-6a2 2 0 0 1-2-2v-1"
	}, null, -1)]));
}
var messages_square_default = {
	name: "lucide-messages-square",
	render: render$78
};
var _hoisted_1$139 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$77(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$139, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("path", { d: "M12 19v3m7-12v2a7 7 0 0 1-14 0v-2" }), createBaseVNode("rect", {
		width: "6",
		height: "13",
		x: "9",
		y: "2",
		rx: "3"
	})], -1)]));
}
var mic_default = {
	name: "lucide-mic",
	render: render$77
};
var _hoisted_1$138 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$76(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$138, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "M12 13v8m0-18v3M4 6a1 1 0 0 0-1 1v5a1 1 0 0 0 1 1h13a2 2 0 0 0 1.152-.365l3.424-2.317a1 1 0 0 0 0-1.635l-3.424-2.318A2 2 0 0 0 17 6z"
	}, null, -1)]));
}
var milestone_default = {
	name: "lucide-milestone",
	render: render$76
};
var _hoisted_1$137 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$75(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$137, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "m14 10l7-7m-1 7h-6V4M3 21l7-7m-6 0h6v6"
	}, null, -1)]));
}
var minimize_2_default = {
	name: "lucide-minimize-2",
	render: render$75
};
var _hoisted_1$136 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$74(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$136, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "M5 12h14"
	}, null, -1)]));
}
var minus_default$1 = {
	name: "lucide-minus",
	render: render$74
};
var _hoisted_1$135 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$73(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$135, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "M12.586 12.586L19 19M3.688 3.037a.497.497 0 0 0-.651.651l6.5 15.999a.501.501 0 0 0 .947-.062l1.569-6.083a2 2 0 0 1 1.448-1.479l6.124-1.579a.5.5 0 0 0 .063-.947z"
	}, null, -1)]));
}
var mouse_pointer_default = {
	name: "lucide-mouse-pointer",
	render: render$73
};
var _hoisted_1$134 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$72(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$134, _cache[0] || (_cache[0] = [createStaticVNode("<g fill=\"none\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\"><rect width=\"6\" height=\"6\" x=\"16\" y=\"16\" rx=\"1\"></rect><rect width=\"6\" height=\"6\" x=\"2\" y=\"16\" rx=\"1\"></rect><rect width=\"6\" height=\"6\" x=\"9\" y=\"2\" rx=\"1\"></rect><path d=\"M5 16v-3a1 1 0 0 1 1-1h12a1 1 0 0 1 1 1v3m-7-4V8\"></path></g>", 1)]));
}
var network_default = {
	name: "lucide-network",
	render: render$72
};
var _hoisted_1$133 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$71(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$133, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("path", { d: "M13.4 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-7.4M2 6h4m-4 4h4m-4 4h4m-4 4h4" }), createBaseVNode("path", { d: "M21.378 5.626a1 1 0 1 0-3.004-3.004l-5.01 5.012a2 2 0 0 0-.506.854l-.837 2.87a.5.5 0 0 0 .62.62l2.87-.837a2 2 0 0 0 .854-.506z" })], -1)]));
}
var notebook_pen_default = {
	name: "lucide-notebook-pen",
	render: render$71
};
var _hoisted_1$132 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$70(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$132, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [
		createBaseVNode("path", { d: "M12 22v-9m3.17-10.79a1.67 1.67 0 0 1 1.63 0L21 4.57a1.93 1.93 0 0 1 0 3.36L8.82 14.79a1.66 1.66 0 0 1-1.64 0L3 12.43a1.93 1.93 0 0 1 0-3.36z" }),
		createBaseVNode("path", { d: "M20 13v3.87a2.06 2.06 0 0 1-1.11 1.83l-6 3.08a1.93 1.93 0 0 1-1.78 0l-6-3.08A2.06 2.06 0 0 1 4 16.87V13" }),
		createBaseVNode("path", { d: "M21 12.43a1.93 1.93 0 0 0 0-3.36L8.83 2.2a1.64 1.64 0 0 0-1.63 0L3 4.57a1.93 1.93 0 0 0 0 3.36l12.18 6.86a1.64 1.64 0 0 0 1.63 0z" })
	], -1)]));
}
var package_open_default = {
	name: "lucide-package-open",
	render: render$70
};
var _hoisted_1$131 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$69(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$131, _cache[0] || (_cache[0] = [createStaticVNode("<g fill=\"none\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\"><path d=\"M12 22a1 1 0 0 1 0-20a10 9 0 0 1 10 9a5 5 0 0 1-5 5h-2.25a1.75 1.75 0 0 0-1.4 2.8l.3.4a1.75 1.75 0 0 1-1.4 2.8z\"></path><circle cx=\"13.5\" cy=\"6.5\" r=\".5\" fill=\"currentColor\"></circle><circle cx=\"17.5\" cy=\"10.5\" r=\".5\" fill=\"currentColor\"></circle><circle cx=\"6.5\" cy=\"12.5\" r=\".5\" fill=\"currentColor\"></circle><circle cx=\"8.5\" cy=\"7.5\" r=\".5\" fill=\"currentColor\"></circle></g>", 1)]));
}
var palette_default = {
	name: "lucide-palette",
	render: render$69
};
var _hoisted_1$130 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$68(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$130, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("rect", {
		width: "18",
		height: "18",
		x: "3",
		y: "3",
		rx: "2"
	}), createBaseVNode("path", { d: "M9 3v18" })], -1)]));
}
var panel_left_default = {
	name: "lucide-panel-left",
	render: render$68
};
var _hoisted_1$129 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$67(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$129, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("rect", {
		width: "18",
		height: "18",
		x: "3",
		y: "3",
		rx: "2"
	}), createBaseVNode("path", { d: "M15 3v18" })], -1)]));
}
var panel_right_default = {
	name: "lucide-panel-right",
	render: render$67
};
var _hoisted_1$128 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$66(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$128, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "m16 6l-8.414 8.586a2 2 0 0 0 2.829 2.829l8.414-8.586a4 4 0 1 0-5.657-5.657l-8.379 8.551a6 6 0 1 0 8.485 8.485l8.379-8.551"
	}, null, -1)]));
}
var paperclip_default = {
	name: "lucide-paperclip",
	render: render$66
};
var _hoisted_1$127 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$65(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$127, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("rect", {
		width: "4",
		height: "16",
		x: "14",
		y: "4",
		rx: "1"
	}), createBaseVNode("rect", {
		width: "4",
		height: "16",
		x: "6",
		y: "4",
		rx: "1"
	})], -1)]));
}
var pause_default = {
	name: "lucide-pause",
	render: render$65
};
var _hoisted_1$126 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$64(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$126, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "M21.174 6.812a1 1 0 0 0-3.986-3.987L3.842 16.174a2 2 0 0 0-.5.83l-1.321 4.352a.5.5 0 0 0 .623.622l4.353-1.32a2 2 0 0 0 .83-.497z"
	}, null, -1)]));
}
var pen_default = {
	name: "lucide-pen",
	render: render$64
};
var _hoisted_1$125 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$63(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$125, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "M21.174 6.812a1 1 0 0 0-3.986-3.987L3.842 16.174a2 2 0 0 0-.5.83l-1.321 4.352a.5.5 0 0 0 .623.622l4.353-1.32a2 2 0 0 0 .83-.497zM15 5l4 4"
	}, null, -1)]));
}
var pencil_default = {
	name: "lucide-pencil",
	render: render$63
};
var _hoisted_1$124 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$62(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$124, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "M12 17v5M9 10.76a2 2 0 0 1-1.11 1.79l-1.78.9A2 2 0 0 0 5 15.24V16a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-.76a2 2 0 0 0-1.11-1.79l-1.78-.9A2 2 0 0 1 15 10.76V7a1 1 0 0 1 1-1a2 2 0 0 0 0-4H8a2 2 0 0 0 0 4a1 1 0 0 1 1 1z"
	}, null, -1)]));
}
var pin_default = {
	name: "lucide-pin",
	render: render$62
};
var _hoisted_1$123 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$61(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$123, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "m6 3l14 9l-14 9z"
	}, null, -1)]));
}
var play_default = {
	name: "lucide-play",
	render: render$61
};
var _hoisted_1$122 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$60(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$122, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "M12 22v-5M9 8V2m6 6V2m3 6v5a4 4 0 0 1-4 4h-4a4 4 0 0 1-4-4V8Z"
	}, null, -1)]));
}
var plug_default = {
	name: "lucide-plug",
	render: render$60
};
var _hoisted_1$121 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$59(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$121, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "M5 12h14m-7-7v14"
	}, null, -1)]));
}
var plus_default$1 = {
	name: "lucide-plus",
	render: render$59
};
var _hoisted_1$120 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$58(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$120, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("path", { d: "M3 2v1c0 1 2 1 2 2S3 6 3 7s2 1 2 2s-2 1-2 2s2 1 2 2m13-7h.01M6 18h.01m14.82-9.17a4 4 0 0 0-5.66-5.66l-12 12a4 4 0 1 0 5.66 5.66Z" }), createBaseVNode("path", { d: "M18 11.66V22a4 4 0 0 0 4-4V6" })], -1)]));
}
var pocket_knife_default = {
	name: "lucide-pocket-knife",
	render: render$58
};
var _hoisted_1$119 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$57(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$119, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "M12 2v10m6.4-5.4a9 9 0 1 1-12.77.04"
	}, null, -1)]));
}
var power_default = {
	name: "lucide-power",
	render: render$57
};
var _hoisted_1$118 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$56(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$118, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("path", { d: "m15 14l5-5l-5-5" }), createBaseVNode("path", { d: "M20 9H9.5A5.5 5.5 0 0 0 4 14.5A5.5 5.5 0 0 0 9.5 20H13" })], -1)]));
}
var redo_2_default = {
	name: "lucide-redo-2",
	render: render$56
};
var _hoisted_1$117 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$55(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$117, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [
		createBaseVNode("path", { d: "M3 12a9 9 0 0 1 9-9a9.75 9.75 0 0 1 6.74 2.74L21 8" }),
		createBaseVNode("path", { d: "M21 3v5h-5m5 4a9 9 0 0 1-9 9a9.75 9.75 0 0 1-6.74-2.74L3 16" }),
		createBaseVNode("path", { d: "M8 16H3v5" })
	], -1)]));
}
var refresh_cw_default = {
	name: "lucide-refresh-cw",
	render: render$55
};
var _hoisted_1$116 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$54(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$116, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "M4 7V4h16v3M5 20h6m2-16L8 20m7-5l5 5m0-5l-5 5"
	}, null, -1)]));
}
var remove_formatting_default = {
	name: "lucide-remove-formatting",
	render: render$54
};
var _hoisted_1$115 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$53(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$115, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("path", { d: "M4 11a9 9 0 0 1 9 9M4 4a16 16 0 0 1 16 16" }), createBaseVNode("circle", {
		cx: "5",
		cy: "19",
		r: "1"
	})], -1)]));
}
var rss_default = {
	name: "lucide-rss",
	render: render$53
};
var _hoisted_1$114 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$52(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$114, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "M4 10a7.31 7.31 0 0 0 10 10Zm5 5l3-3m5 1a6 6 0 0 0-6-6m10 6A10 10 0 0 0 11 3"
	}, null, -1)]));
}
var satellite_dish_default = {
	name: "lucide-satellite-dish",
	render: render$52
};
var _hoisted_1$113 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$51(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$113, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("path", { d: "M15.2 3a2 2 0 0 1 1.4.6l3.8 3.8a2 2 0 0 1 .6 1.4V19a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2z" }), createBaseVNode("path", { d: "M17 21v-7a1 1 0 0 0-1-1H8a1 1 0 0 0-1 1v7M7 3v4a1 1 0 0 0 1 1h7" })], -1)]));
}
var save_default = {
	name: "lucide-save",
	render: render$51
};
var _hoisted_1$112 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$50(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$112, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "m16 16l3-8l3 8c-.87.65-1.92 1-3 1s-2.13-.35-3-1M2 16l3-8l3 8c-.87.65-1.92 1-3 1s-2.13-.35-3-1m5 5h10M12 3v18M3 7h2c2 0 5-1 7-2c2 1 5 2 7 2h2"
	}, null, -1)]));
}
var scale_default = {
	name: "lucide-scale",
	render: render$50
};
var _hoisted_1$111 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$49(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$111, _cache[0] || (_cache[0] = [createStaticVNode("<g fill=\"none\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\"><circle cx=\"6\" cy=\"6\" r=\"3\"></circle><path d=\"M8.12 8.12L12 12m8-8L8.12 15.88\"></path><circle cx=\"6\" cy=\"18\" r=\"3\"></circle><path d=\"M14.8 14.8L20 20\"></path></g>", 1)]));
}
var scissors_default = {
	name: "lucide-scissors",
	render: render$49
};
var _hoisted_1$110 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$48(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$110, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("path", { d: "m21 21l-4.34-4.34" }), createBaseVNode("circle", {
		cx: "11",
		cy: "11",
		r: "8"
	})], -1)]));
}
var search_default = {
	name: "lucide-search",
	render: render$48
};
var _hoisted_1$109 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$47(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$109, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "M14.536 21.686a.5.5 0 0 0 .937-.024l6.5-19a.496.496 0 0 0-.635-.635l-19 6.5a.5.5 0 0 0-.024.937l7.93 3.18a2 2 0 0 1 1.112 1.11zm7.318-19.539l-10.94 10.939"
	}, null, -1)]));
}
var send_default = {
	name: "lucide-send",
	render: render$47
};
var _hoisted_1$108 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$46(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$108, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [
		createBaseVNode("rect", {
			width: "20",
			height: "8",
			x: "2",
			y: "2",
			rx: "2",
			ry: "2"
		}),
		createBaseVNode("rect", {
			width: "20",
			height: "8",
			x: "2",
			y: "14",
			rx: "2",
			ry: "2"
		}),
		createBaseVNode("path", { d: "M6 6h.01M6 18h.01" })
	], -1)]));
}
var server_default = {
	name: "lucide-server",
	render: render$46
};
var _hoisted_1$107 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$45(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$107, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("path", { d: "M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2" }), createBaseVNode("circle", {
		cx: "12",
		cy: "12",
		r: "3"
	})], -1)]));
}
var settings_default = {
	name: "lucide-settings",
	render: render$45
};
var _hoisted_1$106 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$44(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$106, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [
		createBaseVNode("path", { d: "M14 17H5M19 7h-9" }),
		createBaseVNode("circle", {
			cx: "17",
			cy: "17",
			r: "3"
		}),
		createBaseVNode("circle", {
			cx: "7",
			cy: "7",
			r: "3"
		})
	], -1)]));
}
var settings_2_default = {
	name: "lucide-settings-2",
	render: render$44
};
var _hoisted_1$105 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$43(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$105, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "M12 2v13m4-9l-4-4l-4 4m-4 6v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8"
	}, null, -1)]));
}
var share_default = {
	name: "lucide-share",
	render: render$43
};
var _hoisted_1$104 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$42(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$104, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "M21 4h-7m-4 0H3m18 8h-9m-4 0H3m18 8h-5m-4 0H3M14 2v4m-6 4v4m8 4v4"
	}, null, -1)]));
}
var sliders_horizontal_default = {
	name: "lucide-sliders-horizontal",
	render: render$42
};
var _hoisted_1$103 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$41(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$103, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("circle", {
		cx: "12",
		cy: "12",
		r: "10"
	}), createBaseVNode("path", { d: "M8 14s1.5 2 4 2s4-2 4-2M9 9h.01M15 9h.01" })], -1)]));
}
var smile_default = {
	name: "lucide-smile",
	render: render$41
};
var _hoisted_1$102 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$40(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$102, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "M9.937 15.5A2 2 0 0 0 8.5 14.063l-6.135-1.582a.5.5 0 0 1 0-.962L8.5 9.936A2 2 0 0 0 9.937 8.5l1.582-6.135a.5.5 0 0 1 .963 0L14.063 8.5A2 2 0 0 0 15.5 9.937l6.135 1.581a.5.5 0 0 1 0 .964L15.5 14.063a2 2 0 0 0-1.437 1.437l-1.582 6.135a.5.5 0 0 1-.963 0zM20 3v4m2-2h-4M4 17v2m1-1H3"
	}, null, -1)]));
}
var sparkles_default = {
	name: "lucide-sparkles",
	render: render$40
};
var _hoisted_1$101 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$39(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$101, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("path", { d: "M16 3h5v5M8 3H3v5" }), createBaseVNode("path", { d: "M12 22v-8.3a4 4 0 0 0-1.172-2.872L3 3m12 6l6-6" })], -1)]));
}
var split_default = {
	name: "lucide-split",
	render: render$39
};
var _hoisted_1$100 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$38(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$100, _cache[0] || (_cache[0] = [createBaseVNode("rect", {
		width: "18",
		height: "18",
		x: "3",
		y: "3",
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		rx: "2"
	}, null, -1)]));
}
var square_default = {
	name: "lucide-square",
	render: render$38
};
var _hoisted_1$99 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$37(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$99, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("rect", {
		width: "18",
		height: "18",
		x: "3",
		y: "3",
		rx: "2"
	}), createBaseVNode("path", { d: "m9 12l2 2l4-4" })], -1)]));
}
var square_check_default = {
	name: "lucide-square-check",
	render: render$37
};
var _hoisted_1$98 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$36(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$98, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("rect", {
		width: "18",
		height: "18",
		x: "3",
		y: "3",
		rx: "2"
	}), createBaseVNode("path", { d: "M8 12h8" })], -1)]));
}
var square_minus_default = {
	name: "lucide-square-minus",
	render: render$36
};
var _hoisted_1$97 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$35(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$97, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("path", { d: "M12 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7" }), createBaseVNode("path", { d: "M18.375 2.625a1 1 0 0 1 3 3l-9.013 9.014a2 2 0 0 1-.853.505l-2.873.84a.5.5 0 0 1-.62-.62l.84-2.873a2 2 0 0 1 .506-.852z" })], -1)]));
}
var square_pen_default = {
	name: "lucide-square-pen",
	render: render$35
};
var _hoisted_1$96 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$34(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$96, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("rect", {
		width: "18",
		height: "18",
		x: "3",
		y: "3",
		rx: "2"
	}), createBaseVNode("path", { d: "M8 12h8m-4-4v8" })], -1)]));
}
var square_plus_default = {
	name: "lucide-square-plus",
	render: render$34
};
var _hoisted_1$95 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$33(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$95, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("path", { d: "M16 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V8Z" }), createBaseVNode("path", { d: "M15 3v4a2 2 0 0 0 2 2h4" })], -1)]));
}
var sticky_note_default = {
	name: "lucide-sticky-note",
	render: render$33
};
var _hoisted_1$94 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$32(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$94, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("circle", {
		cx: "12",
		cy: "12",
		r: "4"
	}), createBaseVNode("path", { d: "M12 2v2m0 16v2M4.93 4.93l1.41 1.41m11.32 11.32l1.41 1.41M2 12h2m16 0h2M6.34 17.66l-1.41 1.41M19.07 4.93l-1.41 1.41" })], -1)]));
}
var sun_default = {
	name: "lucide-sun",
	render: render$32
};
var _hoisted_1$93 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$31(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$93, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [
		createBaseVNode("path", { d: "M12 3v18" }),
		createBaseVNode("rect", {
			width: "18",
			height: "18",
			x: "3",
			y: "3",
			rx: "2"
		}),
		createBaseVNode("path", { d: "M3 9h18M3 15h18" })
	], -1)]));
}
var table_default = {
	name: "lucide-table",
	render: render$31
};
var _hoisted_1$92 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$30(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$92, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [
		createBaseVNode("path", { d: "m15 5l6.3 6.3a2.4 2.4 0 0 1 0 3.4L17 19" }),
		createBaseVNode("path", { d: "M9.586 5.586A2 2 0 0 0 8.172 5H3a1 1 0 0 0-1 1v5.172a2 2 0 0 0 .586 1.414L8.29 18.29a2.426 2.426 0 0 0 3.42 0l3.58-3.58a2.426 2.426 0 0 0 0-3.42z" }),
		createBaseVNode("circle", {
			cx: "6.5",
			cy: "9.5",
			r: ".5",
			fill: "currentColor"
		})
	], -1)]));
}
var tags_default = {
	name: "lucide-tags",
	render: render$30
};
var _hoisted_1$91 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$29(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$91, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "M12 19h8M4 17l6-6l-6-6"
	}, null, -1)]));
}
var terminal_default = {
	name: "lucide-terminal",
	render: render$29
};
var _hoisted_1$90 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$28(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$90, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "M17 14V2M9 18.12L10 14H4.17a2 2 0 0 1-1.92-2.56l2.33-8A2 2 0 0 1 6.5 2H20a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2h-2.76a2 2 0 0 0-1.79 1.11L12 22a3.13 3.13 0 0 1-3-3.88"
	}, null, -1)]));
}
var thumbs_down_default = {
	name: "lucide-thumbs-down",
	render: render$28
};
var _hoisted_1$89 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$27(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$89, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "M7 10v12m8-16.12L14 10h5.83a2 2 0 0 1 1.92 2.56l-2.33 8A2 2 0 0 1 17.5 22H4a2 2 0 0 1-2-2v-8a2 2 0 0 1 2-2h2.76a2 2 0 0 0 1.79-1.11L12 2a3.13 3.13 0 0 1 3 3.88"
	}, null, -1)]));
}
var thumbs_up_default = {
	name: "lucide-thumbs-up",
	render: render$27
};
var _hoisted_1$88 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$26(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$88, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("path", { d: "M10 2h4m-2 12l3-3" }), createBaseVNode("circle", {
		cx: "12",
		cy: "14",
		r: "8"
	})], -1)]));
}
var timer_default = {
	name: "lucide-timer",
	render: render$26
};
var _hoisted_1$87 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$25(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$87, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("circle", {
		cx: "15",
		cy: "12",
		r: "3"
	}), createBaseVNode("rect", {
		width: "20",
		height: "14",
		x: "2",
		y: "5",
		rx: "7"
	})], -1)]));
}
var toggle_right_default = {
	name: "lucide-toggle-right",
	render: render$25
};
var _hoisted_1$86 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$24(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$86, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "M3 6h18m-2 0v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6m3 0V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2m-6 5v6m4-6v6"
	}, null, -1)]));
}
var trash_2_default = {
	name: "lucide-trash-2",
	render: render$24
};
var _hoisted_1$85 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$23(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$85, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "m17 14l3 3.3a1 1 0 0 1-.7 1.7H4.7a1 1 0 0 1-.7-1.7L7 14h-.3a1 1 0 0 1-.7-1.7L9 9h-.2A1 1 0 0 1 8 7.3L12 3l4 4.3a1 1 0 0 1-.8 1.7H15l3 3.3a1 1 0 0 1-.7 1.7zm-5 8v-3"
	}, null, -1)]));
}
var tree_pine_default = {
	name: "lucide-tree-pine",
	render: render$23
};
var _hoisted_1$84 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$22(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$84, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "m21.73 18l-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3M12 9v4m0 4h.01"
	}, null, -1)]));
}
var triangle_alert_default = {
	name: "lucide-triangle-alert",
	render: render$22
};
var _hoisted_1$83 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$21(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$83, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "M12 4v16M4 7V5a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1v2M9 20h6"
	}, null, -1)]));
}
var type_default = {
	name: "lucide-type",
	render: render$21
};
var _hoisted_1$82 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$20(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$82, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("path", { d: "M9 14L4 9l5-5" }), createBaseVNode("path", { d: "M4 9h10.5a5.5 5.5 0 0 1 5.5 5.5a5.5 5.5 0 0 1-5.5 5.5H11" })], -1)]));
}
var undo_2_default = {
	name: "lucide-undo-2",
	render: render$20
};
var _hoisted_1$81 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$19(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$81, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "m18.84 12.25l1.72-1.71h-.02a5.004 5.004 0 0 0-.12-7.07a5.006 5.006 0 0 0-6.95 0l-1.72 1.71m-6.58 6.57l-1.71 1.71a5.004 5.004 0 0 0 .12 7.07a5.006 5.006 0 0 0 6.95 0l1.71-1.71M8 2v3M2 8h3m11 11v3m3-6h3"
	}, null, -1)]));
}
var unlink_default = {
	name: "lucide-unlink",
	render: render$19
};
var _hoisted_1$80 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$18(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$80, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("path", { d: "M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2" }), createBaseVNode("circle", {
		cx: "12",
		cy: "7",
		r: "4"
	})], -1)]));
}
var user_default = {
	name: "lucide-user",
	render: render$18
};
var _hoisted_1$79 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$17(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$79, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("path", { d: "m16 11l2 2l4-4m-6 12v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2" }), createBaseVNode("circle", {
		cx: "9",
		cy: "7",
		r: "4"
	})], -1)]));
}
var user_check_default = {
	name: "lucide-user-check",
	render: render$17
};
var _hoisted_1$78 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$16(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$78, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [
		createBaseVNode("circle", {
			cx: "10",
			cy: "7",
			r: "4"
		}),
		createBaseVNode("path", { d: "M10.3 15H7a4 4 0 0 0-4 4v2m12-5.5V14a2 2 0 0 1 4 0v1.5" }),
		createBaseVNode("rect", {
			width: "8",
			height: "5",
			x: "13",
			y: "16",
			rx: ".899"
		})
	], -1)]));
}
var user_lock_default = {
	name: "lucide-user-lock",
	render: render$16
};
var _hoisted_1$77 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$15(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$77, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("circle", {
		cx: "12",
		cy: "8",
		r: "5"
	}), createBaseVNode("path", { d: "M20 21a8 8 0 0 0-16 0" })], -1)]));
}
var user_round_default = {
	name: "lucide-user-round",
	render: render$15
};
var _hoisted_1$76 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$14(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$76, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("path", { d: "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2M16 3.128a4 4 0 0 1 0 7.744M22 21v-2a4 4 0 0 0-3-3.87" }), createBaseVNode("circle", {
		cx: "9",
		cy: "7",
		r: "4"
	})], -1)]));
}
var users_default = {
	name: "lucide-users",
	render: render$14
};
var _hoisted_1$75 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$13(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$75, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "M8 21s-4-3-4-9s4-9 4-9m8 0s4 3 4 9s-4 9-4 9M15 9l-6 6m0-6l6 6"
	}, null, -1)]));
}
var variable_default = {
	name: "lucide-variable",
	render: render$13
};
var _hoisted_1$74 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$12(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$74, _cache[0] || (_cache[0] = [createStaticVNode("<g fill=\"none\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\"><rect width=\"18\" height=\"18\" x=\"3\" y=\"3\" rx=\"2\"></rect><circle cx=\"7.5\" cy=\"7.5\" r=\".5\" fill=\"currentColor\"></circle><path d=\"m7.9 7.9l2.7 2.7\"></path><circle cx=\"16.5\" cy=\"7.5\" r=\".5\" fill=\"currentColor\"></circle><path d=\"m13.4 10.6l2.7-2.7\"></path><circle cx=\"7.5\" cy=\"16.5\" r=\".5\" fill=\"currentColor\"></circle><path d=\"m7.9 16.1l2.7-2.7\"></path><circle cx=\"16.5\" cy=\"16.5\" r=\".5\" fill=\"currentColor\"></circle><path d=\"m13.4 13.4l2.7 2.7\"></path><circle cx=\"12\" cy=\"12\" r=\"2\"></circle></g>", 1)]));
}
var vault_default = {
	name: "lucide-vault",
	render: render$12
};
var _hoisted_1$73 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$11(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$73, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("path", { d: "m16 13l5.223 3.482a.5.5 0 0 0 .777-.416V7.87a.5.5 0 0 0-.752-.432L16 10.5" }), createBaseVNode("rect", {
		width: "14",
		height: "12",
		x: "2",
		y: "6",
		rx: "2"
	})], -1)]));
}
var video_default = {
	name: "lucide-video",
	render: render$11
};
var _hoisted_1$72 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$10(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$72, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "M11 4.702a.705.705 0 0 0-1.203-.498L6.413 7.587A1.4 1.4 0 0 1 5.416 8H3a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h2.416a1.4 1.4 0 0 1 .997.413l3.383 3.384A.705.705 0 0 0 11 19.298zM16 9a5 5 0 0 1 0 6m3.364 3.364a9 9 0 0 0 0-12.728"
	}, null, -1)]));
}
var volume_2_default = {
	name: "lucide-volume-2",
	render: render$10
};
var _hoisted_1$71 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$9(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$71, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "M11 4.702a.705.705 0 0 0-1.203-.498L6.413 7.587A1.4 1.4 0 0 1 5.416 8H3a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h2.416a1.4 1.4 0 0 1 .997.413l3.383 3.384A.705.705 0 0 0 11 19.298zM22 9l-6 6m0-6l6 6"
	}, null, -1)]));
}
var volume_x_default = {
	name: "lucide-volume-x",
	render: render$9
};
var _hoisted_1$70 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$8(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$70, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "m21.64 3.64l-1.28-1.28a1.21 1.21 0 0 0-1.72 0L2.36 18.64a1.21 1.21 0 0 0 0 1.72l1.28 1.28a1.2 1.2 0 0 0 1.72 0L21.64 5.36a1.2 1.2 0 0 0 0-1.72M14 7l3 3M5 6v4m14 4v4M10 2v2M7 8H3m18 8h-4M11 3H9"
	}, null, -1)]));
}
var wand_sparkles_default = {
	name: "lucide-wand-sparkles",
	render: render$8
};
var _hoisted_1$69 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$7(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$69, _cache[0] || (_cache[0] = [createStaticVNode("<g fill=\"none\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\"><circle cx=\"12\" cy=\"4.5\" r=\"2.5\"></circle><path d=\"m10.2 6.3l-3.9 3.9\"></path><circle cx=\"4.5\" cy=\"12\" r=\"2.5\"></circle><path d=\"M7 12h10\"></path><circle cx=\"19.5\" cy=\"12\" r=\"2.5\"></circle><path d=\"m13.8 17.7l3.9-3.9\"></path><circle cx=\"12\" cy=\"19.5\" r=\"2.5\"></circle></g>", 1)]));
}
var waypoints_default = {
	name: "lucide-waypoints",
	render: render$7
};
var _hoisted_1$68 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$6(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$68, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"
	}, null, -1)]));
}
var wrench_default = {
	name: "lucide-wrench",
	render: render$6
};
var _hoisted_1$67 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$5(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$67, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "M18 6L6 18M6 6l12 12"
	}, null, -1)]));
}
var x_default = {
	name: "lucide-x",
	render: render$5
};
var _hoisted_1$66 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$4(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$66, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2",
		d: "M4 14a1 1 0 0 1-.78-1.63l9.9-10.2a.5.5 0 0 1 .86.46l-1.92 6.02A1 1 0 0 0 13 10h7a1 1 0 0 1 .78 1.63l-9.9 10.2a.5.5 0 0 1-.86-.46l1.92-6.02A1 1 0 0 0 11 14z"
	}, null, -1)]));
}
var zap_default = {
	name: "lucide-zap",
	render: render$4
};
var _hoisted_1$65 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$3(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$65, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("circle", {
		cx: "11",
		cy: "11",
		r: "8"
	}), createBaseVNode("path", { d: "m21 21l-4.35-4.35M11 8v6m-3-3h6" })], -1)]));
}
var zoom_in_default = {
	name: "lucide-zoom-in",
	render: render$3
};
var _hoisted_1$64 = {
	viewBox: "0 0 24 24",
	width: "1.2em",
	height: "1.2em"
};
function render$2(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$64, _cache[0] || (_cache[0] = [createBaseVNode("g", {
		fill: "none",
		stroke: "currentColor",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		"stroke-width": "2"
	}, [createBaseVNode("circle", {
		cx: "11",
		cy: "11",
		r: "8"
	}), createBaseVNode("path", { d: "m21 21l-4.35-4.35M8 11h6" })], -1)]));
}
var zoom_out_default = {
	name: "lucide-zoom-out",
	render: render$2
};
const deprecatedIconSet = {
	variable: variable_default,
	"pop-out": pop_out_default,
	triangle: triangle_default,
	"status-completed": status_completed_default,
	"status-waiting": status_waiting_default,
	"status-error": status_error_default,
	"status-canceled": status_canceled_default,
	"status-new": status_new_default,
	"status-unknown": status_unknown_default,
	"status-warning": status_warning_default,
	"vector-square": vector_square_default,
	schema: schema_default,
	json: braces_default,
	binary: binary_default,
	text: text_default,
	toolbox: toolbox_default,
	spinner: spinner_default,
	xmark: x_default,
	mcp: mcp_default,
	"caret-up": chevron_up_default,
	"caret-down": chevron_down_default,
	"caret-right": chevron_right_default,
	"caret-left": chevron_left_default,
	"folder-plus": folder_plus_default,
	share: share_default,
	"user-check": user_check_default,
	"check-double": check_check_default,
	"exclamation-circle": circle_alert_default,
	circle: circle_default,
	"eye-slash": eye_off_default,
	folder: folder_default,
	"minus-circle": circle_minus_default,
	adjust: contrast_default,
	refresh: refresh_cw_default,
	vault: vault_default,
	"angle-double-left": chevrons_left_default,
	"angle-down": chevron_down_default,
	"angle-left": chevron_left_default,
	"angle-right": chevron_right_default,
	"angle-up": chevron_up_default,
	archive: archive_default,
	"arrow-left": arrow_left_default$1,
	"arrow-right": arrow_right_default$1,
	"arrow-up": arrow_up_default$1,
	"arrow-down": arrow_down_default$1,
	at: at_sign_default,
	ban: ban_default,
	"balance-scale-left": scale_default,
	bars: menu_default,
	bolt: zap_default,
	book: book_default,
	"box-open": package_open_default,
	bug: bug_default,
	brain: brain_default,
	calculator: calculator_default,
	calendar: calendar_default,
	"chart-bar": chart_column_decreasing_default,
	check: check_default,
	"check-circle": circle_check_default,
	"check-square": square_check_default,
	"chevron-left": chevron_left_default,
	"chevron-right": chevron_right_default,
	"chevron-down": chevron_down_default,
	"chevron-up": chevron_up_default,
	code: code_default,
	"code-branch": git_branch_default,
	cog: cog_default,
	cogs: cog_default,
	"columns-3-cog": columns_3_cog_default,
	comment: message_circle_default,
	comments: messages_square_default,
	clipboard: clipboard_default,
	"clipboard-check": clipboard_check_default,
	"clipboard-list": clipboard_list_default,
	clock: clock_default,
	clone: copy_default,
	cloud: cloud_default,
	"cloud-download-alt": cloud_download_default,
	compress: chevrons_up_down_default,
	copy: files_default,
	cube: box_default,
	cut: scissors_default,
	database: database_default,
	"dot-circle": circle_dot_default,
	"grip-lines-vertical": grip_lines_vertical_default,
	"grip-vertical": grip_vertical_default,
	edit: square_pen_default,
	"ellipsis-h": ellipsis_default,
	"ellipsis-v": ellipsis_vertical_default,
	envelope: mail_default,
	equals: equal_default,
	eye: eye_default,
	"exclamation-triangle": triangle_alert_default,
	expand: maximize_default,
	"expand-alt": maximize_2_default,
	"external-link-alt": external_link_default,
	"exchange-alt": arrow_left_right_default,
	file: file_default,
	"file-alt": file_text_default,
	"file-archive": file_archive_default,
	"file-code": file_code_default,
	"file-download": file_down_default,
	"file-export": file_output_default,
	"file-import": file_input_default,
	"file-pdf": file_text_default,
	filter: funnel_default,
	fingerprint: fingerprint_default,
	flask: flask_conical_default,
	"folder-open": folder_open_default,
	font: case_upper_default,
	gift: gift_default,
	globe: globe_default,
	"globe-americas": earth_default,
	"graduation-cap": graduation_cap_default,
	"hand-holding-usd": hand_coins_default,
	"hand-scissors": scissors_default,
	handshake: handshake_default,
	"hand-point-left": arrow_left_default$1,
	hashtag: hash_default,
	hdd: hard_drive_default,
	history: history_default,
	home: house_default,
	hourglass: hourglass_default,
	image: image_default,
	inbox: inbox_default,
	info: info_default,
	"info-circle": info_default,
	key: key_round_default,
	language: languages_default,
	"layer-group": layers_default,
	link: link_default,
	list: list_default,
	lightbulb: lightbulb_default,
	lock: lock_default,
	"map-signs": milestone_default,
	"mouse-pointer": mouse_pointer_default,
	"network-wired": network_default,
	palette: palette_default,
	pause: pause_default,
	"pause-circle": circle_pause_default,
	pen: pen_default,
	"pencil-alt": pencil_default,
	play: play_default,
	"play-circle": circle_play_default,
	plug: plug_default,
	plus: plus_default$1,
	"plus-circle": circle_plus_default,
	"plus-square": square_plus_default,
	"project-diagram": waypoints_default,
	question: circle_help_default,
	"question-circle": circle_help_default,
	redo: redo_2_default,
	"remove-format": remove_formatting_default,
	robot: bot_default,
	rss: rss_default,
	save: save_default,
	"satellite-dish": satellite_dish_default,
	search: search_default,
	"search-minus": zoom_out_default,
	"search-plus": zoom_in_default,
	server: server_default,
	screwdriver: pocket_knife_default,
	smile: smile_default,
	"sign-in-alt": log_in_default,
	"sign-out-alt": log_out_default,
	"sliders-h": sliders_horizontal_default,
	"sticky-note": sticky_note_default,
	stop: square_default,
	stream: align_right_default,
	sun: sun_default,
	sync: refresh_cw_default,
	"sync-alt": refresh_cw_default,
	table: table_default,
	tags: tags_default,
	tasks: list_checks_default,
	terminal: terminal_default,
	"th-large": grid_2x2_default,
	timer: timer_default,
	thumbtack: pin_default,
	"thumbs-down": thumbs_down_default,
	"thumbs-up": thumbs_up_default,
	times: x_default,
	"times-circle": circle_x_default,
	tools: wrench_default,
	trash: trash_2_default,
	undo: undo_2_default,
	unlink: unlink_default,
	user: user_default,
	"user-circle": circle_user_round_default,
	"user-friends": user_round_default,
	users: users_default,
	video: video_default,
	tree: tree_pine_default,
	"user-lock": user_lock_default,
	gem: gem_default,
	download: hard_drive_download_default,
	"power-off": power_default,
	"paper-plane": send_default,
	bell: bell_default
};
const updatedIconSet = {
	anthropic: anthropic_default,
	"bolt-filled": bolt_filled_default,
	"filled-square": filled_square_default,
	"grip-lines-vertical": grip_lines_vertical_default,
	variable: variable_default,
	"pop-out": pop_out_default,
	triangle: triangle_default,
	"status-completed": status_completed_default,
	"status-waiting": status_waiting_default,
	"status-error": status_error_default,
	"status-canceled": status_canceled_default,
	"status-new": status_new_default,
	"status-unknown": status_unknown_default,
	"status-warning": status_warning_default,
	"vector-square": vector_square_default,
	"continue-on-error": continue_default,
	"always-output-data": empty_output_default,
	"retry-on-fail": retry_default,
	"execute-once": run_once_default,
	schema: schema_default,
	json: braces_default,
	binary: binary_default,
	text: text_default,
	toolbox: toolbox_default,
	spinner: spinner_default,
	"node-dirty": node_dirty_default,
	"node-ellipsis": node_ellipsis_default,
	"node-execution-error": node_execution_error_default,
	"node-validation-error": node_validation_error_default,
	"node-pin": node_pin_default,
	"node-play": node_play_default,
	"node-power": node_power_default,
	"node-success": node_success_default,
	"node-trash": node_trash_default,
	mcp: mcp_default,
	lovable: lovable_default,
	resolver: resolver_default,
	"align-right": align_right_default,
	archive: archive_default,
	"archive-restore": archive_restore_default,
	"arrow-down": arrow_down_default$1,
	"arrow-left": arrow_left_default$1,
	"arrow-left-right": arrow_left_right_default,
	"arrow-right": arrow_right_default$1,
	"arrow-right-from-line": arrow_right_from_line_default,
	"arrow-right-to-line": arrow_right_to_line_default,
	"arrow-up": arrow_up_default$1,
	"arrow-up-right": arrow_up_right_default,
	"at-sign": at_sign_default,
	ban: ban_default,
	bell: bell_default,
	book: book_default,
	"book-open": book_open_default,
	bot: bot_default,
	box: box_default,
	brain: brain_default,
	bug: bug_default,
	calculator: calculator_default,
	calendar: calendar_default,
	"case-upper": case_upper_default,
	"chart-column-decreasing": chart_column_decreasing_default,
	check: check_default,
	"check-check": check_check_default,
	"chevron-down": chevron_down_default,
	"chevron-left": chevron_left_default,
	"chevron-right": chevron_right_default,
	"chevron-up": chevron_up_default,
	"chevrons-left": chevrons_left_default,
	"chevrons-down-up": chevrons_down_up_default,
	"chevrons-up-down": chevrons_up_down_default,
	circle: circle_default,
	"circle-alert": circle_alert_default,
	"circle-check": circle_check_default,
	"circle-dot": circle_dot_default,
	"circle-help": circle_help_default,
	"circle-minus": circle_minus_default,
	"circle-pause": circle_pause_default,
	"circle-play": circle_play_default,
	"circle-plus": circle_plus_default,
	"circle-user-round": circle_user_round_default,
	"circle-x": circle_x_default,
	clipboard: clipboard_default,
	"clipboard-check": clipboard_check_default,
	"clipboard-list": clipboard_list_default,
	clock: clock_default,
	cloud: cloud_default,
	"cloud-download": cloud_download_default,
	code: code_default,
	cog: cog_default,
	contrast: contrast_default,
	copy: copy_default,
	crosshair: crosshair_default,
	database: database_default,
	"door-open": door_open_default,
	dot: dot_default,
	earth: earth_default,
	ellipsis: ellipsis_default,
	"ellipsis-vertical": ellipsis_vertical_default,
	equal: equal_default,
	expand: expand_default,
	"external-link": external_link_default,
	eye: eye_default,
	"eye-off": eye_off_default,
	file: file_default,
	"file-archive": file_archive_default,
	"file-code": file_code_default,
	"file-diff": file_diff_default,
	"file-down": file_down_default,
	"file-input": file_input_default,
	"file-output": file_output_default,
	"file-text": file_text_default,
	files: files_default,
	fingerprint: fingerprint_default,
	"flask-conical": flask_conical_default,
	folder: folder_default,
	"folder-open": folder_open_default,
	"folder-plus": folder_plus_default,
	funnel: funnel_default,
	gem: gem_default,
	gift: gift_default,
	"git-branch": git_branch_default,
	globe: globe_default,
	"graduation-cap": graduation_cap_default,
	"grid-2x2": grid_2x2_default,
	"grip-vertical": grip_vertical_default,
	"hand-coins": hand_coins_default,
	handshake: handshake_default,
	"hard-drive": hard_drive_default,
	"hard-drive-download": hard_drive_download_default,
	hash: hash_default,
	history: history_default,
	hourglass: hourglass_default,
	house: house_default,
	image: image_default,
	inbox: inbox_default,
	info: info_default,
	"key-round": key_round_default,
	languages: languages_default,
	layers: layers_default,
	lightbulb: lightbulb_default,
	link: link_default,
	list: list_default,
	"list-checks": list_checks_default,
	lock: lock_default,
	"log-in": log_in_default,
	"log-out": log_out_default,
	mail: mail_default,
	"minimize-2": minimize_2_default,
	maximize: maximize_default,
	"maximize-2": maximize_2_default,
	menu: menu_default,
	"message-circle": message_circle_default,
	"message-square": message_square_default,
	"messages-square": messages_square_default,
	mic: mic_default,
	milestone: milestone_default,
	minus: minus_default$1,
	"mouse-pointer": mouse_pointer_default,
	network: network_default,
	"notebook-pen": notebook_pen_default,
	"package-open": package_open_default,
	palette: palette_default,
	"panel-left": panel_left_default,
	"panel-right": panel_right_default,
	paperclip: paperclip_default,
	pause: pause_default,
	pen: pen_default,
	pencil: pencil_default,
	pin: pin_default,
	play: play_default,
	plug: plug_default,
	plus: plus_default$1,
	"pocket-knife": pocket_knife_default,
	power: power_default,
	"redo-2": redo_2_default,
	"refresh-cw": refresh_cw_default,
	"remove-formatting": remove_formatting_default,
	rss: rss_default,
	robot: bot_default,
	"satellite-dish": satellite_dish_default,
	save: save_default,
	scale: scale_default,
	scissors: scissors_default,
	search: search_default,
	settings: settings_default,
	settings2: settings_2_default,
	send: send_default,
	server: server_default,
	share: share_default,
	"sliders-horizontal": sliders_horizontal_default,
	smile: smile_default,
	sparkles: sparkles_default,
	split: split_default,
	square: square_default,
	"square-check": square_check_default,
	"square-minus": square_minus_default,
	"square-pen": square_pen_default,
	"square-plus": square_plus_default,
	"sticky-note": sticky_note_default,
	sun: sun_default,
	table: table_default,
	tags: tags_default,
	terminal: terminal_default,
	"thumbs-down": thumbs_down_default,
	"thumbs-up": thumbs_up_default,
	"trash-2": trash_2_default,
	"tree-pine": tree_pine_default,
	"triangle-alert": triangle_alert_default,
	type: type_default,
	"toggle-right": toggle_right_default,
	"undo-2": undo_2_default,
	unlink: unlink_default,
	user: user_default,
	"user-check": user_check_default,
	"user-lock": user_lock_default,
	"user-round": user_round_default,
	users: users_default,
	vault: vault_default,
	video: video_default,
	"volume-2": volume_2_default,
	"volume-x": volume_x_default,
	"wand-sparkles": wand_sparkles_default,
	waypoints: waypoints_default,
	wrench: wrench_default,
	x: x_default,
	zap: zap_default,
	"zoom-in": zoom_in_default,
	"zoom-out": zoom_out_default
};
function isSupportedIconName(iconName) {
	return typeof iconName === "string" && (iconName in updatedIconSet || iconName in deprecatedIconSet);
}
var Icon_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	name: "N8nIcon",
	__name: "Icon",
	props: {
		icon: {},
		size: { default: void 0 },
		spin: {
			type: Boolean,
			default: false
		},
		color: { default: void 0 },
		strokeWidth: {}
	},
	setup(__props) {
		const props = __props;
		const $style = useCssModule();
		const classes = computed(() => {
			const applied = [];
			if (props.spin) applied.push("spin");
			if (props.strokeWidth) applied.push("strokeWidth");
			return ["n8n-icon", ...applied.map((c$2) => $style[c$2])];
		});
		const sizesInPixels = {
			xsmall: 10,
			small: 12,
			medium: 14,
			large: 16,
			xlarge: 20,
			xxlarge: 40
		};
		const size$2 = computed(() => {
			let sizeToApply = "1em";
			if (props.size) sizeToApply = `${typeof props.size === "number" ? props.size : sizesInPixels[props.size]}px`;
			return {
				height: sizeToApply,
				width: sizeToApply
			};
		});
		const colorMap = {
			primary: "--color--primary",
			secondary: "--color--secondary",
			"text-dark": "--color--text--shade-1",
			"text-base": "--color--text",
			"text-light": "--color--text--tint-1",
			"text-xlight": "--color--text--tint-3",
			danger: "--color--danger",
			success: "--color--success",
			warning: "--color--warning",
			"foreground-dark": "--color--foreground--shade-1",
			"foreground-xdark": "--color--foreground--shade-2"
		};
		const styles = computed(() => {
			const stylesToApply = {};
			if (props.color) stylesToApply.color = `var(${colorMap[props.color]})`;
			if (props.strokeWidth) stylesToApply["--icon--stroke-width"] = `${props.strokeWidth}px`;
			return stylesToApply;
		});
		return (_ctx, _cache) => {
			return unref(updatedIconSet)[_ctx.icon] ?? unref(deprecatedIconSet)[_ctx.icon] ? (openBlock(), createBlock(resolveDynamicComponent(unref(updatedIconSet)[_ctx.icon] ?? unref(deprecatedIconSet)[_ctx.icon]), {
				key: 0,
				class: normalizeClass(classes.value),
				"aria-hidden": "true",
				focusable: "false",
				role: "img",
				height: size$2.value.height,
				width: size$2.value.width,
				"data-icon": props.icon,
				style: normalizeStyle(styles.value)
			}, null, 8, [
				"class",
				"height",
				"width",
				"data-icon",
				"style"
			])) : createCommentVNode("", true);
		};
	}
});
var Icon_vue_vue_type_style_index_0_lang_module_default = {
	strokeWidth: "_strokeWidth_1gp7m_123",
	spin: "_spin_1gp7m_128"
};
var Icon_default = /* @__PURE__ */ __plugin_vue_export_helper_default(Icon_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": Icon_vue_vue_type_style_index_0_lang_module_default }]]);
var N8nIcon_default = Icon_default;
var _hoisted_1$63 = { class: "n8n-spinner" };
var _hoisted_2$39 = {
	key: 0,
	class: "lds-ring"
};
var N8nSpinner_default = /* @__PURE__ */ defineComponent({
	name: "N8nSpinner",
	__name: "Spinner",
	props: {
		size: { default: "medium" },
		type: { default: "dots" }
	},
	setup(__props) {
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("span", _hoisted_1$63, [_ctx.type === "ring" ? (openBlock(), createElementBlock("div", _hoisted_2$39, _cache[0] || (_cache[0] = [
				createBaseVNode("div", null, null, -1),
				createBaseVNode("div", null, null, -1),
				createBaseVNode("div", null, null, -1),
				createBaseVNode("div", null, null, -1)
			]))) : (openBlock(), createBlock(unref(N8nIcon_default), {
				key: 1,
				icon: "spinner",
				size: _ctx.size,
				spin: ""
			}, null, 8, ["size"]))]);
		};
	}
});
var _hoisted_1$62 = { key: 1 };
var Button_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	name: "N8nButton",
	__name: "Button",
	props: {
		block: {
			type: Boolean,
			default: false
		},
		element: { default: "button" },
		href: {},
		label: { default: "" },
		square: {
			type: Boolean,
			default: false
		},
		active: {
			type: Boolean,
			default: false
		},
		disabled: {
			type: Boolean,
			default: false
		},
		float: {},
		icon: {},
		loading: {
			type: Boolean,
			default: false
		},
		outline: {
			type: Boolean,
			default: false
		},
		size: { default: "medium" },
		iconSize: {},
		text: {
			type: Boolean,
			default: false
		},
		type: { default: "primary" },
		nativeType: {}
	},
	setup(__props) {
		const $style = useCssModule();
		const attrs = useAttrs();
		const props = __props;
		watchEffect(() => {
			if (props.element === "a" && !props.href) console.error("n8n-button:href is required for link buttons");
		});
		const ariaBusy = computed(() => props.loading ? "true" : void 0);
		const ariaDisabled = computed(() => props.disabled ? "true" : void 0);
		const isDisabled = computed(() => props.disabled || props.loading);
		const iconSize = computed(() => props.iconSize ?? (props.size === "xmini" || props.size === "mini" ? "xsmall" : props.size));
		const classes = computed(() => {
			return `button ${$style.button} ${$style[props.type]}${props.size ? ` ${$style[props.size]}` : ""}${props.outline ? ` ${$style.outline}` : ""}${props.loading ? ` ${$style.loading}` : ""}${props.float ? ` ${$style[`float-${props.float}`]}` : ""}${props.text ? ` ${$style.text}` : ""}${props.disabled ? ` ${$style.disabled}` : ""}${props.block ? ` ${$style.block}` : ""}${props.active ? ` ${$style.active}` : ""}${props.icon || props.loading ? ` ${$style.withIcon}` : ""}${props.square ? ` ${$style.square}` : ""}`;
		});
		return (_ctx, _cache) => {
			return openBlock(), createBlock(resolveDynamicComponent(_ctx.element), mergeProps({
				class: classes.value,
				disabled: isDisabled.value,
				"aria-disabled": ariaDisabled.value,
				"aria-busy": ariaBusy.value,
				href: _ctx.href,
				"aria-live": "polite"
			}, {
				...unref(attrs),
				...props.nativeType ? { type: props.nativeType } : {}
			}), {
				default: withCtx(() => [_ctx.loading || _ctx.icon ? (openBlock(), createElementBlock("span", {
					key: 0,
					class: normalizeClass(unref($style).icon)
				}, [_ctx.loading ? (openBlock(), createBlock(unref(N8nSpinner_default), {
					key: 0,
					size: iconSize.value
				}, null, 8, ["size"])) : _ctx.icon ? (openBlock(), createBlock(unref(N8nIcon_default), {
					key: 1,
					icon: _ctx.icon,
					size: iconSize.value
				}, null, 8, ["icon", "size"])) : createCommentVNode("", true)], 2)) : createCommentVNode("", true), _ctx.label ? (openBlock(), createElementBlock("span", _hoisted_1$62, toDisplayString(_ctx.label), 1)) : _ctx.$slots.default ? renderSlot(_ctx.$slots, "default", { key: 2 }) : createCommentVNode("", true)]),
				_: 3
			}, 16, [
				"class",
				"disabled",
				"aria-disabled",
				"aria-busy",
				"href"
			]);
		};
	}
});
var Button_vue_vue_type_style_index_1_lang_module_default = {
	button: "_button_zpi3n_123",
	active: "_active_zpi3n_157",
	disabled: "_disabled_zpi3n_175",
	loading: "_loading_zpi3n_183",
	secondary: "_secondary_zpi3n_206",
	highlight: "_highlight_zpi3n_228",
	tertiary: "_tertiary_zpi3n_250",
	success: "_success_zpi3n_272",
	warning: "_warning_zpi3n_294",
	danger: "_danger_zpi3n_316",
	xmini: "_xmini_zpi3n_341",
	square: "_square_zpi3n_346",
	mini: "_mini_zpi3n_351",
	small: "_small_zpi3n_361",
	medium: "_medium_zpi3n_371",
	large: "_large_zpi3n_381",
	xlarge: "_xlarge_zpi3n_386",
	outline: "_outline_zpi3n_399",
	primary: "_primary_zpi3n_403",
	text: "_text_zpi3n_440",
	transparent: "_transparent_zpi3n_508",
	withIcon: "_withIcon_zpi3n_513",
	icon: "_icon_zpi3n_519",
	block: "_block_zpi3n_528",
	"float-left": "_float-left_zpi3n_532",
	"float-right": "_float-right_zpi3n_536"
};
var Button_default = /* @__PURE__ */ __plugin_vue_export_helper_default(Button_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": Button_vue_vue_type_style_index_1_lang_module_default }]]);
var N8nButton_default = Button_default;
var Text_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	name: "N8nText",
	__name: "Text",
	props: {
		bold: {
			type: Boolean,
			default: false
		},
		size: { default: "medium" },
		color: {},
		align: {},
		compact: {
			type: Boolean,
			default: false
		},
		tag: { default: "span" }
	},
	setup(__props) {
		const props = __props;
		const $style = useCssModule();
		const classes = computed(() => {
			const applied = [];
			if (props.align) applied.push(`align-${props.align}`);
			if (props.color) applied.push(props.color);
			if (props.compact) applied.push("compact");
			applied.push(`size-${props.size}`);
			applied.push(props.bold ? "bold" : "regular");
			return applied.map((c$2) => $style[c$2]);
		});
		return (_ctx, _cache) => {
			return openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), mergeProps({ class: ["n8n-text", ...classes.value] }, _ctx.$attrs), {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 16, ["class"]);
		};
	}
});
const bold$2 = "_bold_1c4va_123";
const regular$1 = "_regular_1c4va_127";
const compact = "_compact_1c4va_156";
const primary$3 = "_primary_1c4va_160";
const secondary$3 = "_secondary_1c4va_164";
const danger$5 = "_danger_1c4va_184";
const success$4 = "_success_1c4va_188";
const warning$4 = "_warning_1c4va_192";
var Text_vue_vue_type_style_index_0_lang_module_default = {
	bold: bold$2,
	regular: regular$1,
	"size-xlarge": "_size-xlarge_1c4va_131",
	"size-large": "_size-large_1c4va_136",
	"size-medium": "_size-medium_1c4va_141",
	"size-small": "_size-small_1c4va_146",
	"size-xsmall": "_size-xsmall_1c4va_151",
	compact,
	primary: primary$3,
	secondary: secondary$3,
	"text-dark": "_text-dark_1c4va_168",
	"text-base": "_text-base_1c4va_172",
	"text-light": "_text-light_1c4va_176",
	"text-xlight": "_text-xlight_1c4va_180",
	danger: danger$5,
	success: success$4,
	warning: warning$4,
	"foreground-dark": "_foreground-dark_1c4va_196",
	"foreground-xdark": "_foreground-xdark_1c4va_200",
	"align-left": "_align-left_1c4va_204",
	"align-right": "_align-right_1c4va_208",
	"align-center": "_align-center_1c4va_212"
};
var N8nText_default = /* @__PURE__ */ __plugin_vue_export_helper_default(Text_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": Text_vue_vue_type_style_index_0_lang_module_default }]]);
var Callout_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	name: "N8nCallout",
	__name: "Callout",
	props: {
		theme: {},
		icon: {},
		iconSize: { default: "medium" },
		iconless: { type: Boolean },
		slim: { type: Boolean },
		roundCorners: {
			type: Boolean,
			default: true
		},
		onlyBottomBorder: { type: Boolean }
	},
	setup(__props) {
		const CALLOUT_DEFAULT_ICONS = {
			info: "info",
			success: "circle-check",
			warning: "triangle-alert",
			danger: "triangle-alert"
		};
		const props = __props;
		const $style = useCssModule();
		const classes = computed(() => [
			"n8n-callout",
			$style.callout,
			$style[props.theme],
			props.slim ? $style.slim : "",
			props.roundCorners ? $style.round : "",
			props.onlyBottomBorder ? $style.onlyBottomBorder : ""
		]);
		const getIcon = computed(() => props.icon ?? CALLOUT_DEFAULT_ICONS?.[props.theme] ?? CALLOUT_DEFAULT_ICONS.info);
		const getIconSize = computed(() => {
			if (props.iconSize) return props.iconSize;
			if (props.theme === "secondary") return "medium";
			return "large";
		});
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", {
				class: normalizeClass(classes.value),
				role: "alert"
			}, [createBaseVNode("div", { class: normalizeClass(unref($style).messageSection) }, [
				!_ctx.iconless ? (openBlock(), createElementBlock("div", {
					key: 0,
					class: normalizeClass(unref($style).icon)
				}, [createVNode(unref(N8nIcon_default), {
					icon: getIcon.value,
					size: getIconSize.value
				}, null, 8, ["icon", "size"])], 2)) : createCommentVNode("", true),
				createVNode(unref(N8nText_default), { size: "small" }, {
					default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
					_: 3
				}),
				_cache[0] || (_cache[0] = createTextVNode(" \xA0 ")),
				renderSlot(_ctx.$slots, "actions")
			], 2), renderSlot(_ctx.$slots, "trailingContent")], 2);
		};
	}
});
var Callout_vue_vue_type_style_index_0_lang_module_default = {
	callout: "_callout_1nugz_123",
	slim: "_slim_1nugz_135",
	round: "_round_1nugz_150",
	onlyBottomBorder: "_onlyBottomBorder_1nugz_154",
	messageSection: "_messageSection_1nugz_160",
	info: "_info_1nugz_165",
	custom: "_custom_1nugz_166",
	icon: "_icon_1nugz_171",
	success: "_success_1nugz_176",
	warning: "_warning_1nugz_185",
	danger: "_danger_1nugz_194",
	secondary: "_secondary_1nugz_208"
};
var Callout_default = /* @__PURE__ */ __plugin_vue_export_helper_default(Callout_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": Callout_vue_vue_type_style_index_0_lang_module_default }]]);
var N8nCallout_default = Callout_default;
var Heading_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	name: "N8nHeading",
	__name: "Heading",
	props: {
		tag: { default: "span" },
		bold: {
			type: Boolean,
			default: false
		},
		size: { default: "medium" },
		color: {},
		align: {}
	},
	setup(__props) {
		const props = __props;
		const $style = useCssModule();
		const classes = computed(() => {
			const applied = [];
			if (props.align) applied.push(`align-${props.align}`);
			if (props.color) applied.push(props.color);
			applied.push(`size-${props.size}`);
			applied.push(props.bold ? "bold" : "regular");
			return applied.map((c$2) => $style[c$2]);
		});
		return (_ctx, _cache) => {
			return openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), mergeProps({ class: ["n8n-heading", ...classes.value] }, _ctx.$attrs), {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 16, ["class"]);
		};
	}
});
const bold$1 = "_bold_2u9bv_123";
const regular = "_regular_2u9bv_127";
const primary$2 = "_primary_2u9bv_156";
const danger$3 = "_danger_2u9bv_176";
var Heading_vue_vue_type_style_index_0_lang_module_default = {
	bold: bold$1,
	regular,
	"size-2xlarge": "_size-2xlarge_2u9bv_131",
	"size-xlarge": "_size-xlarge_2u9bv_136",
	"size-large": "_size-large_2u9bv_141",
	"size-medium": "_size-medium_2u9bv_146",
	"size-small": "_size-small_2u9bv_151",
	primary: primary$2,
	"text-dark": "_text-dark_2u9bv_160",
	"text-base": "_text-base_2u9bv_164",
	"text-light": "_text-light_2u9bv_168",
	"text-xlight": "_text-xlight_2u9bv_172",
	danger: danger$3,
	"align-left": "_align-left_2u9bv_180",
	"align-right": "_align-right_2u9bv_184",
	"align-center": "_align-center_2u9bv_188"
};
var N8nHeading_default = /* @__PURE__ */ __plugin_vue_export_helper_default(Heading_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": Heading_vue_vue_type_style_index_0_lang_module_default }]]);
var FOCUSABLE_ELEMENT_SELECTORS = `a[href],button:not([disabled]),button:not([hidden]),:not([tabindex="-1"]),input:not([disabled]),input:not([type="hidden"]),select:not([disabled]),textarea:not([disabled])`;
var isVisible = (element) => {
	return getComputedStyle(element).position === "fixed" ? false : element.offsetParent !== null;
};
var obtainAllFocusableElements$1 = (element) => {
	return Array.from(element.querySelectorAll(FOCUSABLE_ELEMENT_SELECTORS)).filter((item$4) => isFocusable(item$4) && isVisible(item$4));
};
var isFocusable = (element) => {
	if (element.tabIndex > 0 || element.tabIndex === 0 && element.getAttribute("tabIndex") !== null) return true;
	if (element.disabled) return false;
	switch (element.nodeName) {
		case "A": return !!element.href && element.rel !== "ignore";
		case "INPUT": return !(element.type === "hidden" || element.type === "file");
		case "BUTTON":
		case "SELECT":
		case "TEXTAREA": return true;
		default: return false;
	}
};
var triggerEvent = function(elm, name$1, ...opts) {
	let eventName;
	if (name$1.includes("mouse") || name$1.includes("click")) eventName = "MouseEvents";
	else if (name$1.includes("key")) eventName = "KeyboardEvent";
	else eventName = "HTMLEvents";
	const evt = document.createEvent(eventName);
	evt.initEvent(name$1, ...opts);
	elm.dispatchEvent(evt);
	return elm;
};
var composeEventHandlers = (theirsHandler, oursHandler, { checkForDefaultPrevented = true } = {}) => {
	const handleEvent = (event) => {
		const shouldPrevent = theirsHandler == null ? void 0 : theirsHandler(event);
		if (checkForDefaultPrevented === false || !shouldPrevent) return oursHandler == null ? void 0 : oursHandler(event);
	};
	return handleEvent;
};
var whenMouse = (handler) => {
	return (e) => e.pointerType === "mouse" ? handler(e) : void 0;
};
var getClientXY = (event) => {
	let clientX;
	let clientY;
	if (event.type === "touchend") {
		clientY = event.changedTouches[0].clientY;
		clientX = event.changedTouches[0].clientX;
	} else if (event.type.startsWith("touch")) {
		clientY = event.touches[0].clientY;
		clientX = event.touches[0].clientX;
	} else {
		clientY = event.clientY;
		clientX = event.clientX;
	}
	return {
		clientX,
		clientY
	};
};
var reWhitespace = /\s/;
function trimmedEndIndex(string) {
	var index = string.length;
	while (index-- && reWhitespace.test(string.charAt(index)));
	return index;
}
var _trimmedEndIndex_default = trimmedEndIndex;
var reTrimStart = /^\s+/;
function baseTrim(string) {
	return string ? string.slice(0, _trimmedEndIndex_default(string) + 1).replace(reTrimStart, "") : string;
}
var _baseTrim_default = baseTrim;
var NAN = NaN;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber(value) {
	if (typeof value == "number") return value;
	if (isSymbol_default(value)) return NAN;
	if (isObject_default(value)) {
		var other = typeof value.valueOf == "function" ? value.valueOf() : value;
		value = isObject_default(other) ? other + "" : other;
	}
	if (typeof value != "string") return value === 0 ? value : +value;
	value = _baseTrim_default(value);
	var isBinary = reIsBinary.test(value);
	return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
var toNumber_default = toNumber;
var INFINITY = Infinity, MAX_INTEGER = 17976931348623157e292;
function toFinite(value) {
	if (!value) return value === 0 ? value : 0;
	value = toNumber_default(value);
	if (value === INFINITY || value === -INFINITY) return (value < 0 ? -1 : 1) * MAX_INTEGER;
	return value === value ? value : 0;
}
var toFinite_default = toFinite;
function toInteger(value) {
	var result = toFinite_default(value), remainder = result % 1;
	return result === result ? remainder ? result - remainder : result : 0;
}
var toInteger_default = toInteger;
function identity$1(value) {
	return value;
}
var identity_default = identity$1;
var _WeakMap_default = _getNative_default(_root_default, "WeakMap");
function apply(func, thisArg, args) {
	switch (args.length) {
		case 0: return func.call(thisArg);
		case 1: return func.call(thisArg, args[0]);
		case 2: return func.call(thisArg, args[0], args[1]);
		case 3: return func.call(thisArg, args[0], args[1], args[2]);
	}
	return func.apply(thisArg, args);
}
var _apply_default = apply;
var HOT_COUNT = 800, HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut(func) {
	var count$3 = 0, lastCalled = 0;
	return function() {
		var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
		lastCalled = stamp;
		if (remaining > 0) {
			if (++count$3 >= HOT_COUNT) return arguments[0];
		} else count$3 = 0;
		return func.apply(void 0, arguments);
	};
}
var _shortOut_default = shortOut;
function constant(value) {
	return function() {
		return value;
	};
}
var constant_default = constant;
var _setToString_default = _shortOut_default(!_defineProperty_default ? identity_default : function(func, string) {
	return _defineProperty_default(func, "toString", {
		"configurable": true,
		"enumerable": false,
		"value": constant_default(string),
		"writable": true
	});
});
function baseFindIndex(array, predicate, fromIndex, fromRight) {
	var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
	while (fromRight ? index-- : ++index < length) if (predicate(array[index], index, array)) return index;
	return -1;
}
var _baseFindIndex_default = baseFindIndex;
var nativeMax$2 = Math.max;
function overRest(func, start, transform) {
	start = nativeMax$2(start === void 0 ? func.length - 1 : start, 0);
	return function() {
		var args = arguments, index = -1, length = nativeMax$2(args.length - start, 0), array = Array(length);
		while (++index < length) array[index] = args[start + index];
		index = -1;
		var otherArgs = Array(start + 1);
		while (++index < start) otherArgs[index] = args[index];
		otherArgs[start] = transform(array);
		return _apply_default(func, this, otherArgs);
	};
}
var _overRest_default = overRest;
var MAX_SAFE_INTEGER = 9007199254740991;
function isLength(value) {
	return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
var isLength_default = isLength;
function isArrayLike(value) {
	return value != null && isLength_default(value.length) && !isFunction_default(value);
}
var isArrayLike_default = isArrayLike;
var objectProto$1 = Object.prototype;
function isPrototype(value) {
	var Ctor = value && value.constructor;
	return value === (typeof Ctor == "function" && Ctor.prototype || objectProto$1);
}
var _isPrototype_default = isPrototype;
function baseTimes(n, iteratee) {
	var index = -1, result = Array(n);
	while (++index < n) result[index] = iteratee(index);
	return result;
}
var _baseTimes_default = baseTimes;
var argsTag$2 = "[object Arguments]";
function baseIsArguments(value) {
	return isObjectLike_default(value) && _baseGetTag_default(value) == argsTag$2;
}
var _baseIsArguments_default = baseIsArguments;
var objectProto = Object.prototype;
var hasOwnProperty$4 = objectProto.hasOwnProperty;
var propertyIsEnumerable$1 = objectProto.propertyIsEnumerable;
var isArguments_default = _baseIsArguments_default(function() {
	return arguments;
}()) ? _baseIsArguments_default : function(value) {
	return isObjectLike_default(value) && hasOwnProperty$4.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
};
function stubFalse() {
	return false;
}
var stubFalse_default = stubFalse;
var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
var Buffer = freeModule$1 && freeModule$1.exports === freeExports$1 ? _root_default.Buffer : void 0;
var isBuffer_default = (Buffer ? Buffer.isBuffer : void 0) || stubFalse_default;
var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", funcTag = "[object Function]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", objectTag$2 = "[object Object]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", weakMapTag$1 = "[object WeakMap]";
var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$1] = typedArrayTags[boolTag$1] = typedArrayTags[dataViewTag$2] = typedArrayTags[dateTag$1] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag] = typedArrayTags[mapTag$2] = typedArrayTags[numberTag$1] = typedArrayTags[objectTag$2] = typedArrayTags[regexpTag$1] = typedArrayTags[setTag$2] = typedArrayTags[stringTag$1] = typedArrayTags[weakMapTag$1] = false;
function baseIsTypedArray(value) {
	return isObjectLike_default(value) && isLength_default(value.length) && !!typedArrayTags[_baseGetTag_default(value)];
}
var _baseIsTypedArray_default = baseIsTypedArray;
function baseUnary(func) {
	return function(value) {
		return func(value);
	};
}
var _baseUnary_default = baseUnary;
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var freeProcess = freeModule && freeModule.exports === freeExports && _freeGlobal_default.process;
var _nodeUtil_default = function() {
	try {
		var types = freeModule && freeModule.require && freeModule.require("util").types;
		if (types) return types;
		return freeProcess && freeProcess.binding && freeProcess.binding("util");
	} catch (e) {}
}();
var nodeIsTypedArray = _nodeUtil_default && _nodeUtil_default.isTypedArray;
var isTypedArray_default = nodeIsTypedArray ? _baseUnary_default(nodeIsTypedArray) : _baseIsTypedArray_default;
var hasOwnProperty$3 = Object.prototype.hasOwnProperty;
function arrayLikeKeys(value, inherited) {
	var isArr = isArray_default(value), isArg = !isArr && isArguments_default(value), isBuff = !isArr && !isArg && isBuffer_default(value), isType = !isArr && !isArg && !isBuff && isTypedArray_default(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? _baseTimes_default(value.length, String) : [], length = result.length;
	for (var key$2 in value) if ((inherited || hasOwnProperty$3.call(value, key$2)) && !(skipIndexes && (key$2 == "length" || isBuff && (key$2 == "offset" || key$2 == "parent") || isType && (key$2 == "buffer" || key$2 == "byteLength" || key$2 == "byteOffset") || _isIndex_default(key$2, length)))) result.push(key$2);
	return result;
}
var _arrayLikeKeys_default = arrayLikeKeys;
function overArg(func, transform) {
	return function(arg) {
		return func(transform(arg));
	};
}
var _overArg_default = overArg;
var _nativeKeys_default = _overArg_default(Object.keys, Object);
var hasOwnProperty$2 = Object.prototype.hasOwnProperty;
function baseKeys(object) {
	if (!_isPrototype_default(object)) return _nativeKeys_default(object);
	var result = [];
	for (var key$2 in Object(object)) if (hasOwnProperty$2.call(object, key$2) && key$2 != "constructor") result.push(key$2);
	return result;
}
var _baseKeys_default = baseKeys;
function keys(object) {
	return isArrayLike_default(object) ? _arrayLikeKeys_default(object) : _baseKeys_default(object);
}
var keys_default = keys;
function arrayPush(array, values) {
	var index = -1, length = values.length, offset$2 = array.length;
	while (++index < length) array[offset$2 + index] = values[index];
	return array;
}
var _arrayPush_default = arrayPush;
var spreadableSymbol = _Symbol_default ? _Symbol_default.isConcatSpreadable : void 0;
function isFlattenable(value) {
	return isArray_default(value) || isArguments_default(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}
var _isFlattenable_default = isFlattenable;
function baseFlatten(array, depth, predicate, isStrict, result) {
	var index = -1, length = array.length;
	predicate || (predicate = _isFlattenable_default);
	result || (result = []);
	while (++index < length) {
		var value = array[index];
		if (depth > 0 && predicate(value)) if (depth > 1) baseFlatten(value, depth - 1, predicate, isStrict, result);
		else _arrayPush_default(result, value);
		else if (!isStrict) result[result.length] = value;
	}
	return result;
}
var _baseFlatten_default = baseFlatten;
function flatten(array) {
	return (array == null ? 0 : array.length) ? _baseFlatten_default(array, 1) : [];
}
var flatten_default = flatten;
function flatRest(func) {
	return _setToString_default(_overRest_default(func, void 0, flatten_default), func + "");
}
var _flatRest_default = flatRest;
function castArray() {
	if (!arguments.length) return [];
	var value = arguments[0];
	return isArray_default(value) ? value : [value];
}
var castArray_default = castArray;
function stackClear() {
	this.__data__ = new _ListCache_default();
	this.size = 0;
}
var _stackClear_default = stackClear;
function stackDelete(key$2) {
	var data = this.__data__, result = data["delete"](key$2);
	this.size = data.size;
	return result;
}
var _stackDelete_default = stackDelete;
function stackGet(key$2) {
	return this.__data__.get(key$2);
}
var _stackGet_default = stackGet;
function stackHas(key$2) {
	return this.__data__.has(key$2);
}
var _stackHas_default = stackHas;
var LARGE_ARRAY_SIZE = 200;
function stackSet(key$2, value) {
	var data = this.__data__;
	if (data instanceof _ListCache_default) {
		var pairs = data.__data__;
		if (!_Map_default || pairs.length < LARGE_ARRAY_SIZE - 1) {
			pairs.push([key$2, value]);
			this.size = ++data.size;
			return this;
		}
		data = this.__data__ = new _MapCache_default(pairs);
	}
	data.set(key$2, value);
	this.size = data.size;
	return this;
}
var _stackSet_default = stackSet;
function Stack(entries) {
	this.size = (this.__data__ = new _ListCache_default(entries)).size;
}
Stack.prototype.clear = _stackClear_default;
Stack.prototype["delete"] = _stackDelete_default;
Stack.prototype.get = _stackGet_default;
Stack.prototype.has = _stackHas_default;
Stack.prototype.set = _stackSet_default;
var _Stack_default = Stack;
function arrayFilter(array, predicate) {
	var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
	while (++index < length) {
		var value = array[index];
		if (predicate(value, index, array)) result[resIndex++] = value;
	}
	return result;
}
var _arrayFilter_default = arrayFilter;
function stubArray() {
	return [];
}
var stubArray_default = stubArray;
var propertyIsEnumerable = Object.prototype.propertyIsEnumerable;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var _getSymbols_default = !nativeGetSymbols ? stubArray_default : function(object) {
	if (object == null) return [];
	object = Object(object);
	return _arrayFilter_default(nativeGetSymbols(object), function(symbol) {
		return propertyIsEnumerable.call(object, symbol);
	});
};
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
	var result = keysFunc(object);
	return isArray_default(object) ? result : _arrayPush_default(result, symbolsFunc(object));
}
var _baseGetAllKeys_default = baseGetAllKeys;
function getAllKeys(object) {
	return _baseGetAllKeys_default(object, keys_default, _getSymbols_default);
}
var _getAllKeys_default = getAllKeys;
var _DataView_default = _getNative_default(_root_default, "DataView");
var _Promise_default = _getNative_default(_root_default, "Promise");
var _Set_default = _getNative_default(_root_default, "Set");
var mapTag$1 = "[object Map]", objectTag$1 = "[object Object]", promiseTag = "[object Promise]", setTag$1 = "[object Set]", weakMapTag = "[object WeakMap]";
var dataViewTag$1 = "[object DataView]";
var dataViewCtorString = _toSource_default(_DataView_default), mapCtorString = _toSource_default(_Map_default), promiseCtorString = _toSource_default(_Promise_default), setCtorString = _toSource_default(_Set_default), weakMapCtorString = _toSource_default(_WeakMap_default);
var getTag = _baseGetTag_default;
if (_DataView_default && getTag(new _DataView_default(/* @__PURE__ */ new ArrayBuffer(1))) != dataViewTag$1 || _Map_default && getTag(new _Map_default()) != mapTag$1 || _Promise_default && getTag(_Promise_default.resolve()) != promiseTag || _Set_default && getTag(new _Set_default()) != setTag$1 || _WeakMap_default && getTag(new _WeakMap_default()) != weakMapTag) getTag = function(value) {
	var result = _baseGetTag_default(value), Ctor = result == objectTag$1 ? value.constructor : void 0, ctorString = Ctor ? _toSource_default(Ctor) : "";
	if (ctorString) switch (ctorString) {
		case dataViewCtorString: return dataViewTag$1;
		case mapCtorString: return mapTag$1;
		case promiseCtorString: return promiseTag;
		case setCtorString: return setTag$1;
		case weakMapCtorString: return weakMapTag;
	}
	return result;
};
var _getTag_default = getTag;
var _Uint8Array_default = _root_default.Uint8Array;
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function setCacheAdd(value) {
	this.__data__.set(value, HASH_UNDEFINED);
	return this;
}
var _setCacheAdd_default = setCacheAdd;
function setCacheHas(value) {
	return this.__data__.has(value);
}
var _setCacheHas_default = setCacheHas;
function SetCache(values) {
	var index = -1, length = values == null ? 0 : values.length;
	this.__data__ = new _MapCache_default();
	while (++index < length) this.add(values[index]);
}
SetCache.prototype.add = SetCache.prototype.push = _setCacheAdd_default;
SetCache.prototype.has = _setCacheHas_default;
var _SetCache_default = SetCache;
function arraySome(array, predicate) {
	var index = -1, length = array == null ? 0 : array.length;
	while (++index < length) if (predicate(array[index], index, array)) return true;
	return false;
}
var _arraySome_default = arraySome;
function cacheHas(cache$1, key$2) {
	return cache$1.has(key$2);
}
var _cacheHas_default = cacheHas;
var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
	var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array.length, othLength = other.length;
	if (arrLength != othLength && !(isPartial && othLength > arrLength)) return false;
	var arrStacked = stack.get(array);
	var othStacked = stack.get(other);
	if (arrStacked && othStacked) return arrStacked == other && othStacked == array;
	var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new _SetCache_default() : void 0;
	stack.set(array, other);
	stack.set(other, array);
	while (++index < arrLength) {
		var arrValue = array[index], othValue = other[index];
		if (customizer) var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
		if (compared !== void 0) {
			if (compared) continue;
			result = false;
			break;
		}
		if (seen) {
			if (!_arraySome_default(other, function(othValue$1, othIndex) {
				if (!_cacheHas_default(seen, othIndex) && (arrValue === othValue$1 || equalFunc(arrValue, othValue$1, bitmask, customizer, stack))) return seen.push(othIndex);
			})) {
				result = false;
				break;
			}
		} else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
			result = false;
			break;
		}
	}
	stack["delete"](array);
	stack["delete"](other);
	return result;
}
var _equalArrays_default = equalArrays;
function mapToArray(map$1) {
	var index = -1, result = Array(map$1.size);
	map$1.forEach(function(value, key$2) {
		result[++index] = [key$2, value];
	});
	return result;
}
var _mapToArray_default = mapToArray;
function setToArray(set) {
	var index = -1, result = Array(set.size);
	set.forEach(function(value) {
		result[++index] = value;
	});
	return result;
}
var _setToArray_default = setToArray;
var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]";
var symbolProto = _Symbol_default ? _Symbol_default.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function equalByTag(object, other, tag$2, bitmask, customizer, equalFunc, stack) {
	switch (tag$2) {
		case dataViewTag:
			if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) return false;
			object = object.buffer;
			other = other.buffer;
		case arrayBufferTag:
			if (object.byteLength != other.byteLength || !equalFunc(new _Uint8Array_default(object), new _Uint8Array_default(other))) return false;
			return true;
		case boolTag:
		case dateTag:
		case numberTag: return eq_default(+object, +other);
		case errorTag: return object.name == other.name && object.message == other.message;
		case regexpTag:
		case stringTag: return object == other + "";
		case mapTag: var convert = _mapToArray_default;
		case setTag:
			var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
			convert || (convert = _setToArray_default);
			if (object.size != other.size && !isPartial) return false;
			var stacked = stack.get(object);
			if (stacked) return stacked == other;
			bitmask |= COMPARE_UNORDERED_FLAG$2;
			stack.set(object, other);
			var result = _equalArrays_default(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
			stack["delete"](object);
			return result;
		case symbolTag: if (symbolValueOf) return symbolValueOf.call(object) == symbolValueOf.call(other);
	}
	return false;
}
var _equalByTag_default = equalByTag;
var COMPARE_PARTIAL_FLAG$3 = 1;
var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
	var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = _getAllKeys_default(object), objLength = objProps.length;
	if (objLength != _getAllKeys_default(other).length && !isPartial) return false;
	var index = objLength;
	while (index--) {
		var key$2 = objProps[index];
		if (!(isPartial ? key$2 in other : hasOwnProperty$1.call(other, key$2))) return false;
	}
	var objStacked = stack.get(object);
	var othStacked = stack.get(other);
	if (objStacked && othStacked) return objStacked == other && othStacked == object;
	var result = true;
	stack.set(object, other);
	stack.set(other, object);
	var skipCtor = isPartial;
	while (++index < objLength) {
		key$2 = objProps[index];
		var objValue = object[key$2], othValue = other[key$2];
		if (customizer) var compared = isPartial ? customizer(othValue, objValue, key$2, other, object, stack) : customizer(objValue, othValue, key$2, object, other, stack);
		if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
			result = false;
			break;
		}
		skipCtor || (skipCtor = key$2 == "constructor");
	}
	if (result && !skipCtor) {
		var objCtor = object.constructor, othCtor = other.constructor;
		if (objCtor != othCtor && "constructor" in object && "constructor" in other && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) result = false;
	}
	stack["delete"](object);
	stack["delete"](other);
	return result;
}
var _equalObjects_default = equalObjects;
var COMPARE_PARTIAL_FLAG$2 = 1;
var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
var hasOwnProperty = Object.prototype.hasOwnProperty;
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
	var objIsArr = isArray_default(object), othIsArr = isArray_default(other), objTag = objIsArr ? arrayTag : _getTag_default(object), othTag = othIsArr ? arrayTag : _getTag_default(other);
	objTag = objTag == argsTag ? objectTag : objTag;
	othTag = othTag == argsTag ? objectTag : othTag;
	var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
	if (isSameTag && isBuffer_default(object)) {
		if (!isBuffer_default(other)) return false;
		objIsArr = true;
		objIsObj = false;
	}
	if (isSameTag && !objIsObj) {
		stack || (stack = new _Stack_default());
		return objIsArr || isTypedArray_default(object) ? _equalArrays_default(object, other, bitmask, customizer, equalFunc, stack) : _equalByTag_default(object, other, objTag, bitmask, customizer, equalFunc, stack);
	}
	if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
		var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
		if (objIsWrapped || othIsWrapped) {
			var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
			stack || (stack = new _Stack_default());
			return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
		}
	}
	if (!isSameTag) return false;
	stack || (stack = new _Stack_default());
	return _equalObjects_default(object, other, bitmask, customizer, equalFunc, stack);
}
var _baseIsEqualDeep_default = baseIsEqualDeep;
function baseIsEqual(value, other, bitmask, customizer, stack) {
	if (value === other) return true;
	if (value == null || other == null || !isObjectLike_default(value) && !isObjectLike_default(other)) return value !== value && other !== other;
	return _baseIsEqualDeep_default(value, other, bitmask, customizer, baseIsEqual, stack);
}
var _baseIsEqual_default = baseIsEqual;
var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
function baseIsMatch(object, source, matchData, customizer) {
	var index = matchData.length, length = index, noCustomizer = !customizer;
	if (object == null) return !length;
	object = Object(object);
	while (index--) {
		var data = matchData[index];
		if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) return false;
	}
	while (++index < length) {
		data = matchData[index];
		var key$2 = data[0], objValue = object[key$2], srcValue = data[1];
		if (noCustomizer && data[2]) {
			if (objValue === void 0 && !(key$2 in object)) return false;
		} else {
			var stack = new _Stack_default();
			if (customizer) var result = customizer(objValue, srcValue, key$2, object, source, stack);
			if (!(result === void 0 ? _baseIsEqual_default(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack) : result)) return false;
		}
	}
	return true;
}
var _baseIsMatch_default = baseIsMatch;
function isStrictComparable(value) {
	return value === value && !isObject_default(value);
}
var _isStrictComparable_default = isStrictComparable;
function getMatchData(object) {
	var result = keys_default(object), length = result.length;
	while (length--) {
		var key$2 = result[length], value = object[key$2];
		result[length] = [
			key$2,
			value,
			_isStrictComparable_default(value)
		];
	}
	return result;
}
var _getMatchData_default = getMatchData;
function matchesStrictComparable(key$2, srcValue) {
	return function(object) {
		if (object == null) return false;
		return object[key$2] === srcValue && (srcValue !== void 0 || key$2 in Object(object));
	};
}
var _matchesStrictComparable_default = matchesStrictComparable;
function baseMatches(source) {
	var matchData = _getMatchData_default(source);
	if (matchData.length == 1 && matchData[0][2]) return _matchesStrictComparable_default(matchData[0][0], matchData[0][1]);
	return function(object) {
		return object === source || _baseIsMatch_default(object, source, matchData);
	};
}
var _baseMatches_default = baseMatches;
function baseHasIn(object, key$2) {
	return object != null && key$2 in Object(object);
}
var _baseHasIn_default = baseHasIn;
function hasPath(object, path, hasFunc) {
	path = _castPath_default(path, object);
	var index = -1, length = path.length, result = false;
	while (++index < length) {
		var key$2 = _toKey_default(path[index]);
		if (!(result = object != null && hasFunc(object, key$2))) break;
		object = object[key$2];
	}
	if (result || ++index != length) return result;
	length = object == null ? 0 : object.length;
	return !!length && isLength_default(length) && _isIndex_default(key$2, length) && (isArray_default(object) || isArguments_default(object));
}
var _hasPath_default = hasPath;
function hasIn(object, path) {
	return object != null && _hasPath_default(object, path, _baseHasIn_default);
}
var hasIn_default = hasIn;
var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
function baseMatchesProperty(path, srcValue) {
	if (_isKey_default(path) && _isStrictComparable_default(srcValue)) return _matchesStrictComparable_default(_toKey_default(path), srcValue);
	return function(object) {
		var objValue = get_default(object, path);
		return objValue === void 0 && objValue === srcValue ? hasIn_default(object, path) : _baseIsEqual_default(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
	};
}
var _baseMatchesProperty_default = baseMatchesProperty;
function baseProperty(key$2) {
	return function(object) {
		return object == null ? void 0 : object[key$2];
	};
}
var _baseProperty_default = baseProperty;
function basePropertyDeep(path) {
	return function(object) {
		return _baseGet_default(object, path);
	};
}
var _basePropertyDeep_default = basePropertyDeep;
function property(path) {
	return _isKey_default(path) ? _baseProperty_default(_toKey_default(path)) : _basePropertyDeep_default(path);
}
var property_default = property;
function baseIteratee(value) {
	if (typeof value == "function") return value;
	if (value == null) return identity_default;
	if (typeof value == "object") return isArray_default(value) ? _baseMatchesProperty_default(value[0], value[1]) : _baseMatches_default(value);
	return property_default(value);
}
var _baseIteratee_default = baseIteratee;
var now = function() {
	return _root_default.Date.now();
};
var now_default = now;
var FUNC_ERROR_TEXT = "Expected a function";
var nativeMax$1 = Math.max, nativeMin$1 = Math.min;
function debounce(func, wait, options$1) {
	var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
	if (typeof func != "function") throw new TypeError(FUNC_ERROR_TEXT);
	wait = toNumber_default(wait) || 0;
	if (isObject_default(options$1)) {
		leading = !!options$1.leading;
		maxing = "maxWait" in options$1;
		maxWait = maxing ? nativeMax$1(toNumber_default(options$1.maxWait) || 0, wait) : maxWait;
		trailing = "trailing" in options$1 ? !!options$1.trailing : trailing;
	}
	function invokeFunc(time) {
		var args = lastArgs, thisArg = lastThis;
		lastArgs = lastThis = void 0;
		lastInvokeTime = time;
		result = func.apply(thisArg, args);
		return result;
	}
	function leadingEdge(time) {
		lastInvokeTime = time;
		timerId = setTimeout(timerExpired, wait);
		return leading ? invokeFunc(time) : result;
	}
	function remainingWait(time) {
		var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
		return maxing ? nativeMin$1(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
	}
	function shouldInvoke(time) {
		var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
		return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
	}
	function timerExpired() {
		var time = now_default();
		if (shouldInvoke(time)) return trailingEdge(time);
		timerId = setTimeout(timerExpired, remainingWait(time));
	}
	function trailingEdge(time) {
		timerId = void 0;
		if (trailing && lastArgs) return invokeFunc(time);
		lastArgs = lastThis = void 0;
		return result;
	}
	function cancel() {
		if (timerId !== void 0) clearTimeout(timerId);
		lastInvokeTime = 0;
		lastArgs = lastCallTime = lastThis = timerId = void 0;
	}
	function flush() {
		return timerId === void 0 ? result : trailingEdge(now_default());
	}
	function debounced() {
		var time = now_default(), isInvoking = shouldInvoke(time);
		lastArgs = arguments;
		lastThis = this;
		lastCallTime = time;
		if (isInvoking) {
			if (timerId === void 0) return leadingEdge(lastCallTime);
			if (maxing) {
				clearTimeout(timerId);
				timerId = setTimeout(timerExpired, wait);
				return invokeFunc(lastCallTime);
			}
		}
		if (timerId === void 0) timerId = setTimeout(timerExpired, wait);
		return result;
	}
	debounced.cancel = cancel;
	debounced.flush = flush;
	return debounced;
}
var debounce_default = debounce;
var nativeMax = Math.max, nativeMin = Math.min;
function findLastIndex(array, predicate, fromIndex) {
	var length = array == null ? 0 : array.length;
	if (!length) return -1;
	var index = length - 1;
	if (fromIndex !== void 0) {
		index = toInteger_default(fromIndex);
		index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
	}
	return _baseFindIndex_default(array, _baseIteratee_default(predicate, 3), index, true);
}
var findLastIndex_default = findLastIndex;
function isEqual$1(value, other) {
	return _baseIsEqual_default(value, other);
}
var isEqual_default = isEqual$1;
function isNil(value) {
	return value == null;
}
var isNil_default = isNil;
function isUndefined$1(value) {
	return value === void 0;
}
var isUndefined_default = isUndefined$1;
function basePickBy(object, paths, predicate) {
	var index = -1, length = paths.length, result = {};
	while (++index < length) {
		var path = paths[index], value = _baseGet_default(object, path);
		if (predicate(value, path)) _baseSet_default(result, _castPath_default(path, object), value);
	}
	return result;
}
var _basePickBy_default = basePickBy;
function basePick(object, paths) {
	return _basePickBy_default(object, paths, function(value, path) {
		return hasIn_default(object, path);
	});
}
var _basePick_default = basePick;
var pick_default = _flatRest_default(function(object, paths) {
	return object == null ? {} : _basePick_default(object, paths);
});
var scrollBarWidth;
var getScrollBarWidth = (namespace) => {
	var _a;
	if (!isClient$1) return 0;
	if (scrollBarWidth !== void 0) return scrollBarWidth;
	const outer = document.createElement("div");
	outer.className = `${namespace}-scrollbar__wrap`;
	outer.style.visibility = "hidden";
	outer.style.width = "100px";
	outer.style.position = "absolute";
	outer.style.top = "-9999px";
	document.body.appendChild(outer);
	const widthNoScroll = outer.offsetWidth;
	outer.style.overflow = "scroll";
	const inner = document.createElement("div");
	inner.style.width = "100%";
	outer.appendChild(inner);
	const widthWithScroll = inner.offsetWidth;
	(_a = outer.parentNode) == null || _a.removeChild(outer);
	scrollBarWidth = widthNoScroll - widthWithScroll;
	return scrollBarWidth;
};
function scrollIntoView(container$18, selected$1) {
	if (!isClient$1) return;
	if (!selected$1) {
		container$18.scrollTop = 0;
		return;
	}
	const offsetParents = [];
	let pointer = selected$1.offsetParent;
	while (pointer !== null && container$18 !== pointer && container$18.contains(pointer)) {
		offsetParents.push(pointer);
		pointer = pointer.offsetParent;
	}
	const top$3 = selected$1.offsetTop + offsetParents.reduce((prev, curr) => prev + curr.offsetTop, 0);
	const bottom$2 = top$3 + selected$1.offsetHeight;
	const viewRectTop = container$18.scrollTop;
	const viewRectBottom = viewRectTop + container$18.clientHeight;
	if (top$3 < viewRectTop) container$18.scrollTop = top$3;
	else if (bottom$2 > viewRectBottom) container$18.scrollTop = bottom$2 - container$18.clientHeight;
}
init_shared_esm_bundler();
var composeRefs = (...refs) => {
	return (el$2) => {
		refs.forEach((ref$1) => {
			if (isFunction$2(ref$1)) ref$1(el$2);
			else ref$1.value = el$2;
		});
	};
};
var datePickTypes = [
	"year",
	"month",
	"date",
	"dates",
	"week",
	"datetime",
	"datetimerange",
	"daterange",
	"monthrange"
];
var UPDATE_MODEL_EVENT = "update:modelValue";
var CHANGE_EVENT = "change";
var INPUT_EVENT = "input";
var getComponentSize = (size$2) => {
	return componentSizeMap[size$2 || "default"];
};
var isValidComponentSize = (val) => ["", ...componentSizes].includes(val);
init_shared_esm_bundler();
var PatchFlags = /* @__PURE__ */ ((PatchFlags2) => {
	PatchFlags2[PatchFlags2["TEXT"] = 1] = "TEXT";
	PatchFlags2[PatchFlags2["CLASS"] = 2] = "CLASS";
	PatchFlags2[PatchFlags2["STYLE"] = 4] = "STYLE";
	PatchFlags2[PatchFlags2["PROPS"] = 8] = "PROPS";
	PatchFlags2[PatchFlags2["FULL_PROPS"] = 16] = "FULL_PROPS";
	PatchFlags2[PatchFlags2["HYDRATE_EVENTS"] = 32] = "HYDRATE_EVENTS";
	PatchFlags2[PatchFlags2["STABLE_FRAGMENT"] = 64] = "STABLE_FRAGMENT";
	PatchFlags2[PatchFlags2["KEYED_FRAGMENT"] = 128] = "KEYED_FRAGMENT";
	PatchFlags2[PatchFlags2["UNKEYED_FRAGMENT"] = 256] = "UNKEYED_FRAGMENT";
	PatchFlags2[PatchFlags2["NEED_PATCH"] = 512] = "NEED_PATCH";
	PatchFlags2[PatchFlags2["DYNAMIC_SLOTS"] = 1024] = "DYNAMIC_SLOTS";
	PatchFlags2[PatchFlags2["HOISTED"] = -1] = "HOISTED";
	PatchFlags2[PatchFlags2["BAIL"] = -2] = "BAIL";
	return PatchFlags2;
})(PatchFlags || {});
var flattedChildren = (children) => {
	const vNodes = isArray(children) ? children : [children];
	const result = [];
	vNodes.forEach((child$1) => {
		var _a;
		if (isArray(child$1)) result.push(...flattedChildren(child$1));
		else if (isVNode(child$1) && isArray(child$1.children)) result.push(...flattedChildren(child$1.children));
		else {
			result.push(child$1);
			if (isVNode(child$1) && ((_a = child$1.component) == null ? void 0 : _a.subTree)) result.push(...flattedChildren(child$1.component.subTree));
		}
	});
	return result;
};
var isKorean = (text$7) => /([\uAC00-\uD7AF\u3130-\u318F])+/gi.test(text$7);
var mutable = (val) => val;
var DEFAULT_EXCLUDE_KEYS = ["class", "style"];
var LISTENER_PREFIX = /^on[A-Z]/;
var useAttrs$1 = (params = {}) => {
	const { excludeListeners = false, excludeKeys } = params;
	const allExcludeKeys = computed(() => {
		return ((excludeKeys == null ? void 0 : excludeKeys.value) || []).concat(DEFAULT_EXCLUDE_KEYS);
	});
	const instance = getCurrentInstance();
	if (!instance) {
		debugWarn("use-attrs", "getCurrentInstance() returned null. useAttrs() must be called at the top of a setup function");
		return computed(() => ({}));
	}
	return computed(() => {
		var _a;
		return fromPairs_default(Object.entries((_a = instance.proxy) == null ? void 0 : _a.$attrs).filter(([key$2]) => !allExcludeKeys.value.includes(key$2) && !(excludeListeners && LISTENER_PREFIX.test(key$2))));
	});
};
var useDeprecated = ({ from, replacement, scope, version, ref: ref$1, type = "API" }, condition) => {
	watch(() => unref(condition), (val) => {
		if (val) debugWarn(scope, `[${type}] ${from} is about to be deprecated in version ${version}, please use ${replacement} instead.
For more detail, please visit: ${ref$1}
`);
	}, { immediate: true });
};
init_shared_esm_bundler();
var _prop = buildProp({
	type: definePropType(Boolean),
	default: null
});
var _event = buildProp({ type: definePropType(Function) });
var createModelToggleComposable = (name$1) => {
	const updateEventKey = `update:${name$1}`;
	const updateEventKeyRaw$1 = `onUpdate:${name$1}`;
	const useModelToggleEmits2 = [updateEventKey];
	const useModelToggleProps2 = {
		[name$1]: _prop,
		[updateEventKeyRaw$1]: _event
	};
	const useModelToggle2 = ({ indicator, toggleReason, shouldHideWhenRouteChanges, shouldProceed, onShow, onHide }) => {
		const instance = getCurrentInstance();
		const { emit } = instance;
		const props = instance.props;
		const hasUpdateHandler = computed(() => isFunction$2(props[updateEventKeyRaw$1]));
		const isModelBindingAbsent = computed(() => props[name$1] === null);
		const doShow = (event) => {
			if (indicator.value === true) return;
			indicator.value = true;
			if (toggleReason) toggleReason.value = event;
			if (isFunction$2(onShow)) onShow(event);
		};
		const doHide = (event) => {
			if (indicator.value === false) return;
			indicator.value = false;
			if (toggleReason) toggleReason.value = event;
			if (isFunction$2(onHide)) onHide(event);
		};
		const show = (event) => {
			if (props.disabled === true || isFunction$2(shouldProceed) && !shouldProceed()) return;
			const shouldEmit = hasUpdateHandler.value && isClient$1;
			if (shouldEmit) emit(updateEventKey, true);
			if (isModelBindingAbsent.value || !shouldEmit) doShow(event);
		};
		const hide$2 = (event) => {
			if (props.disabled === true || !isClient$1) return;
			const shouldEmit = hasUpdateHandler.value && isClient$1;
			if (shouldEmit) emit(updateEventKey, false);
			if (isModelBindingAbsent.value || !shouldEmit) doHide(event);
		};
		const onChange = (val) => {
			if (!isBoolean(val)) return;
			if (props.disabled && val) {
				if (hasUpdateHandler.value) emit(updateEventKey, false);
			} else if (indicator.value !== val) if (val) doShow();
			else doHide();
		};
		const toggle = () => {
			if (indicator.value) hide$2();
			else show();
		};
		watch(() => props[name$1], onChange);
		if (shouldHideWhenRouteChanges && instance.appContext.config.globalProperties.$route !== void 0) watch(() => ({ ...instance.proxy.$route }), () => {
			if (shouldHideWhenRouteChanges.value && indicator.value) hide$2();
		});
		onMounted(() => {
			onChange(props[name$1]);
		});
		return {
			hide: hide$2,
			show,
			toggle,
			hasUpdateHandler
		};
	};
	return {
		useModelToggle: useModelToggle2,
		useModelToggleProps: useModelToggleProps2,
		useModelToggleEmits: useModelToggleEmits2
	};
};
var { useModelToggle, useModelToggleProps, useModelToggleEmits } = createModelToggleComposable("modelValue");
var useProp = (name$1) => {
	const vm = getCurrentInstance();
	return computed(() => {
		var _a, _b;
		return (_b = (_a = vm == null ? void 0 : vm.proxy) == null ? void 0 : _a.$props) == null ? void 0 : _b[name$1];
	});
}, R$1 = "bottom", W$1 = "right", P$1 = "left", me$1 = "auto", G$1 = [
	"top",
	R$1,
	W$1,
	P$1
], U$1 = "start", Xe$1 = "clippingParents", je$1 = "viewport", K$1 = "popper", Ye$1 = "reference", De$1 = G$1.reduce(function(t$1, e) {
	return t$1.concat([e + "-" + U$1, e + "-end"]);
}, []), Ee$1 = [].concat(G$1, [me$1]).reduce(function(t$1, e) {
	return t$1.concat([
		e,
		e + "-" + U$1,
		e + "-end"
	]);
}, []), ot$1 = [
	"beforeRead",
	"read",
	"afterRead",
	"beforeMain",
	"main",
	"afterMain",
	"beforeWrite",
	"write",
	"afterWrite"
];
function C$1(t$1) {
	return t$1 ? (t$1.nodeName || "").toLowerCase() : null;
}
function H$1(t$1) {
	if (t$1 == null) return window;
	if (t$1.toString() !== "[object Window]") {
		var e = t$1.ownerDocument;
		return e && e.defaultView || window;
	}
	return t$1;
}
function Q$1(t$1) {
	return t$1 instanceof H$1(t$1).Element || t$1 instanceof Element;
}
function B$1(t$1) {
	return t$1 instanceof H$1(t$1).HTMLElement || t$1 instanceof HTMLElement;
}
function Pe$1(t$1) {
	if (typeof ShadowRoot == "undefined") return !1;
	return t$1 instanceof H$1(t$1).ShadowRoot || t$1 instanceof ShadowRoot;
}
function Mt(t$1) {
	var e = t$1.state;
	Object.keys(e.elements).forEach(function(n) {
		var r = e.styles[n] || {}, o$1 = e.attributes[n] || {}, i$1 = e.elements[n];
		!B$1(i$1) || !C$1(i$1) || (Object.assign(i$1.style, r), Object.keys(o$1).forEach(function(a$1) {
			var s = o$1[a$1];
			s === !1 ? i$1.removeAttribute(a$1) : i$1.setAttribute(a$1, s === !0 ? "" : s);
		}));
	});
}
function Rt(t$1) {
	var e = t$1.state, n = {
		popper: {
			position: e.options.strategy,
			left: "0",
			top: "0",
			margin: "0"
		},
		arrow: { position: "absolute" },
		reference: {}
	};
	return Object.assign(e.elements.popper.style, n.popper), e.styles = n, e.elements.arrow && Object.assign(e.elements.arrow.style, n.arrow), function() {
		Object.keys(e.elements).forEach(function(r) {
			var o$1 = e.elements[r], i$1 = e.attributes[r] || {}, s = Object.keys(e.styles.hasOwnProperty(r) ? e.styles[r] : n[r]).reduce(function(f, c$2) {
				return f[c$2] = "", f;
			}, {});
			!B$1(o$1) || !C$1(o$1) || (Object.assign(o$1.style, s), Object.keys(i$1).forEach(function(f) {
				o$1.removeAttribute(f);
			}));
		});
	};
}
var Ae$1 = {
	name: "applyStyles",
	enabled: !0,
	phase: "write",
	fn: Mt,
	effect: Rt,
	requires: ["computeStyles"]
};
function q(t$1) {
	return t$1.split("-")[0];
}
var X$1 = Math.max, ve$1 = Math.min, Z = Math.round;
function ee$2(t$1, e) {
	e === void 0 && (e = !1);
	var n = t$1.getBoundingClientRect(), r = 1, o$1 = 1;
	if (B$1(t$1) && e) {
		var i$1 = t$1.offsetHeight, a$1 = t$1.offsetWidth;
		a$1 > 0 && (r = Z(n.width) / a$1 || 1), i$1 > 0 && (o$1 = Z(n.height) / i$1 || 1);
	}
	return {
		width: n.width / r,
		height: n.height / o$1,
		top: n.top / o$1,
		right: n.right / r,
		bottom: n.bottom / o$1,
		left: n.left / r,
		x: n.left / r,
		y: n.top / o$1
	};
}
function ke$1(t$1) {
	var e = ee$2(t$1), n = t$1.offsetWidth, r = t$1.offsetHeight;
	return Math.abs(e.width - n) <= 1 && (n = e.width), Math.abs(e.height - r) <= 1 && (r = e.height), {
		x: t$1.offsetLeft,
		y: t$1.offsetTop,
		width: n,
		height: r
	};
}
function it$3(t$1, e) {
	var n = e.getRootNode && e.getRootNode();
	if (t$1.contains(e)) return !0;
	if (n && Pe$1(n)) {
		var r = e;
		do {
			if (r && t$1.isSameNode(r)) return !0;
			r = r.parentNode || r.host;
		} while (r);
	}
	return !1;
}
function N$1(t$1) {
	return H$1(t$1).getComputedStyle(t$1);
}
function Wt(t$1) {
	return [
		"table",
		"td",
		"th"
	].indexOf(C$1(t$1)) >= 0;
}
function I$1(t$1) {
	return ((Q$1(t$1) ? t$1.ownerDocument : t$1.document) || window.document).documentElement;
}
function ge$2(t$1) {
	return C$1(t$1) === "html" ? t$1 : t$1.assignedSlot || t$1.parentNode || (Pe$1(t$1) ? t$1.host : null) || I$1(t$1);
}
function at$1(t$1) {
	return !B$1(t$1) || N$1(t$1).position === "fixed" ? null : t$1.offsetParent;
}
function Bt(t$1) {
	var e = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1;
	if (navigator.userAgent.indexOf("Trident") !== -1 && B$1(t$1)) {
		if (N$1(t$1).position === "fixed") return null;
	}
	var o$1 = ge$2(t$1);
	for (Pe$1(o$1) && (o$1 = o$1.host); B$1(o$1) && ["html", "body"].indexOf(C$1(o$1)) < 0;) {
		var i$1 = N$1(o$1);
		if (i$1.transform !== "none" || i$1.perspective !== "none" || i$1.contain === "paint" || ["transform", "perspective"].indexOf(i$1.willChange) !== -1 || e && i$1.willChange === "filter" || e && i$1.filter && i$1.filter !== "none") return o$1;
		o$1 = o$1.parentNode;
	}
	return null;
}
function se$1(t$1) {
	for (var e = H$1(t$1), n = at$1(t$1); n && Wt(n) && N$1(n).position === "static";) n = at$1(n);
	return n && (C$1(n) === "html" || C$1(n) === "body" && N$1(n).position === "static") ? e : n || Bt(t$1) || e;
}
function Le$1(t$1) {
	return ["top", "bottom"].indexOf(t$1) >= 0 ? "x" : "y";
}
function fe$1(t$1, e, n) {
	return X$1(t$1, ve$1(e, n));
}
function St$1(t$1, e, n) {
	var r = fe$1(t$1, e, n);
	return r > n ? n : r;
}
function st$1() {
	return {
		top: 0,
		right: 0,
		bottom: 0,
		left: 0
	};
}
function ft$1(t$1) {
	return Object.assign({}, st$1(), t$1);
}
function ct$1(t$1, e) {
	return e.reduce(function(n, r) {
		return n[r] = t$1, n;
	}, {});
}
var Tt = function(t$1, e) {
	return t$1 = typeof t$1 == "function" ? t$1(Object.assign({}, e.rects, { placement: e.placement })) : t$1, ft$1(typeof t$1 != "number" ? t$1 : ct$1(t$1, G$1));
};
function Ht(t$1) {
	var e, n = t$1.state, r = t$1.name, o$1 = t$1.options, i$1 = n.elements.arrow, a$1 = n.modifiersData.popperOffsets, s = q(n.placement), f = Le$1(s), u$1 = ["left", "right"].indexOf(s) >= 0 ? "height" : "width";
	if (!(!i$1 || !a$1)) {
		var m$2 = Tt(o$1.padding, n), v$1 = ke$1(i$1), l = f === "y" ? "top" : P$1, h$2 = f === "y" ? R$1 : W$1, p$1 = n.rects.reference[u$1] + n.rects.reference[f] - a$1[f] - n.rects.popper[u$1], g$1 = a$1[f] - n.rects.reference[f], x$2 = se$1(i$1), y = x$2 ? f === "y" ? x$2.clientHeight || 0 : x$2.clientWidth || 0 : 0, $ = p$1 / 2 - g$1 / 2, d = m$2[l], b$2 = y - v$1[u$1] - m$2[h$2], w = y / 2 - v$1[u$1] / 2 + $, O$1 = fe$1(d, w, b$2), j$1 = f;
		n.modifiersData[r] = (e = {}, e[j$1] = O$1, e.centerOffset = O$1 - w, e);
	}
}
function Ct$1(t$1) {
	var e = t$1.state, r = t$1.options.element, o$1 = r === void 0 ? "[data-popper-arrow]" : r;
	o$1 != null && (typeof o$1 == "string" && (o$1 = e.elements.popper.querySelector(o$1), !o$1) || !it$3(e.elements.popper, o$1) || (e.elements.arrow = o$1));
}
var pt$1 = {
	name: "arrow",
	enabled: !0,
	phase: "main",
	fn: Ht,
	effect: Ct$1,
	requires: ["popperOffsets"],
	requiresIfExists: ["preventOverflow"]
};
function te$1(t$1) {
	return t$1.split("-")[1];
}
var qt$1 = {
	top: "auto",
	right: "auto",
	bottom: "auto",
	left: "auto"
};
function Vt(t$1) {
	var e = t$1.x, n = t$1.y, o$1 = window.devicePixelRatio || 1;
	return {
		x: Z(e * o$1) / o$1 || 0,
		y: Z(n * o$1) / o$1 || 0
	};
}
function ut$1(t$1) {
	var e, n = t$1.popper, r = t$1.popperRect, o$1 = t$1.placement, i$1 = t$1.variation, a$1 = t$1.offsets, s = t$1.position, f = t$1.gpuAcceleration, c$2 = t$1.adaptive, u$1 = t$1.roundOffsets, m$2 = t$1.isFixed, v$1 = a$1.x, l = v$1 === void 0 ? 0 : v$1, h$2 = a$1.y, p$1 = h$2 === void 0 ? 0 : h$2, g$1 = typeof u$1 == "function" ? u$1({
		x: l,
		y: p$1
	}) : {
		x: l,
		y: p$1
	};
	l = g$1.x, p$1 = g$1.y;
	var x$2 = a$1.hasOwnProperty("x"), y = a$1.hasOwnProperty("y"), $ = P$1, d = "top", b$2 = window;
	if (c$2) {
		var w = se$1(n), O$1 = "clientHeight", j$1 = "clientWidth";
		if (w === H$1(n) && (w = I$1(n), N$1(w).position !== "static" && s === "absolute" && (O$1 = "scrollHeight", j$1 = "scrollWidth")), w = w, o$1 === "top" || (o$1 === "left" || o$1 === "right") && i$1 === "end") {
			d = R$1;
			var A$1 = m$2 && w === b$2 && b$2.visualViewport ? b$2.visualViewport.height : w[O$1];
			p$1 -= A$1 - r.height, p$1 *= f ? 1 : -1;
		}
		if (o$1 === "left" || (o$1 === "top" || o$1 === "bottom") && i$1 === "end") {
			$ = W$1;
			var k = m$2 && w === b$2 && b$2.visualViewport ? b$2.visualViewport.width : w[j$1];
			l -= k - r.width, l *= f ? 1 : -1;
		}
	}
	var D$1 = Object.assign({ position: s }, c$2 && qt$1), S$1 = u$1 === !0 ? Vt({
		x: l,
		y: p$1
	}) : {
		x: l,
		y: p$1
	};
	if (l = S$1.x, p$1 = S$1.y, f) {
		var L$1;
		return Object.assign({}, D$1, (L$1 = {}, L$1[d] = y ? "0" : "", L$1[$] = x$2 ? "0" : "", L$1.transform = (b$2.devicePixelRatio || 1) <= 1 ? "translate(" + l + "px, " + p$1 + "px)" : "translate3d(" + l + "px, " + p$1 + "px, 0)", L$1));
	}
	return Object.assign({}, D$1, (e = {}, e[d] = y ? p$1 + "px" : "", e[$] = x$2 ? l + "px" : "", e.transform = "", e));
}
function Nt(t$1) {
	var e = t$1.state, n = t$1.options, r = n.gpuAcceleration, o$1 = r === void 0 ? !0 : r, i$1 = n.adaptive, a$1 = i$1 === void 0 ? !0 : i$1, s = n.roundOffsets, f = s === void 0 ? !0 : s, c$2 = {
		placement: q(e.placement),
		variation: te$1(e.placement),
		popper: e.elements.popper,
		popperRect: e.rects.popper,
		gpuAcceleration: o$1,
		isFixed: e.options.strategy === "fixed"
	};
	e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, ut$1(Object.assign({}, c$2, {
		offsets: e.modifiersData.popperOffsets,
		position: e.options.strategy,
		adaptive: a$1,
		roundOffsets: f
	})))), e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, ut$1(Object.assign({}, c$2, {
		offsets: e.modifiersData.arrow,
		position: "absolute",
		adaptive: !1,
		roundOffsets: f
	})))), e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-placement": e.placement });
}
var Me$1 = {
	name: "computeStyles",
	enabled: !0,
	phase: "beforeWrite",
	fn: Nt,
	data: {}
}, ye$1 = { passive: !0 };
function It$1(t$1) {
	var e = t$1.state, n = t$1.instance, r = t$1.options, o$1 = r.scroll, i$1 = o$1 === void 0 ? !0 : o$1, a$1 = r.resize, s = a$1 === void 0 ? !0 : a$1, f = H$1(e.elements.popper), c$2 = [].concat(e.scrollParents.reference, e.scrollParents.popper);
	return i$1 && c$2.forEach(function(u$1) {
		u$1.addEventListener("scroll", n.update, ye$1);
	}), s && f.addEventListener("resize", n.update, ye$1), function() {
		i$1 && c$2.forEach(function(u$1) {
			u$1.removeEventListener("scroll", n.update, ye$1);
		}), s && f.removeEventListener("resize", n.update, ye$1);
	};
}
var Re$2 = {
	name: "eventListeners",
	enabled: !0,
	phase: "write",
	fn: function() {},
	effect: It$1,
	data: {}
}, _t$1 = {
	left: "right",
	right: "left",
	bottom: "top",
	top: "bottom"
};
function be$1(t$1) {
	return t$1.replace(/left|right|bottom|top/g, function(e) {
		return _t$1[e];
	});
}
var zt$1 = {
	start: "end",
	end: "start"
};
function lt$2(t$1) {
	return t$1.replace(/start|end/g, function(e) {
		return zt$1[e];
	});
}
function We$1(t$1) {
	var e = H$1(t$1);
	return {
		scrollLeft: e.pageXOffset,
		scrollTop: e.pageYOffset
	};
}
function Be$1(t$1) {
	return ee$2(I$1(t$1)).left + We$1(t$1).scrollLeft;
}
function Ft(t$1) {
	var e = H$1(t$1), n = I$1(t$1), r = e.visualViewport, o$1 = n.clientWidth, i$1 = n.clientHeight, a$1 = 0, s = 0;
	return r && (o$1 = r.width, i$1 = r.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (a$1 = r.offsetLeft, s = r.offsetTop)), {
		width: o$1,
		height: i$1,
		x: a$1 + Be$1(t$1),
		y: s
	};
}
function Ut(t$1) {
	var e, n = I$1(t$1), r = We$1(t$1), o$1 = (e = t$1.ownerDocument) == null ? void 0 : e.body, i$1 = X$1(n.scrollWidth, n.clientWidth, o$1 ? o$1.scrollWidth : 0, o$1 ? o$1.clientWidth : 0), a$1 = X$1(n.scrollHeight, n.clientHeight, o$1 ? o$1.scrollHeight : 0, o$1 ? o$1.clientHeight : 0), s = -r.scrollLeft + Be$1(t$1), f = -r.scrollTop;
	return N$1(o$1 || n).direction === "rtl" && (s += X$1(n.clientWidth, o$1 ? o$1.clientWidth : 0) - i$1), {
		width: i$1,
		height: a$1,
		x: s,
		y: f
	};
}
function Se$1(t$1) {
	var e = N$1(t$1), n = e.overflow, r = e.overflowX, o$1 = e.overflowY;
	return /auto|scroll|overlay|hidden/.test(n + o$1 + r);
}
function dt$1(t$1) {
	return [
		"html",
		"body",
		"#document"
	].indexOf(C$1(t$1)) >= 0 ? t$1.ownerDocument.body : B$1(t$1) && Se$1(t$1) ? t$1 : dt$1(ge$2(t$1));
}
function ce$1(t$1, e) {
	var n;
	e === void 0 && (e = []);
	var r = dt$1(t$1), o$1 = r === ((n = t$1.ownerDocument) == null ? void 0 : n.body), i$1 = H$1(r), a$1 = o$1 ? [i$1].concat(i$1.visualViewport || [], Se$1(r) ? r : []) : r, s = e.concat(a$1);
	return o$1 ? s : s.concat(ce$1(ge$2(a$1)));
}
function Te$1(t$1) {
	return Object.assign({}, t$1, {
		left: t$1.x,
		top: t$1.y,
		right: t$1.x + t$1.width,
		bottom: t$1.y + t$1.height
	});
}
function Xt(t$1) {
	var e = ee$2(t$1);
	return e.top = e.top + t$1.clientTop, e.left = e.left + t$1.clientLeft, e.bottom = e.top + t$1.clientHeight, e.right = e.left + t$1.clientWidth, e.width = t$1.clientWidth, e.height = t$1.clientHeight, e.x = e.left, e.y = e.top, e;
}
function ht$1(t$1, e) {
	return e === "viewport" ? Te$1(Ft(t$1)) : Q$1(e) ? Xt(e) : Te$1(Ut(I$1(t$1)));
}
function Yt(t$1) {
	var e = ce$1(ge$2(t$1)), r = ["absolute", "fixed"].indexOf(N$1(t$1).position) >= 0 && B$1(t$1) ? se$1(t$1) : t$1;
	return Q$1(r) ? e.filter(function(o$1) {
		return Q$1(o$1) && it$3(o$1, r) && C$1(o$1) !== "body";
	}) : [];
}
function Gt$1(t$1, e, n) {
	var r = e === "clippingParents" ? Yt(t$1) : [].concat(e), o$1 = [].concat(r, [n]), i$1 = o$1[0], a$1 = o$1.reduce(function(s, f) {
		var c$2 = ht$1(t$1, f);
		return s.top = X$1(c$2.top, s.top), s.right = ve$1(c$2.right, s.right), s.bottom = ve$1(c$2.bottom, s.bottom), s.left = X$1(c$2.left, s.left), s;
	}, ht$1(t$1, i$1));
	return a$1.width = a$1.right - a$1.left, a$1.height = a$1.bottom - a$1.top, a$1.x = a$1.left, a$1.y = a$1.top, a$1;
}
function mt$1(t$1) {
	var e = t$1.reference, n = t$1.element, r = t$1.placement, o$1 = r ? q(r) : null, i$1 = r ? te$1(r) : null, a$1 = e.x + e.width / 2 - n.width / 2, s = e.y + e.height / 2 - n.height / 2, f;
	switch (o$1) {
		case "top":
			f = {
				x: a$1,
				y: e.y - n.height
			};
			break;
		case R$1:
			f = {
				x: a$1,
				y: e.y + e.height
			};
			break;
		case W$1:
			f = {
				x: e.x + e.width,
				y: s
			};
			break;
		case P$1:
			f = {
				x: e.x - n.width,
				y: s
			};
			break;
		default: f = {
			x: e.x,
			y: e.y
		};
	}
	var c$2 = o$1 ? Le$1(o$1) : null;
	if (c$2 != null) {
		var u$1 = c$2 === "y" ? "height" : "width";
		switch (i$1) {
			case U$1:
				f[c$2] = f[c$2] - (e[u$1] / 2 - n[u$1] / 2);
				break;
			case "end":
				f[c$2] = f[c$2] + (e[u$1] / 2 - n[u$1] / 2);
				break;
		}
	}
	return f;
}
function ne$2(t$1, e) {
	e === void 0 && (e = {});
	var n = e, r = n.placement, o$1 = r === void 0 ? t$1.placement : r, i$1 = n.boundary, a$1 = i$1 === void 0 ? Xe$1 : i$1, s = n.rootBoundary, f = s === void 0 ? je$1 : s, c$2 = n.elementContext, u$1 = c$2 === void 0 ? K$1 : c$2, m$2 = n.altBoundary, v$1 = m$2 === void 0 ? !1 : m$2, l = n.padding, h$2 = l === void 0 ? 0 : l, p$1 = ft$1(typeof h$2 != "number" ? h$2 : ct$1(h$2, G$1)), g$1 = u$1 === "popper" ? Ye$1 : K$1, x$2 = t$1.rects.popper, y = t$1.elements[v$1 ? g$1 : u$1], $ = Gt$1(Q$1(y) ? y : y.contextElement || I$1(t$1.elements.popper), a$1, f), d = ee$2(t$1.elements.reference), b$2 = mt$1({
		reference: d,
		element: x$2,
		strategy: "absolute",
		placement: o$1
	}), w = Te$1(Object.assign({}, x$2, b$2)), O$1 = u$1 === "popper" ? w : d, j$1 = {
		top: $.top - O$1.top + p$1.top,
		bottom: O$1.bottom - $.bottom + p$1.bottom,
		left: $.left - O$1.left + p$1.left,
		right: O$1.right - $.right + p$1.right
	}, A$1 = t$1.modifiersData.offset;
	if (u$1 === "popper" && A$1) {
		var k = A$1[o$1];
		Object.keys(j$1).forEach(function(D$1) {
			var S$1 = ["right", "bottom"].indexOf(D$1) >= 0 ? 1 : -1, L$1 = ["top", "bottom"].indexOf(D$1) >= 0 ? "y" : "x";
			j$1[D$1] += k[L$1] * S$1;
		});
	}
	return j$1;
}
function Jt(t$1, e) {
	e === void 0 && (e = {});
	var n = e, r = n.placement, o$1 = n.boundary, i$1 = n.rootBoundary, a$1 = n.padding, s = n.flipVariations, f = n.allowedAutoPlacements, c$2 = f === void 0 ? Ee$1 : f, u$1 = te$1(r), m$2 = u$1 ? s ? De$1 : De$1.filter(function(h$2) {
		return te$1(h$2) === u$1;
	}) : G$1, v$1 = m$2.filter(function(h$2) {
		return c$2.indexOf(h$2) >= 0;
	});
	v$1.length === 0 && (v$1 = m$2);
	var l = v$1.reduce(function(h$2, p$1) {
		return h$2[p$1] = ne$2(t$1, {
			placement: p$1,
			boundary: o$1,
			rootBoundary: i$1,
			padding: a$1
		})[q(p$1)], h$2;
	}, {});
	return Object.keys(l).sort(function(h$2, p$1) {
		return l[h$2] - l[p$1];
	});
}
function Kt(t$1) {
	if (q(t$1) === "auto") return [];
	var e = be$1(t$1);
	return [
		lt$2(t$1),
		e,
		lt$2(e)
	];
}
function Qt(t$1) {
	var e = t$1.state, n = t$1.options, r = t$1.name;
	if (!e.modifiersData[r]._skip) {
		for (var o$1 = n.mainAxis, i$1 = o$1 === void 0 ? !0 : o$1, a$1 = n.altAxis, s = a$1 === void 0 ? !0 : a$1, f = n.fallbackPlacements, c$2 = n.padding, u$1 = n.boundary, m$2 = n.rootBoundary, v$1 = n.altBoundary, l = n.flipVariations, h$2 = l === void 0 ? !0 : l, p$1 = n.allowedAutoPlacements, g$1 = e.options.placement, y = q(g$1) === g$1, $ = f || (y || !h$2 ? [be$1(g$1)] : Kt(g$1)), d = [g$1].concat($).reduce(function(z$1, V$1) {
			return z$1.concat(q(V$1) === "auto" ? Jt(e, {
				placement: V$1,
				boundary: u$1,
				rootBoundary: m$2,
				padding: c$2,
				flipVariations: h$2,
				allowedAutoPlacements: p$1
			}) : V$1);
		}, []), b$2 = e.rects.reference, w = e.rects.popper, O$1 = /* @__PURE__ */ new Map(), j$1 = !0, A$1 = d[0], k = 0; k < d.length; k++) {
			var D$1 = d[k], S$1 = q(D$1), L$1 = te$1(D$1) === U$1, re$1 = ["top", R$1].indexOf(S$1) >= 0, oe$1 = re$1 ? "width" : "height", M$1 = ne$2(e, {
				placement: D$1,
				boundary: u$1,
				rootBoundary: m$2,
				altBoundary: v$1,
				padding: c$2
			}), T$1 = re$1 ? L$1 ? W$1 : P$1 : L$1 ? R$1 : "top";
			b$2[oe$1] > w[oe$1] && (T$1 = be$1(T$1));
			var pe$1 = be$1(T$1), _ = [];
			if (i$1 && _.push(M$1[S$1] <= 0), s && _.push(M$1[T$1] <= 0, M$1[pe$1] <= 0), _.every(function(z$1) {
				return z$1;
			})) {
				A$1 = D$1, j$1 = !1;
				break;
			}
			O$1.set(D$1, _);
		}
		if (j$1) {
			for (var ue$1 = h$2 ? 3 : 1, xe$1 = function(z$1) {
				var V$1 = d.find(function(de$2) {
					var ae$1 = O$1.get(de$2);
					if (ae$1) return ae$1.slice(0, z$1).every(function(Y$1) {
						return Y$1;
					});
				});
				if (V$1) return A$1 = V$1, "break";
			}, ie$1 = ue$1; ie$1 > 0; ie$1--) if (xe$1(ie$1) === "break") break;
		}
		e.placement !== A$1 && (e.modifiersData[r]._skip = !0, e.placement = A$1, e.reset = !0);
	}
}
var vt$1 = {
	name: "flip",
	enabled: !0,
	phase: "main",
	fn: Qt,
	requiresIfExists: ["offset"],
	data: { _skip: !1 }
};
function gt$2(t$1, e, n) {
	return n === void 0 && (n = {
		x: 0,
		y: 0
	}), {
		top: t$1.top - e.height - n.y,
		right: t$1.right - e.width + n.x,
		bottom: t$1.bottom - e.height + n.y,
		left: t$1.left - e.width - n.x
	};
}
function yt$1(t$1) {
	return [
		"top",
		W$1,
		R$1,
		P$1
	].some(function(e) {
		return t$1[e] >= 0;
	});
}
function Zt$1(t$1) {
	var e = t$1.state, n = t$1.name, r = e.rects.reference, o$1 = e.rects.popper, i$1 = e.modifiersData.preventOverflow, a$1 = ne$2(e, { elementContext: "reference" }), s = ne$2(e, { altBoundary: !0 }), f = gt$2(a$1, r), c$2 = gt$2(s, o$1, i$1), u$1 = yt$1(f), m$2 = yt$1(c$2);
	e.modifiersData[n] = {
		referenceClippingOffsets: f,
		popperEscapeOffsets: c$2,
		isReferenceHidden: u$1,
		hasPopperEscaped: m$2
	}, e.attributes.popper = Object.assign({}, e.attributes.popper, {
		"data-popper-reference-hidden": u$1,
		"data-popper-escaped": m$2
	});
}
var bt = {
	name: "hide",
	enabled: !0,
	phase: "main",
	requiresIfExists: ["preventOverflow"],
	fn: Zt$1
};
function en(t$1, e, n) {
	var r = q(t$1), o$1 = ["left", "top"].indexOf(r) >= 0 ? -1 : 1, i$1 = typeof n == "function" ? n(Object.assign({}, e, { placement: t$1 })) : n, a$1 = i$1[0], s = i$1[1];
	return a$1 = a$1 || 0, s = (s || 0) * o$1, ["left", "right"].indexOf(r) >= 0 ? {
		x: s,
		y: a$1
	} : {
		x: a$1,
		y: s
	};
}
function tn(t$1) {
	var e = t$1.state, n = t$1.options, r = t$1.name, o$1 = n.offset, i$1 = o$1 === void 0 ? [0, 0] : o$1, a$1 = Ee$1.reduce(function(u$1, m$2) {
		return u$1[m$2] = en(m$2, e.rects, i$1), u$1;
	}, {}), s = a$1[e.placement], f = s.x, c$2 = s.y;
	e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += f, e.modifiersData.popperOffsets.y += c$2), e.modifiersData[r] = a$1;
}
var wt$1 = {
	name: "offset",
	enabled: !0,
	phase: "main",
	requires: ["popperOffsets"],
	fn: tn
};
function nn(t$1) {
	var e = t$1.state, n = t$1.name;
	e.modifiersData[n] = mt$1({
		reference: e.rects.reference,
		element: e.rects.popper,
		strategy: "absolute",
		placement: e.placement
	});
}
var He$1 = {
	name: "popperOffsets",
	enabled: !0,
	phase: "read",
	fn: nn,
	data: {}
};
function rn(t$1) {
	return t$1 === "x" ? "y" : "x";
}
function on$1(t$1) {
	var e = t$1.state, n = t$1.options, r = t$1.name, o$1 = n.mainAxis, i$1 = o$1 === void 0 ? !0 : o$1, a$1 = n.altAxis, s = a$1 === void 0 ? !1 : a$1, f = n.boundary, c$2 = n.rootBoundary, u$1 = n.altBoundary, m$2 = n.padding, v$1 = n.tether, l = v$1 === void 0 ? !0 : v$1, h$2 = n.tetherOffset, p$1 = h$2 === void 0 ? 0 : h$2, g$1 = ne$2(e, {
		boundary: f,
		rootBoundary: c$2,
		padding: m$2,
		altBoundary: u$1
	}), x$2 = q(e.placement), y = te$1(e.placement), $ = !y, d = Le$1(x$2), b$2 = rn(d), w = e.modifiersData.popperOffsets, O$1 = e.rects.reference, j$1 = e.rects.popper, A$1 = typeof p$1 == "function" ? p$1(Object.assign({}, e.rects, { placement: e.placement })) : p$1, k = typeof A$1 == "number" ? {
		mainAxis: A$1,
		altAxis: A$1
	} : Object.assign({
		mainAxis: 0,
		altAxis: 0
	}, A$1), D$1 = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null, S$1 = {
		x: 0,
		y: 0
	};
	if (w) {
		if (i$1) {
			var L$1, re$1 = d === "y" ? "top" : P$1, oe$1 = d === "y" ? R$1 : W$1, M$1 = d === "y" ? "height" : "width", T$1 = w[d], pe$1 = T$1 + g$1[re$1], _ = T$1 - g$1[oe$1], ue$1 = l ? -j$1[M$1] / 2 : 0, xe$1 = y === "start" ? O$1[M$1] : j$1[M$1], ie$1 = y === "start" ? -j$1[M$1] : -O$1[M$1], le$2 = e.elements.arrow, z$1 = l && le$2 ? ke$1(le$2) : {
				width: 0,
				height: 0
			}, V$1 = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : st$1(), de$2 = V$1[re$1], ae$1 = V$1[oe$1], Y$1 = fe$1(0, O$1[M$1], z$1[M$1]), jt = $ ? O$1[M$1] / 2 - ue$1 - Y$1 - de$2 - k.mainAxis : xe$1 - Y$1 - de$2 - k.mainAxis, Dt = $ ? -O$1[M$1] / 2 + ue$1 + Y$1 + ae$1 + k.mainAxis : ie$1 + Y$1 + ae$1 + k.mainAxis, Oe$1 = e.elements.arrow && se$1(e.elements.arrow), Et$1 = Oe$1 ? d === "y" ? Oe$1.clientTop || 0 : Oe$1.clientLeft || 0 : 0, Ce$1 = (L$1 = D$1 == null ? void 0 : D$1[d]) != null ? L$1 : 0, Pt = T$1 + jt - Ce$1 - Et$1, At = T$1 + Dt - Ce$1, qe$1 = fe$1(l ? ve$1(pe$1, Pt) : pe$1, T$1, l ? X$1(_, At) : _);
			w[d] = qe$1, S$1[d] = qe$1 - T$1;
		}
		if (s) {
			var Ve$1, kt$1 = d === "x" ? "top" : P$1, Lt$1 = d === "x" ? R$1 : W$1, F$1 = w[b$2], he$1 = b$2 === "y" ? "height" : "width", Ne$1 = F$1 + g$1[kt$1], Ie$1 = F$1 - g$1[Lt$1], $e$1 = ["top", P$1].indexOf(x$2) !== -1, _e$1 = (Ve$1 = D$1 == null ? void 0 : D$1[b$2]) != null ? Ve$1 : 0, ze$1 = $e$1 ? Ne$1 : F$1 - O$1[he$1] - j$1[he$1] - _e$1 + k.altAxis, Fe$1 = $e$1 ? F$1 + O$1[he$1] + j$1[he$1] - _e$1 - k.altAxis : Ie$1, Ue$1 = l && $e$1 ? St$1(ze$1, F$1, Fe$1) : fe$1(l ? ze$1 : Ne$1, F$1, l ? Fe$1 : Ie$1);
			w[b$2] = Ue$1, S$1[b$2] = Ue$1 - F$1;
		}
		e.modifiersData[r] = S$1;
	}
}
var xt = {
	name: "preventOverflow",
	enabled: !0,
	phase: "main",
	fn: on$1,
	requiresIfExists: ["offset"]
};
function an(t$1) {
	return {
		scrollLeft: t$1.scrollLeft,
		scrollTop: t$1.scrollTop
	};
}
function sn(t$1) {
	return t$1 === H$1(t$1) || !B$1(t$1) ? We$1(t$1) : an(t$1);
}
function fn(t$1) {
	var e = t$1.getBoundingClientRect(), n = Z(e.width) / t$1.offsetWidth || 1, r = Z(e.height) / t$1.offsetHeight || 1;
	return n !== 1 || r !== 1;
}
function cn$1(t$1, e, n) {
	n === void 0 && (n = !1);
	var r = B$1(e), o$1 = B$1(e) && fn(e), i$1 = I$1(e), a$1 = ee$2(t$1, o$1), s = {
		scrollLeft: 0,
		scrollTop: 0
	}, f = {
		x: 0,
		y: 0
	};
	return (r || !r && !n) && ((C$1(e) !== "body" || Se$1(i$1)) && (s = sn(e)), B$1(e) ? (f = ee$2(e, !0), f.x += e.clientLeft, f.y += e.clientTop) : i$1 && (f.x = Be$1(i$1))), {
		x: a$1.left + s.scrollLeft - f.x,
		y: a$1.top + s.scrollTop - f.y,
		width: a$1.width,
		height: a$1.height
	};
}
function pn(t$1) {
	var e = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), r = [];
	t$1.forEach(function(i$1) {
		e.set(i$1.name, i$1);
	});
	function o$1(i$1) {
		n.add(i$1.name);
		[].concat(i$1.requires || [], i$1.requiresIfExists || []).forEach(function(s) {
			if (!n.has(s)) {
				var f = e.get(s);
				f && o$1(f);
			}
		}), r.push(i$1);
	}
	return t$1.forEach(function(i$1) {
		n.has(i$1.name) || o$1(i$1);
	}), r;
}
function un(t$1) {
	var e = pn(t$1);
	return ot$1.reduce(function(n, r) {
		return n.concat(e.filter(function(o$1) {
			return o$1.phase === r;
		}));
	}, []);
}
function ln(t$1) {
	var e;
	return function() {
		return e || (e = new Promise(function(n) {
			Promise.resolve().then(function() {
				e = void 0, n(t$1());
			});
		})), e;
	};
}
function dn(t$1) {
	var e = t$1.reduce(function(n, r) {
		var o$1 = n[r.name];
		return n[r.name] = o$1 ? Object.assign({}, o$1, r, {
			options: Object.assign({}, o$1.options, r.options),
			data: Object.assign({}, o$1.data, r.data)
		}) : r, n;
	}, {});
	return Object.keys(e).map(function(n) {
		return e[n];
	});
}
var Ot = {
	placement: "bottom",
	modifiers: [],
	strategy: "absolute"
};
function $t$1() {
	for (var t$1 = arguments.length, e = new Array(t$1), n = 0; n < t$1; n++) e[n] = arguments[n];
	return !e.some(function(r) {
		return !(r && typeof r.getBoundingClientRect == "function");
	});
}
function we$1(t$1) {
	t$1 === void 0 && (t$1 = {});
	var e = t$1, n = e.defaultModifiers, r = n === void 0 ? [] : n, o$1 = e.defaultOptions, i$1 = o$1 === void 0 ? Ot : o$1;
	return function(a$1, s, f) {
		f === void 0 && (f = i$1);
		var c$2 = {
			placement: "bottom",
			orderedModifiers: [],
			options: Object.assign({}, Ot, i$1),
			modifiersData: {},
			elements: {
				reference: a$1,
				popper: s
			},
			attributes: {},
			styles: {}
		}, u$1 = [], m$2 = !1, v$1 = {
			state: c$2,
			setOptions: function(p$1) {
				var g$1 = typeof p$1 == "function" ? p$1(c$2.options) : p$1;
				h$2(), c$2.options = Object.assign({}, i$1, c$2.options, g$1), c$2.scrollParents = {
					reference: Q$1(a$1) ? ce$1(a$1) : a$1.contextElement ? ce$1(a$1.contextElement) : [],
					popper: ce$1(s)
				};
				return c$2.orderedModifiers = un(dn([].concat(r, c$2.options.modifiers))).filter(function(y) {
					return y.enabled;
				}), l(), v$1.update();
			},
			forceUpdate: function() {
				if (!m$2) {
					var p$1 = c$2.elements, g$1 = p$1.reference, x$2 = p$1.popper;
					if ($t$1(g$1, x$2)) {
						c$2.rects = {
							reference: cn$1(g$1, se$1(x$2), c$2.options.strategy === "fixed"),
							popper: ke$1(x$2)
						}, c$2.reset = !1, c$2.placement = c$2.options.placement, c$2.orderedModifiers.forEach(function(j$1) {
							return c$2.modifiersData[j$1.name] = Object.assign({}, j$1.data);
						});
						for (var y = 0; y < c$2.orderedModifiers.length; y++) {
							if (c$2.reset === !0) {
								c$2.reset = !1, y = -1;
								continue;
							}
							var $ = c$2.orderedModifiers[y], d = $.fn, b$2 = $.options, w = b$2 === void 0 ? {} : b$2, O$1 = $.name;
							typeof d == "function" && (c$2 = d({
								state: c$2,
								options: w,
								name: O$1,
								instance: v$1
							}) || c$2);
						}
					}
				}
			},
			update: ln(function() {
				return new Promise(function(p$1) {
					v$1.forceUpdate(), p$1(c$2);
				});
			}),
			destroy: function() {
				h$2(), m$2 = !0;
			}
		};
		if (!$t$1(a$1, s)) return v$1;
		v$1.setOptions(f).then(function(p$1) {
			!m$2 && f.onFirstUpdate && f.onFirstUpdate(p$1);
		});
		function l() {
			c$2.orderedModifiers.forEach(function(p$1) {
				var g$1 = p$1.name, x$2 = p$1.options, y = x$2 === void 0 ? {} : x$2, $ = p$1.effect;
				if (typeof $ == "function") {
					var d = $({
						state: c$2,
						name: g$1,
						instance: v$1,
						options: y
					}), b$2 = function() {};
					u$1.push(d || b$2);
				}
			});
		}
		function h$2() {
			u$1.forEach(function(p$1) {
				return p$1();
			}), u$1 = [];
		}
		return v$1;
	};
}
we$1();
we$1({ defaultModifiers: [
	Re$2,
	He$1,
	Me$1,
	Ae$1
] });
var yn = we$1({ defaultModifiers: [
	Re$2,
	He$1,
	Me$1,
	Ae$1,
	wt$1,
	vt$1,
	xt,
	pt$1,
	bt
] });
var usePopper = (referenceElementRef, popperElementRef, opts = {}) => {
	const stateUpdater = {
		name: "updateState",
		enabled: true,
		phase: "write",
		fn: ({ state }) => {
			const derivedState = deriveState(state);
			Object.assign(states.value, derivedState);
		},
		requires: ["computeStyles"]
	};
	const options$1 = computed(() => {
		const { onFirstUpdate, placement, strategy, modifiers } = unref(opts);
		return {
			onFirstUpdate,
			placement: placement || "bottom",
			strategy: strategy || "absolute",
			modifiers: [
				...modifiers || [],
				stateUpdater,
				{
					name: "applyStyles",
					enabled: false
				}
			]
		};
	});
	const instanceRef = shallowRef();
	const states = ref({
		styles: {
			popper: {
				position: unref(options$1).strategy,
				left: "0",
				top: "0"
			},
			arrow: { position: "absolute" }
		},
		attributes: {}
	});
	const destroy = () => {
		if (!instanceRef.value) return;
		instanceRef.value.destroy();
		instanceRef.value = void 0;
	};
	watch(options$1, (newOptions) => {
		const instance = unref(instanceRef);
		if (instance) instance.setOptions(newOptions);
	}, { deep: true });
	watch([referenceElementRef, popperElementRef], ([referenceElement, popperElement]) => {
		destroy();
		if (!referenceElement || !popperElement) return;
		instanceRef.value = yn(referenceElement, popperElement, unref(options$1));
	});
	onBeforeUnmount(() => {
		destroy();
	});
	return {
		state: computed(() => {
			var _a;
			return { ...((_a = unref(instanceRef)) == null ? void 0 : _a.state) || {} };
		}),
		styles: computed(() => unref(states).styles),
		attributes: computed(() => unref(states).attributes),
		update: () => {
			var _a;
			return (_a = unref(instanceRef)) == null ? void 0 : _a.update();
		},
		forceUpdate: () => {
			var _a;
			return (_a = unref(instanceRef)) == null ? void 0 : _a.forceUpdate();
		},
		instanceRef: computed(() => unref(instanceRef))
	};
};
function deriveState(state) {
	const elements = Object.keys(state.elements);
	return {
		styles: fromPairs_default(elements.map((element) => [element, state.styles[element] || {}])),
		attributes: fromPairs_default(elements.map((element) => [element, state.attributes[element]]))
	};
}
var useThrottleRender = (loading$3, throttle = 0) => {
	if (throttle === 0) return loading$3;
	const throttled = ref(false);
	let timeoutHandle = 0;
	const dispatchThrottling = () => {
		if (timeoutHandle) clearTimeout(timeoutHandle);
		timeoutHandle = window.setTimeout(() => {
			throttled.value = loading$3.value;
		}, throttle);
	};
	onMounted(dispatchThrottling);
	watch(() => loading$3.value, (val) => {
		if (val) dispatchThrottling();
		else throttled.value = val;
	});
	return throttled;
};
function useTimeout() {
	let timeoutHandle;
	const registerTimeout = (fn$1, delay) => {
		cancelTimeout();
		timeoutHandle = window.setTimeout(fn$1, delay);
	};
	const cancelTimeout = () => window.clearTimeout(timeoutHandle);
	tryOnScopeDispose$1(() => cancelTimeout());
	return {
		registerTimeout,
		cancelTimeout
	};
}
var defaultIdInjection = {
	prefix: Math.floor(Math.random() * 1e4),
	current: 0
};
var ID_INJECTION_KEY = Symbol("elIdInjection");
var useIdInjection = () => {
	return getCurrentInstance() ? inject(ID_INJECTION_KEY, defaultIdInjection) : defaultIdInjection;
};
var useId$1 = (deterministicId) => {
	const idInjection = useIdInjection();
	if (!isClient$1 && idInjection === defaultIdInjection) debugWarn("IdInjection", `Looks like you are using server rendering, you must provide a id provider to ensure the hydration process to be succeed
usage: app.provide(ID_INJECTION_KEY, {
  prefix: number,
  current: number,
})`);
	const namespace = useGetDerivedNamespace();
	return computed(() => unref(deterministicId) || `${namespace.value}-id-${idInjection.prefix}-${idInjection.current++}`);
};
var registeredEscapeHandlers = [];
var cachedHandler = (e) => {
	const event = e;
	if (event.key === EVENT_CODE.esc) registeredEscapeHandlers.forEach((registeredHandler) => registeredHandler(event));
};
var useEscapeKeydown = (handler) => {
	onMounted(() => {
		if (registeredEscapeHandlers.length === 0) document.addEventListener("keydown", cachedHandler);
		if (isClient$1) registeredEscapeHandlers.push(handler);
	});
	onBeforeUnmount(() => {
		registeredEscapeHandlers = registeredEscapeHandlers.filter((registeredHandler) => registeredHandler !== handler);
		if (registeredEscapeHandlers.length === 0) {
			if (isClient$1) document.removeEventListener("keydown", cachedHandler);
		}
	});
};
var cachedContainer;
var usePopperContainerId = () => {
	const namespace = useGetDerivedNamespace();
	const idInjection = useIdInjection();
	const id$1 = computed(() => {
		return `${namespace.value}-popper-container-${idInjection.prefix}`;
	});
	return {
		id: id$1,
		selector: computed(() => `#${id$1.value}`)
	};
};
var createContainer = (id$1) => {
	const container$18 = document.createElement("div");
	container$18.id = id$1;
	document.body.appendChild(container$18);
	return container$18;
};
var usePopperContainer = () => {
	const { id: id$1, selector } = usePopperContainerId();
	onBeforeMount(() => {
		if (!isClient$1) return;
		if (!cachedContainer && !document.body.querySelector(selector.value)) cachedContainer = createContainer(id$1.value);
	});
	return {
		id: id$1,
		selector
	};
};
var useDelayedToggleProps = buildProps({
	showAfter: {
		type: Number,
		default: 0
	},
	hideAfter: {
		type: Number,
		default: 200
	},
	autoClose: {
		type: Number,
		default: 0
	}
});
var useDelayedToggle = ({ showAfter, hideAfter, autoClose, open, close }) => {
	const { registerTimeout } = useTimeout();
	const { registerTimeout: registerTimeoutForAutoClose, cancelTimeout: cancelTimeoutForAutoClose } = useTimeout();
	const onOpen = (event) => {
		registerTimeout(() => {
			open(event);
			const _autoClose = unref(autoClose);
			if (isNumber(_autoClose) && _autoClose > 0) registerTimeoutForAutoClose(() => {
				close(event);
			}, _autoClose);
		}, unref(showAfter));
	};
	const onClose = (event) => {
		cancelTimeoutForAutoClose();
		registerTimeout(() => {
			close(event);
		}, unref(hideAfter));
	};
	return {
		onOpen,
		onClose
	};
};
var FORWARD_REF_INJECTION_KEY = Symbol("elForwardRef");
var useForwardRef = (forwardRef) => {
	const setForwardRef = (el$2) => {
		forwardRef.value = el$2;
	};
	provide(FORWARD_REF_INJECTION_KEY, { setForwardRef });
};
var useForwardRefDirective = (setForwardRef) => {
	return {
		mounted(el$2) {
			setForwardRef(el$2);
		},
		updated(el$2) {
			setForwardRef(el$2);
		},
		unmounted() {
			setForwardRef(null);
		}
	};
};
var sides = [
	"top",
	"right",
	"bottom",
	"left"
];
var min$1 = Math.min;
var max$1 = Math.max;
var round = Math.round;
var floor = Math.floor;
var createCoords = (v$1) => ({
	x: v$1,
	y: v$1
});
var oppositeSideMap = {
	left: "right",
	right: "left",
	bottom: "top",
	top: "bottom"
};
var oppositeAlignmentMap = {
	start: "end",
	end: "start"
};
function clamp$3(start, value, end$1) {
	return max$1(start, min$1(value, end$1));
}
function evaluate(value, param) {
	return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
	return placement.split("-")[0];
}
function getAlignment(placement) {
	return placement.split("-")[1];
}
function getOppositeAxis(axis) {
	return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
	return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
	return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
	return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
	if (rtl === void 0) rtl = false;
	const alignment = getAlignment(placement);
	const alignmentAxis = getAlignmentAxis(placement);
	const length = getAxisLength(alignmentAxis);
	let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
	if (rects.reference[length] > rects.floating[length]) mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
	return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
	const oppositePlacement = getOppositePlacement(placement);
	return [
		getOppositeAlignmentPlacement(placement),
		oppositePlacement,
		getOppositeAlignmentPlacement(oppositePlacement)
	];
}
function getOppositeAlignmentPlacement(placement) {
	return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
	const lr = ["left", "right"];
	const rl$1 = ["right", "left"];
	const tb = ["top", "bottom"];
	const bt$1 = ["bottom", "top"];
	switch (side) {
		case "top":
		case "bottom":
			if (rtl) return isStart ? rl$1 : lr;
			return isStart ? lr : rl$1;
		case "left":
		case "right": return isStart ? tb : bt$1;
		default: return [];
	}
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
	const alignment = getAlignment(placement);
	let list$1 = getSideList(getSide(placement), direction === "start", rtl);
	if (alignment) {
		list$1 = list$1.map((side) => side + "-" + alignment);
		if (flipAlignment) list$1 = list$1.concat(list$1.map(getOppositeAlignmentPlacement));
	}
	return list$1;
}
function getOppositePlacement(placement) {
	return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
	return {
		top: 0,
		right: 0,
		bottom: 0,
		left: 0,
		...padding
	};
}
function getPaddingObject(padding) {
	return typeof padding !== "number" ? expandPaddingObject(padding) : {
		top: padding,
		right: padding,
		bottom: padding,
		left: padding
	};
}
function rectToClientRect(rect$2) {
	const { x: x$2, y, width, height } = rect$2;
	return {
		width,
		height,
		top: y,
		left: x$2,
		right: x$2 + width,
		bottom: y + height,
		x: x$2,
		y
	};
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
	let { reference, floating } = _ref;
	const sideAxis = getSideAxis(placement);
	const alignmentAxis = getAlignmentAxis(placement);
	const alignLength = getAxisLength(alignmentAxis);
	const side = getSide(placement);
	const isVertical = sideAxis === "y";
	const commonX = reference.x + reference.width / 2 - floating.width / 2;
	const commonY = reference.y + reference.height / 2 - floating.height / 2;
	const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
	let coords;
	switch (side) {
		case "top":
			coords = {
				x: commonX,
				y: reference.y - floating.height
			};
			break;
		case "bottom":
			coords = {
				x: commonX,
				y: reference.y + reference.height
			};
			break;
		case "right":
			coords = {
				x: reference.x + reference.width,
				y: commonY
			};
			break;
		case "left":
			coords = {
				x: reference.x - floating.width,
				y: commonY
			};
			break;
		default: coords = {
			x: reference.x,
			y: reference.y
		};
	}
	switch (getAlignment(placement)) {
		case "start":
			coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
			break;
		case "end":
			coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
			break;
	}
	return coords;
}
var computePosition$1 = async (reference, floating, config$1) => {
	const { placement = "bottom", strategy = "absolute", middleware = [], platform: platform$1 } = config$1;
	const validMiddleware = middleware.filter(Boolean);
	const rtl = await (platform$1.isRTL == null ? void 0 : platform$1.isRTL(floating));
	let rects = await platform$1.getElementRects({
		reference,
		floating,
		strategy
	});
	let { x: x$2, y } = computeCoordsFromPlacement(rects, placement, rtl);
	let statefulPlacement = placement;
	let middlewareData = {};
	let resetCount = 0;
	for (let i$1 = 0; i$1 < validMiddleware.length; i$1++) {
		const { name: name$1, fn: fn$1 } = validMiddleware[i$1];
		const { x: nextX, y: nextY, data, reset } = await fn$1({
			x: x$2,
			y,
			initialPlacement: placement,
			placement: statefulPlacement,
			strategy,
			middlewareData,
			rects,
			platform: platform$1,
			elements: {
				reference,
				floating
			}
		});
		x$2 = nextX != null ? nextX : x$2;
		y = nextY != null ? nextY : y;
		middlewareData = {
			...middlewareData,
			[name$1]: {
				...middlewareData[name$1],
				...data
			}
		};
		if (reset && resetCount <= 50) {
			resetCount++;
			if (typeof reset === "object") {
				if (reset.placement) statefulPlacement = reset.placement;
				if (reset.rects) rects = reset.rects === true ? await platform$1.getElementRects({
					reference,
					floating,
					strategy
				}) : reset.rects;
				({x: x$2, y} = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
			}
			i$1 = -1;
		}
	}
	return {
		x: x$2,
		y,
		placement: statefulPlacement,
		strategy,
		middlewareData
	};
};
async function detectOverflow$1(state, options$1) {
	var _await$platform$isEle;
	if (options$1 === void 0) options$1 = {};
	const { x: x$2, y, platform: platform$1, rects, elements, strategy } = state;
	const { boundary = "clippingAncestors", rootBoundary = "viewport", elementContext = "floating", altBoundary = false, padding = 0 } = evaluate(options$1, state);
	const paddingObject = getPaddingObject(padding);
	const element = elements[altBoundary ? elementContext === "floating" ? "reference" : "floating" : elementContext];
	const clippingClientRect = rectToClientRect(await platform$1.getClippingRect({
		element: ((_await$platform$isEle = await (platform$1.isElement == null ? void 0 : platform$1.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform$1.getDocumentElement == null ? void 0 : platform$1.getDocumentElement(elements.floating)),
		boundary,
		rootBoundary,
		strategy
	}));
	const rect$2 = elementContext === "floating" ? {
		x: x$2,
		y,
		width: rects.floating.width,
		height: rects.floating.height
	} : rects.reference;
	const offsetParent = await (platform$1.getOffsetParent == null ? void 0 : platform$1.getOffsetParent(elements.floating));
	const offsetScale = await (platform$1.isElement == null ? void 0 : platform$1.isElement(offsetParent)) ? await (platform$1.getScale == null ? void 0 : platform$1.getScale(offsetParent)) || {
		x: 1,
		y: 1
	} : {
		x: 1,
		y: 1
	};
	const elementClientRect = rectToClientRect(platform$1.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform$1.convertOffsetParentRelativeRectToViewportRelativeRect({
		elements,
		rect: rect$2,
		offsetParent,
		strategy
	}) : rect$2);
	return {
		top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
		bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
		left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
		right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
	};
}
var arrow$2 = (options$1) => ({
	name: "arrow",
	options: options$1,
	async fn(state) {
		const { x: x$2, y, placement, rects, platform: platform$1, elements, middlewareData } = state;
		const { element, padding = 0 } = evaluate(options$1, state) || {};
		if (element == null) return {};
		const paddingObject = getPaddingObject(padding);
		const coords = {
			x: x$2,
			y
		};
		const axis = getAlignmentAxis(placement);
		const length = getAxisLength(axis);
		const arrowDimensions = await platform$1.getDimensions(element);
		const isYAxis = axis === "y";
		const minProp = isYAxis ? "top" : "left";
		const maxProp = isYAxis ? "bottom" : "right";
		const clientProp = isYAxis ? "clientHeight" : "clientWidth";
		const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
		const startDiff = coords[axis] - rects.reference[axis];
		const arrowOffsetParent = await (platform$1.getOffsetParent == null ? void 0 : platform$1.getOffsetParent(element));
		let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
		if (!clientSize || !await (platform$1.isElement == null ? void 0 : platform$1.isElement(arrowOffsetParent))) clientSize = elements.floating[clientProp] || rects.floating[length];
		const centerToReference = endDiff / 2 - startDiff / 2;
		const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
		const minPadding = min$1(paddingObject[minProp], largestPossiblePadding);
		const maxPadding = min$1(paddingObject[maxProp], largestPossiblePadding);
		const min$1$1 = minPadding;
		const max$2 = clientSize - arrowDimensions[length] - maxPadding;
		const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
		const offset$2 = clamp$3(min$1$1, center, max$2);
		const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset$2 && rects.reference[length] / 2 - (center < min$1$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
		const alignmentOffset = shouldAddOffset ? center < min$1$1 ? center - min$1$1 : center - max$2 : 0;
		return {
			[axis]: coords[axis] + alignmentOffset,
			data: {
				[axis]: offset$2,
				centerOffset: center - offset$2 - alignmentOffset,
				...shouldAddOffset && { alignmentOffset }
			},
			reset: shouldAddOffset
		};
	}
});
var flip$1 = function(options$1) {
	if (options$1 === void 0) options$1 = {};
	return {
		name: "flip",
		options: options$1,
		async fn(state) {
			var _middlewareData$arrow, _middlewareData$flip;
			const { placement, middlewareData, rects, initialPlacement, platform: platform$1, elements } = state;
			const { mainAxis: checkMainAxis = true, crossAxis: checkCrossAxis = true, fallbackPlacements: specifiedFallbackPlacements, fallbackStrategy = "bestFit", fallbackAxisSideDirection = "none", flipAlignment = true,...detectOverflowOptions } = evaluate(options$1, state);
			if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) return {};
			const side = getSide(placement);
			const initialSideAxis = getSideAxis(initialPlacement);
			const isBasePlacement = getSide(initialPlacement) === initialPlacement;
			const rtl = await (platform$1.isRTL == null ? void 0 : platform$1.isRTL(elements.floating));
			const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
			const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
			if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
			const placements$1 = [initialPlacement, ...fallbackPlacements];
			const overflow$1 = await detectOverflow$1(state, detectOverflowOptions);
			const overflows = [];
			let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
			if (checkMainAxis) overflows.push(overflow$1[side]);
			if (checkCrossAxis) {
				const sides$1 = getAlignmentSides(placement, rects, rtl);
				overflows.push(overflow$1[sides$1[0]], overflow$1[sides$1[1]]);
			}
			overflowsData = [...overflowsData, {
				placement,
				overflows
			}];
			if (!overflows.every((side$1) => side$1 <= 0)) {
				var _middlewareData$flip2, _overflowsData$filter;
				const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
				const nextPlacement = placements$1[nextIndex];
				if (nextPlacement) {
					var _overflowsData$;
					const ignoreCrossAxisOverflow = checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : false;
					const hasInitialMainAxisOverflow = ((_overflowsData$ = overflowsData[0]) == null ? void 0 : _overflowsData$.overflows[0]) > 0;
					if (!ignoreCrossAxisOverflow || hasInitialMainAxisOverflow) return {
						data: {
							index: nextIndex,
							overflows: overflowsData
						},
						reset: { placement: nextPlacement }
					};
				}
				let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a$1, b$2) => a$1.overflows[1] - b$2.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
				if (!resetPlacement) switch (fallbackStrategy) {
					case "bestFit": {
						var _overflowsData$filter2;
						const placement$1 = (_overflowsData$filter2 = overflowsData.filter((d) => {
							if (hasFallbackAxisSideDirection) {
								const currentSideAxis = getSideAxis(d.placement);
								return currentSideAxis === initialSideAxis || currentSideAxis === "y";
							}
							return true;
						}).map((d) => [d.placement, d.overflows.filter((overflow$2) => overflow$2 > 0).reduce((acc, overflow$2) => acc + overflow$2, 0)]).sort((a$1, b$2) => a$1[1] - b$2[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
						if (placement$1) resetPlacement = placement$1;
						break;
					}
					case "initialPlacement":
						resetPlacement = initialPlacement;
						break;
				}
				if (placement !== resetPlacement) return { reset: { placement: resetPlacement } };
			}
			return {};
		}
	};
};
function getSideOffsets(overflow$1, rect$2) {
	return {
		top: overflow$1.top - rect$2.height,
		right: overflow$1.right - rect$2.width,
		bottom: overflow$1.bottom - rect$2.height,
		left: overflow$1.left - rect$2.width
	};
}
function isAnySideFullyClipped(overflow$1) {
	return sides.some((side) => overflow$1[side] >= 0);
}
var hide$1 = function(options$1) {
	if (options$1 === void 0) options$1 = {};
	return {
		name: "hide",
		options: options$1,
		async fn(state) {
			const { rects } = state;
			const { strategy = "referenceHidden",...detectOverflowOptions } = evaluate(options$1, state);
			switch (strategy) {
				case "referenceHidden": {
					const offsets = getSideOffsets(await detectOverflow$1(state, {
						...detectOverflowOptions,
						elementContext: "reference"
					}), rects.reference);
					return { data: {
						referenceHiddenOffsets: offsets,
						referenceHidden: isAnySideFullyClipped(offsets)
					} };
				}
				case "escaped": {
					const offsets = getSideOffsets(await detectOverflow$1(state, {
						...detectOverflowOptions,
						altBoundary: true
					}), rects.floating);
					return { data: {
						escapedOffsets: offsets,
						escaped: isAnySideFullyClipped(offsets)
					} };
				}
				default: return {};
			}
		}
	};
};
async function convertValueToCoords(state, options$1) {
	const { placement, platform: platform$1, elements } = state;
	const rtl = await (platform$1.isRTL == null ? void 0 : platform$1.isRTL(elements.floating));
	const side = getSide(placement);
	const alignment = getAlignment(placement);
	const isVertical = getSideAxis(placement) === "y";
	const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
	const crossAxisMulti = rtl && isVertical ? -1 : 1;
	const rawValue = evaluate(options$1, state);
	let { mainAxis, crossAxis, alignmentAxis } = typeof rawValue === "number" ? {
		mainAxis: rawValue,
		crossAxis: 0,
		alignmentAxis: null
	} : {
		mainAxis: rawValue.mainAxis || 0,
		crossAxis: rawValue.crossAxis || 0,
		alignmentAxis: rawValue.alignmentAxis
	};
	if (alignment && typeof alignmentAxis === "number") crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
	return isVertical ? {
		x: crossAxis * crossAxisMulti,
		y: mainAxis * mainAxisMulti
	} : {
		x: mainAxis * mainAxisMulti,
		y: crossAxis * crossAxisMulti
	};
}
var offset$1 = function(options$1) {
	if (options$1 === void 0) options$1 = 0;
	return {
		name: "offset",
		options: options$1,
		async fn(state) {
			var _middlewareData$offse, _middlewareData$arrow;
			const { x: x$2, y, placement, middlewareData } = state;
			const diffCoords = await convertValueToCoords(state, options$1);
			if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) return {};
			return {
				x: x$2 + diffCoords.x,
				y: y + diffCoords.y,
				data: {
					...diffCoords,
					placement
				}
			};
		}
	};
};
var shift$1 = function(options$1) {
	if (options$1 === void 0) options$1 = {};
	return {
		name: "shift",
		options: options$1,
		async fn(state) {
			const { x: x$2, y, placement } = state;
			const { mainAxis: checkMainAxis = true, crossAxis: checkCrossAxis = false, limiter = { fn: (_ref) => {
				let { x: x$3, y: y$1 } = _ref;
				return {
					x: x$3,
					y: y$1
				};
			} },...detectOverflowOptions } = evaluate(options$1, state);
			const coords = {
				x: x$2,
				y
			};
			const overflow$1 = await detectOverflow$1(state, detectOverflowOptions);
			const crossAxis = getSideAxis(getSide(placement));
			const mainAxis = getOppositeAxis(crossAxis);
			let mainAxisCoord = coords[mainAxis];
			let crossAxisCoord = coords[crossAxis];
			if (checkMainAxis) {
				const minSide = mainAxis === "y" ? "top" : "left";
				const maxSide = mainAxis === "y" ? "bottom" : "right";
				const min$2 = mainAxisCoord + overflow$1[minSide];
				const max$2 = mainAxisCoord - overflow$1[maxSide];
				mainAxisCoord = clamp$3(min$2, mainAxisCoord, max$2);
			}
			if (checkCrossAxis) {
				const minSide = crossAxis === "y" ? "top" : "left";
				const maxSide = crossAxis === "y" ? "bottom" : "right";
				const min$2 = crossAxisCoord + overflow$1[minSide];
				const max$2 = crossAxisCoord - overflow$1[maxSide];
				crossAxisCoord = clamp$3(min$2, crossAxisCoord, max$2);
			}
			const limitedCoords = limiter.fn({
				...state,
				[mainAxis]: mainAxisCoord,
				[crossAxis]: crossAxisCoord
			});
			return {
				...limitedCoords,
				data: {
					x: limitedCoords.x - x$2,
					y: limitedCoords.y - y,
					enabled: {
						[mainAxis]: checkMainAxis,
						[crossAxis]: checkCrossAxis
					}
				}
			};
		}
	};
};
var limitShift$1 = function(options$1) {
	if (options$1 === void 0) options$1 = {};
	return {
		options: options$1,
		fn(state) {
			const { x: x$2, y, placement, rects, middlewareData } = state;
			const { offset: offset$2 = 0, mainAxis: checkMainAxis = true, crossAxis: checkCrossAxis = true } = evaluate(options$1, state);
			const coords = {
				x: x$2,
				y
			};
			const crossAxis = getSideAxis(placement);
			const mainAxis = getOppositeAxis(crossAxis);
			let mainAxisCoord = coords[mainAxis];
			let crossAxisCoord = coords[crossAxis];
			const rawOffset = evaluate(offset$2, state);
			const computedOffset = typeof rawOffset === "number" ? {
				mainAxis: rawOffset,
				crossAxis: 0
			} : {
				mainAxis: 0,
				crossAxis: 0,
				...rawOffset
			};
			if (checkMainAxis) {
				const len = mainAxis === "y" ? "height" : "width";
				const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
				const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
				if (mainAxisCoord < limitMin) mainAxisCoord = limitMin;
				else if (mainAxisCoord > limitMax) mainAxisCoord = limitMax;
			}
			if (checkCrossAxis) {
				var _middlewareData$offse, _middlewareData$offse2;
				const len = mainAxis === "y" ? "width" : "height";
				const isOriginSide = ["top", "left"].includes(getSide(placement));
				const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
				const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
				if (crossAxisCoord < limitMin) crossAxisCoord = limitMin;
				else if (crossAxisCoord > limitMax) crossAxisCoord = limitMax;
			}
			return {
				[mainAxis]: mainAxisCoord,
				[crossAxis]: crossAxisCoord
			};
		}
	};
};
var size$1 = function(options$1) {
	if (options$1 === void 0) options$1 = {};
	return {
		name: "size",
		options: options$1,
		async fn(state) {
			var _state$middlewareData, _state$middlewareData2;
			const { placement, rects, platform: platform$1, elements } = state;
			const { apply: apply$1 = () => {},...detectOverflowOptions } = evaluate(options$1, state);
			const overflow$1 = await detectOverflow$1(state, detectOverflowOptions);
			const side = getSide(placement);
			const alignment = getAlignment(placement);
			const isYAxis = getSideAxis(placement) === "y";
			const { width, height } = rects.floating;
			let heightSide;
			let widthSide;
			if (side === "top" || side === "bottom") {
				heightSide = side;
				widthSide = alignment === (await (platform$1.isRTL == null ? void 0 : platform$1.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
			} else {
				widthSide = side;
				heightSide = alignment === "end" ? "top" : "bottom";
			}
			const maximumClippingHeight = height - overflow$1.top - overflow$1.bottom;
			const maximumClippingWidth = width - overflow$1.left - overflow$1.right;
			const overflowAvailableHeight = min$1(height - overflow$1[heightSide], maximumClippingHeight);
			const overflowAvailableWidth = min$1(width - overflow$1[widthSide], maximumClippingWidth);
			const noShift = !state.middlewareData.shift;
			let availableHeight = overflowAvailableHeight;
			let availableWidth = overflowAvailableWidth;
			if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) availableWidth = maximumClippingWidth;
			if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) availableHeight = maximumClippingHeight;
			if (noShift && !alignment) {
				const xMin = max$1(overflow$1.left, 0);
				const xMax = max$1(overflow$1.right, 0);
				const yMin = max$1(overflow$1.top, 0);
				const yMax = max$1(overflow$1.bottom, 0);
				if (isYAxis) availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max$1(overflow$1.left, overflow$1.right));
				else availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max$1(overflow$1.top, overflow$1.bottom));
			}
			await apply$1({
				...state,
				availableWidth,
				availableHeight
			});
			const nextDimensions = await platform$1.getDimensions(elements.floating);
			if (width !== nextDimensions.width || height !== nextDimensions.height) return { reset: { rects: true } };
			return {};
		}
	};
};
function hasWindow() {
	return typeof window !== "undefined";
}
function getNodeName(node) {
	if (isNode(node)) return (node.nodeName || "").toLowerCase();
	return "#document";
}
function getWindow(node) {
	var _node$ownerDocument;
	return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
	var _ref;
	return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
	if (!hasWindow()) return false;
	return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement$1(value) {
	if (!hasWindow()) return false;
	return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement$1(value) {
	if (!hasWindow()) return false;
	return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
	if (!hasWindow() || typeof ShadowRoot === "undefined") return false;
	return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
	const { overflow: overflow$1, overflowX, overflowY, display } = getComputedStyle$1(element);
	return /auto|scroll|overlay|hidden|clip/.test(overflow$1 + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
	return [
		"table",
		"td",
		"th"
	].includes(getNodeName(element));
}
function isTopLayer(element) {
	return [":popover-open", ":modal"].some((selector) => {
		try {
			return element.matches(selector);
		} catch (e) {
			return false;
		}
	});
}
function isContainingBlock(elementOrCss) {
	const webkit = isWebKit();
	const css = isElement$1(elementOrCss) ? getComputedStyle$1(elementOrCss) : elementOrCss;
	return [
		"transform",
		"translate",
		"scale",
		"rotate",
		"perspective"
	].some((value) => css[value] ? css[value] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || [
		"transform",
		"translate",
		"scale",
		"rotate",
		"perspective",
		"filter"
	].some((value) => (css.willChange || "").includes(value)) || [
		"paint",
		"layout",
		"strict",
		"content"
	].some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
	let currentNode = getParentNode(element);
	while (isHTMLElement$1(currentNode) && !isLastTraversableNode(currentNode)) {
		if (isContainingBlock(currentNode)) return currentNode;
		else if (isTopLayer(currentNode)) return null;
		currentNode = getParentNode(currentNode);
	}
	return null;
}
function isWebKit() {
	if (typeof CSS === "undefined" || !CSS.supports) return false;
	return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
	return [
		"html",
		"body",
		"#document"
	].includes(getNodeName(node));
}
function getComputedStyle$1(element) {
	return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
	if (isElement$1(element)) return {
		scrollLeft: element.scrollLeft,
		scrollTop: element.scrollTop
	};
	return {
		scrollLeft: element.scrollX,
		scrollTop: element.scrollY
	};
}
function getParentNode(node) {
	if (getNodeName(node) === "html") return node;
	const result = node.assignedSlot || node.parentNode || isShadowRoot(node) && node.host || getDocumentElement(node);
	return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
	const parentNode = getParentNode(node);
	if (isLastTraversableNode(parentNode)) return node.ownerDocument ? node.ownerDocument.body : node.body;
	if (isHTMLElement$1(parentNode) && isOverflowElement(parentNode)) return parentNode;
	return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list$1, traverseIframes) {
	var _node$ownerDocument2;
	if (list$1 === void 0) list$1 = [];
	if (traverseIframes === void 0) traverseIframes = true;
	const scrollableAncestor = getNearestOverflowAncestor(node);
	const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
	const win = getWindow(scrollableAncestor);
	if (isBody) {
		const frameElement = getFrameElement(win);
		return list$1.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
	}
	return list$1.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
	return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}
function getCssDimensions(element) {
	const css = getComputedStyle$1(element);
	let width = parseFloat(css.width) || 0;
	let height = parseFloat(css.height) || 0;
	const hasOffset = isHTMLElement$1(element);
	const offsetWidth = hasOffset ? element.offsetWidth : width;
	const offsetHeight = hasOffset ? element.offsetHeight : height;
	const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
	if (shouldFallback) {
		width = offsetWidth;
		height = offsetHeight;
	}
	return {
		width,
		height,
		$: shouldFallback
	};
}
function unwrapElement$1(element) {
	return !isElement$1(element) ? element.contextElement : element;
}
function getScale(element) {
	const domElement = unwrapElement$1(element);
	if (!isHTMLElement$1(domElement)) return createCoords(1);
	const rect$2 = domElement.getBoundingClientRect();
	const { width, height, $ } = getCssDimensions(domElement);
	let x$2 = ($ ? round(rect$2.width) : rect$2.width) / width;
	let y = ($ ? round(rect$2.height) : rect$2.height) / height;
	if (!x$2 || !Number.isFinite(x$2)) x$2 = 1;
	if (!y || !Number.isFinite(y)) y = 1;
	return {
		x: x$2,
		y
	};
}
var noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
	const win = getWindow(element);
	if (!isWebKit() || !win.visualViewport) return noOffsets;
	return {
		x: win.visualViewport.offsetLeft,
		y: win.visualViewport.offsetTop
	};
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
	if (isFixed === void 0) isFixed = false;
	if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) return false;
	return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
	if (includeScale === void 0) includeScale = false;
	if (isFixedStrategy === void 0) isFixedStrategy = false;
	const clientRect = element.getBoundingClientRect();
	const domElement = unwrapElement$1(element);
	let scale = createCoords(1);
	if (includeScale) if (offsetParent) {
		if (isElement$1(offsetParent)) scale = getScale(offsetParent);
	} else scale = getScale(element);
	const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
	let x$2 = (clientRect.left + visualOffsets.x) / scale.x;
	let y = (clientRect.top + visualOffsets.y) / scale.y;
	let width = clientRect.width / scale.x;
	let height = clientRect.height / scale.y;
	if (domElement) {
		const win = getWindow(domElement);
		const offsetWin = offsetParent && isElement$1(offsetParent) ? getWindow(offsetParent) : offsetParent;
		let currentWin = win;
		let currentIFrame = getFrameElement(currentWin);
		while (currentIFrame && offsetParent && offsetWin !== currentWin) {
			const iframeScale = getScale(currentIFrame);
			const iframeRect = currentIFrame.getBoundingClientRect();
			const css = getComputedStyle$1(currentIFrame);
			const left$1 = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
			const top$3 = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
			x$2 *= iframeScale.x;
			y *= iframeScale.y;
			width *= iframeScale.x;
			height *= iframeScale.y;
			x$2 += left$1;
			y += top$3;
			currentWin = getWindow(currentIFrame);
			currentIFrame = getFrameElement(currentWin);
		}
	}
	return rectToClientRect({
		width,
		height,
		x: x$2,
		y
	});
}
function getWindowScrollBarX(element, rect$2) {
	const leftScroll = getNodeScroll(element).scrollLeft;
	if (!rect$2) return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
	return rect$2.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll$1, ignoreScrollbarX) {
	if (ignoreScrollbarX === void 0) ignoreScrollbarX = false;
	const htmlRect = documentElement.getBoundingClientRect();
	return {
		x: htmlRect.left + scroll$1.scrollLeft - (ignoreScrollbarX ? 0 : getWindowScrollBarX(documentElement, htmlRect)),
		y: htmlRect.top + scroll$1.scrollTop
	};
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
	let { elements, rect: rect$2, offsetParent, strategy } = _ref;
	const isFixed = strategy === "fixed";
	const documentElement = getDocumentElement(offsetParent);
	const topLayer = elements ? isTopLayer(elements.floating) : false;
	if (offsetParent === documentElement || topLayer && isFixed) return rect$2;
	let scroll$1 = {
		scrollLeft: 0,
		scrollTop: 0
	};
	let scale = createCoords(1);
	const offsets = createCoords(0);
	const isOffsetParentAnElement = isHTMLElement$1(offsetParent);
	if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
		if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) scroll$1 = getNodeScroll(offsetParent);
		if (isHTMLElement$1(offsetParent)) {
			const offsetRect = getBoundingClientRect(offsetParent);
			scale = getScale(offsetParent);
			offsets.x = offsetRect.x + offsetParent.clientLeft;
			offsets.y = offsetRect.y + offsetParent.clientTop;
		}
	}
	const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll$1, true) : createCoords(0);
	return {
		width: rect$2.width * scale.x,
		height: rect$2.height * scale.y,
		x: rect$2.x * scale.x - scroll$1.scrollLeft * scale.x + offsets.x + htmlOffset.x,
		y: rect$2.y * scale.y - scroll$1.scrollTop * scale.y + offsets.y + htmlOffset.y
	};
}
function getClientRects(element) {
	return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
	const html = getDocumentElement(element);
	const scroll$1 = getNodeScroll(element);
	const body$2 = element.ownerDocument.body;
	const width = max$1(html.scrollWidth, html.clientWidth, body$2.scrollWidth, body$2.clientWidth);
	const height = max$1(html.scrollHeight, html.clientHeight, body$2.scrollHeight, body$2.clientHeight);
	let x$2 = -scroll$1.scrollLeft + getWindowScrollBarX(element);
	const y = -scroll$1.scrollTop;
	if (getComputedStyle$1(body$2).direction === "rtl") x$2 += max$1(html.clientWidth, body$2.clientWidth) - width;
	return {
		width,
		height,
		x: x$2,
		y
	};
}
function getViewportRect(element, strategy) {
	const win = getWindow(element);
	const html = getDocumentElement(element);
	const visualViewport = win.visualViewport;
	let width = html.clientWidth;
	let height = html.clientHeight;
	let x$2 = 0;
	let y = 0;
	if (visualViewport) {
		width = visualViewport.width;
		height = visualViewport.height;
		const visualViewportBased = isWebKit();
		if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
			x$2 = visualViewport.offsetLeft;
			y = visualViewport.offsetTop;
		}
	}
	return {
		width,
		height,
		x: x$2,
		y
	};
}
function getInnerBoundingClientRect(element, strategy) {
	const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
	const top$3 = clientRect.top + element.clientTop;
	const left$1 = clientRect.left + element.clientLeft;
	const scale = isHTMLElement$1(element) ? getScale(element) : createCoords(1);
	return {
		width: element.clientWidth * scale.x,
		height: element.clientHeight * scale.y,
		x: left$1 * scale.x,
		y: top$3 * scale.y
	};
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
	let rect$2;
	if (clippingAncestor === "viewport") rect$2 = getViewportRect(element, strategy);
	else if (clippingAncestor === "document") rect$2 = getDocumentRect(getDocumentElement(element));
	else if (isElement$1(clippingAncestor)) rect$2 = getInnerBoundingClientRect(clippingAncestor, strategy);
	else {
		const visualOffsets = getVisualOffsets(element);
		rect$2 = {
			x: clippingAncestor.x - visualOffsets.x,
			y: clippingAncestor.y - visualOffsets.y,
			width: clippingAncestor.width,
			height: clippingAncestor.height
		};
	}
	return rectToClientRect(rect$2);
}
function hasFixedPositionAncestor(element, stopNode) {
	const parentNode = getParentNode(element);
	if (parentNode === stopNode || !isElement$1(parentNode) || isLastTraversableNode(parentNode)) return false;
	return getComputedStyle$1(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache$1) {
	const cachedResult = cache$1.get(element);
	if (cachedResult) return cachedResult;
	let result = getOverflowAncestors(element, [], false).filter((el$2) => isElement$1(el$2) && getNodeName(el$2) !== "body");
	let currentContainingBlockComputedStyle = null;
	const elementIsFixed = getComputedStyle$1(element).position === "fixed";
	let currentNode = elementIsFixed ? getParentNode(element) : element;
	while (isElement$1(currentNode) && !isLastTraversableNode(currentNode)) {
		const computedStyle = getComputedStyle$1(currentNode);
		const currentNodeIsContaining = isContainingBlock(currentNode);
		if (!currentNodeIsContaining && computedStyle.position === "fixed") currentContainingBlockComputedStyle = null;
		if (elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode)) result = result.filter((ancestor) => ancestor !== currentNode);
		else currentContainingBlockComputedStyle = computedStyle;
		currentNode = getParentNode(currentNode);
	}
	cache$1.set(element, result);
	return result;
}
function getClippingRect(_ref) {
	let { element, boundary, rootBoundary, strategy } = _ref;
	const clippingAncestors = [...boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary), rootBoundary];
	const firstClippingAncestor = clippingAncestors[0];
	const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
		const rect$2 = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
		accRect.top = max$1(rect$2.top, accRect.top);
		accRect.right = min$1(rect$2.right, accRect.right);
		accRect.bottom = min$1(rect$2.bottom, accRect.bottom);
		accRect.left = max$1(rect$2.left, accRect.left);
		return accRect;
	}, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
	return {
		width: clippingRect.right - clippingRect.left,
		height: clippingRect.bottom - clippingRect.top,
		x: clippingRect.left,
		y: clippingRect.top
	};
}
function getDimensions(element) {
	const { width, height } = getCssDimensions(element);
	return {
		width,
		height
	};
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
	const isOffsetParentAnElement = isHTMLElement$1(offsetParent);
	const documentElement = getDocumentElement(offsetParent);
	const isFixed = strategy === "fixed";
	const rect$2 = getBoundingClientRect(element, true, isFixed, offsetParent);
	let scroll$1 = {
		scrollLeft: 0,
		scrollTop: 0
	};
	const offsets = createCoords(0);
	function setLeftRTLScrollbarOffset() {
		offsets.x = getWindowScrollBarX(documentElement);
	}
	if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
		if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) scroll$1 = getNodeScroll(offsetParent);
		if (isOffsetParentAnElement) {
			const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
			offsets.x = offsetRect.x + offsetParent.clientLeft;
			offsets.y = offsetRect.y + offsetParent.clientTop;
		} else if (documentElement) setLeftRTLScrollbarOffset();
	}
	if (isFixed && !isOffsetParentAnElement && documentElement) setLeftRTLScrollbarOffset();
	const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll$1) : createCoords(0);
	return {
		x: rect$2.left + scroll$1.scrollLeft - offsets.x - htmlOffset.x,
		y: rect$2.top + scroll$1.scrollTop - offsets.y - htmlOffset.y,
		width: rect$2.width,
		height: rect$2.height
	};
}
function isStaticPositioned(element) {
	return getComputedStyle$1(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
	if (!isHTMLElement$1(element) || getComputedStyle$1(element).position === "fixed") return null;
	if (polyfill) return polyfill(element);
	let rawOffsetParent = element.offsetParent;
	if (getDocumentElement(element) === rawOffsetParent) rawOffsetParent = rawOffsetParent.ownerDocument.body;
	return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
	const win = getWindow(element);
	if (isTopLayer(element)) return win;
	if (!isHTMLElement$1(element)) {
		let svgOffsetParent = getParentNode(element);
		while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
			if (isElement$1(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) return svgOffsetParent;
			svgOffsetParent = getParentNode(svgOffsetParent);
		}
		return win;
	}
	let offsetParent = getTrueOffsetParent(element, polyfill);
	while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) offsetParent = getTrueOffsetParent(offsetParent, polyfill);
	if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) return win;
	return offsetParent || getContainingBlock(element) || win;
}
var getElementRects = async function(data) {
	const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
	const getDimensionsFn = this.getDimensions;
	const floatingDimensions = await getDimensionsFn(data.floating);
	return {
		reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
		floating: {
			x: 0,
			y: 0,
			width: floatingDimensions.width,
			height: floatingDimensions.height
		}
	};
};
function isRTL(element) {
	return getComputedStyle$1(element).direction === "rtl";
}
var platform = {
	convertOffsetParentRelativeRectToViewportRelativeRect,
	getDocumentElement,
	getClippingRect,
	getOffsetParent,
	getElementRects,
	getClientRects,
	getDimensions,
	getScale,
	isElement: isElement$1,
	isRTL
};
function rectsAreEqual(a$1, b$2) {
	return a$1.x === b$2.x && a$1.y === b$2.y && a$1.width === b$2.width && a$1.height === b$2.height;
}
function observeMove(element, onMove) {
	let io = null;
	let timeoutId;
	const root = getDocumentElement(element);
	function cleanup() {
		var _io;
		clearTimeout(timeoutId);
		(_io = io) == null || _io.disconnect();
		io = null;
	}
	function refresh(skip, threshold) {
		if (skip === void 0) skip = false;
		if (threshold === void 0) threshold = 1;
		cleanup();
		const elementRectForRootMargin = element.getBoundingClientRect();
		const { left: left$1, top: top$3, width, height } = elementRectForRootMargin;
		if (!skip) onMove();
		if (!width || !height) return;
		const insetTop = floor(top$3);
		const insetRight = floor(root.clientWidth - (left$1 + width));
		const insetBottom = floor(root.clientHeight - (top$3 + height));
		const insetLeft = floor(left$1);
		const options$1 = {
			rootMargin: -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px",
			threshold: max$1(0, min$1(1, threshold)) || 1
		};
		let isFirstUpdate = true;
		function handleObserve(entries) {
			const ratio$1 = entries[0].intersectionRatio;
			if (ratio$1 !== threshold) {
				if (!isFirstUpdate) return refresh();
				if (!ratio$1) timeoutId = setTimeout(() => {
					refresh(false, 1e-7);
				}, 1e3);
				else refresh(false, ratio$1);
			}
			if (ratio$1 === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) refresh();
			isFirstUpdate = false;
		}
		try {
			io = new IntersectionObserver(handleObserve, {
				...options$1,
				root: root.ownerDocument
			});
		} catch (_e$1) {
			io = new IntersectionObserver(handleObserve, options$1);
		}
		io.observe(element);
	}
	refresh(true);
	return cleanup;
}
function autoUpdate(reference, floating, update, options$1) {
	if (options$1 === void 0) options$1 = {};
	const { ancestorScroll = true, ancestorResize = true, elementResize = typeof ResizeObserver === "function", layoutShift = typeof IntersectionObserver === "function", animationFrame = false } = options$1;
	const referenceEl = unwrapElement$1(reference);
	const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
	ancestors.forEach((ancestor) => {
		ancestorScroll && ancestor.addEventListener("scroll", update, { passive: true });
		ancestorResize && ancestor.addEventListener("resize", update);
	});
	const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
	let reobserveFrame = -1;
	let resizeObserver = null;
	if (elementResize) {
		resizeObserver = new ResizeObserver((_ref) => {
			let [firstEntry] = _ref;
			if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
				resizeObserver.unobserve(floating);
				cancelAnimationFrame(reobserveFrame);
				reobserveFrame = requestAnimationFrame(() => {
					var _resizeObserver;
					(_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
				});
			}
			update();
		});
		if (referenceEl && !animationFrame) resizeObserver.observe(referenceEl);
		resizeObserver.observe(floating);
	}
	let frameId;
	let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
	if (animationFrame) frameLoop();
	function frameLoop() {
		const nextRefRect = getBoundingClientRect(reference);
		if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) update();
		prevRefRect = nextRefRect;
		frameId = requestAnimationFrame(frameLoop);
	}
	update();
	return () => {
		var _resizeObserver2;
		ancestors.forEach((ancestor) => {
			ancestorScroll && ancestor.removeEventListener("scroll", update);
			ancestorResize && ancestor.removeEventListener("resize", update);
		});
		cleanupIo?.();
		(_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
		resizeObserver = null;
		if (animationFrame) cancelAnimationFrame(frameId);
	};
}
var offset = offset$1;
var shift = shift$1;
var flip = flip$1;
var size = size$1;
var hide = hide$1;
var arrow$1 = arrow$2;
var limitShift = limitShift$1;
var computePosition = (reference, floating, options$1) => {
	const cache$1 = /* @__PURE__ */ new Map();
	const mergedOptions = {
		platform,
		...options$1
	};
	const platformWithCache = {
		...mergedOptions.platform,
		_c: cache$1
	};
	return computePosition$1(reference, floating, {
		...mergedOptions,
		platform: platformWithCache
	});
};
function useCursor(input$4) {
	const selectionRef = ref();
	function recordCursor() {
		if (input$4.value == void 0) return;
		const { selectionStart, selectionEnd, value } = input$4.value;
		if (selectionStart == null || selectionEnd == null) return;
		selectionRef.value = {
			selectionStart,
			selectionEnd,
			value,
			beforeTxt: value.slice(0, Math.max(0, selectionStart)),
			afterTxt: value.slice(Math.max(0, selectionEnd))
		};
	}
	function setCursor() {
		if (input$4.value == void 0 || selectionRef.value == void 0) return;
		const { value } = input$4.value;
		const { beforeTxt, afterTxt, selectionStart } = selectionRef.value;
		if (beforeTxt == void 0 || afterTxt == void 0 || selectionStart == void 0) return;
		let startPos = value.length;
		if (value.endsWith(afterTxt)) startPos = value.length - afterTxt.length;
		else if (value.startsWith(beforeTxt)) startPos = beforeTxt.length;
		else {
			const beforeLastChar = beforeTxt[selectionStart - 1];
			const newIndex = value.indexOf(beforeLastChar, selectionStart - 1);
			if (newIndex !== -1) startPos = newIndex + 1;
		}
		input$4.value.setSelectionRange(startPos, startPos);
	}
	return [recordCursor, setCursor];
}
init_shared_esm_bundler();
function useFocusController(target$1, { afterFocus, beforeBlur, afterBlur } = {}) {
	const { emit } = getCurrentInstance();
	const wrapperRef = shallowRef();
	const isFocused = ref(false);
	const handleFocus = (event) => {
		if (isFocused.value) return;
		isFocused.value = true;
		emit("focus", event);
		afterFocus?.();
	};
	const handleBlur = (event) => {
		var _a;
		if ((isFunction$2(beforeBlur) ? beforeBlur(event) : false) || event.relatedTarget && ((_a = wrapperRef.value) == null ? void 0 : _a.contains(event.relatedTarget))) return;
		isFocused.value = false;
		emit("blur", event);
		afterBlur?.();
	};
	const handleClick = () => {
		var _a;
		(_a = target$1.value) == null || _a.focus();
	};
	watch(wrapperRef, (el$2) => {
		if (el$2) el$2.setAttribute("tabindex", "-1");
	});
	useEventListener$1(wrapperRef, "click", handleClick);
	return {
		wrapperRef,
		isFocused,
		handleFocus,
		handleBlur
	};
}
var formContextKey = Symbol("formContextKey");
var formItemContextKey = Symbol("formItemContextKey");
var useFormSize = (fallback, ignore = {}) => {
	const emptyRef = ref(void 0);
	const size$2 = ignore.prop ? emptyRef : useProp("size");
	const globalConfig = ignore.global ? emptyRef : useGlobalSize();
	const form = ignore.form ? { size: void 0 } : inject(formContextKey, void 0);
	const formItem = ignore.formItem ? { size: void 0 } : inject(formItemContextKey, void 0);
	return computed(() => size$2.value || unref(fallback) || (formItem == null ? void 0 : formItem.size) || (form == null ? void 0 : form.size) || globalConfig.value || "");
};
var useFormDisabled = (fallback) => {
	const disabled$9 = useProp("disabled");
	const form = inject(formContextKey, void 0);
	return computed(() => disabled$9.value || unref(fallback) || (form == null ? void 0 : form.disabled) || false);
};
var useFormItem = () => {
	return {
		form: inject(formContextKey, void 0),
		formItem: inject(formItemContextKey, void 0)
	};
};
var useFormItemInputId = (props, { formItemContext, disableIdGeneration, disableIdManagement }) => {
	if (!disableIdGeneration) disableIdGeneration = ref(false);
	if (!disableIdManagement) disableIdManagement = ref(false);
	const inputId = ref();
	let idUnwatch = void 0;
	const isLabeledByFormItem = computed(() => {
		var _a;
		return !!(!props.label && formItemContext && formItemContext.inputIds && ((_a = formItemContext.inputIds) == null ? void 0 : _a.length) <= 1);
	});
	onMounted(() => {
		idUnwatch = watch([toRef(props, "id"), disableIdGeneration], ([id$1, disableIdGeneration2]) => {
			const newId = id$1 != null ? id$1 : !disableIdGeneration2 ? useId$1().value : void 0;
			if (newId !== inputId.value) {
				if (formItemContext == null ? void 0 : formItemContext.removeInputId) {
					inputId.value && formItemContext.removeInputId(inputId.value);
					if (!(disableIdManagement == null ? void 0 : disableIdManagement.value) && !disableIdGeneration2 && newId) formItemContext.addInputId(newId);
				}
				inputId.value = newId;
			}
		}, { immediate: true });
	});
	onUnmounted(() => {
		idUnwatch && idUnwatch();
		if (formItemContext == null ? void 0 : formItemContext.removeInputId) inputId.value && formItemContext.removeInputId(inputId.value);
	});
	return {
		isLabeledByFormItem,
		inputId
	};
};
var hiddenTextarea = void 0;
var HIDDEN_STYLE = `
  height:0 !important;
  visibility:hidden !important;
  ${isFirefox() ? "" : "overflow:hidden !important;"}
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important;
`;
var CONTEXT_STYLE = [
	"letter-spacing",
	"line-height",
	"padding-top",
	"padding-bottom",
	"font-family",
	"font-weight",
	"font-size",
	"text-rendering",
	"text-transform",
	"width",
	"text-indent",
	"padding-left",
	"padding-right",
	"border-width",
	"box-sizing"
];
function calculateNodeStyling(targetElement) {
	const style = window.getComputedStyle(targetElement);
	const boxSizing = style.getPropertyValue("box-sizing");
	const paddingSize = Number.parseFloat(style.getPropertyValue("padding-bottom")) + Number.parseFloat(style.getPropertyValue("padding-top"));
	const borderSize = Number.parseFloat(style.getPropertyValue("border-bottom-width")) + Number.parseFloat(style.getPropertyValue("border-top-width"));
	return {
		contextStyle: CONTEXT_STYLE.map((name$1) => `${name$1}:${style.getPropertyValue(name$1)}`).join(";"),
		paddingSize,
		borderSize,
		boxSizing
	};
}
function calcTextareaHeight(targetElement, minRows = 1, maxRows) {
	var _a;
	if (!hiddenTextarea) {
		hiddenTextarea = document.createElement("textarea");
		document.body.appendChild(hiddenTextarea);
	}
	const { paddingSize, borderSize, boxSizing, contextStyle } = calculateNodeStyling(targetElement);
	hiddenTextarea.setAttribute("style", `${contextStyle};${HIDDEN_STYLE}`);
	hiddenTextarea.value = targetElement.value || targetElement.placeholder || "";
	let height = hiddenTextarea.scrollHeight;
	const result = {};
	if (boxSizing === "border-box") height = height + borderSize;
	else if (boxSizing === "content-box") height = height - paddingSize;
	hiddenTextarea.value = "";
	const singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;
	if (isNumber(minRows)) {
		let minHeight = singleRowHeight * minRows;
		if (boxSizing === "border-box") minHeight = minHeight + paddingSize + borderSize;
		height = Math.max(minHeight, height);
		result.minHeight = `${minHeight}px`;
	}
	if (isNumber(maxRows)) {
		let maxHeight = singleRowHeight * maxRows;
		if (boxSizing === "border-box") maxHeight = maxHeight + paddingSize + borderSize;
		height = Math.min(maxHeight, height);
	}
	result.height = `${height}px`;
	(_a = hiddenTextarea.parentNode) == null || _a.removeChild(hiddenTextarea);
	hiddenTextarea = void 0;
	return result;
}
init_shared_esm_bundler();
var inputProps = buildProps({
	id: {
		type: String,
		default: void 0
	},
	size: useSizeProp,
	disabled: Boolean,
	modelValue: {
		type: definePropType([
			String,
			Number,
			Object
		]),
		default: ""
	},
	type: {
		type: String,
		default: "text"
	},
	resize: {
		type: String,
		values: [
			"none",
			"both",
			"horizontal",
			"vertical"
		]
	},
	autosize: {
		type: definePropType([Boolean, Object]),
		default: false
	},
	autocomplete: {
		type: String,
		default: "off"
	},
	formatter: { type: Function },
	parser: { type: Function },
	placeholder: { type: String },
	form: { type: String },
	readonly: {
		type: Boolean,
		default: false
	},
	clearable: {
		type: Boolean,
		default: false
	},
	showPassword: {
		type: Boolean,
		default: false
	},
	showWordLimit: {
		type: Boolean,
		default: false
	},
	suffixIcon: { type: iconPropType },
	prefixIcon: { type: iconPropType },
	containerRole: {
		type: String,
		default: void 0
	},
	label: {
		type: String,
		default: void 0
	},
	tabindex: {
		type: [String, Number],
		default: 0
	},
	validateEvent: {
		type: Boolean,
		default: true
	},
	inputStyle: {
		type: definePropType([
			Object,
			Array,
			String
		]),
		default: () => mutable({})
	},
	autofocus: {
		type: Boolean,
		default: false
	}
});
var inputEmits = {
	[UPDATE_MODEL_EVENT]: (value) => isString$2(value),
	input: (value) => isString$2(value),
	change: (value) => isString$2(value),
	focus: (evt) => evt instanceof FocusEvent,
	blur: (evt) => evt instanceof FocusEvent,
	clear: () => true,
	mouseleave: (evt) => evt instanceof MouseEvent,
	mouseenter: (evt) => evt instanceof MouseEvent,
	keydown: (evt) => evt instanceof Event,
	compositionstart: (evt) => evt instanceof CompositionEvent,
	compositionupdate: (evt) => evt instanceof CompositionEvent,
	compositionend: (evt) => evt instanceof CompositionEvent
};
init_shared_esm_bundler();
var _hoisted_1$61 = ["role"];
var _hoisted_2$38 = [
	"id",
	"type",
	"disabled",
	"formatter",
	"parser",
	"readonly",
	"autocomplete",
	"tabindex",
	"aria-label",
	"placeholder",
	"form",
	"autofocus"
];
var _hoisted_3$13 = [
	"id",
	"tabindex",
	"disabled",
	"readonly",
	"autocomplete",
	"aria-label",
	"placeholder",
	"form",
	"autofocus"
];
var ElInput = withInstall(/* @__PURE__ */ _export_sfc(/* @__PURE__ */ defineComponent({
	...defineComponent({
		name: "ElInput",
		inheritAttrs: false
	}),
	props: inputProps,
	emits: inputEmits,
	setup(__props, { expose, emit }) {
		const props = __props;
		const rawAttrs = useAttrs();
		const slots = useSlots();
		const containerAttrs = computed(() => {
			const comboBoxAttrs = {};
			if (props.containerRole === "combobox") {
				comboBoxAttrs["aria-haspopup"] = rawAttrs["aria-haspopup"];
				comboBoxAttrs["aria-owns"] = rawAttrs["aria-owns"];
				comboBoxAttrs["aria-expanded"] = rawAttrs["aria-expanded"];
			}
			return comboBoxAttrs;
		});
		const containerKls = computed(() => [
			props.type === "textarea" ? nsTextarea.b() : nsInput.b(),
			nsInput.m(inputSize.value),
			nsInput.is("disabled", inputDisabled.value),
			nsInput.is("exceed", inputExceed.value),
			{
				[nsInput.b("group")]: slots.prepend || slots.append,
				[nsInput.bm("group", "append")]: slots.append,
				[nsInput.bm("group", "prepend")]: slots.prepend,
				[nsInput.m("prefix")]: slots.prefix || props.prefixIcon,
				[nsInput.m("suffix")]: slots.suffix || props.suffixIcon || props.clearable || props.showPassword,
				[nsInput.bm("suffix", "password-clear")]: showClear.value && showPwdVisible.value
			},
			rawAttrs.class
		]);
		const wrapperKls = computed(() => [nsInput.e("wrapper"), nsInput.is("focus", isFocused.value)]);
		const attrs = useAttrs$1({ excludeKeys: computed(() => {
			return Object.keys(containerAttrs.value);
		}) });
		const { form, formItem } = useFormItem();
		const { inputId } = useFormItemInputId(props, { formItemContext: formItem });
		const inputSize = useFormSize();
		const inputDisabled = useFormDisabled();
		const nsInput = useNamespace("input");
		const nsTextarea = useNamespace("textarea");
		const input$4 = shallowRef();
		const textarea$1 = shallowRef();
		const hovering = ref(false);
		const isComposing = ref(false);
		const passwordVisible = ref(false);
		const countStyle = ref();
		const textareaCalcStyle = shallowRef(props.inputStyle);
		const _ref = computed(() => input$4.value || textarea$1.value);
		const { wrapperRef, isFocused, handleFocus, handleBlur } = useFocusController(_ref, { afterBlur() {
			var _a;
			if (props.validateEvent) (_a = formItem == null ? void 0 : formItem.validate) == null || _a.call(formItem, "blur").catch((err) => debugWarn(err));
		} });
		const needStatusIcon = computed(() => {
			var _a;
			return (_a = form == null ? void 0 : form.statusIcon) != null ? _a : false;
		});
		const validateState = computed(() => (formItem == null ? void 0 : formItem.validateState) || "");
		const validateIcon = computed(() => validateState.value && ValidateComponentsMap[validateState.value]);
		const passwordIcon = computed(() => passwordVisible.value ? view_default : hide_default);
		const containerStyle = computed(() => [rawAttrs.style, props.inputStyle]);
		const textareaStyle = computed(() => [
			props.inputStyle,
			textareaCalcStyle.value,
			{ resize: props.resize }
		]);
		const nativeInputValue = computed(() => isNil_default(props.modelValue) ? "" : String(props.modelValue));
		const showClear = computed(() => props.clearable && !inputDisabled.value && !props.readonly && !!nativeInputValue.value && (isFocused.value || hovering.value));
		const showPwdVisible = computed(() => props.showPassword && !inputDisabled.value && !props.readonly && !!nativeInputValue.value && (!!nativeInputValue.value || isFocused.value));
		const isWordLimitVisible = computed(() => props.showWordLimit && !!attrs.value.maxlength && (props.type === "text" || props.type === "textarea") && !inputDisabled.value && !props.readonly && !props.showPassword);
		const textLength = computed(() => nativeInputValue.value.length);
		const inputExceed = computed(() => !!isWordLimitVisible.value && textLength.value > Number(attrs.value.maxlength));
		const suffixVisible = computed(() => !!slots.suffix || !!props.suffixIcon || showClear.value || props.showPassword || isWordLimitVisible.value || !!validateState.value && needStatusIcon.value);
		const [recordCursor, setCursor] = useCursor(input$4);
		useResizeObserver$2(textarea$1, (entries) => {
			onceInitSizeTextarea();
			if (!isWordLimitVisible.value || props.resize !== "both") return;
			const { width } = entries[0].contentRect;
			countStyle.value = { right: `calc(100% - ${width + 15 + 6}px)` };
		});
		const resizeTextarea = () => {
			const { type, autosize } = props;
			if (!isClient$1 || type !== "textarea" || !textarea$1.value) return;
			if (autosize) {
				const minRows = isObject$2(autosize) ? autosize.minRows : void 0;
				const maxRows = isObject$2(autosize) ? autosize.maxRows : void 0;
				const textareaStyle2 = calcTextareaHeight(textarea$1.value, minRows, maxRows);
				textareaCalcStyle.value = {
					overflowY: "hidden",
					...textareaStyle2
				};
				nextTick(() => {
					textarea$1.value.offsetHeight;
					textareaCalcStyle.value = textareaStyle2;
				});
			} else textareaCalcStyle.value = { minHeight: calcTextareaHeight(textarea$1.value).minHeight };
		};
		const createOnceInitResize = (resizeTextarea2) => {
			let isInit = false;
			return () => {
				var _a;
				if (isInit || !props.autosize) return;
				if (!(((_a = textarea$1.value) == null ? void 0 : _a.offsetParent) === null)) {
					resizeTextarea2();
					isInit = true;
				}
			};
		};
		const onceInitSizeTextarea = createOnceInitResize(resizeTextarea);
		const setNativeInputValue = () => {
			const input2 = _ref.value;
			const formatterValue = props.formatter ? props.formatter(nativeInputValue.value) : nativeInputValue.value;
			if (!input2 || input2.value === formatterValue) return;
			input2.value = formatterValue;
		};
		const handleInput = async (event) => {
			recordCursor();
			let { value } = event.target;
			if (props.formatter) value = props.parser ? props.parser(value) : value;
			if (isComposing.value) return;
			if (value === nativeInputValue.value) {
				setNativeInputValue();
				return;
			}
			emit(UPDATE_MODEL_EVENT, value);
			emit("input", value);
			await nextTick();
			setNativeInputValue();
			setCursor();
		};
		const handleChange = (event) => {
			emit("change", event.target.value);
		};
		const handleCompositionStart = (event) => {
			emit("compositionstart", event);
			isComposing.value = true;
		};
		const handleCompositionUpdate = (event) => {
			var _a;
			emit("compositionupdate", event);
			const text$7 = (_a = event.target) == null ? void 0 : _a.value;
			isComposing.value = !isKorean(text$7[text$7.length - 1] || "");
		};
		const handleCompositionEnd = (event) => {
			emit("compositionend", event);
			if (isComposing.value) {
				isComposing.value = false;
				handleInput(event);
			}
		};
		const handlePasswordVisible = () => {
			passwordVisible.value = !passwordVisible.value;
			focus$1();
		};
		const focus$1 = async () => {
			var _a;
			await nextTick();
			(_a = _ref.value) == null || _a.focus();
		};
		const blur = () => {
			var _a;
			return (_a = _ref.value) == null ? void 0 : _a.blur();
		};
		const handleMouseLeave = (evt) => {
			hovering.value = false;
			emit("mouseleave", evt);
		};
		const handleMouseEnter = (evt) => {
			hovering.value = true;
			emit("mouseenter", evt);
		};
		const handleKeydown = (evt) => {
			emit("keydown", evt);
		};
		const select = () => {
			var _a;
			(_a = _ref.value) == null || _a.select();
		};
		const clear = () => {
			emit(UPDATE_MODEL_EVENT, "");
			emit("change", "");
			emit("clear");
			emit("input", "");
		};
		watch(() => props.modelValue, () => {
			var _a;
			nextTick(() => resizeTextarea());
			if (props.validateEvent) (_a = formItem == null ? void 0 : formItem.validate) == null || _a.call(formItem, "change").catch((err) => debugWarn(err));
		});
		watch(nativeInputValue, () => setNativeInputValue());
		watch(() => props.type, async () => {
			await nextTick();
			setNativeInputValue();
			resizeTextarea();
		});
		onMounted(() => {
			if (!props.formatter && props.parser) debugWarn("ElInput", "If you set the parser, you also need to set the formatter.");
			setNativeInputValue();
			nextTick(resizeTextarea);
		});
		expose({
			input: input$4,
			textarea: textarea$1,
			ref: _ref,
			textareaStyle,
			autosize: toRef(props, "autosize"),
			focus: focus$1,
			blur,
			select,
			clear,
			resizeTextarea
		});
		return (_ctx, _cache) => {
			return withDirectives((openBlock(), createElementBlock("div", mergeProps(unref(containerAttrs), {
				class: unref(containerKls),
				style: unref(containerStyle),
				role: _ctx.containerRole,
				onMouseenter: handleMouseEnter,
				onMouseleave: handleMouseLeave
			}), [createCommentVNode(" input "), _ctx.type !== "textarea" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
				createCommentVNode(" prepend slot "),
				_ctx.$slots.prepend ? (openBlock(), createElementBlock("div", {
					key: 0,
					class: normalizeClass(unref(nsInput).be("group", "prepend"))
				}, [renderSlot(_ctx.$slots, "prepend")], 2)) : createCommentVNode("v-if", true),
				createBaseVNode("div", {
					ref_key: "wrapperRef",
					ref: wrapperRef,
					class: normalizeClass(unref(wrapperKls))
				}, [
					createCommentVNode(" prefix slot "),
					_ctx.$slots.prefix || _ctx.prefixIcon ? (openBlock(), createElementBlock("span", {
						key: 0,
						class: normalizeClass(unref(nsInput).e("prefix"))
					}, [createBaseVNode("span", { class: normalizeClass(unref(nsInput).e("prefix-inner")) }, [renderSlot(_ctx.$slots, "prefix"), _ctx.prefixIcon ? (openBlock(), createBlock(unref(ElIcon), {
						key: 0,
						class: normalizeClass(unref(nsInput).e("icon"))
					}, {
						default: withCtx(() => [(openBlock(), createBlock(resolveDynamicComponent(_ctx.prefixIcon)))]),
						_: 1
					}, 8, ["class"])) : createCommentVNode("v-if", true)], 2)], 2)) : createCommentVNode("v-if", true),
					createBaseVNode("input", mergeProps({
						id: unref(inputId),
						ref_key: "input",
						ref: input$4,
						class: unref(nsInput).e("inner")
					}, unref(attrs), {
						type: _ctx.showPassword ? passwordVisible.value ? "text" : "password" : _ctx.type,
						disabled: unref(inputDisabled),
						formatter: _ctx.formatter,
						parser: _ctx.parser,
						readonly: _ctx.readonly,
						autocomplete: _ctx.autocomplete,
						tabindex: _ctx.tabindex,
						"aria-label": _ctx.label,
						placeholder: _ctx.placeholder,
						style: _ctx.inputStyle,
						form: props.form,
						autofocus: props.autofocus,
						onCompositionstart: handleCompositionStart,
						onCompositionupdate: handleCompositionUpdate,
						onCompositionend: handleCompositionEnd,
						onInput: handleInput,
						onFocus: _cache[0] || (_cache[0] = (...args) => unref(handleFocus) && unref(handleFocus)(...args)),
						onBlur: _cache[1] || (_cache[1] = (...args) => unref(handleBlur) && unref(handleBlur)(...args)),
						onChange: handleChange,
						onKeydown: handleKeydown
					}), null, 16, _hoisted_2$38),
					createCommentVNode(" suffix slot "),
					unref(suffixVisible) ? (openBlock(), createElementBlock("span", {
						key: 1,
						class: normalizeClass(unref(nsInput).e("suffix"))
					}, [createBaseVNode("span", { class: normalizeClass(unref(nsInput).e("suffix-inner")) }, [
						!unref(showClear) || !unref(showPwdVisible) || !unref(isWordLimitVisible) ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [renderSlot(_ctx.$slots, "suffix"), _ctx.suffixIcon ? (openBlock(), createBlock(unref(ElIcon), {
							key: 0,
							class: normalizeClass(unref(nsInput).e("icon"))
						}, {
							default: withCtx(() => [(openBlock(), createBlock(resolveDynamicComponent(_ctx.suffixIcon)))]),
							_: 1
						}, 8, ["class"])) : createCommentVNode("v-if", true)], 64)) : createCommentVNode("v-if", true),
						unref(showClear) ? (openBlock(), createBlock(unref(ElIcon), {
							key: 1,
							class: normalizeClass([unref(nsInput).e("icon"), unref(nsInput).e("clear")]),
							onMousedown: withModifiers(unref(NOOP), ["prevent"]),
							onClick: clear
						}, {
							default: withCtx(() => [createVNode(unref(circle_close_default))]),
							_: 1
						}, 8, ["class", "onMousedown"])) : createCommentVNode("v-if", true),
						unref(showPwdVisible) ? (openBlock(), createBlock(unref(ElIcon), {
							key: 2,
							class: normalizeClass([unref(nsInput).e("icon"), unref(nsInput).e("password")]),
							onClick: handlePasswordVisible
						}, {
							default: withCtx(() => [(openBlock(), createBlock(resolveDynamicComponent(unref(passwordIcon))))]),
							_: 1
						}, 8, ["class"])) : createCommentVNode("v-if", true),
						unref(isWordLimitVisible) ? (openBlock(), createElementBlock("span", {
							key: 3,
							class: normalizeClass(unref(nsInput).e("count"))
						}, [createBaseVNode("span", { class: normalizeClass(unref(nsInput).e("count-inner")) }, toDisplayString(unref(textLength)) + " / " + toDisplayString(unref(attrs).maxlength), 3)], 2)) : createCommentVNode("v-if", true),
						unref(validateState) && unref(validateIcon) && unref(needStatusIcon) ? (openBlock(), createBlock(unref(ElIcon), {
							key: 4,
							class: normalizeClass([
								unref(nsInput).e("icon"),
								unref(nsInput).e("validateIcon"),
								unref(nsInput).is("loading", unref(validateState) === "validating")
							])
						}, {
							default: withCtx(() => [(openBlock(), createBlock(resolveDynamicComponent(unref(validateIcon))))]),
							_: 1
						}, 8, ["class"])) : createCommentVNode("v-if", true)
					], 2)], 2)) : createCommentVNode("v-if", true)
				], 2),
				createCommentVNode(" append slot "),
				_ctx.$slots.append ? (openBlock(), createElementBlock("div", {
					key: 1,
					class: normalizeClass(unref(nsInput).be("group", "append"))
				}, [renderSlot(_ctx.$slots, "append")], 2)) : createCommentVNode("v-if", true)
			], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
				createCommentVNode(" textarea "),
				createBaseVNode("textarea", mergeProps({
					id: unref(inputId),
					ref_key: "textarea",
					ref: textarea$1,
					class: unref(nsTextarea).e("inner")
				}, unref(attrs), {
					tabindex: _ctx.tabindex,
					disabled: unref(inputDisabled),
					readonly: _ctx.readonly,
					autocomplete: _ctx.autocomplete,
					style: unref(textareaStyle),
					"aria-label": _ctx.label,
					placeholder: _ctx.placeholder,
					form: props.form,
					autofocus: props.autofocus,
					onCompositionstart: handleCompositionStart,
					onCompositionupdate: handleCompositionUpdate,
					onCompositionend: handleCompositionEnd,
					onInput: handleInput,
					onFocus: _cache[2] || (_cache[2] = (...args) => unref(handleFocus) && unref(handleFocus)(...args)),
					onBlur: _cache[3] || (_cache[3] = (...args) => unref(handleBlur) && unref(handleBlur)(...args)),
					onChange: handleChange,
					onKeydown: handleKeydown
				}), null, 16, _hoisted_3$13),
				unref(isWordLimitVisible) ? (openBlock(), createElementBlock("span", {
					key: 0,
					style: normalizeStyle(countStyle.value),
					class: normalizeClass(unref(nsInput).e("count"))
				}, toDisplayString(unref(textLength)) + " / " + toDisplayString(unref(attrs).maxlength), 7)) : createCommentVNode("v-if", true)
			], 64))], 16, _hoisted_1$61)), [[vShow, _ctx.type !== "hidden"]]);
		};
	}
}), [["__file", "/home/runner/work/element-plus/element-plus/packages/components/input/src/input.vue"]]));
var BAR_MAP = {
	vertical: {
		offset: "offsetHeight",
		scroll: "scrollTop",
		scrollSize: "scrollHeight",
		size: "height",
		key: "vertical",
		axis: "Y",
		client: "clientY",
		direction: "top"
	},
	horizontal: {
		offset: "offsetWidth",
		scroll: "scrollLeft",
		scrollSize: "scrollWidth",
		size: "width",
		key: "horizontal",
		axis: "X",
		client: "clientX",
		direction: "left"
	}
};
var renderThumbStyle = ({ move, size: size$2, bar }) => ({
	[bar.size]: size$2,
	transform: `translate${bar.axis}(${move}%)`
});
var scrollbarContextKey = Symbol("scrollbarContextKey");
var thumbProps = buildProps({
	vertical: Boolean,
	size: String,
	move: Number,
	ratio: {
		type: Number,
		required: true
	},
	always: Boolean
});
var COMPONENT_NAME$5 = "Thumb";
var Thumb = /* @__PURE__ */ _export_sfc(/* @__PURE__ */ defineComponent({
	__name: "thumb",
	props: thumbProps,
	setup(__props) {
		const props = __props;
		const scrollbar$1 = inject(scrollbarContextKey);
		const ns = useNamespace("scrollbar");
		if (!scrollbar$1) throwError(COMPONENT_NAME$5, "can not inject scrollbar context");
		const instance = ref();
		const thumb$1 = ref();
		const thumbState = ref({});
		const visible$1 = ref(false);
		let cursorDown = false;
		let cursorLeave = false;
		let originalOnSelectStart = isClient$1 ? document.onselectstart : null;
		const bar = computed(() => BAR_MAP[props.vertical ? "vertical" : "horizontal"]);
		const thumbStyle = computed(() => renderThumbStyle({
			size: props.size,
			move: props.move,
			bar: bar.value
		}));
		const offsetRatio = computed(() => instance.value[bar.value.offset] ** 2 / scrollbar$1.wrapElement[bar.value.scrollSize] / props.ratio / thumb$1.value[bar.value.offset]);
		const clickThumbHandler = (e) => {
			var _a;
			e.stopPropagation();
			if (e.ctrlKey || [1, 2].includes(e.button)) return;
			(_a = window.getSelection()) == null || _a.removeAllRanges();
			startDrag(e);
			const el$2 = e.currentTarget;
			if (!el$2) return;
			thumbState.value[bar.value.axis] = el$2[bar.value.offset] - (e[bar.value.client] - el$2.getBoundingClientRect()[bar.value.direction]);
		};
		const clickTrackHandler = (e) => {
			if (!thumb$1.value || !instance.value || !scrollbar$1.wrapElement) return;
			const thumbPositionPercentage = (Math.abs(e.target.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]) - thumb$1.value[bar.value.offset] / 2) * 100 * offsetRatio.value / instance.value[bar.value.offset];
			scrollbar$1.wrapElement[bar.value.scroll] = thumbPositionPercentage * scrollbar$1.wrapElement[bar.value.scrollSize] / 100;
		};
		const startDrag = (e) => {
			e.stopImmediatePropagation();
			cursorDown = true;
			document.addEventListener("mousemove", mouseMoveDocumentHandler);
			document.addEventListener("mouseup", mouseUpDocumentHandler);
			originalOnSelectStart = document.onselectstart;
			document.onselectstart = () => false;
		};
		const mouseMoveDocumentHandler = (e) => {
			if (!instance.value || !thumb$1.value) return;
			if (cursorDown === false) return;
			const prevPage = thumbState.value[bar.value.axis];
			if (!prevPage) return;
			const thumbPositionPercentage = ((instance.value.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]) * -1 - (thumb$1.value[bar.value.offset] - prevPage)) * 100 * offsetRatio.value / instance.value[bar.value.offset];
			scrollbar$1.wrapElement[bar.value.scroll] = thumbPositionPercentage * scrollbar$1.wrapElement[bar.value.scrollSize] / 100;
		};
		const mouseUpDocumentHandler = () => {
			cursorDown = false;
			thumbState.value[bar.value.axis] = 0;
			document.removeEventListener("mousemove", mouseMoveDocumentHandler);
			document.removeEventListener("mouseup", mouseUpDocumentHandler);
			restoreOnselectstart();
			if (cursorLeave) visible$1.value = false;
		};
		const mouseMoveScrollbarHandler = () => {
			cursorLeave = false;
			visible$1.value = !!props.size;
		};
		const mouseLeaveScrollbarHandler = () => {
			cursorLeave = true;
			visible$1.value = cursorDown;
		};
		onBeforeUnmount(() => {
			restoreOnselectstart();
			document.removeEventListener("mouseup", mouseUpDocumentHandler);
		});
		const restoreOnselectstart = () => {
			if (document.onselectstart !== originalOnSelectStart) document.onselectstart = originalOnSelectStart;
		};
		useEventListener$1(toRef(scrollbar$1, "scrollbarElement"), "mousemove", mouseMoveScrollbarHandler);
		useEventListener$1(toRef(scrollbar$1, "scrollbarElement"), "mouseleave", mouseLeaveScrollbarHandler);
		return (_ctx, _cache) => {
			return openBlock(), createBlock(Transition, {
				name: unref(ns).b("fade"),
				persisted: ""
			}, {
				default: withCtx(() => [withDirectives(createBaseVNode("div", {
					ref_key: "instance",
					ref: instance,
					class: normalizeClass([unref(ns).e("bar"), unref(ns).is(unref(bar).key)]),
					onMousedown: clickTrackHandler
				}, [createBaseVNode("div", {
					ref_key: "thumb",
					ref: thumb$1,
					class: normalizeClass(unref(ns).e("thumb")),
					style: normalizeStyle(unref(thumbStyle)),
					onMousedown: clickThumbHandler
				}, null, 38)], 34), [[vShow, _ctx.always || visible$1.value]])]),
				_: 1
			}, 8, ["name"]);
		};
	}
}), [["__file", "/home/runner/work/element-plus/element-plus/packages/components/scrollbar/src/thumb.vue"]]);
var Bar = /* @__PURE__ */ _export_sfc(/* @__PURE__ */ defineComponent({
	__name: "bar",
	props: buildProps({
		always: {
			type: Boolean,
			default: true
		},
		width: String,
		height: String,
		ratioX: {
			type: Number,
			default: 1
		},
		ratioY: {
			type: Number,
			default: 1
		}
	}),
	setup(__props, { expose }) {
		const props = __props;
		const moveX = ref(0);
		const moveY = ref(0);
		const handleScroll = (wrap) => {
			if (wrap) {
				const offsetHeight = wrap.offsetHeight - 4;
				const offsetWidth = wrap.offsetWidth - 4;
				moveY.value = wrap.scrollTop * 100 / offsetHeight * props.ratioY;
				moveX.value = wrap.scrollLeft * 100 / offsetWidth * props.ratioX;
			}
		};
		expose({ handleScroll });
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock(Fragment, null, [createVNode(Thumb, {
				move: moveX.value,
				ratio: _ctx.ratioX,
				size: _ctx.width,
				always: _ctx.always
			}, null, 8, [
				"move",
				"ratio",
				"size",
				"always"
			]), createVNode(Thumb, {
				move: moveY.value,
				ratio: _ctx.ratioY,
				size: _ctx.height,
				vertical: "",
				always: _ctx.always
			}, null, 8, [
				"move",
				"ratio",
				"size",
				"always"
			])], 64);
		};
	}
}), [["__file", "/home/runner/work/element-plus/element-plus/packages/components/scrollbar/src/bar.vue"]]);
var scrollbarProps = buildProps({
	height: {
		type: [String, Number],
		default: ""
	},
	maxHeight: {
		type: [String, Number],
		default: ""
	},
	native: {
		type: Boolean,
		default: false
	},
	wrapStyle: {
		type: definePropType([
			String,
			Object,
			Array
		]),
		default: ""
	},
	wrapClass: {
		type: [String, Array],
		default: ""
	},
	viewClass: {
		type: [String, Array],
		default: ""
	},
	viewStyle: {
		type: [
			String,
			Array,
			Object
		],
		default: ""
	},
	noresize: Boolean,
	tag: {
		type: String,
		default: "div"
	},
	always: Boolean,
	minSize: {
		type: Number,
		default: 20
	},
	id: String,
	role: String,
	ariaLabel: String,
	ariaOrientation: {
		type: String,
		values: ["horizontal", "vertical"]
	}
});
var scrollbarEmits = { scroll: ({ scrollTop, scrollLeft }) => [scrollTop, scrollLeft].every(isNumber) };
init_shared_esm_bundler();
var COMPONENT_NAME$4 = "ElScrollbar";
var ElScrollbar = withInstall(/* @__PURE__ */ _export_sfc(/* @__PURE__ */ defineComponent({
	...defineComponent({ name: COMPONENT_NAME$4 }),
	props: scrollbarProps,
	emits: scrollbarEmits,
	setup(__props, { expose, emit }) {
		const props = __props;
		const ns = useNamespace("scrollbar");
		let stopResizeObserver = void 0;
		let stopResizeListener = void 0;
		const scrollbarRef = ref();
		const wrapRef = ref();
		const resizeRef = ref();
		const sizeWidth = ref("0");
		const sizeHeight = ref("0");
		const barRef = ref();
		const ratioY = ref(1);
		const ratioX = ref(1);
		const wrapStyle = computed(() => {
			const style = {};
			if (props.height) style.height = addUnit(props.height);
			if (props.maxHeight) style.maxHeight = addUnit(props.maxHeight);
			return [props.wrapStyle, style];
		});
		const wrapKls = computed(() => {
			return [
				props.wrapClass,
				ns.e("wrap"),
				{ [ns.em("wrap", "hidden-default")]: !props.native }
			];
		});
		const resizeKls = computed(() => {
			return [ns.e("view"), props.viewClass];
		});
		const handleScroll = () => {
			var _a;
			if (wrapRef.value) {
				(_a = barRef.value) == null || _a.handleScroll(wrapRef.value);
				emit("scroll", {
					scrollTop: wrapRef.value.scrollTop,
					scrollLeft: wrapRef.value.scrollLeft
				});
			}
		};
		function scrollTo(arg1, arg2) {
			if (isObject$2(arg1)) wrapRef.value.scrollTo(arg1);
			else if (isNumber(arg1) && isNumber(arg2)) wrapRef.value.scrollTo(arg1, arg2);
		}
		const setScrollTop = (value) => {
			if (!isNumber(value)) {
				debugWarn(COMPONENT_NAME$4, "value must be a number");
				return;
			}
			wrapRef.value.scrollTop = value;
		};
		const setScrollLeft = (value) => {
			if (!isNumber(value)) {
				debugWarn(COMPONENT_NAME$4, "value must be a number");
				return;
			}
			wrapRef.value.scrollLeft = value;
		};
		const update = () => {
			if (!wrapRef.value) return;
			const offsetHeight = wrapRef.value.offsetHeight - 4;
			const offsetWidth = wrapRef.value.offsetWidth - 4;
			const originalHeight = offsetHeight ** 2 / wrapRef.value.scrollHeight;
			const originalWidth = offsetWidth ** 2 / wrapRef.value.scrollWidth;
			const height = Math.max(originalHeight, props.minSize);
			const width = Math.max(originalWidth, props.minSize);
			ratioY.value = originalHeight / (offsetHeight - originalHeight) / (height / (offsetHeight - height));
			ratioX.value = originalWidth / (offsetWidth - originalWidth) / (width / (offsetWidth - width));
			sizeHeight.value = height + 4 < offsetHeight ? `${height}px` : "";
			sizeWidth.value = width + 4 < offsetWidth ? `${width}px` : "";
		};
		watch(() => props.noresize, (noresize) => {
			if (noresize) {
				stopResizeObserver?.();
				stopResizeListener?.();
			} else {
				({stop: stopResizeObserver} = useResizeObserver$2(resizeRef, update));
				stopResizeListener = useEventListener$1("resize", update);
			}
		}, { immediate: true });
		watch(() => [props.maxHeight, props.height], () => {
			if (!props.native) nextTick(() => {
				var _a;
				update();
				if (wrapRef.value) (_a = barRef.value) == null || _a.handleScroll(wrapRef.value);
			});
		});
		provide(scrollbarContextKey, reactive({
			scrollbarElement: scrollbarRef,
			wrapElement: wrapRef
		}));
		onMounted(() => {
			if (!props.native) nextTick(() => {
				update();
			});
		});
		onUpdated(() => update());
		expose({
			wrapRef,
			update,
			scrollTo,
			setScrollTop,
			setScrollLeft,
			handleScroll
		});
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", {
				ref_key: "scrollbarRef",
				ref: scrollbarRef,
				class: normalizeClass(unref(ns).b())
			}, [createBaseVNode("div", {
				ref_key: "wrapRef",
				ref: wrapRef,
				class: normalizeClass(unref(wrapKls)),
				style: normalizeStyle(unref(wrapStyle)),
				onScroll: handleScroll
			}, [(openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), {
				id: _ctx.id,
				ref_key: "resizeRef",
				ref: resizeRef,
				class: normalizeClass(unref(resizeKls)),
				style: normalizeStyle(_ctx.viewStyle),
				role: _ctx.role,
				"aria-label": _ctx.ariaLabel,
				"aria-orientation": _ctx.ariaOrientation
			}, {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 8, [
				"id",
				"class",
				"style",
				"role",
				"aria-label",
				"aria-orientation"
			]))], 38), !_ctx.native ? (openBlock(), createBlock(Bar, {
				key: 0,
				ref_key: "barRef",
				ref: barRef,
				height: sizeHeight.value,
				width: sizeWidth.value,
				always: _ctx.always,
				"ratio-x": ratioX.value,
				"ratio-y": ratioY.value
			}, null, 8, [
				"height",
				"width",
				"always",
				"ratio-x",
				"ratio-y"
			])) : createCommentVNode("v-if", true)], 2);
		};
	}
}), [["__file", "/home/runner/work/element-plus/element-plus/packages/components/scrollbar/src/scrollbar.vue"]]));
var POPPER_INJECTION_KEY = Symbol("popper");
var POPPER_CONTENT_INJECTION_KEY = Symbol("popperContent");
var popperProps = buildProps({ role: {
	type: String,
	values: [
		"dialog",
		"grid",
		"group",
		"listbox",
		"menu",
		"navigation",
		"tooltip",
		"tree"
	],
	default: "tooltip"
} });
var Popper = /* @__PURE__ */ _export_sfc(/* @__PURE__ */ defineComponent({
	...defineComponent({
		name: "ElPopper",
		inheritAttrs: false
	}),
	props: popperProps,
	setup(__props, { expose }) {
		const props = __props;
		const popperProvides = {
			triggerRef: ref(),
			popperInstanceRef: ref(),
			contentRef: ref(),
			referenceRef: ref(),
			role: computed(() => props.role)
		};
		expose(popperProvides);
		provide(POPPER_INJECTION_KEY, popperProvides);
		return (_ctx, _cache) => {
			return renderSlot(_ctx.$slots, "default");
		};
	}
}), [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/popper.vue"]]);
var popperArrowProps = buildProps({ arrowOffset: {
	type: Number,
	default: 5
} });
var ElPopperArrow = /* @__PURE__ */ _export_sfc(/* @__PURE__ */ defineComponent({
	...defineComponent({
		name: "ElPopperArrow",
		inheritAttrs: false
	}),
	props: popperArrowProps,
	setup(__props, { expose }) {
		const props = __props;
		const ns = useNamespace("popper");
		const { arrowOffset, arrowRef, arrowStyle } = inject(POPPER_CONTENT_INJECTION_KEY, void 0);
		watch(() => props.arrowOffset, (val) => {
			arrowOffset.value = val;
		});
		onBeforeUnmount(() => {
			arrowRef.value = void 0;
		});
		expose({ arrowRef });
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("span", {
				ref_key: "arrowRef",
				ref: arrowRef,
				class: normalizeClass(unref(ns).e("arrow")),
				style: normalizeStyle(unref(arrowStyle)),
				"data-popper-arrow": ""
			}, null, 6);
		};
	}
}), [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/arrow.vue"]]);
init_shared_esm_bundler();
var NAME = "ElOnlyChild";
var OnlyChild = defineComponent({
	name: NAME,
	setup(_, { slots, attrs }) {
		var _a;
		const forwardRefInjection = inject(FORWARD_REF_INJECTION_KEY);
		const forwardRefDirective = useForwardRefDirective((_a = forwardRefInjection == null ? void 0 : forwardRefInjection.setForwardRef) != null ? _a : NOOP);
		return () => {
			var _a2;
			const defaultSlot = (_a2 = slots.default) == null ? void 0 : _a2.call(slots, attrs);
			if (!defaultSlot) return null;
			if (defaultSlot.length > 1) {
				debugWarn(NAME, "requires exact only one valid child.");
				return null;
			}
			const firstLegitNode = findFirstLegitChild(defaultSlot);
			if (!firstLegitNode) {
				debugWarn(NAME, "no valid child node found");
				return null;
			}
			return withDirectives(cloneVNode(firstLegitNode, attrs), [[forwardRefDirective]]);
		};
	}
});
function findFirstLegitChild(node) {
	if (!node) return null;
	const children = node;
	for (const child$1 of children) {
		if (isObject$2(child$1)) switch (child$1.type) {
			case Comment: continue;
			case Text:
			case "svg": return wrapTextContent(child$1);
			case Fragment: return findFirstLegitChild(child$1.children);
			default: return child$1;
		}
		return wrapTextContent(child$1);
	}
	return null;
}
function wrapTextContent(s) {
	const ns = useNamespace("only-child");
	return createVNode("span", { "class": ns.e("content") }, [s]);
}
var popperTriggerProps = buildProps({
	virtualRef: { type: definePropType(Object) },
	virtualTriggering: Boolean,
	onMouseenter: { type: definePropType(Function) },
	onMouseleave: { type: definePropType(Function) },
	onClick: { type: definePropType(Function) },
	onKeydown: { type: definePropType(Function) },
	onFocus: { type: definePropType(Function) },
	onBlur: { type: definePropType(Function) },
	onContextmenu: { type: definePropType(Function) },
	id: String,
	open: Boolean
});
var ElPopperTrigger = /* @__PURE__ */ _export_sfc(/* @__PURE__ */ defineComponent({
	...defineComponent({
		name: "ElPopperTrigger",
		inheritAttrs: false
	}),
	props: popperTriggerProps,
	setup(__props, { expose }) {
		const props = __props;
		const { role, triggerRef: triggerRef$1 } = inject(POPPER_INJECTION_KEY, void 0);
		useForwardRef(triggerRef$1);
		const ariaControls = computed(() => {
			return ariaHaspopup.value ? props.id : void 0;
		});
		const ariaDescribedby = computed(() => {
			if (role && role.value === "tooltip") return props.open && props.id ? props.id : void 0;
		});
		const ariaHaspopup = computed(() => {
			if (role && role.value !== "tooltip") return role.value;
		});
		const ariaExpanded = computed(() => {
			return ariaHaspopup.value ? `${props.open}` : void 0;
		});
		let virtualTriggerAriaStopWatch = void 0;
		onMounted(() => {
			watch(() => props.virtualRef, (virtualEl) => {
				if (virtualEl) triggerRef$1.value = unrefElement$1(virtualEl);
			}, { immediate: true });
			watch(triggerRef$1, (el$2, prevEl) => {
				virtualTriggerAriaStopWatch?.();
				virtualTriggerAriaStopWatch = void 0;
				if (isElement(el$2)) {
					[
						"onMouseenter",
						"onMouseleave",
						"onClick",
						"onKeydown",
						"onFocus",
						"onBlur",
						"onContextmenu"
					].forEach((eventName) => {
						var _a;
						const handler = props[eventName];
						if (handler) {
							el$2.addEventListener(eventName.slice(2).toLowerCase(), handler);
							(_a = prevEl == null ? void 0 : prevEl.removeEventListener) == null || _a.call(prevEl, eventName.slice(2).toLowerCase(), handler);
						}
					});
					virtualTriggerAriaStopWatch = watch([
						ariaControls,
						ariaDescribedby,
						ariaHaspopup,
						ariaExpanded
					], (watches) => {
						[
							"aria-controls",
							"aria-describedby",
							"aria-haspopup",
							"aria-expanded"
						].forEach((key$2, idx) => {
							isNil_default(watches[idx]) ? el$2.removeAttribute(key$2) : el$2.setAttribute(key$2, watches[idx]);
						});
					}, { immediate: true });
				}
				if (isElement(prevEl)) [
					"aria-controls",
					"aria-describedby",
					"aria-haspopup",
					"aria-expanded"
				].forEach((key$2) => prevEl.removeAttribute(key$2));
			}, { immediate: true });
		});
		onBeforeUnmount(() => {
			virtualTriggerAriaStopWatch?.();
			virtualTriggerAriaStopWatch = void 0;
		});
		expose({ triggerRef: triggerRef$1 });
		return (_ctx, _cache) => {
			return !_ctx.virtualTriggering ? (openBlock(), createBlock(unref(OnlyChild), mergeProps({ key: 0 }, _ctx.$attrs, {
				"aria-controls": unref(ariaControls),
				"aria-describedby": unref(ariaDescribedby),
				"aria-expanded": unref(ariaExpanded),
				"aria-haspopup": unref(ariaHaspopup)
			}), {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 16, [
				"aria-controls",
				"aria-describedby",
				"aria-expanded",
				"aria-haspopup"
			])) : createCommentVNode("v-if", true);
		};
	}
}), [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/trigger.vue"]]);
var FOCUS_AFTER_TRAPPED = "focus-trap.focus-after-trapped";
var FOCUS_AFTER_RELEASED = "focus-trap.focus-after-released";
var FOCUSOUT_PREVENTED = "focus-trap.focusout-prevented";
var FOCUS_AFTER_TRAPPED_OPTS = {
	cancelable: true,
	bubbles: false
};
var FOCUSOUT_PREVENTED_OPTS = {
	cancelable: true,
	bubbles: false
};
var ON_TRAP_FOCUS_EVT = "focusAfterTrapped";
var ON_RELEASE_FOCUS_EVT = "focusAfterReleased";
var FOCUS_TRAP_INJECTION_KEY = Symbol("elFocusTrap");
var focusReason = ref();
var lastUserFocusTimestamp = ref(0);
var lastAutomatedFocusTimestamp = ref(0);
var focusReasonUserCount = 0;
var obtainAllFocusableElements = (element) => {
	const nodes = [];
	const walker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT, { acceptNode: (node) => {
		const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
		if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;
		return node.tabIndex >= 0 || node === document.activeElement ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
	} });
	while (walker.nextNode()) nodes.push(walker.currentNode);
	return nodes;
};
var getVisibleElement = (elements, container$18) => {
	for (const element of elements) if (!isHidden$1(element, container$18)) return element;
};
var isHidden$1 = (element, container$18) => {
	if (getComputedStyle(element).visibility === "hidden") return true;
	while (element) {
		if (container$18 && element === container$18) return false;
		if (getComputedStyle(element).display === "none") return true;
		element = element.parentElement;
	}
	return false;
};
var getEdges = (container$18) => {
	const focusable = obtainAllFocusableElements(container$18);
	return [getVisibleElement(focusable, container$18), getVisibleElement(focusable.reverse(), container$18)];
};
var isSelectable = (element) => {
	return element instanceof HTMLInputElement && "select" in element;
};
var tryFocus = (element, shouldSelect) => {
	if (element && element.focus) {
		const prevFocusedElement = document.activeElement;
		element.focus({ preventScroll: true });
		lastAutomatedFocusTimestamp.value = window.performance.now();
		if (element !== prevFocusedElement && isSelectable(element) && shouldSelect) element.select();
	}
};
function removeFromStack(list$1, item$4) {
	const copy$1 = [...list$1];
	const idx = list$1.indexOf(item$4);
	if (idx !== -1) copy$1.splice(idx, 1);
	return copy$1;
}
var createFocusableStack = () => {
	let stack = [];
	const push = (layer) => {
		const currentLayer = stack[0];
		if (currentLayer && layer !== currentLayer) currentLayer.pause();
		stack = removeFromStack(stack, layer);
		stack.unshift(layer);
	};
	const remove = (layer) => {
		var _a, _b;
		stack = removeFromStack(stack, layer);
		(_b = (_a = stack[0]) == null ? void 0 : _a.resume) == null || _b.call(_a);
	};
	return {
		push,
		remove
	};
};
var focusFirstDescendant = (elements, shouldSelect = false) => {
	const prevFocusedElement = document.activeElement;
	for (const element of elements) {
		tryFocus(element, shouldSelect);
		if (document.activeElement !== prevFocusedElement) return;
	}
};
var focusableStack = createFocusableStack();
var isFocusCausedByUserEvent = () => {
	return lastUserFocusTimestamp.value > lastAutomatedFocusTimestamp.value;
};
var notifyFocusReasonPointer = () => {
	focusReason.value = "pointer";
	lastUserFocusTimestamp.value = window.performance.now();
};
var notifyFocusReasonKeydown = () => {
	focusReason.value = "keyboard";
	lastUserFocusTimestamp.value = window.performance.now();
};
var useFocusReason = () => {
	onMounted(() => {
		if (focusReasonUserCount === 0) {
			document.addEventListener("mousedown", notifyFocusReasonPointer);
			document.addEventListener("touchstart", notifyFocusReasonPointer);
			document.addEventListener("keydown", notifyFocusReasonKeydown);
		}
		focusReasonUserCount++;
	});
	onBeforeUnmount(() => {
		focusReasonUserCount--;
		if (focusReasonUserCount <= 0) {
			document.removeEventListener("mousedown", notifyFocusReasonPointer);
			document.removeEventListener("touchstart", notifyFocusReasonPointer);
			document.removeEventListener("keydown", notifyFocusReasonKeydown);
		}
	});
	return {
		focusReason,
		lastUserFocusTimestamp,
		lastAutomatedFocusTimestamp
	};
};
var createFocusOutPreventedEvent = (detail) => {
	return new CustomEvent(FOCUSOUT_PREVENTED, {
		...FOCUSOUT_PREVENTED_OPTS,
		detail
	});
};
init_shared_esm_bundler();
var _sfc_main$21 = defineComponent({
	name: "ElFocusTrap",
	inheritAttrs: false,
	props: {
		loop: Boolean,
		trapped: Boolean,
		focusTrapEl: Object,
		focusStartEl: {
			type: [Object, String],
			default: "first"
		}
	},
	emits: [
		ON_TRAP_FOCUS_EVT,
		ON_RELEASE_FOCUS_EVT,
		"focusin",
		"focusout",
		"focusout-prevented",
		"release-requested"
	],
	setup(props, { emit }) {
		const forwardRef = ref();
		let lastFocusBeforeTrapped;
		let lastFocusAfterTrapped;
		const { focusReason: focusReason$1 } = useFocusReason();
		useEscapeKeydown((event) => {
			if (props.trapped && !focusLayer.paused) emit("release-requested", event);
		});
		const focusLayer = {
			paused: false,
			pause() {
				this.paused = true;
			},
			resume() {
				this.paused = false;
			}
		};
		const onKeydown = (e) => {
			if (!props.loop && !props.trapped) return;
			if (focusLayer.paused) return;
			const { key: key$2, altKey, ctrlKey, metaKey, currentTarget, shiftKey } = e;
			const { loop: loop$1 } = props;
			const isTabbing = key$2 === EVENT_CODE.tab && !altKey && !ctrlKey && !metaKey;
			const currentFocusingEl = document.activeElement;
			if (isTabbing && currentFocusingEl) {
				const container$18 = currentTarget;
				const [first, last] = getEdges(container$18);
				if (!(first && last)) {
					if (currentFocusingEl === container$18) {
						const focusoutPreventedEvent = createFocusOutPreventedEvent({ focusReason: focusReason$1.value });
						emit("focusout-prevented", focusoutPreventedEvent);
						if (!focusoutPreventedEvent.defaultPrevented) e.preventDefault();
					}
				} else if (!shiftKey && currentFocusingEl === last) {
					const focusoutPreventedEvent = createFocusOutPreventedEvent({ focusReason: focusReason$1.value });
					emit("focusout-prevented", focusoutPreventedEvent);
					if (!focusoutPreventedEvent.defaultPrevented) {
						e.preventDefault();
						if (loop$1) tryFocus(first, true);
					}
				} else if (shiftKey && [first, container$18].includes(currentFocusingEl)) {
					const focusoutPreventedEvent = createFocusOutPreventedEvent({ focusReason: focusReason$1.value });
					emit("focusout-prevented", focusoutPreventedEvent);
					if (!focusoutPreventedEvent.defaultPrevented) {
						e.preventDefault();
						if (loop$1) tryFocus(last, true);
					}
				}
			}
		};
		provide(FOCUS_TRAP_INJECTION_KEY, {
			focusTrapRef: forwardRef,
			onKeydown
		});
		watch(() => props.focusTrapEl, (focusTrapEl) => {
			if (focusTrapEl) forwardRef.value = focusTrapEl;
		}, { immediate: true });
		watch([forwardRef], ([forwardRef2], [oldForwardRef]) => {
			if (forwardRef2) {
				forwardRef2.addEventListener("keydown", onKeydown);
				forwardRef2.addEventListener("focusin", onFocusIn);
				forwardRef2.addEventListener("focusout", onFocusOut);
			}
			if (oldForwardRef) {
				oldForwardRef.removeEventListener("keydown", onKeydown);
				oldForwardRef.removeEventListener("focusin", onFocusIn);
				oldForwardRef.removeEventListener("focusout", onFocusOut);
			}
		});
		const trapOnFocus = (e) => {
			emit(ON_TRAP_FOCUS_EVT, e);
		};
		const releaseOnFocus = (e) => emit(ON_RELEASE_FOCUS_EVT, e);
		const onFocusIn = (e) => {
			const trapContainer = unref(forwardRef);
			if (!trapContainer) return;
			const target$1 = e.target;
			const relatedTarget = e.relatedTarget;
			const isFocusedInTrap = target$1 && trapContainer.contains(target$1);
			if (!props.trapped) {
				if (!(relatedTarget && trapContainer.contains(relatedTarget))) lastFocusBeforeTrapped = relatedTarget;
			}
			if (isFocusedInTrap) emit("focusin", e);
			if (focusLayer.paused) return;
			if (props.trapped) if (isFocusedInTrap) lastFocusAfterTrapped = target$1;
			else tryFocus(lastFocusAfterTrapped, true);
		};
		const onFocusOut = (e) => {
			const trapContainer = unref(forwardRef);
			if (focusLayer.paused || !trapContainer) return;
			if (props.trapped) {
				const relatedTarget = e.relatedTarget;
				if (!isNil_default(relatedTarget) && !trapContainer.contains(relatedTarget)) setTimeout(() => {
					if (!focusLayer.paused && props.trapped) {
						const focusoutPreventedEvent = createFocusOutPreventedEvent({ focusReason: focusReason$1.value });
						emit("focusout-prevented", focusoutPreventedEvent);
						if (!focusoutPreventedEvent.defaultPrevented) tryFocus(lastFocusAfterTrapped, true);
					}
				}, 0);
			} else {
				const target$1 = e.target;
				if (!(target$1 && trapContainer.contains(target$1))) emit("focusout", e);
			}
		};
		async function startTrap() {
			await nextTick();
			const trapContainer = unref(forwardRef);
			if (trapContainer) {
				focusableStack.push(focusLayer);
				const prevFocusedElement = trapContainer.contains(document.activeElement) ? lastFocusBeforeTrapped : document.activeElement;
				lastFocusBeforeTrapped = prevFocusedElement;
				if (!trapContainer.contains(prevFocusedElement)) {
					const focusEvent = new Event(FOCUS_AFTER_TRAPPED, FOCUS_AFTER_TRAPPED_OPTS);
					trapContainer.addEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus);
					trapContainer.dispatchEvent(focusEvent);
					if (!focusEvent.defaultPrevented) nextTick(() => {
						let focusStartEl = props.focusStartEl;
						if (!isString$2(focusStartEl)) {
							tryFocus(focusStartEl);
							if (document.activeElement !== focusStartEl) focusStartEl = "first";
						}
						if (focusStartEl === "first") focusFirstDescendant(obtainAllFocusableElements(trapContainer), true);
						if (document.activeElement === prevFocusedElement || focusStartEl === "container") tryFocus(trapContainer);
					});
				}
			}
		}
		function stopTrap() {
			const trapContainer = unref(forwardRef);
			if (trapContainer) {
				trapContainer.removeEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus);
				const releasedEvent = new CustomEvent(FOCUS_AFTER_RELEASED, {
					...FOCUS_AFTER_TRAPPED_OPTS,
					detail: { focusReason: focusReason$1.value }
				});
				trapContainer.addEventListener(FOCUS_AFTER_RELEASED, releaseOnFocus);
				trapContainer.dispatchEvent(releasedEvent);
				if (!releasedEvent.defaultPrevented && (focusReason$1.value == "keyboard" || !isFocusCausedByUserEvent() || trapContainer.contains(document.activeElement))) tryFocus(lastFocusBeforeTrapped != null ? lastFocusBeforeTrapped : document.body);
				trapContainer.removeEventListener(FOCUS_AFTER_RELEASED, releaseOnFocus);
				focusableStack.remove(focusLayer);
			}
		}
		onMounted(() => {
			if (props.trapped) startTrap();
			watch(() => props.trapped, (trapped) => {
				if (trapped) startTrap();
				else stopTrap();
			});
		});
		onBeforeUnmount(() => {
			if (props.trapped) stopTrap();
		});
		return { onKeydown };
	}
});
function _sfc_render$21(_ctx, _cache, $props, $setup, $data, $options) {
	return renderSlot(_ctx.$slots, "default", { handleKeydown: _ctx.onKeydown });
}
var ElFocusTrap = /* @__PURE__ */ _export_sfc(_sfc_main$21, [["render", _sfc_render$21], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/focus-trap/src/focus-trap.vue"]]);
var popperContentProps = buildProps({
	...buildProps({
		boundariesPadding: {
			type: Number,
			default: 0
		},
		fallbackPlacements: {
			type: definePropType(Array),
			default: void 0
		},
		gpuAcceleration: {
			type: Boolean,
			default: true
		},
		offset: {
			type: Number,
			default: 12
		},
		placement: {
			type: String,
			values: Ee$1,
			default: "bottom"
		},
		popperOptions: {
			type: definePropType(Object),
			default: () => ({})
		},
		strategy: {
			type: String,
			values: ["fixed", "absolute"],
			default: "absolute"
		}
	}),
	id: String,
	style: { type: definePropType([
		String,
		Array,
		Object
	]) },
	className: { type: definePropType([
		String,
		Array,
		Object
	]) },
	effect: {
		type: String,
		default: "dark"
	},
	visible: Boolean,
	enterable: {
		type: Boolean,
		default: true
	},
	pure: Boolean,
	focusOnShow: {
		type: Boolean,
		default: false
	},
	trapping: {
		type: Boolean,
		default: false
	},
	popperClass: { type: definePropType([
		String,
		Array,
		Object
	]) },
	popperStyle: { type: definePropType([
		String,
		Array,
		Object
	]) },
	referenceEl: { type: definePropType(Object) },
	triggerTargetEl: { type: definePropType(Object) },
	stopPopperMouseEvent: {
		type: Boolean,
		default: true
	},
	ariaLabel: {
		type: String,
		default: void 0
	},
	virtualTriggering: Boolean,
	zIndex: Number
});
var popperContentEmits = {
	mouseenter: (evt) => evt instanceof MouseEvent,
	mouseleave: (evt) => evt instanceof MouseEvent,
	focus: () => true,
	blur: () => true,
	close: () => true
};
var buildPopperOptions = (props, modifiers = []) => {
	const { placement, strategy, popperOptions } = props;
	const options$1 = {
		placement,
		strategy,
		...popperOptions,
		modifiers: [...genModifiers(props), ...modifiers]
	};
	deriveExtraModifiers(options$1, popperOptions == null ? void 0 : popperOptions.modifiers);
	return options$1;
};
var unwrapMeasurableEl = ($el) => {
	if (!isClient$1) return;
	return unrefElement$1($el);
};
function genModifiers(options$1) {
	const { offset: offset$2, gpuAcceleration, fallbackPlacements } = options$1;
	return [
		{
			name: "offset",
			options: { offset: [0, offset$2 != null ? offset$2 : 12] }
		},
		{
			name: "preventOverflow",
			options: { padding: {
				top: 2,
				bottom: 2,
				left: 5,
				right: 5
			} }
		},
		{
			name: "flip",
			options: {
				padding: 5,
				fallbackPlacements
			}
		},
		{
			name: "computeStyles",
			options: { gpuAcceleration }
		}
	];
}
function deriveExtraModifiers(options$1, modifiers) {
	if (modifiers) options$1.modifiers = [...options$1.modifiers, ...modifiers != null ? modifiers : []];
}
var DEFAULT_ARROW_OFFSET = 0;
var usePopperContent = (props) => {
	const { popperInstanceRef, contentRef, triggerRef: triggerRef$1, role } = inject(POPPER_INJECTION_KEY, void 0);
	const arrowRef = ref();
	const arrowOffset = ref();
	const eventListenerModifier = computed(() => {
		return {
			name: "eventListeners",
			enabled: !!props.visible
		};
	});
	const arrowModifier = computed(() => {
		var _a;
		const arrowEl = unref(arrowRef);
		const offset$2 = (_a = unref(arrowOffset)) != null ? _a : DEFAULT_ARROW_OFFSET;
		return {
			name: "arrow",
			enabled: !isUndefined_default(arrowEl),
			options: {
				element: arrowEl,
				padding: offset$2
			}
		};
	});
	const options$1 = computed(() => {
		return {
			onFirstUpdate: () => {
				update();
			},
			...buildPopperOptions(props, [unref(arrowModifier), unref(eventListenerModifier)])
		};
	});
	const computedReference = computed(() => unwrapMeasurableEl(props.referenceEl) || unref(triggerRef$1));
	const { attributes, state, styles, update, forceUpdate, instanceRef } = usePopper(computedReference, contentRef, options$1);
	watch(instanceRef, (instance) => popperInstanceRef.value = instance);
	onMounted(() => {
		watch(() => {
			var _a;
			return (_a = unref(computedReference)) == null ? void 0 : _a.getBoundingClientRect();
		}, () => {
			update();
		});
	});
	return {
		attributes,
		arrowRef,
		contentRef,
		instanceRef,
		state,
		styles,
		role,
		forceUpdate,
		update
	};
};
var usePopperContentDOM = (props, { attributes, styles, role }) => {
	const { nextZIndex } = useZIndex();
	const ns = useNamespace("popper");
	const contentAttrs = computed(() => unref(attributes).popper);
	const contentZIndex = ref(isNumber(props.zIndex) ? props.zIndex : nextZIndex());
	const contentClass = computed(() => [
		ns.b(),
		ns.is("pure", props.pure),
		ns.is(props.effect),
		props.popperClass
	]);
	const contentStyle = computed(() => {
		return [
			{ zIndex: unref(contentZIndex) },
			unref(styles).popper,
			props.popperStyle || {}
		];
	});
	const ariaModal = computed(() => role.value === "dialog" ? "false" : void 0);
	const arrowStyle = computed(() => unref(styles).arrow || {});
	const updateZIndex = () => {
		contentZIndex.value = isNumber(props.zIndex) ? props.zIndex : nextZIndex();
	};
	return {
		ariaModal,
		arrowStyle,
		contentAttrs,
		contentClass,
		contentStyle,
		contentZIndex,
		updateZIndex
	};
};
var usePopperContentFocusTrap = (props, emit) => {
	const trapped = ref(false);
	const focusStartRef = ref();
	const onFocusAfterTrapped = () => {
		emit("focus");
	};
	const onFocusAfterReleased = (event) => {
		var _a;
		if (((_a = event.detail) == null ? void 0 : _a.focusReason) !== "pointer") {
			focusStartRef.value = "first";
			emit("blur");
		}
	};
	const onFocusInTrap = (event) => {
		if (props.visible && !trapped.value) {
			if (event.target) focusStartRef.value = event.target;
			trapped.value = true;
		}
	};
	const onFocusoutPrevented = (event) => {
		if (!props.trapping) {
			if (event.detail.focusReason === "pointer") event.preventDefault();
			trapped.value = false;
		}
	};
	const onReleaseRequested = () => {
		trapped.value = false;
		emit("close");
	};
	return {
		focusStartRef,
		trapped,
		onFocusAfterReleased,
		onFocusAfterTrapped,
		onFocusInTrap,
		onFocusoutPrevented,
		onReleaseRequested
	};
};
init_shared_esm_bundler();
var ElPopperContent = /* @__PURE__ */ _export_sfc(/* @__PURE__ */ defineComponent({
	...defineComponent({ name: "ElPopperContent" }),
	props: popperContentProps,
	emits: popperContentEmits,
	setup(__props, { expose, emit }) {
		const props = __props;
		const { focusStartRef, trapped, onFocusAfterReleased, onFocusAfterTrapped, onFocusInTrap, onFocusoutPrevented, onReleaseRequested } = usePopperContentFocusTrap(props, emit);
		const { attributes, arrowRef, contentRef, styles, instanceRef, role, update } = usePopperContent(props);
		const { ariaModal, arrowStyle, contentAttrs, contentClass, contentStyle, updateZIndex } = usePopperContentDOM(props, {
			styles,
			attributes,
			role
		});
		const formItemContext = inject(formItemContextKey, void 0);
		provide(POPPER_CONTENT_INJECTION_KEY, {
			arrowStyle,
			arrowRef,
			arrowOffset: ref()
		});
		if (formItemContext && (formItemContext.addInputId || formItemContext.removeInputId)) provide(formItemContextKey, {
			...formItemContext,
			addInputId: NOOP,
			removeInputId: NOOP
		});
		let triggerTargetAriaStopWatch = void 0;
		const updatePopper = (shouldUpdateZIndex = true) => {
			update();
			shouldUpdateZIndex && updateZIndex();
		};
		const togglePopperAlive = () => {
			updatePopper(false);
			if (props.visible && props.focusOnShow) trapped.value = true;
			else if (props.visible === false) trapped.value = false;
		};
		onMounted(() => {
			watch(() => props.triggerTargetEl, (triggerTargetEl, prevTriggerTargetEl) => {
				triggerTargetAriaStopWatch?.();
				triggerTargetAriaStopWatch = void 0;
				const el$2 = unref(triggerTargetEl || contentRef.value);
				const prevEl = unref(prevTriggerTargetEl || contentRef.value);
				if (isElement(el$2)) triggerTargetAriaStopWatch = watch([
					role,
					() => props.ariaLabel,
					ariaModal,
					() => props.id
				], (watches) => {
					[
						"role",
						"aria-label",
						"aria-modal",
						"id"
					].forEach((key$2, idx) => {
						isNil_default(watches[idx]) ? el$2.removeAttribute(key$2) : el$2.setAttribute(key$2, watches[idx]);
					});
				}, { immediate: true });
				if (prevEl !== el$2 && isElement(prevEl)) [
					"role",
					"aria-label",
					"aria-modal",
					"id"
				].forEach((key$2) => {
					prevEl.removeAttribute(key$2);
				});
			}, { immediate: true });
			watch(() => props.visible, togglePopperAlive, { immediate: true });
		});
		onBeforeUnmount(() => {
			triggerTargetAriaStopWatch?.();
			triggerTargetAriaStopWatch = void 0;
		});
		expose({
			popperContentRef: contentRef,
			popperInstanceRef: instanceRef,
			updatePopper,
			contentStyle
		});
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", mergeProps({
				ref_key: "contentRef",
				ref: contentRef
			}, unref(contentAttrs), {
				style: unref(contentStyle),
				class: unref(contentClass),
				tabindex: "-1",
				onMouseenter: _cache[0] || (_cache[0] = (e) => _ctx.$emit("mouseenter", e)),
				onMouseleave: _cache[1] || (_cache[1] = (e) => _ctx.$emit("mouseleave", e))
			}), [createVNode(unref(ElFocusTrap), {
				trapped: unref(trapped),
				"trap-on-focus-in": true,
				"focus-trap-el": unref(contentRef),
				"focus-start-el": unref(focusStartRef),
				onFocusAfterTrapped: unref(onFocusAfterTrapped),
				onFocusAfterReleased: unref(onFocusAfterReleased),
				onFocusin: unref(onFocusInTrap),
				onFocusoutPrevented: unref(onFocusoutPrevented),
				onReleaseRequested: unref(onReleaseRequested)
			}, {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 8, [
				"trapped",
				"focus-trap-el",
				"focus-start-el",
				"onFocusAfterTrapped",
				"onFocusAfterReleased",
				"onFocusin",
				"onFocusoutPrevented",
				"onReleaseRequested"
			])], 16);
		};
	}
}), [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/content.vue"]]);
var ElPopper = withInstall(Popper);
var TOOLTIP_INJECTION_KEY = Symbol("elTooltip");
var useTooltipContentProps = buildProps({
	...useDelayedToggleProps,
	...popperContentProps,
	appendTo: { type: definePropType([String, Object]) },
	content: {
		type: String,
		default: ""
	},
	rawContent: {
		type: Boolean,
		default: false
	},
	persistent: Boolean,
	ariaLabel: String,
	visible: {
		type: definePropType(Boolean),
		default: null
	},
	transition: String,
	teleported: {
		type: Boolean,
		default: true
	},
	disabled: Boolean
});
var useTooltipTriggerProps = buildProps({
	...popperTriggerProps,
	disabled: Boolean,
	trigger: {
		type: definePropType([String, Array]),
		default: "hover"
	},
	triggerKeys: {
		type: definePropType(Array),
		default: () => [EVENT_CODE.enter, EVENT_CODE.space]
	}
});
var { useModelToggleProps: useTooltipModelToggleProps, useModelToggleEmits: useTooltipModelToggleEmits, useModelToggle: useTooltipModelToggle } = createModelToggleComposable("visible");
var useTooltipProps = buildProps({
	...popperProps,
	...useTooltipModelToggleProps,
	...useTooltipContentProps,
	...useTooltipTriggerProps,
	...popperArrowProps,
	showArrow: {
		type: Boolean,
		default: true
	}
});
var tooltipEmits = [
	...useTooltipModelToggleEmits,
	"before-show",
	"before-hide",
	"show",
	"hide",
	"open",
	"close"
];
init_shared_esm_bundler();
var isTriggerType = (trigger, type) => {
	if (isArray(trigger)) return trigger.includes(type);
	return trigger === type;
};
var whenTrigger = (trigger, type, handler) => {
	return (e) => {
		isTriggerType(unref(trigger), type) && handler(e);
	};
};
var ElTooltipTrigger = /* @__PURE__ */ _export_sfc(/* @__PURE__ */ defineComponent({
	...defineComponent({ name: "ElTooltipTrigger" }),
	props: useTooltipTriggerProps,
	setup(__props, { expose }) {
		const props = __props;
		const ns = useNamespace("tooltip");
		const { controlled, id: id$1, open, onOpen, onClose, onToggle } = inject(TOOLTIP_INJECTION_KEY, void 0);
		const triggerRef$1 = ref(null);
		const stopWhenControlledOrDisabled = () => {
			if (unref(controlled) || props.disabled) return true;
		};
		const trigger = toRef(props, "trigger");
		const onMouseenter = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger, "hover", onOpen));
		const onMouseleave = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger, "hover", onClose));
		const onClick = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger, "click", (e) => {
			if (e.button === 0) onToggle(e);
		}));
		const onFocus = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger, "focus", onOpen));
		const onBlur = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger, "focus", onClose));
		const onContextMenu = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger, "contextmenu", (e) => {
			e.preventDefault();
			onToggle(e);
		}));
		const onKeydown = composeEventHandlers(stopWhenControlledOrDisabled, (e) => {
			const { code } = e;
			if (props.triggerKeys.includes(code)) {
				e.preventDefault();
				onToggle(e);
			}
		});
		expose({ triggerRef: triggerRef$1 });
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(ElPopperTrigger), {
				id: unref(id$1),
				"virtual-ref": _ctx.virtualRef,
				open: unref(open),
				"virtual-triggering": _ctx.virtualTriggering,
				class: normalizeClass(unref(ns).e("trigger")),
				onBlur: unref(onBlur),
				onClick: unref(onClick),
				onContextmenu: unref(onContextMenu),
				onFocus: unref(onFocus),
				onMouseenter: unref(onMouseenter),
				onMouseleave: unref(onMouseleave),
				onKeydown: unref(onKeydown)
			}, {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 8, [
				"id",
				"virtual-ref",
				"open",
				"virtual-triggering",
				"class",
				"onBlur",
				"onClick",
				"onContextmenu",
				"onFocus",
				"onMouseenter",
				"onMouseleave",
				"onKeydown"
			]);
		};
	}
}), [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip/src/trigger.vue"]]);
var ElTooltipContent = /* @__PURE__ */ _export_sfc(/* @__PURE__ */ defineComponent({
	...defineComponent({
		name: "ElTooltipContent",
		inheritAttrs: false
	}),
	props: useTooltipContentProps,
	setup(__props, { expose }) {
		const props = __props;
		const { selector } = usePopperContainerId();
		const ns = useNamespace("tooltip");
		const contentRef = ref(null);
		const destroyed = ref(false);
		const { controlled, id: id$1, open, trigger, onClose, onOpen, onShow, onHide, onBeforeShow, onBeforeHide } = inject(TOOLTIP_INJECTION_KEY, void 0);
		const transitionClass = computed(() => {
			return props.transition || `${ns.namespace.value}-fade-in-linear`;
		});
		const persistentRef = computed(() => {
			return props.persistent;
		});
		onBeforeUnmount(() => {
			destroyed.value = true;
		});
		const shouldRender = computed(() => {
			return unref(persistentRef) ? true : unref(open);
		});
		const shouldShow = computed(() => {
			return props.disabled ? false : unref(open);
		});
		const appendTo = computed(() => {
			return props.appendTo || selector.value;
		});
		const contentStyle = computed(() => {
			var _a;
			return (_a = props.style) != null ? _a : {};
		});
		const ariaHidden = computed(() => !unref(open));
		const onTransitionLeave = () => {
			onHide();
		};
		const stopWhenControlled = () => {
			if (unref(controlled)) return true;
		};
		const onContentEnter = composeEventHandlers(stopWhenControlled, () => {
			if (props.enterable && unref(trigger) === "hover") onOpen();
		});
		const onContentLeave = composeEventHandlers(stopWhenControlled, () => {
			if (unref(trigger) === "hover") onClose();
		});
		const onBeforeEnter = () => {
			var _a, _b;
			(_b = (_a = contentRef.value) == null ? void 0 : _a.updatePopper) == null || _b.call(_a);
			onBeforeShow?.();
		};
		const onBeforeLeave = () => {
			onBeforeHide?.();
		};
		const onAfterShow = () => {
			onShow();
			stopHandle = onClickOutside$1(computed(() => {
				var _a;
				return (_a = contentRef.value) == null ? void 0 : _a.popperContentRef;
			}), () => {
				if (unref(controlled)) return;
				if (unref(trigger) !== "hover") onClose();
			});
		};
		const onBlur = () => {
			if (!props.virtualTriggering) onClose();
		};
		let stopHandle;
		watch(() => unref(open), (val) => {
			if (!val) stopHandle?.();
		}, { flush: "post" });
		watch(() => props.content, () => {
			var _a, _b;
			(_b = (_a = contentRef.value) == null ? void 0 : _a.updatePopper) == null || _b.call(_a);
		});
		expose({ contentRef });
		return (_ctx, _cache) => {
			return openBlock(), createBlock(Teleport, {
				disabled: !_ctx.teleported,
				to: unref(appendTo)
			}, [createVNode(Transition, {
				name: unref(transitionClass),
				onAfterLeave: onTransitionLeave,
				onBeforeEnter,
				onAfterEnter: onAfterShow,
				onBeforeLeave
			}, {
				default: withCtx(() => [unref(shouldRender) ? withDirectives((openBlock(), createBlock(unref(ElPopperContent), mergeProps({
					key: 0,
					id: unref(id$1),
					ref_key: "contentRef",
					ref: contentRef
				}, _ctx.$attrs, {
					"aria-label": _ctx.ariaLabel,
					"aria-hidden": unref(ariaHidden),
					"boundaries-padding": _ctx.boundariesPadding,
					"fallback-placements": _ctx.fallbackPlacements,
					"gpu-acceleration": _ctx.gpuAcceleration,
					offset: _ctx.offset,
					placement: _ctx.placement,
					"popper-options": _ctx.popperOptions,
					strategy: _ctx.strategy,
					effect: _ctx.effect,
					enterable: _ctx.enterable,
					pure: _ctx.pure,
					"popper-class": _ctx.popperClass,
					"popper-style": [_ctx.popperStyle, unref(contentStyle)],
					"reference-el": _ctx.referenceEl,
					"trigger-target-el": _ctx.triggerTargetEl,
					visible: unref(shouldShow),
					"z-index": _ctx.zIndex,
					onMouseenter: unref(onContentEnter),
					onMouseleave: unref(onContentLeave),
					onBlur,
					onClose: unref(onClose)
				}), {
					default: withCtx(() => [!destroyed.value ? renderSlot(_ctx.$slots, "default", { key: 0 }) : createCommentVNode("v-if", true)]),
					_: 3
				}, 16, [
					"id",
					"aria-label",
					"aria-hidden",
					"boundaries-padding",
					"fallback-placements",
					"gpu-acceleration",
					"offset",
					"placement",
					"popper-options",
					"strategy",
					"effect",
					"enterable",
					"pure",
					"popper-class",
					"popper-style",
					"reference-el",
					"trigger-target-el",
					"visible",
					"z-index",
					"onMouseenter",
					"onMouseleave",
					"onClose"
				])), [[vShow, unref(shouldShow)]]) : createCommentVNode("v-if", true)]),
				_: 3
			}, 8, ["name"])], 8, ["disabled", "to"]);
		};
	}
}), [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip/src/content.vue"]]);
var _hoisted_1$60 = ["innerHTML"];
var _hoisted_2$37 = { key: 1 };
var ElTooltip = withInstall(/* @__PURE__ */ _export_sfc(/* @__PURE__ */ defineComponent({
	...defineComponent({ name: "ElTooltip" }),
	props: useTooltipProps,
	emits: tooltipEmits,
	setup(__props, { expose, emit }) {
		const props = __props;
		usePopperContainer();
		const id$1 = useId$1();
		const popperRef = ref();
		const contentRef = ref();
		const updatePopper = () => {
			var _a;
			const popperComponent = unref(popperRef);
			if (popperComponent) (_a = popperComponent.popperInstanceRef) == null || _a.update();
		};
		const open = ref(false);
		const toggleReason = ref();
		const { show, hide: hide$2, hasUpdateHandler } = useTooltipModelToggle({
			indicator: open,
			toggleReason
		});
		const { onOpen, onClose } = useDelayedToggle({
			showAfter: toRef(props, "showAfter"),
			hideAfter: toRef(props, "hideAfter"),
			autoClose: toRef(props, "autoClose"),
			open: show,
			close: hide$2
		});
		provide(TOOLTIP_INJECTION_KEY, {
			controlled: computed(() => isBoolean(props.visible) && !hasUpdateHandler.value),
			id: id$1,
			open: readonly(open),
			trigger: toRef(props, "trigger"),
			onOpen: (event) => {
				onOpen(event);
			},
			onClose: (event) => {
				onClose(event);
			},
			onToggle: (event) => {
				if (unref(open)) onClose(event);
				else onOpen(event);
			},
			onShow: () => {
				emit("show", toggleReason.value);
			},
			onHide: () => {
				emit("hide", toggleReason.value);
			},
			onBeforeShow: () => {
				emit("before-show", toggleReason.value);
			},
			onBeforeHide: () => {
				emit("before-hide", toggleReason.value);
			},
			updatePopper
		});
		watch(() => props.disabled, (disabled$9) => {
			if (disabled$9 && open.value) open.value = false;
		});
		const isFocusInsideContent = (event) => {
			var _a, _b;
			const popperContent = (_b = (_a = contentRef.value) == null ? void 0 : _a.contentRef) == null ? void 0 : _b.popperContentRef;
			const activeElement = (event == null ? void 0 : event.relatedTarget) || document.activeElement;
			return popperContent && popperContent.contains(activeElement);
		};
		onDeactivated(() => open.value && hide$2());
		expose({
			popperRef,
			contentRef,
			isFocusInsideContent,
			updatePopper,
			onOpen,
			onClose,
			hide: hide$2
		});
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(ElPopper), {
				ref_key: "popperRef",
				ref: popperRef,
				role: _ctx.role
			}, {
				default: withCtx(() => [createVNode(ElTooltipTrigger, {
					disabled: _ctx.disabled,
					trigger: _ctx.trigger,
					"trigger-keys": _ctx.triggerKeys,
					"virtual-ref": _ctx.virtualRef,
					"virtual-triggering": _ctx.virtualTriggering
				}, {
					default: withCtx(() => [_ctx.$slots.default ? renderSlot(_ctx.$slots, "default", { key: 0 }) : createCommentVNode("v-if", true)]),
					_: 3
				}, 8, [
					"disabled",
					"trigger",
					"trigger-keys",
					"virtual-ref",
					"virtual-triggering"
				]), createVNode(ElTooltipContent, {
					ref_key: "contentRef",
					ref: contentRef,
					"aria-label": _ctx.ariaLabel,
					"boundaries-padding": _ctx.boundariesPadding,
					content: _ctx.content,
					disabled: _ctx.disabled,
					effect: _ctx.effect,
					enterable: _ctx.enterable,
					"fallback-placements": _ctx.fallbackPlacements,
					"hide-after": _ctx.hideAfter,
					"gpu-acceleration": _ctx.gpuAcceleration,
					offset: _ctx.offset,
					persistent: _ctx.persistent,
					"popper-class": _ctx.popperClass,
					"popper-style": _ctx.popperStyle,
					placement: _ctx.placement,
					"popper-options": _ctx.popperOptions,
					pure: _ctx.pure,
					"raw-content": _ctx.rawContent,
					"reference-el": _ctx.referenceEl,
					"trigger-target-el": _ctx.triggerTargetEl,
					"show-after": _ctx.showAfter,
					strategy: _ctx.strategy,
					teleported: _ctx.teleported,
					transition: _ctx.transition,
					"virtual-triggering": _ctx.virtualTriggering,
					"z-index": _ctx.zIndex,
					"append-to": _ctx.appendTo
				}, {
					default: withCtx(() => [renderSlot(_ctx.$slots, "content", {}, () => [_ctx.rawContent ? (openBlock(), createElementBlock("span", {
						key: 0,
						innerHTML: _ctx.content
					}, null, 8, _hoisted_1$60)) : (openBlock(), createElementBlock("span", _hoisted_2$37, toDisplayString(_ctx.content), 1))]), _ctx.showArrow ? (openBlock(), createBlock(unref(ElPopperArrow), {
						key: 0,
						"arrow-offset": _ctx.arrowOffset
					}, null, 8, ["arrow-offset"])) : createCommentVNode("v-if", true)]),
					_: 3
				}, 8, [
					"aria-label",
					"boundaries-padding",
					"content",
					"disabled",
					"effect",
					"enterable",
					"fallback-placements",
					"hide-after",
					"gpu-acceleration",
					"offset",
					"persistent",
					"popper-class",
					"popper-style",
					"placement",
					"popper-options",
					"pure",
					"raw-content",
					"reference-el",
					"trigger-target-el",
					"show-after",
					"strategy",
					"teleported",
					"transition",
					"virtual-triggering",
					"z-index",
					"append-to"
				])]),
				_: 3
			}, 8, ["role"]);
		};
	}
}), [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip/src/tooltip.vue"]]));
var buttonGroupContextKey = Symbol("buttonGroupContextKey");
var useButton = (props, emit) => {
	useDeprecated({
		from: "type.text",
		replacement: "link",
		version: "3.0.0",
		scope: "props",
		ref: "https://element-plus.org/en-US/component/button.html#button-attributes"
	}, computed(() => props.type === "text"));
	const buttonGroupContext = inject(buttonGroupContextKey, void 0);
	const globalConfig = useGlobalConfig("button");
	const { form } = useFormItem();
	const _size = useFormSize(computed(() => buttonGroupContext == null ? void 0 : buttonGroupContext.size));
	const _disabled = useFormDisabled();
	const _ref = ref();
	const slots = useSlots();
	const _type = computed(() => props.type || (buttonGroupContext == null ? void 0 : buttonGroupContext.type) || "");
	const autoInsertSpace = computed(() => {
		var _a, _b, _c;
		return (_c = (_b = props.autoInsertSpace) != null ? _b : (_a = globalConfig.value) == null ? void 0 : _a.autoInsertSpace) != null ? _c : false;
	});
	const _props = computed(() => {
		if (props.tag === "button") return {
			ariaDisabled: _disabled.value || props.loading,
			disabled: _disabled.value || props.loading,
			autofocus: props.autofocus,
			type: props.nativeType
		};
		return {};
	});
	const shouldAddSpace = computed(() => {
		var _a;
		const defaultSlot = (_a = slots.default) == null ? void 0 : _a.call(slots);
		if (autoInsertSpace.value && (defaultSlot == null ? void 0 : defaultSlot.length) === 1) {
			const slot = defaultSlot[0];
			if ((slot == null ? void 0 : slot.type) === Text) {
				const text$7 = slot.children;
				return /^\p{Unified_Ideograph}{2}$/u.test(text$7.trim());
			}
		}
		return false;
	});
	const handleClick = (evt) => {
		if (props.nativeType === "reset") form?.resetFields();
		emit("click", evt);
	};
	return {
		_disabled,
		_size,
		_type,
		_ref,
		_props,
		shouldAddSpace,
		handleClick
	};
};
var buttonProps = buildProps({
	size: useSizeProp,
	disabled: Boolean,
	type: {
		type: String,
		values: [
			"default",
			"primary",
			"success",
			"warning",
			"info",
			"danger",
			"text",
			""
		],
		default: ""
	},
	icon: { type: iconPropType },
	nativeType: {
		type: String,
		values: [
			"button",
			"submit",
			"reset"
		],
		default: "button"
	},
	loading: Boolean,
	loadingIcon: {
		type: iconPropType,
		default: () => loading_default
	},
	plain: Boolean,
	text: Boolean,
	link: Boolean,
	bg: Boolean,
	autofocus: Boolean,
	round: Boolean,
	circle: Boolean,
	color: String,
	dark: Boolean,
	autoInsertSpace: {
		type: Boolean,
		default: void 0
	},
	tag: {
		type: definePropType([String, Object]),
		default: "button"
	}
});
var buttonEmits = { click: (evt) => evt instanceof MouseEvent };
function bound01$1(n, max$2) {
	if (isOnePointZero$1(n)) n = "100%";
	var isPercent = isPercentage$1(n);
	n = max$2 === 360 ? n : Math.min(max$2, Math.max(0, parseFloat(n)));
	if (isPercent) n = parseInt(String(n * max$2), 10) / 100;
	if (Math.abs(n - max$2) < 1e-6) return 1;
	if (max$2 === 360) n = (n < 0 ? n % max$2 + max$2 : n % max$2) / parseFloat(String(max$2));
	else n = n % max$2 / parseFloat(String(max$2));
	return n;
}
function clamp01(val) {
	return Math.min(1, Math.max(0, val));
}
function isOnePointZero$1(n) {
	return typeof n === "string" && n.indexOf(".") !== -1 && parseFloat(n) === 1;
}
function isPercentage$1(n) {
	return typeof n === "string" && n.indexOf("%") !== -1;
}
function boundAlpha(a$1) {
	a$1 = parseFloat(a$1);
	if (isNaN(a$1) || a$1 < 0 || a$1 > 1) a$1 = 1;
	return a$1;
}
function convertToPercentage(n) {
	if (n <= 1) return "".concat(Number(n) * 100, "%");
	return n;
}
function pad2(c$2) {
	return c$2.length === 1 ? "0" + c$2 : String(c$2);
}
function rgbToRgb(r, g$1, b$2) {
	return {
		r: bound01$1(r, 255) * 255,
		g: bound01$1(g$1, 255) * 255,
		b: bound01$1(b$2, 255) * 255
	};
}
function rgbToHsl(r, g$1, b$2) {
	r = bound01$1(r, 255);
	g$1 = bound01$1(g$1, 255);
	b$2 = bound01$1(b$2, 255);
	var max$2 = Math.max(r, g$1, b$2);
	var min$2 = Math.min(r, g$1, b$2);
	var h$2 = 0;
	var s = 0;
	var l = (max$2 + min$2) / 2;
	if (max$2 === min$2) {
		s = 0;
		h$2 = 0;
	} else {
		var d = max$2 - min$2;
		s = l > .5 ? d / (2 - max$2 - min$2) : d / (max$2 + min$2);
		switch (max$2) {
			case r:
				h$2 = (g$1 - b$2) / d + (g$1 < b$2 ? 6 : 0);
				break;
			case g$1:
				h$2 = (b$2 - r) / d + 2;
				break;
			case b$2:
				h$2 = (r - g$1) / d + 4;
				break;
			default: break;
		}
		h$2 /= 6;
	}
	return {
		h: h$2,
		s,
		l
	};
}
function hue2rgb(p$1, q$1, t$1) {
	if (t$1 < 0) t$1 += 1;
	if (t$1 > 1) t$1 -= 1;
	if (t$1 < 1 / 6) return p$1 + (q$1 - p$1) * (6 * t$1);
	if (t$1 < 1 / 2) return q$1;
	if (t$1 < 2 / 3) return p$1 + (q$1 - p$1) * (2 / 3 - t$1) * 6;
	return p$1;
}
function hslToRgb(h$2, s, l) {
	var r;
	var g$1;
	var b$2;
	h$2 = bound01$1(h$2, 360);
	s = bound01$1(s, 100);
	l = bound01$1(l, 100);
	if (s === 0) {
		g$1 = l;
		b$2 = l;
		r = l;
	} else {
		var q$1 = l < .5 ? l * (1 + s) : l + s - l * s;
		var p$1 = 2 * l - q$1;
		r = hue2rgb(p$1, q$1, h$2 + 1 / 3);
		g$1 = hue2rgb(p$1, q$1, h$2);
		b$2 = hue2rgb(p$1, q$1, h$2 - 1 / 3);
	}
	return {
		r: r * 255,
		g: g$1 * 255,
		b: b$2 * 255
	};
}
function rgbToHsv(r, g$1, b$2) {
	r = bound01$1(r, 255);
	g$1 = bound01$1(g$1, 255);
	b$2 = bound01$1(b$2, 255);
	var max$2 = Math.max(r, g$1, b$2);
	var min$2 = Math.min(r, g$1, b$2);
	var h$2 = 0;
	var v$1 = max$2;
	var d = max$2 - min$2;
	var s = max$2 === 0 ? 0 : d / max$2;
	if (max$2 === min$2) h$2 = 0;
	else {
		switch (max$2) {
			case r:
				h$2 = (g$1 - b$2) / d + (g$1 < b$2 ? 6 : 0);
				break;
			case g$1:
				h$2 = (b$2 - r) / d + 2;
				break;
			case b$2:
				h$2 = (r - g$1) / d + 4;
				break;
			default: break;
		}
		h$2 /= 6;
	}
	return {
		h: h$2,
		s,
		v: v$1
	};
}
function hsvToRgb(h$2, s, v$1) {
	h$2 = bound01$1(h$2, 360) * 6;
	s = bound01$1(s, 100);
	v$1 = bound01$1(v$1, 100);
	var i$1 = Math.floor(h$2);
	var f = h$2 - i$1;
	var p$1 = v$1 * (1 - s);
	var q$1 = v$1 * (1 - f * s);
	var t$1 = v$1 * (1 - (1 - f) * s);
	var mod = i$1 % 6;
	var r = [
		v$1,
		q$1,
		p$1,
		p$1,
		t$1,
		v$1
	][mod];
	var g$1 = [
		t$1,
		v$1,
		v$1,
		q$1,
		p$1,
		p$1
	][mod];
	var b$2 = [
		p$1,
		p$1,
		t$1,
		v$1,
		v$1,
		q$1
	][mod];
	return {
		r: r * 255,
		g: g$1 * 255,
		b: b$2 * 255
	};
}
function rgbToHex(r, g$1, b$2, allow3Char) {
	var hex = [
		pad2(Math.round(r).toString(16)),
		pad2(Math.round(g$1).toString(16)),
		pad2(Math.round(b$2).toString(16))
	];
	if (allow3Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1))) return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
	return hex.join("");
}
function rgbaToHex(r, g$1, b$2, a$1, allow4Char) {
	var hex = [
		pad2(Math.round(r).toString(16)),
		pad2(Math.round(g$1).toString(16)),
		pad2(Math.round(b$2).toString(16)),
		pad2(convertDecimalToHex(a$1))
	];
	if (allow4Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1)) && hex[3].startsWith(hex[3].charAt(1))) return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
	return hex.join("");
}
function convertDecimalToHex(d) {
	return Math.round(parseFloat(d) * 255).toString(16);
}
function convertHexToDecimal(h$2) {
	return parseIntFromHex(h$2) / 255;
}
function parseIntFromHex(val) {
	return parseInt(val, 16);
}
function numberInputToObject(color) {
	return {
		r: color >> 16,
		g: (color & 65280) >> 8,
		b: color & 255
	};
}
var names = {
	aliceblue: "#f0f8ff",
	antiquewhite: "#faebd7",
	aqua: "#00ffff",
	aquamarine: "#7fffd4",
	azure: "#f0ffff",
	beige: "#f5f5dc",
	bisque: "#ffe4c4",
	black: "#000000",
	blanchedalmond: "#ffebcd",
	blue: "#0000ff",
	blueviolet: "#8a2be2",
	brown: "#a52a2a",
	burlywood: "#deb887",
	cadetblue: "#5f9ea0",
	chartreuse: "#7fff00",
	chocolate: "#d2691e",
	coral: "#ff7f50",
	cornflowerblue: "#6495ed",
	cornsilk: "#fff8dc",
	crimson: "#dc143c",
	cyan: "#00ffff",
	darkblue: "#00008b",
	darkcyan: "#008b8b",
	darkgoldenrod: "#b8860b",
	darkgray: "#a9a9a9",
	darkgreen: "#006400",
	darkgrey: "#a9a9a9",
	darkkhaki: "#bdb76b",
	darkmagenta: "#8b008b",
	darkolivegreen: "#556b2f",
	darkorange: "#ff8c00",
	darkorchid: "#9932cc",
	darkred: "#8b0000",
	darksalmon: "#e9967a",
	darkseagreen: "#8fbc8f",
	darkslateblue: "#483d8b",
	darkslategray: "#2f4f4f",
	darkslategrey: "#2f4f4f",
	darkturquoise: "#00ced1",
	darkviolet: "#9400d3",
	deeppink: "#ff1493",
	deepskyblue: "#00bfff",
	dimgray: "#696969",
	dimgrey: "#696969",
	dodgerblue: "#1e90ff",
	firebrick: "#b22222",
	floralwhite: "#fffaf0",
	forestgreen: "#228b22",
	fuchsia: "#ff00ff",
	gainsboro: "#dcdcdc",
	ghostwhite: "#f8f8ff",
	goldenrod: "#daa520",
	gold: "#ffd700",
	gray: "#808080",
	green: "#008000",
	greenyellow: "#adff2f",
	grey: "#808080",
	honeydew: "#f0fff0",
	hotpink: "#ff69b4",
	indianred: "#cd5c5c",
	indigo: "#4b0082",
	ivory: "#fffff0",
	khaki: "#f0e68c",
	lavenderblush: "#fff0f5",
	lavender: "#e6e6fa",
	lawngreen: "#7cfc00",
	lemonchiffon: "#fffacd",
	lightblue: "#add8e6",
	lightcoral: "#f08080",
	lightcyan: "#e0ffff",
	lightgoldenrodyellow: "#fafad2",
	lightgray: "#d3d3d3",
	lightgreen: "#90ee90",
	lightgrey: "#d3d3d3",
	lightpink: "#ffb6c1",
	lightsalmon: "#ffa07a",
	lightseagreen: "#20b2aa",
	lightskyblue: "#87cefa",
	lightslategray: "#778899",
	lightslategrey: "#778899",
	lightsteelblue: "#b0c4de",
	lightyellow: "#ffffe0",
	lime: "#00ff00",
	limegreen: "#32cd32",
	linen: "#faf0e6",
	magenta: "#ff00ff",
	maroon: "#800000",
	mediumaquamarine: "#66cdaa",
	mediumblue: "#0000cd",
	mediumorchid: "#ba55d3",
	mediumpurple: "#9370db",
	mediumseagreen: "#3cb371",
	mediumslateblue: "#7b68ee",
	mediumspringgreen: "#00fa9a",
	mediumturquoise: "#48d1cc",
	mediumvioletred: "#c71585",
	midnightblue: "#191970",
	mintcream: "#f5fffa",
	mistyrose: "#ffe4e1",
	moccasin: "#ffe4b5",
	navajowhite: "#ffdead",
	navy: "#000080",
	oldlace: "#fdf5e6",
	olive: "#808000",
	olivedrab: "#6b8e23",
	orange: "#ffa500",
	orangered: "#ff4500",
	orchid: "#da70d6",
	palegoldenrod: "#eee8aa",
	palegreen: "#98fb98",
	paleturquoise: "#afeeee",
	palevioletred: "#db7093",
	papayawhip: "#ffefd5",
	peachpuff: "#ffdab9",
	peru: "#cd853f",
	pink: "#ffc0cb",
	plum: "#dda0dd",
	powderblue: "#b0e0e6",
	purple: "#800080",
	rebeccapurple: "#663399",
	red: "#ff0000",
	rosybrown: "#bc8f8f",
	royalblue: "#4169e1",
	saddlebrown: "#8b4513",
	salmon: "#fa8072",
	sandybrown: "#f4a460",
	seagreen: "#2e8b57",
	seashell: "#fff5ee",
	sienna: "#a0522d",
	silver: "#c0c0c0",
	skyblue: "#87ceeb",
	slateblue: "#6a5acd",
	slategray: "#708090",
	slategrey: "#708090",
	snow: "#fffafa",
	springgreen: "#00ff7f",
	steelblue: "#4682b4",
	tan: "#d2b48c",
	teal: "#008080",
	thistle: "#d8bfd8",
	tomato: "#ff6347",
	turquoise: "#40e0d0",
	violet: "#ee82ee",
	wheat: "#f5deb3",
	white: "#ffffff",
	whitesmoke: "#f5f5f5",
	yellow: "#ffff00",
	yellowgreen: "#9acd32"
};
function inputToRGB(color) {
	var rgb = {
		r: 0,
		g: 0,
		b: 0
	};
	var a$1 = 1;
	var s = null;
	var v$1 = null;
	var l = null;
	var ok$1 = false;
	var format$1 = false;
	if (typeof color === "string") color = stringInputToObject(color);
	if (typeof color === "object") {
		if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
			rgb = rgbToRgb(color.r, color.g, color.b);
			ok$1 = true;
			format$1 = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
		} else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
			s = convertToPercentage(color.s);
			v$1 = convertToPercentage(color.v);
			rgb = hsvToRgb(color.h, s, v$1);
			ok$1 = true;
			format$1 = "hsv";
		} else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
			s = convertToPercentage(color.s);
			l = convertToPercentage(color.l);
			rgb = hslToRgb(color.h, s, l);
			ok$1 = true;
			format$1 = "hsl";
		}
		if (Object.prototype.hasOwnProperty.call(color, "a")) a$1 = color.a;
	}
	a$1 = boundAlpha(a$1);
	return {
		ok: ok$1,
		format: color.format || format$1,
		r: Math.min(255, Math.max(rgb.r, 0)),
		g: Math.min(255, Math.max(rgb.g, 0)),
		b: Math.min(255, Math.max(rgb.b, 0)),
		a: a$1
	};
}
var CSS_UNIT = "(?:".concat("[-\\+]?\\d*\\.\\d+%?", ")|(?:").concat("[-\\+]?\\d+%?", ")");
var PERMISSIVE_MATCH3 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
var PERMISSIVE_MATCH4 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
var matchers = {
	CSS_UNIT: new RegExp(CSS_UNIT),
	rgb: /* @__PURE__ */ new RegExp("rgb" + PERMISSIVE_MATCH3),
	rgba: /* @__PURE__ */ new RegExp("rgba" + PERMISSIVE_MATCH4),
	hsl: /* @__PURE__ */ new RegExp("hsl" + PERMISSIVE_MATCH3),
	hsla: /* @__PURE__ */ new RegExp("hsla" + PERMISSIVE_MATCH4),
	hsv: /* @__PURE__ */ new RegExp("hsv" + PERMISSIVE_MATCH3),
	hsva: /* @__PURE__ */ new RegExp("hsva" + PERMISSIVE_MATCH4),
	hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
	hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
	hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
	hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
};
function stringInputToObject(color) {
	color = color.trim().toLowerCase();
	if (color.length === 0) return false;
	var named = false;
	if (names[color]) {
		color = names[color];
		named = true;
	} else if (color === "transparent") return {
		r: 0,
		g: 0,
		b: 0,
		a: 0,
		format: "name"
	};
	var match = matchers.rgb.exec(color);
	if (match) return {
		r: match[1],
		g: match[2],
		b: match[3]
	};
	match = matchers.rgba.exec(color);
	if (match) return {
		r: match[1],
		g: match[2],
		b: match[3],
		a: match[4]
	};
	match = matchers.hsl.exec(color);
	if (match) return {
		h: match[1],
		s: match[2],
		l: match[3]
	};
	match = matchers.hsla.exec(color);
	if (match) return {
		h: match[1],
		s: match[2],
		l: match[3],
		a: match[4]
	};
	match = matchers.hsv.exec(color);
	if (match) return {
		h: match[1],
		s: match[2],
		v: match[3]
	};
	match = matchers.hsva.exec(color);
	if (match) return {
		h: match[1],
		s: match[2],
		v: match[3],
		a: match[4]
	};
	match = matchers.hex8.exec(color);
	if (match) return {
		r: parseIntFromHex(match[1]),
		g: parseIntFromHex(match[2]),
		b: parseIntFromHex(match[3]),
		a: convertHexToDecimal(match[4]),
		format: named ? "name" : "hex8"
	};
	match = matchers.hex6.exec(color);
	if (match) return {
		r: parseIntFromHex(match[1]),
		g: parseIntFromHex(match[2]),
		b: parseIntFromHex(match[3]),
		format: named ? "name" : "hex"
	};
	match = matchers.hex4.exec(color);
	if (match) return {
		r: parseIntFromHex(match[1] + match[1]),
		g: parseIntFromHex(match[2] + match[2]),
		b: parseIntFromHex(match[3] + match[3]),
		a: convertHexToDecimal(match[4] + match[4]),
		format: named ? "name" : "hex8"
	};
	match = matchers.hex3.exec(color);
	if (match) return {
		r: parseIntFromHex(match[1] + match[1]),
		g: parseIntFromHex(match[2] + match[2]),
		b: parseIntFromHex(match[3] + match[3]),
		format: named ? "name" : "hex"
	};
	return false;
}
function isValidCSSUnit(color) {
	return Boolean(matchers.CSS_UNIT.exec(String(color)));
}
var TinyColor = function() {
	function TinyColor$1(color, opts) {
		if (color === void 0) color = "";
		if (opts === void 0) opts = {};
		var _a;
		if (color instanceof TinyColor$1) return color;
		if (typeof color === "number") color = numberInputToObject(color);
		this.originalInput = color;
		var rgb = inputToRGB(color);
		this.originalInput = color;
		this.r = rgb.r;
		this.g = rgb.g;
		this.b = rgb.b;
		this.a = rgb.a;
		this.roundA = Math.round(100 * this.a) / 100;
		this.format = (_a = opts.format) !== null && _a !== void 0 ? _a : rgb.format;
		this.gradientType = opts.gradientType;
		if (this.r < 1) this.r = Math.round(this.r);
		if (this.g < 1) this.g = Math.round(this.g);
		if (this.b < 1) this.b = Math.round(this.b);
		this.isValid = rgb.ok;
	}
	TinyColor$1.prototype.isDark = function() {
		return this.getBrightness() < 128;
	};
	TinyColor$1.prototype.isLight = function() {
		return !this.isDark();
	};
	TinyColor$1.prototype.getBrightness = function() {
		var rgb = this.toRgb();
		return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
	};
	TinyColor$1.prototype.getLuminance = function() {
		var rgb = this.toRgb();
		var R$2;
		var G$2;
		var B$2;
		var RsRGB = rgb.r / 255;
		var GsRGB = rgb.g / 255;
		var BsRGB = rgb.b / 255;
		if (RsRGB <= .03928) R$2 = RsRGB / 12.92;
		else R$2 = Math.pow((RsRGB + .055) / 1.055, 2.4);
		if (GsRGB <= .03928) G$2 = GsRGB / 12.92;
		else G$2 = Math.pow((GsRGB + .055) / 1.055, 2.4);
		if (BsRGB <= .03928) B$2 = BsRGB / 12.92;
		else B$2 = Math.pow((BsRGB + .055) / 1.055, 2.4);
		return .2126 * R$2 + .7152 * G$2 + .0722 * B$2;
	};
	TinyColor$1.prototype.getAlpha = function() {
		return this.a;
	};
	TinyColor$1.prototype.setAlpha = function(alpha$1) {
		this.a = boundAlpha(alpha$1);
		this.roundA = Math.round(100 * this.a) / 100;
		return this;
	};
	TinyColor$1.prototype.isMonochrome = function() {
		return this.toHsl().s === 0;
	};
	TinyColor$1.prototype.toHsv = function() {
		var hsv = rgbToHsv(this.r, this.g, this.b);
		return {
			h: hsv.h * 360,
			s: hsv.s,
			v: hsv.v,
			a: this.a
		};
	};
	TinyColor$1.prototype.toHsvString = function() {
		var hsv = rgbToHsv(this.r, this.g, this.b);
		var h$2 = Math.round(hsv.h * 360);
		var s = Math.round(hsv.s * 100);
		var v$1 = Math.round(hsv.v * 100);
		return this.a === 1 ? "hsv(".concat(h$2, ", ").concat(s, "%, ").concat(v$1, "%)") : "hsva(".concat(h$2, ", ").concat(s, "%, ").concat(v$1, "%, ").concat(this.roundA, ")");
	};
	TinyColor$1.prototype.toHsl = function() {
		var hsl = rgbToHsl(this.r, this.g, this.b);
		return {
			h: hsl.h * 360,
			s: hsl.s,
			l: hsl.l,
			a: this.a
		};
	};
	TinyColor$1.prototype.toHslString = function() {
		var hsl = rgbToHsl(this.r, this.g, this.b);
		var h$2 = Math.round(hsl.h * 360);
		var s = Math.round(hsl.s * 100);
		var l = Math.round(hsl.l * 100);
		return this.a === 1 ? "hsl(".concat(h$2, ", ").concat(s, "%, ").concat(l, "%)") : "hsla(".concat(h$2, ", ").concat(s, "%, ").concat(l, "%, ").concat(this.roundA, ")");
	};
	TinyColor$1.prototype.toHex = function(allow3Char) {
		if (allow3Char === void 0) allow3Char = false;
		return rgbToHex(this.r, this.g, this.b, allow3Char);
	};
	TinyColor$1.prototype.toHexString = function(allow3Char) {
		if (allow3Char === void 0) allow3Char = false;
		return "#" + this.toHex(allow3Char);
	};
	TinyColor$1.prototype.toHex8 = function(allow4Char) {
		if (allow4Char === void 0) allow4Char = false;
		return rgbaToHex(this.r, this.g, this.b, this.a, allow4Char);
	};
	TinyColor$1.prototype.toHex8String = function(allow4Char) {
		if (allow4Char === void 0) allow4Char = false;
		return "#" + this.toHex8(allow4Char);
	};
	TinyColor$1.prototype.toHexShortString = function(allowShortChar) {
		if (allowShortChar === void 0) allowShortChar = false;
		return this.a === 1 ? this.toHexString(allowShortChar) : this.toHex8String(allowShortChar);
	};
	TinyColor$1.prototype.toRgb = function() {
		return {
			r: Math.round(this.r),
			g: Math.round(this.g),
			b: Math.round(this.b),
			a: this.a
		};
	};
	TinyColor$1.prototype.toRgbString = function() {
		var r = Math.round(this.r);
		var g$1 = Math.round(this.g);
		var b$2 = Math.round(this.b);
		return this.a === 1 ? "rgb(".concat(r, ", ").concat(g$1, ", ").concat(b$2, ")") : "rgba(".concat(r, ", ").concat(g$1, ", ").concat(b$2, ", ").concat(this.roundA, ")");
	};
	TinyColor$1.prototype.toPercentageRgb = function() {
		var fmt = function(x$2) {
			return "".concat(Math.round(bound01$1(x$2, 255) * 100), "%");
		};
		return {
			r: fmt(this.r),
			g: fmt(this.g),
			b: fmt(this.b),
			a: this.a
		};
	};
	TinyColor$1.prototype.toPercentageRgbString = function() {
		var rnd = function(x$2) {
			return Math.round(bound01$1(x$2, 255) * 100);
		};
		return this.a === 1 ? "rgb(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%)") : "rgba(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%, ").concat(this.roundA, ")");
	};
	TinyColor$1.prototype.toName = function() {
		if (this.a === 0) return "transparent";
		if (this.a < 1) return false;
		var hex = "#" + rgbToHex(this.r, this.g, this.b, false);
		for (var _i = 0, _a = Object.entries(names); _i < _a.length; _i++) {
			var _b = _a[_i], key$2 = _b[0];
			if (hex === _b[1]) return key$2;
		}
		return false;
	};
	TinyColor$1.prototype.toString = function(format$1) {
		var formatSet = Boolean(format$1);
		format$1 = format$1 !== null && format$1 !== void 0 ? format$1 : this.format;
		var formattedString = false;
		var hasAlpha = this.a < 1 && this.a >= 0;
		if (!formatSet && hasAlpha && (format$1.startsWith("hex") || format$1 === "name")) {
			if (format$1 === "name" && this.a === 0) return this.toName();
			return this.toRgbString();
		}
		if (format$1 === "rgb") formattedString = this.toRgbString();
		if (format$1 === "prgb") formattedString = this.toPercentageRgbString();
		if (format$1 === "hex" || format$1 === "hex6") formattedString = this.toHexString();
		if (format$1 === "hex3") formattedString = this.toHexString(true);
		if (format$1 === "hex4") formattedString = this.toHex8String(true);
		if (format$1 === "hex8") formattedString = this.toHex8String();
		if (format$1 === "name") formattedString = this.toName();
		if (format$1 === "hsl") formattedString = this.toHslString();
		if (format$1 === "hsv") formattedString = this.toHsvString();
		return formattedString || this.toHexString();
	};
	TinyColor$1.prototype.toNumber = function() {
		return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
	};
	TinyColor$1.prototype.clone = function() {
		return new TinyColor$1(this.toString());
	};
	TinyColor$1.prototype.lighten = function(amount) {
		if (amount === void 0) amount = 10;
		var hsl = this.toHsl();
		hsl.l += amount / 100;
		hsl.l = clamp01(hsl.l);
		return new TinyColor$1(hsl);
	};
	TinyColor$1.prototype.brighten = function(amount) {
		if (amount === void 0) amount = 10;
		var rgb = this.toRgb();
		rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
		rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
		rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
		return new TinyColor$1(rgb);
	};
	TinyColor$1.prototype.darken = function(amount) {
		if (amount === void 0) amount = 10;
		var hsl = this.toHsl();
		hsl.l -= amount / 100;
		hsl.l = clamp01(hsl.l);
		return new TinyColor$1(hsl);
	};
	TinyColor$1.prototype.tint = function(amount) {
		if (amount === void 0) amount = 10;
		return this.mix("white", amount);
	};
	TinyColor$1.prototype.shade = function(amount) {
		if (amount === void 0) amount = 10;
		return this.mix("black", amount);
	};
	TinyColor$1.prototype.desaturate = function(amount) {
		if (amount === void 0) amount = 10;
		var hsl = this.toHsl();
		hsl.s -= amount / 100;
		hsl.s = clamp01(hsl.s);
		return new TinyColor$1(hsl);
	};
	TinyColor$1.prototype.saturate = function(amount) {
		if (amount === void 0) amount = 10;
		var hsl = this.toHsl();
		hsl.s += amount / 100;
		hsl.s = clamp01(hsl.s);
		return new TinyColor$1(hsl);
	};
	TinyColor$1.prototype.greyscale = function() {
		return this.desaturate(100);
	};
	TinyColor$1.prototype.spin = function(amount) {
		var hsl = this.toHsl();
		var hue = (hsl.h + amount) % 360;
		hsl.h = hue < 0 ? 360 + hue : hue;
		return new TinyColor$1(hsl);
	};
	TinyColor$1.prototype.mix = function(color, amount) {
		if (amount === void 0) amount = 50;
		var rgb1 = this.toRgb();
		var rgb2 = new TinyColor$1(color).toRgb();
		var p$1 = amount / 100;
		return new TinyColor$1({
			r: (rgb2.r - rgb1.r) * p$1 + rgb1.r,
			g: (rgb2.g - rgb1.g) * p$1 + rgb1.g,
			b: (rgb2.b - rgb1.b) * p$1 + rgb1.b,
			a: (rgb2.a - rgb1.a) * p$1 + rgb1.a
		});
	};
	TinyColor$1.prototype.analogous = function(results, slices) {
		if (results === void 0) results = 6;
		if (slices === void 0) slices = 30;
		var hsl = this.toHsl();
		var part$1 = 360 / slices;
		var ret = [this];
		for (hsl.h = (hsl.h - (part$1 * results >> 1) + 720) % 360; --results;) {
			hsl.h = (hsl.h + part$1) % 360;
			ret.push(new TinyColor$1(hsl));
		}
		return ret;
	};
	TinyColor$1.prototype.complement = function() {
		var hsl = this.toHsl();
		hsl.h = (hsl.h + 180) % 360;
		return new TinyColor$1(hsl);
	};
	TinyColor$1.prototype.monochromatic = function(results) {
		if (results === void 0) results = 6;
		var hsv = this.toHsv();
		var h$2 = hsv.h;
		var s = hsv.s;
		var v$1 = hsv.v;
		var res = [];
		var modification = 1 / results;
		while (results--) {
			res.push(new TinyColor$1({
				h: h$2,
				s,
				v: v$1
			}));
			v$1 = (v$1 + modification) % 1;
		}
		return res;
	};
	TinyColor$1.prototype.splitcomplement = function() {
		var hsl = this.toHsl();
		var h$2 = hsl.h;
		return [
			this,
			new TinyColor$1({
				h: (h$2 + 72) % 360,
				s: hsl.s,
				l: hsl.l
			}),
			new TinyColor$1({
				h: (h$2 + 216) % 360,
				s: hsl.s,
				l: hsl.l
			})
		];
	};
	TinyColor$1.prototype.onBackground = function(background) {
		var fg = this.toRgb();
		var bg = new TinyColor$1(background).toRgb();
		var alpha$1 = fg.a + bg.a * (1 - fg.a);
		return new TinyColor$1({
			r: (fg.r * fg.a + bg.r * bg.a * (1 - fg.a)) / alpha$1,
			g: (fg.g * fg.a + bg.g * bg.a * (1 - fg.a)) / alpha$1,
			b: (fg.b * fg.a + bg.b * bg.a * (1 - fg.a)) / alpha$1,
			a: alpha$1
		});
	};
	TinyColor$1.prototype.triad = function() {
		return this.polyad(3);
	};
	TinyColor$1.prototype.tetrad = function() {
		return this.polyad(4);
	};
	TinyColor$1.prototype.polyad = function(n) {
		var hsl = this.toHsl();
		var h$2 = hsl.h;
		var result = [this];
		var increment = 360 / n;
		for (var i$1 = 1; i$1 < n; i$1++) result.push(new TinyColor$1({
			h: (h$2 + i$1 * increment) % 360,
			s: hsl.s,
			l: hsl.l
		}));
		return result;
	};
	TinyColor$1.prototype.equals = function(color) {
		return this.toRgbString() === new TinyColor$1(color).toRgbString();
	};
	return TinyColor$1;
}();
function darken(color, amount = 20) {
	return color.mix("#141414", amount).toString();
}
function useButtonCustomStyle(props) {
	const _disabled = useFormDisabled();
	const ns = useNamespace("button");
	return computed(() => {
		let styles = {};
		const buttonColor = props.color;
		if (buttonColor) {
			const color = new TinyColor(buttonColor);
			const activeBgColor = props.dark ? color.tint(20).toString() : darken(color, 20);
			if (props.plain) {
				styles = ns.cssVarBlock({
					"bg-color": props.dark ? darken(color, 90) : color.tint(90).toString(),
					"text-color": buttonColor,
					"border-color": props.dark ? darken(color, 50) : color.tint(50).toString(),
					"hover-text-color": `var(${ns.cssVarName("color-white")})`,
					"hover-bg-color": buttonColor,
					"hover-border-color": buttonColor,
					"active-bg-color": activeBgColor,
					"active-text-color": `var(${ns.cssVarName("color-white")})`,
					"active-border-color": activeBgColor
				});
				if (_disabled.value) {
					styles[ns.cssVarBlockName("disabled-bg-color")] = props.dark ? darken(color, 90) : color.tint(90).toString();
					styles[ns.cssVarBlockName("disabled-text-color")] = props.dark ? darken(color, 50) : color.tint(50).toString();
					styles[ns.cssVarBlockName("disabled-border-color")] = props.dark ? darken(color, 80) : color.tint(80).toString();
				}
			} else {
				const hoverBgColor = props.dark ? darken(color, 30) : color.tint(30).toString();
				const textColor = color.isDark() ? `var(${ns.cssVarName("color-white")})` : `var(${ns.cssVarName("color-black")})`;
				styles = ns.cssVarBlock({
					"bg-color": buttonColor,
					"text-color": textColor,
					"border-color": buttonColor,
					"hover-bg-color": hoverBgColor,
					"hover-text-color": textColor,
					"hover-border-color": hoverBgColor,
					"active-bg-color": activeBgColor,
					"active-border-color": activeBgColor
				});
				if (_disabled.value) {
					const disabledButtonColor = props.dark ? darken(color, 50) : color.tint(50).toString();
					styles[ns.cssVarBlockName("disabled-bg-color")] = disabledButtonColor;
					styles[ns.cssVarBlockName("disabled-text-color")] = props.dark ? "rgba(255, 255, 255, 0.5)" : `var(${ns.cssVarName("color-white")})`;
					styles[ns.cssVarBlockName("disabled-border-color")] = disabledButtonColor;
				}
			}
		}
		return styles;
	});
}
var Button = /* @__PURE__ */ _export_sfc(/* @__PURE__ */ defineComponent({
	...defineComponent({ name: "ElButton" }),
	props: buttonProps,
	emits: buttonEmits,
	setup(__props, { expose, emit }) {
		const props = __props;
		const buttonStyle = useButtonCustomStyle(props);
		const ns = useNamespace("button");
		const { _ref, _size, _type, _disabled, _props, shouldAddSpace, handleClick } = useButton(props, emit);
		expose({
			ref: _ref,
			size: _size,
			type: _type,
			disabled: _disabled,
			shouldAddSpace
		});
		return (_ctx, _cache) => {
			return openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), mergeProps({
				ref_key: "_ref",
				ref: _ref
			}, unref(_props), {
				class: [
					unref(ns).b(),
					unref(ns).m(unref(_type)),
					unref(ns).m(unref(_size)),
					unref(ns).is("disabled", unref(_disabled)),
					unref(ns).is("loading", _ctx.loading),
					unref(ns).is("plain", _ctx.plain),
					unref(ns).is("round", _ctx.round),
					unref(ns).is("circle", _ctx.circle),
					unref(ns).is("text", _ctx.text),
					unref(ns).is("link", _ctx.link),
					unref(ns).is("has-bg", _ctx.bg)
				],
				style: unref(buttonStyle),
				onClick: unref(handleClick)
			}), {
				default: withCtx(() => [_ctx.loading ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [_ctx.$slots.loading ? renderSlot(_ctx.$slots, "loading", { key: 0 }) : (openBlock(), createBlock(unref(ElIcon), {
					key: 1,
					class: normalizeClass(unref(ns).is("loading"))
				}, {
					default: withCtx(() => [(openBlock(), createBlock(resolveDynamicComponent(_ctx.loadingIcon)))]),
					_: 1
				}, 8, ["class"]))], 64)) : _ctx.icon || _ctx.$slots.icon ? (openBlock(), createBlock(unref(ElIcon), { key: 1 }, {
					default: withCtx(() => [_ctx.icon ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.icon), { key: 0 })) : renderSlot(_ctx.$slots, "icon", { key: 1 })]),
					_: 3
				})) : createCommentVNode("v-if", true), _ctx.$slots.default ? (openBlock(), createElementBlock("span", {
					key: 2,
					class: normalizeClass({ [unref(ns).em("text", "expand")]: unref(shouldAddSpace) })
				}, [renderSlot(_ctx.$slots, "default")], 2)) : createCommentVNode("v-if", true)]),
				_: 3
			}, 16, [
				"class",
				"style",
				"onClick"
			]);
		};
	}
}), [["__file", "/home/runner/work/element-plus/element-plus/packages/components/button/src/button.vue"]]);
var buttonGroupProps = {
	size: buttonProps.size,
	type: buttonProps.type
};
var ButtonGroup = /* @__PURE__ */ _export_sfc(/* @__PURE__ */ defineComponent({
	...defineComponent({ name: "ElButtonGroup" }),
	props: buttonGroupProps,
	setup(__props) {
		const props = __props;
		provide(buttonGroupContextKey, reactive({
			size: toRef(props, "size"),
			type: toRef(props, "type")
		}));
		const ns = useNamespace("button");
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", { class: normalizeClass(`${unref(ns).b("group")}`) }, [renderSlot(_ctx.$slots, "default")], 2);
		};
	}
}), [["__file", "/home/runner/work/element-plus/element-plus/packages/components/button/src/button-group.vue"]]);
var ElButton = withInstall(Button, { ButtonGroup });
withNoopInstall(ButtonGroup);
var nodeList = /* @__PURE__ */ new Map();
var startClick;
if (isClient$1) {
	document.addEventListener("mousedown", (e) => startClick = e);
	document.addEventListener("mouseup", (e) => {
		for (const handlers of nodeList.values()) for (const { documentHandler } of handlers) documentHandler(e, startClick);
	});
}
function createDocumentHandler(el$2, binding) {
	let excludes = [];
	if (Array.isArray(binding.arg)) excludes = binding.arg;
	else if (isElement(binding.arg)) excludes.push(binding.arg);
	return function(mouseup, mousedown) {
		const popperRef = binding.instance.popperRef;
		const mouseUpTarget = mouseup.target;
		const mouseDownTarget = mousedown == null ? void 0 : mousedown.target;
		const isBound = !binding || !binding.instance;
		const isTargetExists = !mouseUpTarget || !mouseDownTarget;
		const isContainedByEl = el$2.contains(mouseUpTarget) || el$2.contains(mouseDownTarget);
		const isSelf = el$2 === mouseUpTarget;
		const isTargetExcluded = excludes.length && excludes.some((item$4) => item$4 == null ? void 0 : item$4.contains(mouseUpTarget)) || excludes.length && excludes.includes(mouseDownTarget);
		const isContainedByPopper = popperRef && (popperRef.contains(mouseUpTarget) || popperRef.contains(mouseDownTarget));
		if (isBound || isTargetExists || isContainedByEl || isSelf || isTargetExcluded || isContainedByPopper) return;
		binding.value(mouseup, mousedown);
	};
}
var ClickOutside = {
	beforeMount(el$2, binding) {
		if (!nodeList.has(el$2)) nodeList.set(el$2, []);
		nodeList.get(el$2).push({
			documentHandler: createDocumentHandler(el$2, binding),
			bindingFn: binding.value
		});
	},
	updated(el$2, binding) {
		if (!nodeList.has(el$2)) nodeList.set(el$2, []);
		const handlers = nodeList.get(el$2);
		const oldHandlerIndex = handlers.findIndex((item$4) => item$4.bindingFn === binding.oldValue);
		const newHandler = {
			documentHandler: createDocumentHandler(el$2, binding),
			bindingFn: binding.value
		};
		if (oldHandlerIndex >= 0) handlers.splice(oldHandlerIndex, 1, newHandler);
		else handlers.push(newHandler);
	},
	unmounted(el$2) {
		nodeList.delete(el$2);
	}
};
init_shared_esm_bundler();
var vRepeatClick = { beforeMount(el$2, binding) {
	const value = binding.value;
	const { interval = 100, delay = 600 } = isFunction$2(value) ? {} : value;
	let intervalId;
	let delayId;
	const handler = () => isFunction$2(value) ? value() : value.handler();
	const clear = () => {
		if (delayId) {
			clearTimeout(delayId);
			delayId = void 0;
		}
		if (intervalId) {
			clearInterval(intervalId);
			intervalId = void 0;
		}
	};
	el$2.addEventListener("mousedown", (evt) => {
		if (evt.button !== 0) return;
		clear();
		handler();
		document.addEventListener("mouseup", () => clear(), { once: true });
		delayId = setTimeout(() => {
			intervalId = setInterval(() => {
				handler();
			}, interval);
		}, delay);
	});
} };
init_shared_esm_bundler();
var checkboxProps = {
	modelValue: {
		type: [
			Number,
			String,
			Boolean
		],
		default: void 0
	},
	label: {
		type: [
			String,
			Boolean,
			Number,
			Object
		],
		default: void 0
	},
	indeterminate: Boolean,
	disabled: Boolean,
	checked: Boolean,
	name: {
		type: String,
		default: void 0
	},
	trueLabel: {
		type: [String, Number],
		default: void 0
	},
	falseLabel: {
		type: [String, Number],
		default: void 0
	},
	id: {
		type: String,
		default: void 0
	},
	controls: {
		type: String,
		default: void 0
	},
	border: Boolean,
	size: useSizeProp,
	tabindex: [String, Number],
	validateEvent: {
		type: Boolean,
		default: true
	}
};
var checkboxEmits = {
	[UPDATE_MODEL_EVENT]: (val) => isString$2(val) || isNumber(val) || isBoolean(val),
	change: (val) => isString$2(val) || isNumber(val) || isBoolean(val)
};
var checkboxGroupContextKey = Symbol("checkboxGroupContextKey");
var useCheckboxDisabled = ({ model, isChecked }) => {
	const checkboxGroup = inject(checkboxGroupContextKey, void 0);
	const isLimitDisabled = computed(() => {
		var _a, _b;
		const max$2 = (_a = checkboxGroup == null ? void 0 : checkboxGroup.max) == null ? void 0 : _a.value;
		const min$2 = (_b = checkboxGroup == null ? void 0 : checkboxGroup.min) == null ? void 0 : _b.value;
		return !isUndefined(max$2) && model.value.length >= max$2 && !isChecked.value || !isUndefined(min$2) && model.value.length <= min$2 && isChecked.value;
	});
	return {
		isDisabled: useFormDisabled(computed(() => (checkboxGroup == null ? void 0 : checkboxGroup.disabled.value) || isLimitDisabled.value)),
		isLimitDisabled
	};
};
var useCheckboxEvent = (props, { model, isLimitExceeded, hasOwnLabel, isDisabled, isLabeledByFormItem }) => {
	const checkboxGroup = inject(checkboxGroupContextKey, void 0);
	const { formItem } = useFormItem();
	const { emit } = getCurrentInstance();
	function getLabeledValue(value) {
		var _a, _b;
		return value === props.trueLabel || value === true ? (_a = props.trueLabel) != null ? _a : true : (_b = props.falseLabel) != null ? _b : false;
	}
	function emitChangeEvent(checked, e) {
		emit("change", getLabeledValue(checked), e);
	}
	function handleChange(e) {
		if (isLimitExceeded.value) return;
		const target$1 = e.target;
		emit("change", getLabeledValue(target$1.checked), e);
	}
	async function onClickRoot(e) {
		if (isLimitExceeded.value) return;
		if (!hasOwnLabel.value && !isDisabled.value && isLabeledByFormItem.value) {
			if (!e.composedPath().some((item$4) => item$4.tagName === "LABEL")) {
				model.value = getLabeledValue([false, props.falseLabel].includes(model.value));
				await nextTick();
				emitChangeEvent(model.value, e);
			}
		}
	}
	const validateEvent = computed(() => (checkboxGroup == null ? void 0 : checkboxGroup.validateEvent) || props.validateEvent);
	watch(() => props.modelValue, () => {
		if (validateEvent.value) formItem?.validate("change").catch((err) => debugWarn(err));
	});
	return {
		handleChange,
		onClickRoot
	};
};
init_shared_esm_bundler();
var useCheckboxModel = (props) => {
	const selfModel = ref(false);
	const { emit } = getCurrentInstance();
	const checkboxGroup = inject(checkboxGroupContextKey, void 0);
	const isGroup = computed(() => isUndefined(checkboxGroup) === false);
	const isLimitExceeded = ref(false);
	return {
		model: computed({
			get() {
				var _a, _b;
				return isGroup.value ? (_a = checkboxGroup == null ? void 0 : checkboxGroup.modelValue) == null ? void 0 : _a.value : (_b = props.modelValue) != null ? _b : selfModel.value;
			},
			set(val) {
				var _a, _b;
				if (isGroup.value && isArray(val)) {
					isLimitExceeded.value = ((_a = checkboxGroup == null ? void 0 : checkboxGroup.max) == null ? void 0 : _a.value) !== void 0 && val.length > (checkboxGroup == null ? void 0 : checkboxGroup.max.value);
					isLimitExceeded.value === false && ((_b = checkboxGroup == null ? void 0 : checkboxGroup.changeEvent) == null || _b.call(checkboxGroup, val));
				} else {
					emit(UPDATE_MODEL_EVENT, val);
					selfModel.value = val;
				}
			}
		}),
		isGroup,
		isLimitExceeded
	};
};
init_shared_esm_bundler();
var useCheckboxStatus = (props, slots, { model }) => {
	const checkboxGroup = inject(checkboxGroupContextKey, void 0);
	const isFocused = ref(false);
	const isChecked = computed(() => {
		const value = model.value;
		if (isBoolean(value)) return value;
		else if (isArray(value)) if (isObject$2(props.label)) return value.map(toRaw).some((o$1) => isEqual_default(o$1, props.label));
		else return value.map(toRaw).includes(props.label);
		else if (value !== null && value !== void 0) return value === props.trueLabel;
		else return !!value;
	});
	return {
		checkboxButtonSize: useFormSize(computed(() => {
			var _a;
			return (_a = checkboxGroup == null ? void 0 : checkboxGroup.size) == null ? void 0 : _a.value;
		}), { prop: true }),
		isChecked,
		isFocused,
		checkboxSize: useFormSize(computed(() => {
			var _a;
			return (_a = checkboxGroup == null ? void 0 : checkboxGroup.size) == null ? void 0 : _a.value;
		})),
		hasOwnLabel: computed(() => {
			return !!slots.default || !isNil_default(props.label);
		})
	};
};
init_shared_esm_bundler();
var setStoreValue = (props, { model }) => {
	function addToStore() {
		if (isArray(model.value) && !model.value.includes(props.label)) model.value.push(props.label);
		else model.value = props.trueLabel || true;
	}
	props.checked && addToStore();
};
var useCheckbox = (props, slots) => {
	const { formItem: elFormItem } = useFormItem();
	const { model, isGroup, isLimitExceeded } = useCheckboxModel(props);
	const { isFocused, isChecked, checkboxButtonSize, checkboxSize, hasOwnLabel } = useCheckboxStatus(props, slots, { model });
	const { isDisabled } = useCheckboxDisabled({
		model,
		isChecked
	});
	const { inputId, isLabeledByFormItem } = useFormItemInputId(props, {
		formItemContext: elFormItem,
		disableIdGeneration: hasOwnLabel,
		disableIdManagement: isGroup
	});
	const { handleChange, onClickRoot } = useCheckboxEvent(props, {
		model,
		isLimitExceeded,
		hasOwnLabel,
		isDisabled,
		isLabeledByFormItem
	});
	setStoreValue(props, { model });
	return {
		inputId,
		isLabeledByFormItem,
		isChecked,
		isDisabled,
		isFocused,
		checkboxButtonSize,
		checkboxSize,
		hasOwnLabel,
		model,
		handleChange,
		onClickRoot
	};
};
var _hoisted_1$59 = [
	"id",
	"indeterminate",
	"name",
	"tabindex",
	"disabled",
	"true-value",
	"false-value"
];
var _hoisted_2$36 = [
	"id",
	"indeterminate",
	"disabled",
	"value",
	"name",
	"tabindex"
];
var Checkbox = /* @__PURE__ */ _export_sfc(/* @__PURE__ */ defineComponent({
	...defineComponent({ name: "ElCheckbox" }),
	props: checkboxProps,
	emits: checkboxEmits,
	setup(__props) {
		const props = __props;
		const { inputId, isLabeledByFormItem, isChecked, isDisabled, isFocused, checkboxSize, hasOwnLabel, model, handleChange, onClickRoot } = useCheckbox(props, useSlots());
		const ns = useNamespace("checkbox");
		const compKls = computed(() => {
			return [
				ns.b(),
				ns.m(checkboxSize.value),
				ns.is("disabled", isDisabled.value),
				ns.is("bordered", props.border),
				ns.is("checked", isChecked.value)
			];
		});
		const spanKls = computed(() => {
			return [
				ns.e("input"),
				ns.is("disabled", isDisabled.value),
				ns.is("checked", isChecked.value),
				ns.is("indeterminate", props.indeterminate),
				ns.is("focus", isFocused.value)
			];
		});
		return (_ctx, _cache) => {
			return openBlock(), createBlock(resolveDynamicComponent(!unref(hasOwnLabel) && unref(isLabeledByFormItem) ? "span" : "label"), {
				class: normalizeClass(unref(compKls)),
				"aria-controls": _ctx.indeterminate ? _ctx.controls : null,
				onClick: unref(onClickRoot)
			}, {
				default: withCtx(() => [createBaseVNode("span", { class: normalizeClass(unref(spanKls)) }, [_ctx.trueLabel || _ctx.falseLabel ? withDirectives((openBlock(), createElementBlock("input", {
					key: 0,
					id: unref(inputId),
					"onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(model) ? model.value = $event : null),
					class: normalizeClass(unref(ns).e("original")),
					type: "checkbox",
					indeterminate: _ctx.indeterminate,
					name: _ctx.name,
					tabindex: _ctx.tabindex,
					disabled: unref(isDisabled),
					"true-value": _ctx.trueLabel,
					"false-value": _ctx.falseLabel,
					onChange: _cache[1] || (_cache[1] = (...args) => unref(handleChange) && unref(handleChange)(...args)),
					onFocus: _cache[2] || (_cache[2] = ($event) => isFocused.value = true),
					onBlur: _cache[3] || (_cache[3] = ($event) => isFocused.value = false),
					onClick: _cache[4] || (_cache[4] = withModifiers(() => {}, ["stop"]))
				}, null, 42, _hoisted_1$59)), [[vModelCheckbox, unref(model)]]) : withDirectives((openBlock(), createElementBlock("input", {
					key: 1,
					id: unref(inputId),
					"onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => isRef(model) ? model.value = $event : null),
					class: normalizeClass(unref(ns).e("original")),
					type: "checkbox",
					indeterminate: _ctx.indeterminate,
					disabled: unref(isDisabled),
					value: _ctx.label,
					name: _ctx.name,
					tabindex: _ctx.tabindex,
					onChange: _cache[6] || (_cache[6] = (...args) => unref(handleChange) && unref(handleChange)(...args)),
					onFocus: _cache[7] || (_cache[7] = ($event) => isFocused.value = true),
					onBlur: _cache[8] || (_cache[8] = ($event) => isFocused.value = false),
					onClick: _cache[9] || (_cache[9] = withModifiers(() => {}, ["stop"]))
				}, null, 42, _hoisted_2$36)), [[vModelCheckbox, unref(model)]]), createBaseVNode("span", { class: normalizeClass(unref(ns).e("inner")) }, null, 2)], 2), unref(hasOwnLabel) ? (openBlock(), createElementBlock("span", {
					key: 0,
					class: normalizeClass(unref(ns).e("label"))
				}, [renderSlot(_ctx.$slots, "default"), !_ctx.$slots.default ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [createTextVNode(toDisplayString(_ctx.label), 1)], 64)) : createCommentVNode("v-if", true)], 2)) : createCommentVNode("v-if", true)]),
				_: 3
			}, 8, [
				"class",
				"aria-controls",
				"onClick"
			]);
		};
	}
}), [["__file", "/home/runner/work/element-plus/element-plus/packages/components/checkbox/src/checkbox.vue"]]);
var _hoisted_1$58 = [
	"name",
	"tabindex",
	"disabled",
	"true-value",
	"false-value"
];
var _hoisted_2$35 = [
	"name",
	"tabindex",
	"disabled",
	"value"
];
var CheckboxButton = /* @__PURE__ */ _export_sfc(/* @__PURE__ */ defineComponent({
	...defineComponent({ name: "ElCheckboxButton" }),
	props: checkboxProps,
	emits: checkboxEmits,
	setup(__props) {
		const { isFocused, isChecked, isDisabled, checkboxButtonSize, model, handleChange } = useCheckbox(__props, useSlots());
		const checkboxGroup = inject(checkboxGroupContextKey, void 0);
		const ns = useNamespace("checkbox");
		const activeStyle = computed(() => {
			var _a, _b, _c, _d;
			const fillValue = (_b = (_a = checkboxGroup == null ? void 0 : checkboxGroup.fill) == null ? void 0 : _a.value) != null ? _b : "";
			return {
				backgroundColor: fillValue,
				borderColor: fillValue,
				color: (_d = (_c = checkboxGroup == null ? void 0 : checkboxGroup.textColor) == null ? void 0 : _c.value) != null ? _d : "",
				boxShadow: fillValue ? `-1px 0 0 0 ${fillValue}` : void 0
			};
		});
		const labelKls = computed(() => {
			return [
				ns.b("button"),
				ns.bm("button", checkboxButtonSize.value),
				ns.is("disabled", isDisabled.value),
				ns.is("checked", isChecked.value),
				ns.is("focus", isFocused.value)
			];
		});
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("label", { class: normalizeClass(unref(labelKls)) }, [_ctx.trueLabel || _ctx.falseLabel ? withDirectives((openBlock(), createElementBlock("input", {
				key: 0,
				"onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(model) ? model.value = $event : null),
				class: normalizeClass(unref(ns).be("button", "original")),
				type: "checkbox",
				name: _ctx.name,
				tabindex: _ctx.tabindex,
				disabled: unref(isDisabled),
				"true-value": _ctx.trueLabel,
				"false-value": _ctx.falseLabel,
				onChange: _cache[1] || (_cache[1] = (...args) => unref(handleChange) && unref(handleChange)(...args)),
				onFocus: _cache[2] || (_cache[2] = ($event) => isFocused.value = true),
				onBlur: _cache[3] || (_cache[3] = ($event) => isFocused.value = false),
				onClick: _cache[4] || (_cache[4] = withModifiers(() => {}, ["stop"]))
			}, null, 42, _hoisted_1$58)), [[vModelCheckbox, unref(model)]]) : withDirectives((openBlock(), createElementBlock("input", {
				key: 1,
				"onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => isRef(model) ? model.value = $event : null),
				class: normalizeClass(unref(ns).be("button", "original")),
				type: "checkbox",
				name: _ctx.name,
				tabindex: _ctx.tabindex,
				disabled: unref(isDisabled),
				value: _ctx.label,
				onChange: _cache[6] || (_cache[6] = (...args) => unref(handleChange) && unref(handleChange)(...args)),
				onFocus: _cache[7] || (_cache[7] = ($event) => isFocused.value = true),
				onBlur: _cache[8] || (_cache[8] = ($event) => isFocused.value = false),
				onClick: _cache[9] || (_cache[9] = withModifiers(() => {}, ["stop"]))
			}, null, 42, _hoisted_2$35)), [[vModelCheckbox, unref(model)]]), _ctx.$slots.default || _ctx.label ? (openBlock(), createElementBlock("span", {
				key: 2,
				class: normalizeClass(unref(ns).be("button", "inner")),
				style: normalizeStyle(unref(isChecked) ? unref(activeStyle) : void 0)
			}, [renderSlot(_ctx.$slots, "default", {}, () => [createTextVNode(toDisplayString(_ctx.label), 1)])], 6)) : createCommentVNode("v-if", true)], 2);
		};
	}
}), [["__file", "/home/runner/work/element-plus/element-plus/packages/components/checkbox/src/checkbox-button.vue"]]);
init_shared_esm_bundler();
var checkboxGroupProps = buildProps({
	modelValue: {
		type: definePropType(Array),
		default: () => []
	},
	disabled: Boolean,
	min: Number,
	max: Number,
	size: useSizeProp,
	label: String,
	fill: String,
	textColor: String,
	tag: {
		type: String,
		default: "div"
	},
	validateEvent: {
		type: Boolean,
		default: true
	}
});
var checkboxGroupEmits = {
	[UPDATE_MODEL_EVENT]: (val) => isArray(val),
	change: (val) => isArray(val)
};
var CheckboxGroup = /* @__PURE__ */ _export_sfc(/* @__PURE__ */ defineComponent({
	...defineComponent({ name: "ElCheckboxGroup" }),
	props: checkboxGroupProps,
	emits: checkboxGroupEmits,
	setup(__props, { emit }) {
		const props = __props;
		const ns = useNamespace("checkbox");
		const { formItem } = useFormItem();
		const { inputId: groupId, isLabeledByFormItem } = useFormItemInputId(props, { formItemContext: formItem });
		const changeEvent = async (value) => {
			emit(UPDATE_MODEL_EVENT, value);
			await nextTick();
			emit("change", value);
		};
		const modelValue = computed({
			get() {
				return props.modelValue;
			},
			set(val) {
				changeEvent(val);
			}
		});
		provide(checkboxGroupContextKey, {
			...pick_default(toRefs(props), [
				"size",
				"min",
				"max",
				"disabled",
				"validateEvent",
				"fill",
				"textColor"
			]),
			modelValue,
			changeEvent
		});
		watch(() => props.modelValue, () => {
			if (props.validateEvent) formItem?.validate("change").catch((err) => debugWarn(err));
		});
		return (_ctx, _cache) => {
			var _a;
			return openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), {
				id: unref(groupId),
				class: normalizeClass(unref(ns).b("group")),
				role: "group",
				"aria-label": !unref(isLabeledByFormItem) ? _ctx.label || "checkbox-group" : void 0,
				"aria-labelledby": unref(isLabeledByFormItem) ? (_a = unref(formItem)) == null ? void 0 : _a.labelId : void 0
			}, {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 8, [
				"id",
				"class",
				"aria-label",
				"aria-labelledby"
			]);
		};
	}
}), [["__file", "/home/runner/work/element-plus/element-plus/packages/components/checkbox/src/checkbox-group.vue"]]);
var ElCheckbox = withInstall(Checkbox, {
	CheckboxButton,
	CheckboxGroup
});
withNoopInstall(CheckboxButton);
withNoopInstall(CheckboxGroup);
var tagProps = buildProps({
	type: {
		type: String,
		values: [
			"success",
			"info",
			"warning",
			"danger",
			""
		],
		default: ""
	},
	closable: Boolean,
	disableTransitions: Boolean,
	hit: Boolean,
	color: {
		type: String,
		default: ""
	},
	size: {
		type: String,
		values: componentSizes,
		default: ""
	},
	effect: {
		type: String,
		values: [
			"dark",
			"light",
			"plain"
		],
		default: "light"
	},
	round: Boolean
});
var tagEmits = {
	close: (evt) => evt instanceof MouseEvent,
	click: (evt) => evt instanceof MouseEvent
};
var ElTag = withInstall(/* @__PURE__ */ _export_sfc(/* @__PURE__ */ defineComponent({
	...defineComponent({ name: "ElTag" }),
	props: tagProps,
	emits: tagEmits,
	setup(__props, { emit }) {
		const props = __props;
		const tagSize = useFormSize();
		const ns = useNamespace("tag");
		const containerKls = computed(() => {
			const { type, hit, effect, closable, round: round$2 } = props;
			return [
				ns.b(),
				ns.is("closable", closable),
				ns.m(type),
				ns.m(tagSize.value),
				ns.m(effect),
				ns.is("hit", hit),
				ns.is("round", round$2)
			];
		});
		const handleClose = (event) => {
			emit("close", event);
		};
		const handleClick = (event) => {
			emit("click", event);
		};
		return (_ctx, _cache) => {
			return _ctx.disableTransitions ? (openBlock(), createElementBlock("span", {
				key: 0,
				class: normalizeClass(unref(containerKls)),
				style: normalizeStyle({ backgroundColor: _ctx.color }),
				onClick: handleClick
			}, [createBaseVNode("span", { class: normalizeClass(unref(ns).e("content")) }, [renderSlot(_ctx.$slots, "default")], 2), _ctx.closable ? (openBlock(), createBlock(unref(ElIcon), {
				key: 0,
				class: normalizeClass(unref(ns).e("close")),
				onClick: withModifiers(handleClose, ["stop"])
			}, {
				default: withCtx(() => [createVNode(unref(close_default))]),
				_: 1
			}, 8, ["class", "onClick"])) : createCommentVNode("v-if", true)], 6)) : (openBlock(), createBlock(Transition, {
				key: 1,
				name: `${unref(ns).namespace.value}-zoom-in-center`,
				appear: ""
			}, {
				default: withCtx(() => [createBaseVNode("span", {
					class: normalizeClass(unref(containerKls)),
					style: normalizeStyle({ backgroundColor: _ctx.color }),
					onClick: handleClick
				}, [createBaseVNode("span", { class: normalizeClass(unref(ns).e("content")) }, [renderSlot(_ctx.$slots, "default")], 2), _ctx.closable ? (openBlock(), createBlock(unref(ElIcon), {
					key: 0,
					class: normalizeClass(unref(ns).e("close")),
					onClick: withModifiers(handleClose, ["stop"])
				}, {
					default: withCtx(() => [createVNode(unref(close_default))]),
					_: 1
				}, 8, ["class", "onClick"])) : createCommentVNode("v-if", true)], 6)]),
				_: 3
			}, 8, ["name"]));
		};
	}
}), [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tag/src/tag.vue"]]));
var CollapseTransition = /* @__PURE__ */ _export_sfc(/* @__PURE__ */ defineComponent({
	...defineComponent({ name: "ElCollapseTransition" }),
	setup(__props) {
		const ns = useNamespace("collapse-transition");
		const reset = (el$2) => {
			el$2.style.maxHeight = "";
			el$2.style.overflow = el$2.dataset.oldOverflow;
			el$2.style.paddingTop = el$2.dataset.oldPaddingTop;
			el$2.style.paddingBottom = el$2.dataset.oldPaddingBottom;
		};
		const on$2 = {
			beforeEnter(el$2) {
				if (!el$2.dataset) el$2.dataset = {};
				el$2.dataset.oldPaddingTop = el$2.style.paddingTop;
				el$2.dataset.oldPaddingBottom = el$2.style.paddingBottom;
				el$2.style.maxHeight = 0;
				el$2.style.paddingTop = 0;
				el$2.style.paddingBottom = 0;
			},
			enter(el$2) {
				el$2.dataset.oldOverflow = el$2.style.overflow;
				if (el$2.scrollHeight !== 0) el$2.style.maxHeight = `${el$2.scrollHeight}px`;
				else el$2.style.maxHeight = 0;
				el$2.style.paddingTop = el$2.dataset.oldPaddingTop;
				el$2.style.paddingBottom = el$2.dataset.oldPaddingBottom;
				el$2.style.overflow = "hidden";
			},
			afterEnter(el$2) {
				el$2.style.maxHeight = "";
				el$2.style.overflow = el$2.dataset.oldOverflow;
			},
			enterCancelled(el$2) {
				reset(el$2);
			},
			beforeLeave(el$2) {
				if (!el$2.dataset) el$2.dataset = {};
				el$2.dataset.oldPaddingTop = el$2.style.paddingTop;
				el$2.dataset.oldPaddingBottom = el$2.style.paddingBottom;
				el$2.dataset.oldOverflow = el$2.style.overflow;
				el$2.style.maxHeight = `${el$2.scrollHeight}px`;
				el$2.style.overflow = "hidden";
			},
			leave(el$2) {
				if (el$2.scrollHeight !== 0) {
					el$2.style.maxHeight = 0;
					el$2.style.paddingTop = 0;
					el$2.style.paddingBottom = 0;
				}
			},
			afterLeave(el$2) {
				reset(el$2);
			},
			leaveCancelled(el$2) {
				reset(el$2);
			}
		};
		return (_ctx, _cache) => {
			return openBlock(), createBlock(Transition, mergeProps({ name: unref(ns).b() }, toHandlers(on$2)), {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 16, ["name"]);
		};
	}
}), [["__file", "/home/runner/work/element-plus/element-plus/packages/components/collapse-transition/src/collapse-transition.vue"]]);
CollapseTransition.install = (app) => {
	app.component(CollapseTransition.name, CollapseTransition);
};
var _CollapseTransition = CollapseTransition;
var ElCollapseTransition = _CollapseTransition;
var alphaSliderProps = buildProps({
	color: {
		type: definePropType(Object),
		required: true
	},
	vertical: {
		type: Boolean,
		default: false
	}
});
var isDragging = false;
function draggable$1(element, options$1) {
	if (!isClient$1) return;
	const moveFn = function(event) {
		var _a;
		(_a = options$1.drag) == null || _a.call(options$1, event);
	};
	const upFn = function(event) {
		var _a;
		document.removeEventListener("mousemove", moveFn);
		document.removeEventListener("mouseup", upFn);
		document.removeEventListener("touchmove", moveFn);
		document.removeEventListener("touchend", upFn);
		document.onselectstart = null;
		document.ondragstart = null;
		isDragging = false;
		(_a = options$1.end) == null || _a.call(options$1, event);
	};
	const downFn = function(event) {
		var _a;
		if (isDragging) return;
		event.preventDefault();
		document.onselectstart = () => false;
		document.ondragstart = () => false;
		document.addEventListener("mousemove", moveFn);
		document.addEventListener("mouseup", upFn);
		document.addEventListener("touchmove", moveFn);
		document.addEventListener("touchend", upFn);
		isDragging = true;
		(_a = options$1.start) == null || _a.call(options$1, event);
	};
	element.addEventListener("mousedown", downFn);
	element.addEventListener("touchstart", downFn);
}
var useAlphaSlider = (props) => {
	const instance = getCurrentInstance();
	const thumb$1 = shallowRef();
	const bar = shallowRef();
	function handleClick(event) {
		if (event.target !== thumb$1.value) handleDrag(event);
	}
	function handleDrag(event) {
		if (!bar.value || !thumb$1.value) return;
		const rect$2 = instance.vnode.el.getBoundingClientRect();
		const { clientX, clientY } = getClientXY(event);
		if (!props.vertical) {
			let left$1 = clientX - rect$2.left;
			left$1 = Math.max(thumb$1.value.offsetWidth / 2, left$1);
			left$1 = Math.min(left$1, rect$2.width - thumb$1.value.offsetWidth / 2);
			props.color.set("alpha", Math.round((left$1 - thumb$1.value.offsetWidth / 2) / (rect$2.width - thumb$1.value.offsetWidth) * 100));
		} else {
			let top$3 = clientY - rect$2.top;
			top$3 = Math.max(thumb$1.value.offsetHeight / 2, top$3);
			top$3 = Math.min(top$3, rect$2.height - thumb$1.value.offsetHeight / 2);
			props.color.set("alpha", Math.round((top$3 - thumb$1.value.offsetHeight / 2) / (rect$2.height - thumb$1.value.offsetHeight) * 100));
		}
	}
	return {
		thumb: thumb$1,
		bar,
		handleDrag,
		handleClick
	};
};
var useAlphaSliderDOM = (props, { bar, thumb: thumb$1, handleDrag }) => {
	const instance = getCurrentInstance();
	const ns = useNamespace("color-alpha-slider");
	const thumbLeft = ref(0);
	const thumbTop = ref(0);
	const background = ref();
	function getThumbLeft() {
		if (!thumb$1.value) return 0;
		if (props.vertical) return 0;
		const el$2 = instance.vnode.el;
		const alpha$1 = props.color.get("alpha");
		if (!el$2) return 0;
		return Math.round(alpha$1 * (el$2.offsetWidth - thumb$1.value.offsetWidth / 2) / 100);
	}
	function getThumbTop() {
		if (!thumb$1.value) return 0;
		const el$2 = instance.vnode.el;
		if (!props.vertical) return 0;
		const alpha$1 = props.color.get("alpha");
		if (!el$2) return 0;
		return Math.round(alpha$1 * (el$2.offsetHeight - thumb$1.value.offsetHeight / 2) / 100);
	}
	function getBackground() {
		if (props.color && props.color.value) {
			const { r, g: g$1, b: b$2 } = props.color.toRgb();
			return `linear-gradient(to right, rgba(${r}, ${g$1}, ${b$2}, 0) 0%, rgba(${r}, ${g$1}, ${b$2}, 1) 100%)`;
		}
		return "";
	}
	function update() {
		thumbLeft.value = getThumbLeft();
		thumbTop.value = getThumbTop();
		background.value = getBackground();
	}
	onMounted(() => {
		if (!bar.value || !thumb$1.value) return;
		const dragConfig = {
			drag: (event) => {
				handleDrag(event);
			},
			end: (event) => {
				handleDrag(event);
			}
		};
		draggable$1(bar.value, dragConfig);
		draggable$1(thumb$1.value, dragConfig);
		update();
	});
	watch(() => props.color.get("alpha"), () => update());
	watch(() => props.color.value, () => update());
	const rootKls = computed(() => [ns.b(), ns.is("vertical", props.vertical)]);
	const barKls = computed(() => ns.e("bar"));
	const thumbKls = computed(() => ns.e("thumb"));
	return {
		rootKls,
		barKls,
		barStyle: computed(() => ({ background: background.value })),
		thumbKls,
		thumbStyle: computed(() => ({
			left: addUnit(thumbLeft.value),
			top: addUnit(thumbTop.value)
		})),
		update
	};
};
var AlphaSlider = /* @__PURE__ */ _export_sfc(/* @__PURE__ */ defineComponent({
	...defineComponent({ name: "ElColorAlphaSlider" }),
	props: alphaSliderProps,
	setup(__props, { expose }) {
		const props = __props;
		const { bar, thumb: thumb$1, handleDrag, handleClick } = useAlphaSlider(props);
		const { rootKls, barKls, barStyle, thumbKls, thumbStyle, update } = useAlphaSliderDOM(props, {
			bar,
			thumb: thumb$1,
			handleDrag
		});
		expose({
			update,
			bar,
			thumb: thumb$1
		});
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", { class: normalizeClass(unref(rootKls)) }, [createBaseVNode("div", {
				ref_key: "bar",
				ref: bar,
				class: normalizeClass(unref(barKls)),
				style: normalizeStyle(unref(barStyle)),
				onClick: _cache[0] || (_cache[0] = (...args) => unref(handleClick) && unref(handleClick)(...args))
			}, null, 6), createBaseVNode("div", {
				ref_key: "thumb",
				ref: thumb$1,
				class: normalizeClass(unref(thumbKls)),
				style: normalizeStyle(unref(thumbStyle))
			}, null, 6)], 2);
		};
	}
}), [["__file", "/home/runner/work/element-plus/element-plus/packages/components/color-picker/src/components/alpha-slider.vue"]]);
var _sfc_main$20 = defineComponent({
	name: "ElColorHueSlider",
	props: {
		color: {
			type: Object,
			required: true
		},
		vertical: Boolean
	},
	setup(props) {
		const ns = useNamespace("color-hue-slider");
		const instance = getCurrentInstance();
		const thumb$1 = ref();
		const bar = ref();
		const thumbLeft = ref(0);
		const thumbTop = ref(0);
		const hueValue = computed(() => {
			return props.color.get("hue");
		});
		watch(() => hueValue.value, () => {
			update();
		});
		function handleClick(event) {
			if (event.target !== thumb$1.value) handleDrag(event);
		}
		function handleDrag(event) {
			if (!bar.value || !thumb$1.value) return;
			const rect$2 = instance.vnode.el.getBoundingClientRect();
			const { clientX, clientY } = getClientXY(event);
			let hue;
			if (!props.vertical) {
				let left$1 = clientX - rect$2.left;
				left$1 = Math.min(left$1, rect$2.width - thumb$1.value.offsetWidth / 2);
				left$1 = Math.max(thumb$1.value.offsetWidth / 2, left$1);
				hue = Math.round((left$1 - thumb$1.value.offsetWidth / 2) / (rect$2.width - thumb$1.value.offsetWidth) * 360);
			} else {
				let top$3 = clientY - rect$2.top;
				top$3 = Math.min(top$3, rect$2.height - thumb$1.value.offsetHeight / 2);
				top$3 = Math.max(thumb$1.value.offsetHeight / 2, top$3);
				hue = Math.round((top$3 - thumb$1.value.offsetHeight / 2) / (rect$2.height - thumb$1.value.offsetHeight) * 360);
			}
			props.color.set("hue", hue);
		}
		function getThumbLeft() {
			if (!thumb$1.value) return 0;
			const el$2 = instance.vnode.el;
			if (props.vertical) return 0;
			const hue = props.color.get("hue");
			if (!el$2) return 0;
			return Math.round(hue * (el$2.offsetWidth - thumb$1.value.offsetWidth / 2) / 360);
		}
		function getThumbTop() {
			if (!thumb$1.value) return 0;
			const el$2 = instance.vnode.el;
			if (!props.vertical) return 0;
			const hue = props.color.get("hue");
			if (!el$2) return 0;
			return Math.round(hue * (el$2.offsetHeight - thumb$1.value.offsetHeight / 2) / 360);
		}
		function update() {
			thumbLeft.value = getThumbLeft();
			thumbTop.value = getThumbTop();
		}
		onMounted(() => {
			if (!bar.value || !thumb$1.value) return;
			const dragConfig = {
				drag: (event) => {
					handleDrag(event);
				},
				end: (event) => {
					handleDrag(event);
				}
			};
			draggable$1(bar.value, dragConfig);
			draggable$1(thumb$1.value, dragConfig);
			update();
		});
		return {
			bar,
			thumb: thumb$1,
			thumbLeft,
			thumbTop,
			hueValue,
			handleClick,
			update,
			ns
		};
	}
});
function _sfc_render$20(_ctx, _cache, $props, $setup, $data, $options) {
	return openBlock(), createElementBlock("div", { class: normalizeClass([_ctx.ns.b(), _ctx.ns.is("vertical", _ctx.vertical)]) }, [createBaseVNode("div", {
		ref: "bar",
		class: normalizeClass(_ctx.ns.e("bar")),
		onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
	}, null, 2), createBaseVNode("div", {
		ref: "thumb",
		class: normalizeClass(_ctx.ns.e("thumb")),
		style: normalizeStyle({
			left: _ctx.thumbLeft + "px",
			top: _ctx.thumbTop + "px"
		})
	}, null, 6)], 2);
}
var HueSlider = /* @__PURE__ */ _export_sfc(_sfc_main$20, [["render", _sfc_render$20], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/color-picker/src/components/hue-slider.vue"]]);
init_shared_esm_bundler();
var colorPickerProps = buildProps({
	modelValue: String,
	id: String,
	showAlpha: Boolean,
	colorFormat: String,
	disabled: Boolean,
	size: useSizeProp,
	popperClass: {
		type: String,
		default: ""
	},
	label: {
		type: String,
		default: void 0
	},
	tabindex: {
		type: [String, Number],
		default: 0
	},
	predefine: { type: definePropType(Array) },
	validateEvent: {
		type: Boolean,
		default: true
	}
});
var colorPickerEmits = {
	[UPDATE_MODEL_EVENT]: (val) => isString$2(val) || isNil_default(val),
	[CHANGE_EVENT]: (val) => isString$2(val) || isNil_default(val),
	activeChange: (val) => isString$2(val) || isNil_default(val),
	focus: (event) => event instanceof FocusEvent,
	blur: (event) => event instanceof FocusEvent
};
var colorPickerContextKey = Symbol("colorPickerContextKey");
init_shared_esm_bundler();
var hsv2hsl = function(hue, sat, val) {
	return [
		hue,
		sat * val / ((hue = (2 - sat) * val) < 1 ? hue : 2 - hue) || 0,
		hue / 2
	];
};
var isOnePointZero = function(n) {
	return typeof n === "string" && n.includes(".") && Number.parseFloat(n) === 1;
};
var isPercentage = function(n) {
	return typeof n === "string" && n.includes("%");
};
var bound01 = function(value, max$2) {
	if (isOnePointZero(value)) value = "100%";
	const processPercent = isPercentage(value);
	value = Math.min(max$2, Math.max(0, Number.parseFloat(`${value}`)));
	if (processPercent) value = Number.parseInt(`${value * max$2}`, 10) / 100;
	if (Math.abs(value - max$2) < 1e-6) return 1;
	return value % max$2 / Number.parseFloat(max$2);
};
var INT_HEX_MAP = {
	10: "A",
	11: "B",
	12: "C",
	13: "D",
	14: "E",
	15: "F"
};
var hexOne = (value) => {
	value = Math.min(Math.round(value), 255);
	const high = Math.floor(value / 16);
	const low = value % 16;
	return `${INT_HEX_MAP[high] || high}${INT_HEX_MAP[low] || low}`;
};
var toHex = function({ r, g: g$1, b: b$2 }) {
	if (Number.isNaN(+r) || Number.isNaN(+g$1) || Number.isNaN(+b$2)) return "";
	return `#${hexOne(r)}${hexOne(g$1)}${hexOne(b$2)}`;
};
var HEX_INT_MAP = {
	A: 10,
	B: 11,
	C: 12,
	D: 13,
	E: 14,
	F: 15
};
var parseHexChannel = function(hex) {
	if (hex.length === 2) return (HEX_INT_MAP[hex[0].toUpperCase()] || +hex[0]) * 16 + (HEX_INT_MAP[hex[1].toUpperCase()] || +hex[1]);
	return HEX_INT_MAP[hex[1].toUpperCase()] || +hex[1];
};
var hsl2hsv = function(hue, sat, light) {
	sat = sat / 100;
	light = light / 100;
	let smin = sat;
	const lmin = Math.max(light, .01);
	light *= 2;
	sat *= light <= 1 ? light : 2 - light;
	smin *= lmin <= 1 ? lmin : 2 - lmin;
	const v$1 = (light + sat) / 2;
	return {
		h: hue,
		s: (light === 0 ? 2 * smin / (lmin + smin) : 2 * sat / (light + sat)) * 100,
		v: v$1 * 100
	};
};
var rgb2hsv = (r, g$1, b$2) => {
	r = bound01(r, 255);
	g$1 = bound01(g$1, 255);
	b$2 = bound01(b$2, 255);
	const max$2 = Math.max(r, g$1, b$2);
	const min$2 = Math.min(r, g$1, b$2);
	let h$2;
	const v$1 = max$2;
	const d = max$2 - min$2;
	const s = max$2 === 0 ? 0 : d / max$2;
	if (max$2 === min$2) h$2 = 0;
	else {
		switch (max$2) {
			case r:
				h$2 = (g$1 - b$2) / d + (g$1 < b$2 ? 6 : 0);
				break;
			case g$1:
				h$2 = (b$2 - r) / d + 2;
				break;
			case b$2:
				h$2 = (r - g$1) / d + 4;
				break;
		}
		h$2 /= 6;
	}
	return {
		h: h$2 * 360,
		s: s * 100,
		v: v$1 * 100
	};
};
var hsv2rgb = function(h$2, s, v$1) {
	h$2 = bound01(h$2, 360) * 6;
	s = bound01(s, 100);
	v$1 = bound01(v$1, 100);
	const i$1 = Math.floor(h$2);
	const f = h$2 - i$1;
	const p$1 = v$1 * (1 - s);
	const q$1 = v$1 * (1 - f * s);
	const t$1 = v$1 * (1 - (1 - f) * s);
	const mod = i$1 % 6;
	const r = [
		v$1,
		q$1,
		p$1,
		p$1,
		t$1,
		v$1
	][mod];
	const g$1 = [
		t$1,
		v$1,
		v$1,
		q$1,
		p$1,
		p$1
	][mod];
	const b$2 = [
		p$1,
		p$1,
		t$1,
		v$1,
		v$1,
		q$1
	][mod];
	return {
		r: Math.round(r * 255),
		g: Math.round(g$1 * 255),
		b: Math.round(b$2 * 255)
	};
};
var Color = class {
	constructor(options$1 = {}) {
		this._hue = 0;
		this._saturation = 100;
		this._value = 100;
		this._alpha = 100;
		this.enableAlpha = false;
		this.format = "hex";
		this.value = "";
		for (const option in options$1) if (hasOwn$1(options$1, option)) this[option] = options$1[option];
		if (options$1.value) this.fromString(options$1.value);
		else this.doOnChange();
	}
	set(prop$1, value) {
		if (arguments.length === 1 && typeof prop$1 === "object") {
			for (const p$1 in prop$1) if (hasOwn$1(prop$1, p$1)) this.set(p$1, prop$1[p$1]);
			return;
		}
		this[`_${prop$1}`] = value;
		this.doOnChange();
	}
	get(prop$1) {
		if (prop$1 === "alpha") return Math.floor(this[`_${prop$1}`]);
		return this[`_${prop$1}`];
	}
	toRgb() {
		return hsv2rgb(this._hue, this._saturation, this._value);
	}
	fromString(value) {
		if (!value) {
			this._hue = 0;
			this._saturation = 100;
			this._value = 100;
			this.doOnChange();
			return;
		}
		const fromHSV = (h$2, s, v$1) => {
			this._hue = Math.max(0, Math.min(360, h$2));
			this._saturation = Math.max(0, Math.min(100, s));
			this._value = Math.max(0, Math.min(100, v$1));
			this.doOnChange();
		};
		if (value.includes("hsl")) {
			const parts = value.replace(/hsla|hsl|\(|\)/gm, "").split(/\s|,/g).filter((val) => val !== "").map((val, index) => index > 2 ? Number.parseFloat(val) : Number.parseInt(val, 10));
			if (parts.length === 4) this._alpha = Number.parseFloat(parts[3]) * 100;
			else if (parts.length === 3) this._alpha = 100;
			if (parts.length >= 3) {
				const { h: h$2, s, v: v$1 } = hsl2hsv(parts[0], parts[1], parts[2]);
				fromHSV(h$2, s, v$1);
			}
		} else if (value.includes("hsv")) {
			const parts = value.replace(/hsva|hsv|\(|\)/gm, "").split(/\s|,/g).filter((val) => val !== "").map((val, index) => index > 2 ? Number.parseFloat(val) : Number.parseInt(val, 10));
			if (parts.length === 4) this._alpha = Number.parseFloat(parts[3]) * 100;
			else if (parts.length === 3) this._alpha = 100;
			if (parts.length >= 3) fromHSV(parts[0], parts[1], parts[2]);
		} else if (value.includes("rgb")) {
			const parts = value.replace(/rgba|rgb|\(|\)/gm, "").split(/\s|,/g).filter((val) => val !== "").map((val, index) => index > 2 ? Number.parseFloat(val) : Number.parseInt(val, 10));
			if (parts.length === 4) this._alpha = Number.parseFloat(parts[3]) * 100;
			else if (parts.length === 3) this._alpha = 100;
			if (parts.length >= 3) {
				const { h: h$2, s, v: v$1 } = rgb2hsv(parts[0], parts[1], parts[2]);
				fromHSV(h$2, s, v$1);
			}
		} else if (value.includes("#")) {
			const hex = value.replace("#", "").trim();
			if (!/^[0-9a-fA-F]{3}$|^[0-9a-fA-F]{6}$|^[0-9a-fA-F]{8}$/.test(hex)) return;
			let r, g$1, b$2;
			if (hex.length === 3) {
				r = parseHexChannel(hex[0] + hex[0]);
				g$1 = parseHexChannel(hex[1] + hex[1]);
				b$2 = parseHexChannel(hex[2] + hex[2]);
			} else if (hex.length === 6 || hex.length === 8) {
				r = parseHexChannel(hex.slice(0, 2));
				g$1 = parseHexChannel(hex.slice(2, 4));
				b$2 = parseHexChannel(hex.slice(4, 6));
			}
			if (hex.length === 8) this._alpha = parseHexChannel(hex.slice(6)) / 255 * 100;
			else if (hex.length === 3 || hex.length === 6) this._alpha = 100;
			const { h: h$2, s, v: v$1 } = rgb2hsv(r, g$1, b$2);
			fromHSV(h$2, s, v$1);
		}
	}
	compare(color) {
		return Math.abs(color._hue - this._hue) < 2 && Math.abs(color._saturation - this._saturation) < 1 && Math.abs(color._value - this._value) < 1 && Math.abs(color._alpha - this._alpha) < 1;
	}
	doOnChange() {
		const { _hue, _saturation, _value, _alpha, format: format$1 } = this;
		if (this.enableAlpha) switch (format$1) {
			case "hsl": {
				const hsl = hsv2hsl(_hue, _saturation / 100, _value / 100);
				this.value = `hsla(${_hue}, ${Math.round(hsl[1] * 100)}%, ${Math.round(hsl[2] * 100)}%, ${this.get("alpha") / 100})`;
				break;
			}
			case "hsv":
				this.value = `hsva(${_hue}, ${Math.round(_saturation)}%, ${Math.round(_value)}%, ${this.get("alpha") / 100})`;
				break;
			case "hex":
				this.value = `${toHex(hsv2rgb(_hue, _saturation, _value))}${hexOne(_alpha * 255 / 100)}`;
				break;
			default: {
				const { r, g: g$1, b: b$2 } = hsv2rgb(_hue, _saturation, _value);
				this.value = `rgba(${r}, ${g$1}, ${b$2}, ${this.get("alpha") / 100})`;
			}
		}
		else switch (format$1) {
			case "hsl": {
				const hsl = hsv2hsl(_hue, _saturation / 100, _value / 100);
				this.value = `hsl(${_hue}, ${Math.round(hsl[1] * 100)}%, ${Math.round(hsl[2] * 100)}%)`;
				break;
			}
			case "hsv":
				this.value = `hsv(${_hue}, ${Math.round(_saturation)}%, ${Math.round(_value)}%)`;
				break;
			case "rgb": {
				const { r, g: g$1, b: b$2 } = hsv2rgb(_hue, _saturation, _value);
				this.value = `rgb(${r}, ${g$1}, ${b$2})`;
				break;
			}
			default: this.value = toHex(hsv2rgb(_hue, _saturation, _value));
		}
	}
};
var _sfc_main$19 = defineComponent({
	props: {
		colors: {
			type: Array,
			required: true
		},
		color: {
			type: Object,
			required: true
		}
	},
	setup(props) {
		const ns = useNamespace("color-predefine");
		const { currentColor } = inject(colorPickerContextKey);
		const rgbaColors = ref(parseColors(props.colors, props.color));
		watch(() => currentColor.value, (val) => {
			const color = new Color();
			color.fromString(val);
			rgbaColors.value.forEach((item$4) => {
				item$4.selected = color.compare(item$4);
			});
		});
		watchEffect(() => {
			rgbaColors.value = parseColors(props.colors, props.color);
		});
		function handleSelect(index) {
			props.color.fromString(props.colors[index]);
		}
		function parseColors(colors, color) {
			return colors.map((value) => {
				const c$2 = new Color();
				c$2.enableAlpha = true;
				c$2.format = "rgba";
				c$2.fromString(value);
				c$2.selected = c$2.value === color.value;
				return c$2;
			});
		}
		return {
			rgbaColors,
			handleSelect,
			ns
		};
	}
});
var _hoisted_1$57 = ["onClick"];
function _sfc_render$19(_ctx, _cache, $props, $setup, $data, $options) {
	return openBlock(), createElementBlock("div", { class: normalizeClass(_ctx.ns.b()) }, [createBaseVNode("div", { class: normalizeClass(_ctx.ns.e("colors")) }, [(openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.rgbaColors, (item$4, index) => {
		return openBlock(), createElementBlock("div", {
			key: _ctx.colors[index],
			class: normalizeClass([
				_ctx.ns.e("color-selector"),
				_ctx.ns.is("alpha", item$4._alpha < 100),
				{ selected: item$4.selected }
			]),
			onClick: ($event) => _ctx.handleSelect(index)
		}, [createBaseVNode("div", { style: normalizeStyle({ backgroundColor: item$4.value }) }, null, 4)], 10, _hoisted_1$57);
	}), 128))], 2)], 2);
}
var Predefine = /* @__PURE__ */ _export_sfc(_sfc_main$19, [["render", _sfc_render$19], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/color-picker/src/components/predefine.vue"]]);
var _sfc_main$18 = defineComponent({
	name: "ElSlPanel",
	props: { color: {
		type: Object,
		required: true
	} },
	setup(props) {
		const ns = useNamespace("color-svpanel");
		const instance = getCurrentInstance();
		const cursorTop = ref(0);
		const cursorLeft = ref(0);
		const background = ref("hsl(0, 100%, 50%)");
		const colorValue = computed(() => {
			return {
				hue: props.color.get("hue"),
				value: props.color.get("value")
			};
		});
		function update() {
			const saturation = props.color.get("saturation");
			const value = props.color.get("value");
			const { clientWidth: width, clientHeight: height } = instance.vnode.el;
			cursorLeft.value = saturation * width / 100;
			cursorTop.value = (100 - value) * height / 100;
			background.value = `hsl(${props.color.get("hue")}, 100%, 50%)`;
		}
		function handleDrag(event) {
			const rect$2 = instance.vnode.el.getBoundingClientRect();
			const { clientX, clientY } = getClientXY(event);
			let left$1 = clientX - rect$2.left;
			let top$3 = clientY - rect$2.top;
			left$1 = Math.max(0, left$1);
			left$1 = Math.min(left$1, rect$2.width);
			top$3 = Math.max(0, top$3);
			top$3 = Math.min(top$3, rect$2.height);
			cursorLeft.value = left$1;
			cursorTop.value = top$3;
			props.color.set({
				saturation: left$1 / rect$2.width * 100,
				value: 100 - top$3 / rect$2.height * 100
			});
		}
		watch(() => colorValue.value, () => {
			update();
		});
		onMounted(() => {
			draggable$1(instance.vnode.el, {
				drag: (event) => {
					handleDrag(event);
				},
				end: (event) => {
					handleDrag(event);
				}
			});
			update();
		});
		return {
			cursorTop,
			cursorLeft,
			background,
			colorValue,
			handleDrag,
			update,
			ns
		};
	}
});
var _hoisted_2$34 = [/* @__PURE__ */ createBaseVNode("div", null, null, -1)];
function _sfc_render$18(_ctx, _cache, $props, $setup, $data, $options) {
	return openBlock(), createElementBlock("div", {
		class: normalizeClass(_ctx.ns.b()),
		style: normalizeStyle({ backgroundColor: _ctx.background })
	}, [
		createBaseVNode("div", { class: normalizeClass(_ctx.ns.e("white")) }, null, 2),
		createBaseVNode("div", { class: normalizeClass(_ctx.ns.e("black")) }, null, 2),
		createBaseVNode("div", {
			class: normalizeClass(_ctx.ns.e("cursor")),
			style: normalizeStyle({
				top: _ctx.cursorTop + "px",
				left: _ctx.cursorLeft + "px"
			})
		}, _hoisted_2$34, 6)
	], 6);
}
var SvPanel = /* @__PURE__ */ _export_sfc(_sfc_main$18, [["render", _sfc_render$18], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/color-picker/src/components/sv-panel.vue"]]);
var _hoisted_1$56 = ["onKeydown"];
var _hoisted_2$33 = [
	"id",
	"aria-label",
	"aria-labelledby",
	"aria-description",
	"aria-disabled",
	"tabindex"
];
var ElColorPicker = withInstall(/* @__PURE__ */ _export_sfc(/* @__PURE__ */ defineComponent({
	...defineComponent({ name: "ElColorPicker" }),
	props: colorPickerProps,
	emits: colorPickerEmits,
	setup(__props, { expose, emit }) {
		const props = __props;
		const { t: t$1 } = useLocale$1();
		const ns = useNamespace("color");
		const { formItem } = useFormItem();
		const colorSize = useFormSize();
		const colorDisabled = useFormDisabled();
		const { inputId: buttonId, isLabeledByFormItem } = useFormItemInputId(props, { formItemContext: formItem });
		const hue = ref();
		const sv = ref();
		const alpha$1 = ref();
		const popper = ref();
		const triggerRef$1 = ref();
		const inputRef = ref();
		const { isFocused, handleFocus: _handleFocus, handleBlur } = useFocusController(triggerRef$1, {
			beforeBlur(event) {
				var _a;
				return (_a = popper.value) == null ? void 0 : _a.isFocusInsideContent(event);
			},
			afterBlur() {
				setShowPicker(false);
				resetColor();
			}
		});
		const handleFocus = (event) => {
			if (colorDisabled.value) return blur();
			_handleFocus(event);
		};
		let shouldActiveChange = true;
		const color = reactive(new Color({
			enableAlpha: props.showAlpha,
			format: props.colorFormat || "",
			value: props.modelValue
		}));
		const showPicker = ref(false);
		const showPanelColor = ref(false);
		const customInput = ref("");
		const displayedColor = computed(() => {
			if (!props.modelValue && !showPanelColor.value) return "transparent";
			return displayedRgb(color, props.showAlpha);
		});
		const currentColor = computed(() => {
			return !props.modelValue && !showPanelColor.value ? "" : color.value;
		});
		const buttonAriaLabel = computed(() => {
			return !isLabeledByFormItem.value ? props.label || t$1("el.colorpicker.defaultLabel") : void 0;
		});
		const buttonAriaLabelledby = computed(() => {
			return isLabeledByFormItem.value ? formItem == null ? void 0 : formItem.labelId : void 0;
		});
		const btnKls = computed(() => {
			return [
				ns.b("picker"),
				ns.is("disabled", colorDisabled.value),
				ns.bm("picker", colorSize.value),
				ns.is("focused", isFocused.value)
			];
		});
		function displayedRgb(color2, showAlpha) {
			if (!(color2 instanceof Color)) throw new TypeError("color should be instance of _color Class");
			const { r, g: g$1, b: b$2 } = color2.toRgb();
			return showAlpha ? `rgba(${r}, ${g$1}, ${b$2}, ${color2.get("alpha") / 100})` : `rgb(${r}, ${g$1}, ${b$2})`;
		}
		function setShowPicker(value) {
			showPicker.value = value;
		}
		const debounceSetShowPicker = debounce_default(setShowPicker, 100, { leading: true });
		function show() {
			if (colorDisabled.value) return;
			setShowPicker(true);
		}
		function hide$2() {
			debounceSetShowPicker(false);
			resetColor();
		}
		function resetColor() {
			nextTick(() => {
				if (props.modelValue) color.fromString(props.modelValue);
				else {
					color.value = "";
					nextTick(() => {
						showPanelColor.value = false;
					});
				}
			});
		}
		function handleTrigger() {
			if (colorDisabled.value) return;
			debounceSetShowPicker(!showPicker.value);
		}
		function handleConfirm() {
			color.fromString(customInput.value);
		}
		function confirmValue() {
			const value = color.value;
			emit(UPDATE_MODEL_EVENT, value);
			emit("change", value);
			if (props.validateEvent) formItem?.validate("change").catch((err) => debugWarn(err));
			debounceSetShowPicker(false);
			nextTick(() => {
				const newColor = new Color({
					enableAlpha: props.showAlpha,
					format: props.colorFormat || "",
					value: props.modelValue
				});
				if (!color.compare(newColor)) resetColor();
			});
		}
		function clear() {
			debounceSetShowPicker(false);
			emit(UPDATE_MODEL_EVENT, null);
			emit("change", null);
			if (props.modelValue !== null && props.validateEvent) formItem?.validate("change").catch((err) => debugWarn(err));
			resetColor();
		}
		function handleClickOutside(event) {
			if (!showPicker.value) return;
			hide$2();
			if (isFocused.value) handleBlur(new FocusEvent("focus", event));
		}
		function handleEsc(event) {
			event.preventDefault();
			event.stopPropagation();
			setShowPicker(false);
			resetColor();
		}
		function handleKeyDown(event) {
			switch (event.code) {
				case EVENT_CODE.enter:
				case EVENT_CODE.space:
					event.preventDefault();
					event.stopPropagation();
					show();
					inputRef.value.focus();
					break;
				case EVENT_CODE.esc:
					handleEsc(event);
					break;
			}
		}
		function focus$1() {
			triggerRef$1.value.focus();
		}
		function blur() {
			triggerRef$1.value.blur();
		}
		onMounted(() => {
			if (props.modelValue) customInput.value = currentColor.value;
		});
		watch(() => props.modelValue, (newVal) => {
			if (!newVal) showPanelColor.value = false;
			else if (newVal && newVal !== color.value) {
				shouldActiveChange = false;
				color.fromString(newVal);
			}
		});
		watch(() => currentColor.value, (val) => {
			customInput.value = val;
			shouldActiveChange && emit("activeChange", val);
			shouldActiveChange = true;
		});
		watch(() => color.value, () => {
			if (!props.modelValue && !showPanelColor.value) showPanelColor.value = true;
		});
		watch(() => showPicker.value, () => {
			nextTick(() => {
				var _a, _b, _c;
				(_a = hue.value) == null || _a.update();
				(_b = sv.value) == null || _b.update();
				(_c = alpha$1.value) == null || _c.update();
			});
		});
		provide(colorPickerContextKey, { currentColor });
		expose({
			color,
			show,
			hide: hide$2,
			focus: focus$1,
			blur
		});
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(ElTooltip), {
				ref_key: "popper",
				ref: popper,
				visible: showPicker.value,
				"show-arrow": false,
				"fallback-placements": [
					"bottom",
					"top",
					"right",
					"left"
				],
				offset: 0,
				"gpu-acceleration": false,
				"popper-class": [
					unref(ns).be("picker", "panel"),
					unref(ns).b("dropdown"),
					_ctx.popperClass
				],
				"stop-popper-mouse-event": false,
				effect: "light",
				trigger: "click",
				transition: `${unref(ns).namespace.value}-zoom-in-top`,
				persistent: "",
				onHide: _cache[2] || (_cache[2] = ($event) => setShowPicker(false))
			}, {
				content: withCtx(() => [withDirectives((openBlock(), createElementBlock("div", { onKeydown: withKeys(handleEsc, ["esc"]) }, [
					createBaseVNode("div", { class: normalizeClass(unref(ns).be("dropdown", "main-wrapper")) }, [createVNode(HueSlider, {
						ref_key: "hue",
						ref: hue,
						class: "hue-slider",
						color: unref(color),
						vertical: ""
					}, null, 8, ["color"]), createVNode(SvPanel, {
						ref_key: "sv",
						ref: sv,
						color: unref(color)
					}, null, 8, ["color"])], 2),
					_ctx.showAlpha ? (openBlock(), createBlock(AlphaSlider, {
						key: 0,
						ref_key: "alpha",
						ref: alpha$1,
						color: unref(color)
					}, null, 8, ["color"])) : createCommentVNode("v-if", true),
					_ctx.predefine ? (openBlock(), createBlock(Predefine, {
						key: 1,
						ref: "predefine",
						color: unref(color),
						colors: _ctx.predefine
					}, null, 8, ["color", "colors"])) : createCommentVNode("v-if", true),
					createBaseVNode("div", { class: normalizeClass(unref(ns).be("dropdown", "btns")) }, [
						createBaseVNode("span", { class: normalizeClass(unref(ns).be("dropdown", "value")) }, [createVNode(unref(ElInput), {
							ref_key: "inputRef",
							ref: inputRef,
							modelValue: customInput.value,
							"onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => customInput.value = $event),
							"validate-event": false,
							size: "small",
							onKeyup: withKeys(handleConfirm, ["enter"]),
							onBlur: handleConfirm
						}, null, 8, ["modelValue", "onKeyup"])], 2),
						createVNode(unref(ElButton), {
							class: normalizeClass(unref(ns).be("dropdown", "link-btn")),
							text: "",
							size: "small",
							onClick: clear
						}, {
							default: withCtx(() => [createTextVNode(toDisplayString(unref(t$1)("el.colorpicker.clear")), 1)]),
							_: 1
						}, 8, ["class"]),
						createVNode(unref(ElButton), {
							plain: "",
							size: "small",
							class: normalizeClass(unref(ns).be("dropdown", "btn")),
							onClick: confirmValue
						}, {
							default: withCtx(() => [createTextVNode(toDisplayString(unref(t$1)("el.colorpicker.confirm")), 1)]),
							_: 1
						}, 8, ["class"])
					], 2)
				], 40, _hoisted_1$56)), [[unref(ClickOutside), handleClickOutside]])]),
				default: withCtx(() => [createBaseVNode("div", {
					id: unref(buttonId),
					ref_key: "triggerRef",
					ref: triggerRef$1,
					class: normalizeClass(unref(btnKls)),
					role: "button",
					"aria-label": unref(buttonAriaLabel),
					"aria-labelledby": unref(buttonAriaLabelledby),
					"aria-description": unref(t$1)("el.colorpicker.description", { color: _ctx.modelValue || "" }),
					"aria-disabled": unref(colorDisabled),
					tabindex: unref(colorDisabled) ? -1 : _ctx.tabindex,
					onKeydown: handleKeyDown,
					onFocus: handleFocus,
					onBlur: _cache[1] || (_cache[1] = (...args) => unref(handleBlur) && unref(handleBlur)(...args))
				}, [unref(colorDisabled) ? (openBlock(), createElementBlock("div", {
					key: 0,
					class: normalizeClass(unref(ns).be("picker", "mask"))
				}, null, 2)) : createCommentVNode("v-if", true), createBaseVNode("div", {
					class: normalizeClass(unref(ns).be("picker", "trigger")),
					onClick: handleTrigger
				}, [createBaseVNode("span", { class: normalizeClass([unref(ns).be("picker", "color"), unref(ns).is("alpha", _ctx.showAlpha)]) }, [createBaseVNode("span", {
					class: normalizeClass(unref(ns).be("picker", "color-inner")),
					style: normalizeStyle({ backgroundColor: unref(displayedColor) })
				}, [withDirectives(createVNode(unref(ElIcon), { class: normalizeClass([unref(ns).be("picker", "icon"), unref(ns).is("icon-arrow-down")]) }, {
					default: withCtx(() => [createVNode(unref(arrow_down_default))]),
					_: 1
				}, 8, ["class"]), [[vShow, _ctx.modelValue || showPanelColor.value]]), withDirectives(createVNode(unref(ElIcon), { class: normalizeClass([unref(ns).be("picker", "empty"), unref(ns).is("icon-close")]) }, {
					default: withCtx(() => [createVNode(unref(close_default))]),
					_: 1
				}, 8, ["class"]), [[vShow, !_ctx.modelValue && !showPanelColor.value]])], 6)], 2)], 2)], 42, _hoisted_2$33)]),
				_: 1
			}, 8, [
				"visible",
				"popper-class",
				"transition"
			]);
		};
	}
}), [["__file", "/home/runner/work/element-plus/element-plus/packages/components/color-picker/src/color-picker.vue"]]));
var _sfc_main$17 = /* @__PURE__ */ defineComponent({ inheritAttrs: false });
function _sfc_render$17(_ctx, _cache, $props, $setup, $data, $options) {
	return renderSlot(_ctx.$slots, "default");
}
var Collection = /* @__PURE__ */ _export_sfc(_sfc_main$17, [["render", _sfc_render$17], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/collection/src/collection.vue"]]);
var _sfc_main$16 = /* @__PURE__ */ defineComponent({
	name: "ElCollectionItem",
	inheritAttrs: false
});
function _sfc_render$16(_ctx, _cache, $props, $setup, $data, $options) {
	return renderSlot(_ctx.$slots, "default");
}
var CollectionItem = /* @__PURE__ */ _export_sfc(_sfc_main$16, [["render", _sfc_render$16], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/collection/src/collection-item.vue"]]);
var COLLECTION_ITEM_SIGN = `data-el-collection-item`;
var createCollectionWithScope = (name$1) => {
	const COLLECTION_NAME = `El${name$1}Collection`;
	const COLLECTION_ITEM_NAME = `${COLLECTION_NAME}Item`;
	const COLLECTION_INJECTION_KEY$2 = Symbol(COLLECTION_NAME);
	const COLLECTION_ITEM_INJECTION_KEY$2 = Symbol(COLLECTION_ITEM_NAME);
	return {
		COLLECTION_INJECTION_KEY: COLLECTION_INJECTION_KEY$2,
		COLLECTION_ITEM_INJECTION_KEY: COLLECTION_ITEM_INJECTION_KEY$2,
		ElCollection: {
			...Collection,
			name: COLLECTION_NAME,
			setup() {
				const collectionRef = ref(null);
				const itemMap = /* @__PURE__ */ new Map();
				const getItems = () => {
					const collectionEl = unref(collectionRef);
					if (!collectionEl) return [];
					const orderedNodes = Array.from(collectionEl.querySelectorAll(`[${COLLECTION_ITEM_SIGN}]`));
					return [...itemMap.values()].sort((a$1, b$2) => orderedNodes.indexOf(a$1.ref) - orderedNodes.indexOf(b$2.ref));
				};
				provide(COLLECTION_INJECTION_KEY$2, {
					itemMap,
					getItems,
					collectionRef
				});
			}
		},
		ElCollectionItem: {
			...CollectionItem,
			name: COLLECTION_ITEM_NAME,
			setup(_, { attrs }) {
				const collectionItemRef = ref(null);
				const collectionInjection = inject(COLLECTION_INJECTION_KEY$2, void 0);
				provide(COLLECTION_ITEM_INJECTION_KEY$2, { collectionItemRef });
				onMounted(() => {
					const collectionItemEl = unref(collectionItemRef);
					if (collectionItemEl) collectionInjection.itemMap.set(collectionItemEl, {
						ref: collectionItemEl,
						...attrs
					});
				});
				onBeforeUnmount(() => {
					const collectionItemEl = unref(collectionItemRef);
					collectionInjection.itemMap.delete(collectionItemEl);
				});
			}
		}
	};
};
var rovingFocusGroupProps = buildProps({
	style: { type: definePropType([
		String,
		Array,
		Object
	]) },
	currentTabId: { type: definePropType(String) },
	defaultCurrentTabId: String,
	loop: Boolean,
	dir: {
		type: String,
		values: ["ltr", "rtl"],
		default: "ltr"
	},
	orientation: { type: definePropType(String) },
	onBlur: Function,
	onFocus: Function,
	onMousedown: Function
});
var { ElCollection: ElCollection$1, ElCollectionItem: ElCollectionItem$1, COLLECTION_INJECTION_KEY: COLLECTION_INJECTION_KEY$1, COLLECTION_ITEM_INJECTION_KEY: COLLECTION_ITEM_INJECTION_KEY$1 } = createCollectionWithScope("RovingFocusGroup");
var ROVING_FOCUS_GROUP_INJECTION_KEY = Symbol("elRovingFocusGroup");
var ROVING_FOCUS_GROUP_ITEM_INJECTION_KEY = Symbol("elRovingFocusGroupItem");
var MAP_KEY_TO_FOCUS_INTENT = {
	ArrowLeft: "prev",
	ArrowUp: "prev",
	ArrowRight: "next",
	ArrowDown: "next",
	PageUp: "first",
	Home: "first",
	PageDown: "last",
	End: "last"
};
var getDirectionAwareKey = (key$2, dir) => {
	if (dir !== "rtl") return key$2;
	switch (key$2) {
		case EVENT_CODE.right: return EVENT_CODE.left;
		case EVENT_CODE.left: return EVENT_CODE.right;
		default: return key$2;
	}
};
var getFocusIntent = (event, orientation, dir) => {
	const key$2 = getDirectionAwareKey(event.key, dir);
	if (orientation === "vertical" && [EVENT_CODE.left, EVENT_CODE.right].includes(key$2)) return void 0;
	if (orientation === "horizontal" && [EVENT_CODE.up, EVENT_CODE.down].includes(key$2)) return void 0;
	return MAP_KEY_TO_FOCUS_INTENT[key$2];
};
var reorderArray = (array, atIdx) => {
	return array.map((_, idx) => array[(idx + atIdx) % array.length]);
};
var focusFirst$2 = (elements) => {
	const { activeElement: prevActive } = document;
	for (const element of elements) {
		if (element === prevActive) return;
		element.focus();
		if (prevActive !== document.activeElement) return;
	}
};
var CURRENT_TAB_ID_CHANGE_EVT = "currentTabIdChange";
var ENTRY_FOCUS_EVT = "rovingFocusGroup.entryFocus";
var EVT_OPTS = {
	bubbles: false,
	cancelable: true
};
var _sfc_main$15 = defineComponent({
	name: "ElRovingFocusGroupImpl",
	inheritAttrs: false,
	props: rovingFocusGroupProps,
	emits: [CURRENT_TAB_ID_CHANGE_EVT, "entryFocus"],
	setup(props, { emit }) {
		var _a;
		const currentTabbedId = ref((_a = props.currentTabId || props.defaultCurrentTabId) != null ? _a : null);
		const isBackingOut = ref(false);
		const isClickFocus = ref(false);
		const rovingFocusGroupRef = ref(null);
		const { getItems } = inject(COLLECTION_INJECTION_KEY$1, void 0);
		const rovingFocusGroupRootStyle = computed(() => {
			return [{ outline: "none" }, props.style];
		});
		const onItemFocus = (tabbedId) => {
			emit(CURRENT_TAB_ID_CHANGE_EVT, tabbedId);
		};
		const onItemShiftTab = () => {
			isBackingOut.value = true;
		};
		const onMousedown = composeEventHandlers((e) => {
			var _a2;
			(_a2 = props.onMousedown) == null || _a2.call(props, e);
		}, () => {
			isClickFocus.value = true;
		});
		const onFocus = composeEventHandlers((e) => {
			var _a2;
			(_a2 = props.onFocus) == null || _a2.call(props, e);
		}, (e) => {
			const isKeyboardFocus = !unref(isClickFocus);
			const { target: target$1, currentTarget } = e;
			if (target$1 === currentTarget && isKeyboardFocus && !unref(isBackingOut)) {
				const entryFocusEvt = new Event(ENTRY_FOCUS_EVT, EVT_OPTS);
				currentTarget?.dispatchEvent(entryFocusEvt);
				if (!entryFocusEvt.defaultPrevented) {
					const items = getItems().filter((item$4) => item$4.focusable);
					focusFirst$2([
						items.find((item$4) => item$4.active),
						items.find((item$4) => item$4.id === unref(currentTabbedId)),
						...items
					].filter(Boolean).map((item$4) => item$4.ref));
				}
			}
			isClickFocus.value = false;
		});
		const onBlur = composeEventHandlers((e) => {
			var _a2;
			(_a2 = props.onBlur) == null || _a2.call(props, e);
		}, () => {
			isBackingOut.value = false;
		});
		const handleEntryFocus = (...args) => {
			emit("entryFocus", ...args);
		};
		provide(ROVING_FOCUS_GROUP_INJECTION_KEY, {
			currentTabbedId: readonly(currentTabbedId),
			loop: toRef(props, "loop"),
			tabIndex: computed(() => {
				return unref(isBackingOut) ? -1 : 0;
			}),
			rovingFocusGroupRef,
			rovingFocusGroupRootStyle,
			orientation: toRef(props, "orientation"),
			dir: toRef(props, "dir"),
			onItemFocus,
			onItemShiftTab,
			onBlur,
			onFocus,
			onMousedown
		});
		watch(() => props.currentTabId, (val) => {
			currentTabbedId.value = val != null ? val : null;
		});
		useEventListener$1(rovingFocusGroupRef, ENTRY_FOCUS_EVT, handleEntryFocus);
	}
});
function _sfc_render$15(_ctx, _cache, $props, $setup, $data, $options) {
	return renderSlot(_ctx.$slots, "default");
}
var _sfc_main$14 = defineComponent({
	name: "ElRovingFocusGroup",
	components: {
		ElFocusGroupCollection: ElCollection$1,
		ElRovingFocusGroupImpl: /* @__PURE__ */ _export_sfc(_sfc_main$15, [["render", _sfc_render$15], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/roving-focus-group/src/roving-focus-group-impl.vue"]])
	}
});
function _sfc_render$14(_ctx, _cache, $props, $setup, $data, $options) {
	const _component_el_roving_focus_group_impl = resolveComponent("el-roving-focus-group-impl");
	const _component_el_focus_group_collection = resolveComponent("el-focus-group-collection");
	return openBlock(), createBlock(_component_el_focus_group_collection, null, {
		default: withCtx(() => [createVNode(_component_el_roving_focus_group_impl, normalizeProps(guardReactiveProps(_ctx.$attrs)), {
			default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
			_: 3
		}, 16)]),
		_: 3
	});
}
var ElRovingFocusGroup = /* @__PURE__ */ _export_sfc(_sfc_main$14, [["render", _sfc_render$14], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/roving-focus-group/src/roving-focus-group.vue"]]);
var _sfc_main$13 = defineComponent({
	components: { ElRovingFocusCollectionItem: ElCollectionItem$1 },
	props: {
		focusable: {
			type: Boolean,
			default: true
		},
		active: {
			type: Boolean,
			default: false
		}
	},
	emits: [
		"mousedown",
		"focus",
		"keydown"
	],
	setup(props, { emit }) {
		const { currentTabbedId, loop: loop$1, onItemFocus, onItemShiftTab } = inject(ROVING_FOCUS_GROUP_INJECTION_KEY, void 0);
		const { getItems } = inject(COLLECTION_INJECTION_KEY$1, void 0);
		const id$1 = useId$1();
		const rovingFocusGroupItemRef = ref(null);
		const handleMousedown = composeEventHandlers((e) => {
			emit("mousedown", e);
		}, (e) => {
			if (!props.focusable) e.preventDefault();
			else onItemFocus(unref(id$1));
		});
		const handleFocus = composeEventHandlers((e) => {
			emit("focus", e);
		}, () => {
			onItemFocus(unref(id$1));
		});
		const handleKeydown = composeEventHandlers((e) => {
			emit("keydown", e);
		}, (e) => {
			const { key: key$2, shiftKey, target: target$1, currentTarget } = e;
			if (key$2 === EVENT_CODE.tab && shiftKey) {
				onItemShiftTab();
				return;
			}
			if (target$1 !== currentTarget) return;
			const focusIntent = getFocusIntent(e);
			if (focusIntent) {
				e.preventDefault();
				let elements = getItems().filter((item$4) => item$4.focusable).map((item$4) => item$4.ref);
				switch (focusIntent) {
					case "last":
						elements.reverse();
						break;
					case "prev":
					case "next": {
						if (focusIntent === "prev") elements.reverse();
						const currentIdx = elements.indexOf(currentTarget);
						elements = loop$1.value ? reorderArray(elements, currentIdx + 1) : elements.slice(currentIdx + 1);
						break;
					}
					default: break;
				}
				nextTick(() => {
					focusFirst$2(elements);
				});
			}
		});
		const isCurrentTab = computed(() => currentTabbedId.value === unref(id$1));
		provide(ROVING_FOCUS_GROUP_ITEM_INJECTION_KEY, {
			rovingFocusGroupItemRef,
			tabIndex: computed(() => unref(isCurrentTab) ? 0 : -1),
			handleMousedown,
			handleFocus,
			handleKeydown
		});
		return {
			id: id$1,
			handleKeydown,
			handleFocus,
			handleMousedown
		};
	}
});
function _sfc_render$13(_ctx, _cache, $props, $setup, $data, $options) {
	const _component_el_roving_focus_collection_item = resolveComponent("el-roving-focus-collection-item");
	return openBlock(), createBlock(_component_el_roving_focus_collection_item, {
		id: _ctx.id,
		focusable: _ctx.focusable,
		active: _ctx.active
	}, {
		default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
		_: 3
	}, 8, [
		"id",
		"focusable",
		"active"
	]);
}
var ElRovingFocusItem = /* @__PURE__ */ _export_sfc(_sfc_main$13, [["render", _sfc_render$13], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/roving-focus-group/src/roving-focus-item.vue"]]);
var dropdownProps = buildProps({
	trigger: useTooltipTriggerProps.trigger,
	effect: {
		...useTooltipContentProps.effect,
		default: "light"
	},
	type: { type: definePropType(String) },
	placement: {
		type: definePropType(String),
		default: "bottom"
	},
	popperOptions: {
		type: definePropType(Object),
		default: () => ({})
	},
	id: String,
	size: {
		type: String,
		default: ""
	},
	splitButton: Boolean,
	hideOnClick: {
		type: Boolean,
		default: true
	},
	loop: {
		type: Boolean,
		default: true
	},
	showTimeout: {
		type: Number,
		default: 150
	},
	hideTimeout: {
		type: Number,
		default: 150
	},
	tabindex: {
		type: definePropType([Number, String]),
		default: 0
	},
	maxHeight: {
		type: definePropType([Number, String]),
		default: ""
	},
	popperClass: {
		type: String,
		default: ""
	},
	disabled: {
		type: Boolean,
		default: false
	},
	role: {
		type: String,
		default: "menu"
	},
	buttonProps: { type: definePropType(Object) },
	teleported: useTooltipContentProps.teleported
});
var dropdownItemProps = buildProps({
	command: {
		type: [
			Object,
			String,
			Number
		],
		default: () => ({})
	},
	disabled: Boolean,
	divided: Boolean,
	textValue: String,
	icon: { type: iconPropType }
});
var dropdownMenuProps = buildProps({ onKeydown: { type: definePropType(Function) } });
var FIRST_KEYS$1 = [
	EVENT_CODE.down,
	EVENT_CODE.pageDown,
	EVENT_CODE.home
];
var LAST_KEYS$1 = [
	EVENT_CODE.up,
	EVENT_CODE.pageUp,
	EVENT_CODE.end
];
var FIRST_LAST_KEYS$1 = [...FIRST_KEYS$1, ...LAST_KEYS$1];
var { ElCollection, ElCollectionItem, COLLECTION_INJECTION_KEY, COLLECTION_ITEM_INJECTION_KEY } = createCollectionWithScope("Dropdown");
var DROPDOWN_INJECTION_KEY = Symbol("elDropdown");
var { ButtonGroup: ElButtonGroup } = ElButton;
var _sfc_main$12 = defineComponent({
	name: "ElDropdown",
	components: {
		ElButton,
		ElButtonGroup,
		ElScrollbar,
		ElDropdownCollection: ElCollection,
		ElTooltip,
		ElRovingFocusGroup,
		ElOnlyChild: OnlyChild,
		ElIcon,
		ArrowDown: arrow_down_default
	},
	props: dropdownProps,
	emits: [
		"visible-change",
		"click",
		"command"
	],
	setup(props, { emit }) {
		const _instance = getCurrentInstance();
		const ns = useNamespace("dropdown");
		const { t: t$1 } = useLocale$1();
		const triggeringElementRef = ref();
		const referenceElementRef = ref();
		const popperRef = ref(null);
		const contentRef = ref(null);
		const scrollbar$1 = ref(null);
		const currentTabId = ref(null);
		const isUsingKeyboard = ref(false);
		const triggerKeys = [
			EVENT_CODE.enter,
			EVENT_CODE.space,
			EVENT_CODE.down
		];
		const wrapStyle = computed(() => ({ maxHeight: addUnit(props.maxHeight) }));
		const dropdownTriggerKls = computed(() => [ns.m(dropdownSize.value)]);
		const trigger = computed(() => castArray_default(props.trigger));
		const defaultTriggerId = useId$1().value;
		const triggerId = computed(() => {
			return props.id || defaultTriggerId;
		});
		watch([triggeringElementRef, trigger], ([triggeringElement, trigger2], [prevTriggeringElement]) => {
			var _a, _b, _c;
			if ((_a = prevTriggeringElement == null ? void 0 : prevTriggeringElement.$el) == null ? void 0 : _a.removeEventListener) prevTriggeringElement.$el.removeEventListener("pointerenter", onAutofocusTriggerEnter);
			if ((_b = triggeringElement == null ? void 0 : triggeringElement.$el) == null ? void 0 : _b.removeEventListener) triggeringElement.$el.removeEventListener("pointerenter", onAutofocusTriggerEnter);
			if (((_c = triggeringElement == null ? void 0 : triggeringElement.$el) == null ? void 0 : _c.addEventListener) && trigger2.includes("hover")) triggeringElement.$el.addEventListener("pointerenter", onAutofocusTriggerEnter);
		}, { immediate: true });
		onBeforeUnmount(() => {
			var _a, _b;
			if ((_b = (_a = triggeringElementRef.value) == null ? void 0 : _a.$el) == null ? void 0 : _b.removeEventListener) triggeringElementRef.value.$el.removeEventListener("pointerenter", onAutofocusTriggerEnter);
		});
		function handleClick() {
			handleClose();
		}
		function handleClose() {
			var _a;
			(_a = popperRef.value) == null || _a.onClose();
		}
		function handleOpen() {
			var _a;
			(_a = popperRef.value) == null || _a.onOpen();
		}
		const dropdownSize = useFormSize();
		function commandHandler(...args) {
			emit("command", ...args);
		}
		function onAutofocusTriggerEnter() {
			var _a, _b;
			(_b = (_a = triggeringElementRef.value) == null ? void 0 : _a.$el) == null || _b.focus();
		}
		function onItemEnter() {}
		function onItemLeave() {
			const contentEl = unref(contentRef);
			trigger.value.includes("hover") && contentEl?.focus();
			currentTabId.value = null;
		}
		function handleCurrentTabIdChange(id$1) {
			currentTabId.value = id$1;
		}
		function handleEntryFocus(e) {
			if (!isUsingKeyboard.value) {
				e.preventDefault();
				e.stopImmediatePropagation();
			}
		}
		function handleBeforeShowTooltip() {
			emit("visible-change", true);
		}
		function handleShowTooltip(event) {
			if ((event == null ? void 0 : event.type) === "keydown") contentRef.value.focus();
		}
		function handleBeforeHideTooltip() {
			emit("visible-change", false);
		}
		provide(DROPDOWN_INJECTION_KEY, {
			contentRef,
			role: computed(() => props.role),
			triggerId,
			isUsingKeyboard,
			onItemEnter,
			onItemLeave
		});
		provide("elDropdown", {
			instance: _instance,
			dropdownSize,
			handleClick,
			commandHandler,
			trigger: toRef(props, "trigger"),
			hideOnClick: toRef(props, "hideOnClick")
		});
		const onFocusAfterTrapped = (e) => {
			var _a, _b;
			e.preventDefault();
			(_b = (_a = contentRef.value) == null ? void 0 : _a.focus) == null || _b.call(_a, { preventScroll: true });
		};
		const handlerMainButtonClick = (event) => {
			emit("click", event);
		};
		return {
			t: t$1,
			ns,
			scrollbar: scrollbar$1,
			wrapStyle,
			dropdownTriggerKls,
			dropdownSize,
			triggerId,
			triggerKeys,
			currentTabId,
			handleCurrentTabIdChange,
			handlerMainButtonClick,
			handleEntryFocus,
			handleClose,
			handleOpen,
			handleBeforeShowTooltip,
			handleShowTooltip,
			handleBeforeHideTooltip,
			onFocusAfterTrapped,
			popperRef,
			contentRef,
			triggeringElementRef,
			referenceElementRef
		};
	}
});
function _sfc_render$12(_ctx, _cache, $props, $setup, $data, $options) {
	var _a;
	const _component_el_dropdown_collection = resolveComponent("el-dropdown-collection");
	const _component_el_roving_focus_group = resolveComponent("el-roving-focus-group");
	const _component_el_scrollbar = resolveComponent("el-scrollbar");
	const _component_el_only_child = resolveComponent("el-only-child");
	const _component_el_tooltip = resolveComponent("el-tooltip");
	const _component_el_button = resolveComponent("el-button");
	const _component_arrow_down = resolveComponent("arrow-down");
	const _component_el_icon = resolveComponent("el-icon");
	const _component_el_button_group = resolveComponent("el-button-group");
	return openBlock(), createElementBlock("div", { class: normalizeClass([_ctx.ns.b(), _ctx.ns.is("disabled", _ctx.disabled)]) }, [createVNode(_component_el_tooltip, {
		ref: "popperRef",
		role: _ctx.role,
		effect: _ctx.effect,
		"fallback-placements": ["bottom", "top"],
		"popper-options": _ctx.popperOptions,
		"gpu-acceleration": false,
		"hide-after": _ctx.trigger === "hover" ? _ctx.hideTimeout : 0,
		"manual-mode": true,
		placement: _ctx.placement,
		"popper-class": [_ctx.ns.e("popper"), _ctx.popperClass],
		"reference-element": (_a = _ctx.referenceElementRef) == null ? void 0 : _a.$el,
		trigger: _ctx.trigger,
		"trigger-keys": _ctx.triggerKeys,
		"trigger-target-el": _ctx.contentRef,
		"show-after": _ctx.trigger === "hover" ? _ctx.showTimeout : 0,
		"stop-popper-mouse-event": false,
		"virtual-ref": _ctx.triggeringElementRef,
		"virtual-triggering": _ctx.splitButton,
		disabled: _ctx.disabled,
		transition: `${_ctx.ns.namespace.value}-zoom-in-top`,
		teleported: _ctx.teleported,
		pure: "",
		persistent: "",
		onBeforeShow: _ctx.handleBeforeShowTooltip,
		onShow: _ctx.handleShowTooltip,
		onBeforeHide: _ctx.handleBeforeHideTooltip
	}, createSlots({
		content: withCtx(() => [createVNode(_component_el_scrollbar, {
			ref: "scrollbar",
			"wrap-style": _ctx.wrapStyle,
			tag: "div",
			"view-class": _ctx.ns.e("list")
		}, {
			default: withCtx(() => [createVNode(_component_el_roving_focus_group, {
				loop: _ctx.loop,
				"current-tab-id": _ctx.currentTabId,
				orientation: "horizontal",
				onCurrentTabIdChange: _ctx.handleCurrentTabIdChange,
				onEntryFocus: _ctx.handleEntryFocus
			}, {
				default: withCtx(() => [createVNode(_component_el_dropdown_collection, null, {
					default: withCtx(() => [renderSlot(_ctx.$slots, "dropdown")]),
					_: 3
				})]),
				_: 3
			}, 8, [
				"loop",
				"current-tab-id",
				"onCurrentTabIdChange",
				"onEntryFocus"
			])]),
			_: 3
		}, 8, ["wrap-style", "view-class"])]),
		_: 2
	}, [!_ctx.splitButton ? {
		name: "default",
		fn: withCtx(() => [createVNode(_component_el_only_child, {
			id: _ctx.triggerId,
			ref: "triggeringElementRef",
			role: "button",
			tabindex: _ctx.tabindex
		}, {
			default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
			_: 3
		}, 8, ["id", "tabindex"])])
	} : void 0]), 1032, [
		"role",
		"effect",
		"popper-options",
		"hide-after",
		"placement",
		"popper-class",
		"reference-element",
		"trigger",
		"trigger-keys",
		"trigger-target-el",
		"show-after",
		"virtual-ref",
		"virtual-triggering",
		"disabled",
		"transition",
		"teleported",
		"onBeforeShow",
		"onShow",
		"onBeforeHide"
	]), _ctx.splitButton ? (openBlock(), createBlock(_component_el_button_group, { key: 0 }, {
		default: withCtx(() => [createVNode(_component_el_button, mergeProps({ ref: "referenceElementRef" }, _ctx.buttonProps, {
			size: _ctx.dropdownSize,
			type: _ctx.type,
			disabled: _ctx.disabled,
			tabindex: _ctx.tabindex,
			onClick: _ctx.handlerMainButtonClick
		}), {
			default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
			_: 3
		}, 16, [
			"size",
			"type",
			"disabled",
			"tabindex",
			"onClick"
		]), createVNode(_component_el_button, mergeProps({
			id: _ctx.triggerId,
			ref: "triggeringElementRef"
		}, _ctx.buttonProps, {
			role: "button",
			size: _ctx.dropdownSize,
			type: _ctx.type,
			class: _ctx.ns.e("caret-button"),
			disabled: _ctx.disabled,
			tabindex: _ctx.tabindex,
			"aria-label": _ctx.t("el.dropdown.toggleDropdown")
		}), {
			default: withCtx(() => [createVNode(_component_el_icon, { class: normalizeClass(_ctx.ns.e("icon")) }, {
				default: withCtx(() => [createVNode(_component_arrow_down)]),
				_: 1
			}, 8, ["class"])]),
			_: 1
		}, 16, [
			"id",
			"size",
			"type",
			"class",
			"disabled",
			"tabindex",
			"aria-label"
		])]),
		_: 3
	})) : createCommentVNode("v-if", true)], 2);
}
var Dropdown = /* @__PURE__ */ _export_sfc(_sfc_main$12, [["render", _sfc_render$12], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/dropdown/src/dropdown.vue"]]);
var _sfc_main$11 = defineComponent({
	name: "DropdownItemImpl",
	components: { ElIcon },
	props: dropdownItemProps,
	emits: [
		"pointermove",
		"pointerleave",
		"click",
		"clickimpl"
	],
	setup(_, { emit }) {
		const ns = useNamespace("dropdown");
		const { role: menuRole } = inject(DROPDOWN_INJECTION_KEY, void 0);
		const { collectionItemRef: dropdownCollectionItemRef } = inject(COLLECTION_ITEM_INJECTION_KEY, void 0);
		const { collectionItemRef: rovingFocusCollectionItemRef } = inject(COLLECTION_ITEM_INJECTION_KEY$1, void 0);
		const { rovingFocusGroupItemRef, tabIndex, handleFocus, handleKeydown: handleItemKeydown, handleMousedown } = inject(ROVING_FOCUS_GROUP_ITEM_INJECTION_KEY, void 0);
		const itemRef = composeRefs(dropdownCollectionItemRef, rovingFocusCollectionItemRef, rovingFocusGroupItemRef);
		const role = computed(() => {
			if (menuRole.value === "menu") return "menuitem";
			else if (menuRole.value === "navigation") return "link";
			return "button";
		});
		const handleKeydown = composeEventHandlers((e) => {
			const { code } = e;
			if (code === EVENT_CODE.enter || code === EVENT_CODE.space) {
				e.preventDefault();
				e.stopImmediatePropagation();
				emit("clickimpl", e);
				return true;
			}
		}, handleItemKeydown);
		return {
			ns,
			itemRef,
			dataset: { [COLLECTION_ITEM_SIGN]: "" },
			role,
			tabIndex,
			handleFocus,
			handleKeydown,
			handleMousedown
		};
	}
});
var _hoisted_1$55 = [
	"aria-disabled",
	"tabindex",
	"role"
];
function _sfc_render$11(_ctx, _cache, $props, $setup, $data, $options) {
	const _component_el_icon = resolveComponent("el-icon");
	return openBlock(), createElementBlock(Fragment, null, [_ctx.divided ? (openBlock(), createElementBlock("li", mergeProps({
		key: 0,
		role: "separator",
		class: _ctx.ns.bem("menu", "item", "divided")
	}, _ctx.$attrs), null, 16)) : createCommentVNode("v-if", true), createBaseVNode("li", mergeProps({ ref: _ctx.itemRef }, {
		..._ctx.dataset,
		..._ctx.$attrs
	}, {
		"aria-disabled": _ctx.disabled,
		class: [_ctx.ns.be("menu", "item"), _ctx.ns.is("disabled", _ctx.disabled)],
		tabindex: _ctx.tabIndex,
		role: _ctx.role,
		onClick: _cache[0] || (_cache[0] = (e) => _ctx.$emit("clickimpl", e)),
		onFocus: _cache[1] || (_cache[1] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
		onKeydown: _cache[2] || (_cache[2] = withModifiers((...args) => _ctx.handleKeydown && _ctx.handleKeydown(...args), ["self"])),
		onMousedown: _cache[3] || (_cache[3] = (...args) => _ctx.handleMousedown && _ctx.handleMousedown(...args)),
		onPointermove: _cache[4] || (_cache[4] = (e) => _ctx.$emit("pointermove", e)),
		onPointerleave: _cache[5] || (_cache[5] = (e) => _ctx.$emit("pointerleave", e))
	}), [_ctx.icon ? (openBlock(), createBlock(_component_el_icon, { key: 0 }, {
		default: withCtx(() => [(openBlock(), createBlock(resolveDynamicComponent(_ctx.icon)))]),
		_: 1
	})) : createCommentVNode("v-if", true), renderSlot(_ctx.$slots, "default")], 16, _hoisted_1$55)], 64);
}
var ElDropdownItemImpl = /* @__PURE__ */ _export_sfc(_sfc_main$11, [["render", _sfc_render$11], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/dropdown/src/dropdown-item-impl.vue"]]);
var useDropdown = () => {
	const elDropdown = inject("elDropdown", {});
	return {
		elDropdown,
		_elDropdownSize: computed(() => elDropdown == null ? void 0 : elDropdown.dropdownSize)
	};
};
var _sfc_main$10 = defineComponent({
	name: "ElDropdownItem",
	components: {
		ElDropdownCollectionItem: ElCollectionItem,
		ElRovingFocusItem,
		ElDropdownItemImpl
	},
	inheritAttrs: false,
	props: dropdownItemProps,
	emits: [
		"pointermove",
		"pointerleave",
		"click"
	],
	setup(props, { emit, attrs }) {
		const { elDropdown } = useDropdown();
		const _instance = getCurrentInstance();
		const itemRef = ref(null);
		const textContent = computed(() => {
			var _a, _b;
			return (_b = (_a = unref(itemRef)) == null ? void 0 : _a.textContent) != null ? _b : "";
		});
		const { onItemEnter, onItemLeave } = inject(DROPDOWN_INJECTION_KEY, void 0);
		const handlePointerMove = composeEventHandlers((e) => {
			emit("pointermove", e);
			return e.defaultPrevented;
		}, whenMouse((e) => {
			if (props.disabled) {
				onItemLeave(e);
				return;
			}
			const target$1 = e.currentTarget;
			if (target$1 === document.activeElement || target$1.contains(document.activeElement)) return;
			onItemEnter(e);
			if (!e.defaultPrevented) target$1?.focus();
		}));
		const handlePointerLeave = composeEventHandlers((e) => {
			emit("pointerleave", e);
			return e.defaultPrevented;
		}, whenMouse((e) => {
			onItemLeave(e);
		}));
		return {
			handleClick: composeEventHandlers((e) => {
				if (props.disabled) return;
				emit("click", e);
				return e.type !== "keydown" && e.defaultPrevented;
			}, (e) => {
				var _a, _b, _c;
				if (props.disabled) {
					e.stopImmediatePropagation();
					return;
				}
				if ((_a = elDropdown == null ? void 0 : elDropdown.hideOnClick) == null ? void 0 : _a.value) (_b = elDropdown.handleClick) == null || _b.call(elDropdown);
				(_c = elDropdown.commandHandler) == null || _c.call(elDropdown, props.command, _instance, e);
			}),
			handlePointerMove,
			handlePointerLeave,
			textContent,
			propsAndAttrs: computed(() => {
				return {
					...props,
					...attrs
				};
			})
		};
	}
});
function _sfc_render$10(_ctx, _cache, $props, $setup, $data, $options) {
	var _a;
	const _component_el_dropdown_item_impl = resolveComponent("el-dropdown-item-impl");
	const _component_el_roving_focus_item = resolveComponent("el-roving-focus-item");
	const _component_el_dropdown_collection_item = resolveComponent("el-dropdown-collection-item");
	return openBlock(), createBlock(_component_el_dropdown_collection_item, {
		disabled: _ctx.disabled,
		"text-value": (_a = _ctx.textValue) != null ? _a : _ctx.textContent
	}, {
		default: withCtx(() => [createVNode(_component_el_roving_focus_item, { focusable: !_ctx.disabled }, {
			default: withCtx(() => [createVNode(_component_el_dropdown_item_impl, mergeProps(_ctx.propsAndAttrs, {
				onPointerleave: _ctx.handlePointerLeave,
				onPointermove: _ctx.handlePointerMove,
				onClickimpl: _ctx.handleClick
			}), {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 16, [
				"onPointerleave",
				"onPointermove",
				"onClickimpl"
			])]),
			_: 3
		}, 8, ["focusable"])]),
		_: 3
	}, 8, ["disabled", "text-value"]);
}
var DropdownItem = /* @__PURE__ */ _export_sfc(_sfc_main$10, [["render", _sfc_render$10], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/dropdown/src/dropdown-item.vue"]]);
var _sfc_main$9 = defineComponent({
	name: "ElDropdownMenu",
	props: dropdownMenuProps,
	setup(props) {
		const ns = useNamespace("dropdown");
		const { _elDropdownSize } = useDropdown();
		const size$2 = _elDropdownSize.value;
		const { focusTrapRef, onKeydown } = inject(FOCUS_TRAP_INJECTION_KEY, void 0);
		const { contentRef, role, triggerId } = inject(DROPDOWN_INJECTION_KEY, void 0);
		const { collectionRef: dropdownCollectionRef, getItems } = inject(COLLECTION_INJECTION_KEY, void 0);
		const { rovingFocusGroupRef, rovingFocusGroupRootStyle, tabIndex, onBlur, onFocus, onMousedown } = inject(ROVING_FOCUS_GROUP_INJECTION_KEY, void 0);
		const { collectionRef: rovingFocusGroupCollectionRef } = inject(COLLECTION_INJECTION_KEY$1, void 0);
		const dropdownKls = computed(() => {
			return [ns.b("menu"), ns.bm("menu", size$2 == null ? void 0 : size$2.value)];
		});
		const dropdownListWrapperRef = composeRefs(contentRef, dropdownCollectionRef, focusTrapRef, rovingFocusGroupRef, rovingFocusGroupCollectionRef);
		const composedKeydown = composeEventHandlers((e) => {
			var _a;
			(_a = props.onKeydown) == null || _a.call(props, e);
		}, (e) => {
			const { currentTarget, code, target: target$1 } = e;
			if (currentTarget.contains(target$1)) {}
			if (EVENT_CODE.tab === code) e.stopImmediatePropagation();
			e.preventDefault();
			if (target$1 !== unref(contentRef)) return;
			if (!FIRST_LAST_KEYS$1.includes(code)) return;
			const targets = getItems().filter((item$4) => !item$4.disabled).map((item$4) => item$4.ref);
			if (LAST_KEYS$1.includes(code)) targets.reverse();
			focusFirst$2(targets);
		});
		const handleKeydown = (e) => {
			composedKeydown(e);
			onKeydown(e);
		};
		return {
			size: size$2,
			rovingFocusGroupRootStyle,
			tabIndex,
			dropdownKls,
			role,
			triggerId,
			dropdownListWrapperRef,
			handleKeydown,
			onBlur,
			onFocus,
			onMousedown
		};
	}
});
var _hoisted_1$54 = ["role", "aria-labelledby"];
function _sfc_render$9(_ctx, _cache, $props, $setup, $data, $options) {
	return openBlock(), createElementBlock("ul", {
		ref: _ctx.dropdownListWrapperRef,
		class: normalizeClass(_ctx.dropdownKls),
		style: normalizeStyle(_ctx.rovingFocusGroupRootStyle),
		tabindex: -1,
		role: _ctx.role,
		"aria-labelledby": _ctx.triggerId,
		onBlur: _cache[0] || (_cache[0] = (...args) => _ctx.onBlur && _ctx.onBlur(...args)),
		onFocus: _cache[1] || (_cache[1] = (...args) => _ctx.onFocus && _ctx.onFocus(...args)),
		onKeydown: _cache[2] || (_cache[2] = withModifiers((...args) => _ctx.handleKeydown && _ctx.handleKeydown(...args), ["self"])),
		onMousedown: _cache[3] || (_cache[3] = withModifiers((...args) => _ctx.onMousedown && _ctx.onMousedown(...args), ["self"]))
	}, [renderSlot(_ctx.$slots, "default")], 46, _hoisted_1$54);
}
var DropdownMenu = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["render", _sfc_render$9], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/dropdown/src/dropdown-menu.vue"]]);
var ElDropdown = withInstall(Dropdown, {
	DropdownItem,
	DropdownMenu
});
var ElDropdownItem = withNoopInstall(DropdownItem);
var ElDropdownMenu = withNoopInstall(DropdownMenu);
var inputNumberProps = buildProps({
	id: {
		type: String,
		default: void 0
	},
	step: {
		type: Number,
		default: 1
	},
	stepStrictly: Boolean,
	max: {
		type: Number,
		default: Number.POSITIVE_INFINITY
	},
	min: {
		type: Number,
		default: Number.NEGATIVE_INFINITY
	},
	modelValue: Number,
	readonly: Boolean,
	disabled: Boolean,
	size: useSizeProp,
	controls: {
		type: Boolean,
		default: true
	},
	controlsPosition: {
		type: String,
		default: "",
		values: ["", "right"]
	},
	valueOnClear: {
		type: [
			String,
			Number,
			null
		],
		validator: (val) => val === null || isNumber(val) || ["min", "max"].includes(val),
		default: null
	},
	name: String,
	label: String,
	placeholder: String,
	precision: {
		type: Number,
		validator: (val) => val >= 0 && val === Number.parseInt(`${val}`, 10)
	},
	validateEvent: {
		type: Boolean,
		default: true
	}
});
var inputNumberEmits = {
	[CHANGE_EVENT]: (cur, prev) => prev !== cur,
	blur: (e) => e instanceof FocusEvent,
	focus: (e) => e instanceof FocusEvent,
	[INPUT_EVENT]: (val) => isNumber(val) || isNil_default(val),
	[UPDATE_MODEL_EVENT]: (val) => isNumber(val) || isNil_default(val)
};
init_shared_esm_bundler();
var _hoisted_1$53 = ["aria-label", "onKeydown"];
var _hoisted_2$32 = ["aria-label", "onKeydown"];
var ElInputNumber = withInstall(/* @__PURE__ */ _export_sfc(/* @__PURE__ */ defineComponent({
	...defineComponent({ name: "ElInputNumber" }),
	props: inputNumberProps,
	emits: inputNumberEmits,
	setup(__props, { expose, emit }) {
		const props = __props;
		const { t: t$1 } = useLocale$1();
		const ns = useNamespace("input-number");
		const input$4 = ref();
		const data = reactive({
			currentValue: props.modelValue,
			userInput: null
		});
		const { formItem } = useFormItem();
		const minDisabled = computed(() => isNumber(props.modelValue) && props.modelValue <= props.min);
		const maxDisabled = computed(() => isNumber(props.modelValue) && props.modelValue >= props.max);
		const numPrecision = computed(() => {
			const stepPrecision = getPrecision(props.step);
			if (!isUndefined(props.precision)) {
				if (stepPrecision > props.precision) debugWarn("InputNumber", "precision should not be less than the decimal places of step");
				return props.precision;
			} else return Math.max(getPrecision(props.modelValue), stepPrecision);
		});
		const controlsAtRight = computed(() => {
			return props.controls && props.controlsPosition === "right";
		});
		const inputNumberSize = useFormSize();
		const inputNumberDisabled = useFormDisabled();
		const displayValue = computed(() => {
			if (data.userInput !== null) return data.userInput;
			let currentValue = data.currentValue;
			if (isNil_default(currentValue)) return "";
			if (isNumber(currentValue)) {
				if (Number.isNaN(currentValue)) return "";
				if (!isUndefined(props.precision)) currentValue = currentValue.toFixed(props.precision);
			}
			return currentValue;
		});
		const toPrecision = (num$2, pre$1) => {
			if (isUndefined(pre$1)) pre$1 = numPrecision.value;
			if (pre$1 === 0) return Math.round(num$2);
			let snum = String(num$2);
			const pointPos = snum.indexOf(".");
			if (pointPos === -1) return num$2;
			if (!snum.replace(".", "").split("")[pointPos + pre$1]) return num$2;
			const length = snum.length;
			if (snum.charAt(length - 1) === "5") snum = `${snum.slice(0, Math.max(0, length - 1))}6`;
			return Number.parseFloat(Number(snum).toFixed(pre$1));
		};
		const getPrecision = (value) => {
			if (isNil_default(value)) return 0;
			const valueString = value.toString();
			const dotPosition = valueString.indexOf(".");
			let precision = 0;
			if (dotPosition !== -1) precision = valueString.length - dotPosition - 1;
			return precision;
		};
		const ensurePrecision = (val, coefficient = 1) => {
			if (!isNumber(val)) return data.currentValue;
			return toPrecision(val + props.step * coefficient);
		};
		const increase = () => {
			if (props.readonly || inputNumberDisabled.value || maxDisabled.value) return;
			setCurrentValue(ensurePrecision(Number(displayValue.value) || 0));
			emit(INPUT_EVENT, data.currentValue);
		};
		const decrease = () => {
			if (props.readonly || inputNumberDisabled.value || minDisabled.value) return;
			setCurrentValue(ensurePrecision(Number(displayValue.value) || 0, -1));
			emit(INPUT_EVENT, data.currentValue);
		};
		const verifyValue = (value, update) => {
			const { max: max$2, min: min$2, step, precision, stepStrictly, valueOnClear } = props;
			if (max$2 < min$2) throwError("InputNumber", "min should not be greater than max.");
			let newVal = Number(value);
			if (isNil_default(value) || Number.isNaN(newVal)) return null;
			if (value === "") {
				if (valueOnClear === null) return null;
				newVal = isString$2(valueOnClear) ? {
					min: min$2,
					max: max$2
				}[valueOnClear] : valueOnClear;
			}
			if (stepStrictly) newVal = toPrecision(Math.round(newVal / step) * step, precision);
			if (!isUndefined(precision)) newVal = toPrecision(newVal, precision);
			if (newVal > max$2 || newVal < min$2) {
				newVal = newVal > max$2 ? max$2 : min$2;
				update && emit("update:modelValue", newVal);
			}
			return newVal;
		};
		const setCurrentValue = (value, emitChange = true) => {
			var _a;
			const oldVal = data.currentValue;
			const newVal = verifyValue(value);
			if (!emitChange) {
				emit(UPDATE_MODEL_EVENT, newVal);
				return;
			}
			if (oldVal === newVal) return;
			data.userInput = null;
			emit(UPDATE_MODEL_EVENT, newVal);
			emit(CHANGE_EVENT, newVal, oldVal);
			if (props.validateEvent) (_a = formItem == null ? void 0 : formItem.validate) == null || _a.call(formItem, "change").catch((err) => debugWarn(err));
			data.currentValue = newVal;
		};
		const handleInput = (value) => {
			data.userInput = value;
			const newVal = value === "" ? null : Number(value);
			emit(INPUT_EVENT, newVal);
			setCurrentValue(newVal, false);
		};
		const handleInputChange = (value) => {
			const newVal = value !== "" ? Number(value) : "";
			if (isNumber(newVal) && !Number.isNaN(newVal) || value === "") setCurrentValue(newVal);
			data.userInput = null;
		};
		const focus$1 = () => {
			var _a, _b;
			(_b = (_a = input$4.value) == null ? void 0 : _a.focus) == null || _b.call(_a);
		};
		const blur = () => {
			var _a, _b;
			(_b = (_a = input$4.value) == null ? void 0 : _a.blur) == null || _b.call(_a);
		};
		const handleFocus = (event) => {
			emit("focus", event);
		};
		const handleBlur = (event) => {
			var _a;
			emit("blur", event);
			if (props.validateEvent) (_a = formItem == null ? void 0 : formItem.validate) == null || _a.call(formItem, "blur").catch((err) => debugWarn(err));
		};
		watch(() => props.modelValue, (value) => {
			const userInput = verifyValue(data.userInput);
			const newValue = verifyValue(value, true);
			if (!isNumber(userInput) && (!userInput || userInput !== newValue)) {
				data.currentValue = newValue;
				data.userInput = null;
			}
		}, { immediate: true });
		onMounted(() => {
			var _a;
			const { min: min$2, max: max$2, modelValue } = props;
			const innerInput = (_a = input$4.value) == null ? void 0 : _a.input;
			innerInput.setAttribute("role", "spinbutton");
			if (Number.isFinite(max$2)) innerInput.setAttribute("aria-valuemax", String(max$2));
			else innerInput.removeAttribute("aria-valuemax");
			if (Number.isFinite(min$2)) innerInput.setAttribute("aria-valuemin", String(min$2));
			else innerInput.removeAttribute("aria-valuemin");
			innerInput.setAttribute("aria-valuenow", data.currentValue || data.currentValue === 0 ? String(data.currentValue) : "");
			innerInput.setAttribute("aria-disabled", String(inputNumberDisabled.value));
			if (!isNumber(modelValue) && modelValue != null) {
				let val = Number(modelValue);
				if (Number.isNaN(val)) val = null;
				emit(UPDATE_MODEL_EVENT, val);
			}
		});
		onUpdated(() => {
			var _a, _b;
			((_a = input$4.value) == null ? void 0 : _a.input)?.setAttribute("aria-valuenow", `${(_b = data.currentValue) != null ? _b : ""}`);
		});
		expose({
			focus: focus$1,
			blur
		});
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", {
				class: normalizeClass([
					unref(ns).b(),
					unref(ns).m(unref(inputNumberSize)),
					unref(ns).is("disabled", unref(inputNumberDisabled)),
					unref(ns).is("without-controls", !_ctx.controls),
					unref(ns).is("controls-right", unref(controlsAtRight))
				]),
				onDragstart: _cache[1] || (_cache[1] = withModifiers(() => {}, ["prevent"]))
			}, [
				_ctx.controls ? withDirectives((openBlock(), createElementBlock("span", {
					key: 0,
					role: "button",
					"aria-label": unref(t$1)("el.inputNumber.decrease"),
					class: normalizeClass([unref(ns).e("decrease"), unref(ns).is("disabled", unref(minDisabled))]),
					onKeydown: withKeys(decrease, ["enter"])
				}, [createVNode(unref(ElIcon), null, {
					default: withCtx(() => [unref(controlsAtRight) ? (openBlock(), createBlock(unref(arrow_down_default), { key: 0 })) : (openBlock(), createBlock(unref(minus_default), { key: 1 }))]),
					_: 1
				})], 42, _hoisted_1$53)), [[unref(vRepeatClick), decrease]]) : createCommentVNode("v-if", true),
				_ctx.controls ? withDirectives((openBlock(), createElementBlock("span", {
					key: 1,
					role: "button",
					"aria-label": unref(t$1)("el.inputNumber.increase"),
					class: normalizeClass([unref(ns).e("increase"), unref(ns).is("disabled", unref(maxDisabled))]),
					onKeydown: withKeys(increase, ["enter"])
				}, [createVNode(unref(ElIcon), null, {
					default: withCtx(() => [unref(controlsAtRight) ? (openBlock(), createBlock(unref(arrow_up_default), { key: 0 })) : (openBlock(), createBlock(unref(plus_default), { key: 1 }))]),
					_: 1
				})], 42, _hoisted_2$32)), [[unref(vRepeatClick), increase]]) : createCommentVNode("v-if", true),
				createVNode(unref(ElInput), {
					id: _ctx.id,
					ref_key: "input",
					ref: input$4,
					type: "number",
					step: _ctx.step,
					"model-value": unref(displayValue),
					placeholder: _ctx.placeholder,
					readonly: _ctx.readonly,
					disabled: unref(inputNumberDisabled),
					size: unref(inputNumberSize),
					max: _ctx.max,
					min: _ctx.min,
					name: _ctx.name,
					label: _ctx.label,
					"validate-event": false,
					onWheel: _cache[0] || (_cache[0] = withModifiers(() => {}, ["prevent"])),
					onKeydown: [withKeys(withModifiers(increase, ["prevent"]), ["up"]), withKeys(withModifiers(decrease, ["prevent"]), ["down"])],
					onBlur: handleBlur,
					onFocus: handleFocus,
					onInput: handleInput,
					onChange: handleInputChange
				}, null, 8, [
					"id",
					"step",
					"model-value",
					"placeholder",
					"readonly",
					"disabled",
					"size",
					"max",
					"min",
					"name",
					"label",
					"onKeydown"
				])
			], 34);
		};
	}
}), [["__file", "/home/runner/work/element-plus/element-plus/packages/components/input-number/src/input-number.vue"]]));
var SubMenu$1 = class {
	constructor(parent, domNode) {
		this.parent = parent;
		this.domNode = domNode;
		this.subIndex = 0;
		this.subIndex = 0;
		this.init();
	}
	init() {
		this.subMenuItems = this.domNode.querySelectorAll("li");
		this.addListeners();
	}
	gotoSubIndex(idx) {
		if (idx === this.subMenuItems.length) idx = 0;
		else if (idx < 0) idx = this.subMenuItems.length - 1;
		this.subMenuItems[idx].focus();
		this.subIndex = idx;
	}
	addListeners() {
		const parentNode = this.parent.domNode;
		Array.prototype.forEach.call(this.subMenuItems, (el$2) => {
			el$2.addEventListener("keydown", (event) => {
				let prevDef = false;
				switch (event.code) {
					case EVENT_CODE.down:
						this.gotoSubIndex(this.subIndex + 1);
						prevDef = true;
						break;
					case EVENT_CODE.up:
						this.gotoSubIndex(this.subIndex - 1);
						prevDef = true;
						break;
					case EVENT_CODE.tab:
						triggerEvent(parentNode, "mouseleave");
						break;
					case EVENT_CODE.enter:
					case EVENT_CODE.space:
						prevDef = true;
						event.currentTarget.click();
						break;
				}
				if (prevDef) {
					event.preventDefault();
					event.stopPropagation();
				}
				return false;
			});
		});
	}
};
var MenuItem$1 = class {
	constructor(domNode, namespace) {
		this.domNode = domNode;
		this.submenu = null;
		this.submenu = null;
		this.init(namespace);
	}
	init(namespace) {
		this.domNode.setAttribute("tabindex", "0");
		const menuChild = this.domNode.querySelector(`.${namespace}-menu`);
		if (menuChild) this.submenu = new SubMenu$1(this, menuChild);
		this.addListeners();
	}
	addListeners() {
		this.domNode.addEventListener("keydown", (event) => {
			let prevDef = false;
			switch (event.code) {
				case EVENT_CODE.down:
					triggerEvent(event.currentTarget, "mouseenter");
					this.submenu && this.submenu.gotoSubIndex(0);
					prevDef = true;
					break;
				case EVENT_CODE.up:
					triggerEvent(event.currentTarget, "mouseenter");
					this.submenu && this.submenu.gotoSubIndex(this.submenu.subMenuItems.length - 1);
					prevDef = true;
					break;
				case EVENT_CODE.tab:
					triggerEvent(event.currentTarget, "mouseleave");
					break;
				case EVENT_CODE.enter:
				case EVENT_CODE.space:
					prevDef = true;
					event.currentTarget.click();
					break;
			}
			if (prevDef) event.preventDefault();
		});
	}
};
var Menu$1 = class {
	constructor(domNode, namespace) {
		this.domNode = domNode;
		this.init(namespace);
	}
	init(namespace) {
		const menuChildren = this.domNode.childNodes;
		Array.from(menuChildren).forEach((child$1) => {
			if (child$1.nodeType === 1) new MenuItem$1(child$1, namespace);
		});
	}
};
var _sfc_main$8 = defineComponent({
	name: "ElMenuCollapseTransition",
	setup() {
		const ns = useNamespace("menu");
		return { listeners: {
			onBeforeEnter: (el$2) => el$2.style.opacity = "0.2",
			onEnter(el$2, done) {
				addClass(el$2, `${ns.namespace.value}-opacity-transition`);
				el$2.style.opacity = "1";
				done();
			},
			onAfterEnter(el$2) {
				removeClass(el$2, `${ns.namespace.value}-opacity-transition`);
				el$2.style.opacity = "";
			},
			onBeforeLeave(el$2) {
				if (!el$2.dataset) el$2.dataset = {};
				if (hasClass(el$2, ns.m("collapse"))) {
					removeClass(el$2, ns.m("collapse"));
					el$2.dataset.oldOverflow = el$2.style.overflow;
					el$2.dataset.scrollWidth = el$2.clientWidth.toString();
					addClass(el$2, ns.m("collapse"));
				} else {
					addClass(el$2, ns.m("collapse"));
					el$2.dataset.oldOverflow = el$2.style.overflow;
					el$2.dataset.scrollWidth = el$2.clientWidth.toString();
					removeClass(el$2, ns.m("collapse"));
				}
				el$2.style.width = `${el$2.scrollWidth}px`;
				el$2.style.overflow = "hidden";
			},
			onLeave(el$2) {
				addClass(el$2, "horizontal-collapse-transition");
				el$2.style.width = `${el$2.dataset.scrollWidth}px`;
			}
		} };
	}
});
function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
	return openBlock(), createBlock(Transition, mergeProps({ mode: "out-in" }, _ctx.listeners), {
		default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
		_: 3
	}, 16);
}
var ElMenuCollapseTransition = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["render", _sfc_render$8], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/menu/src/menu-collapse-transition.vue"]]);
function useMenu(instance, currentIndex) {
	const indexPath = computed(() => {
		let parent = instance.parent;
		const path = [currentIndex.value];
		while (parent.type.name !== "ElMenu") {
			if (parent.props.index) path.unshift(parent.props.index);
			parent = parent.parent;
		}
		return path;
	});
	return {
		parentMenu: computed(() => {
			let parent = instance.parent;
			while (parent && !["ElMenu", "ElSubMenu"].includes(parent.type.name)) parent = parent.parent;
			return parent;
		}),
		indexPath
	};
}
function useMenuColor(props) {
	return computed(() => {
		const color = props.backgroundColor;
		if (!color) return "";
		else return new TinyColor(color).shade(20).toString();
	});
}
var useMenuCssVar = (props, level) => {
	const ns = useNamespace("menu");
	return computed(() => {
		return ns.cssVarBlock({
			"text-color": props.textColor || "",
			"hover-text-color": props.textColor || "",
			"bg-color": props.backgroundColor || "",
			"hover-bg-color": useMenuColor(props).value || "",
			"active-color": props.activeTextColor || "",
			level: `${level}`
		});
	});
};
init_shared_esm_bundler();
var subMenuProps = buildProps({
	index: {
		type: String,
		required: true
	},
	showTimeout: {
		type: Number,
		default: 300
	},
	hideTimeout: {
		type: Number,
		default: 300
	},
	popperClass: String,
	disabled: Boolean,
	popperAppendToBody: {
		type: Boolean,
		default: void 0
	},
	teleported: {
		type: Boolean,
		default: void 0
	},
	popperOffset: {
		type: Number,
		default: 6
	},
	expandCloseIcon: { type: iconPropType },
	expandOpenIcon: { type: iconPropType },
	collapseCloseIcon: { type: iconPropType },
	collapseOpenIcon: { type: iconPropType }
});
var COMPONENT_NAME$3 = "ElSubMenu";
var SubMenu = defineComponent({
	name: COMPONENT_NAME$3,
	props: subMenuProps,
	setup(props, { slots, expose }) {
		useDeprecated({
			from: "popper-append-to-body",
			replacement: "teleported",
			scope: COMPONENT_NAME$3,
			version: "2.3.0",
			ref: "https://element-plus.org/en-US/component/menu.html#submenu-attributes"
		}, computed(() => props.popperAppendToBody !== void 0));
		const instance = getCurrentInstance();
		const { indexPath, parentMenu } = useMenu(instance, computed(() => props.index));
		const nsMenu = useNamespace("menu");
		const nsSubMenu = useNamespace("sub-menu");
		const rootMenu = inject("rootMenu");
		if (!rootMenu) throwError(COMPONENT_NAME$3, "can not inject root menu");
		const subMenu = inject(`subMenu:${parentMenu.value.uid}`);
		if (!subMenu) throwError(COMPONENT_NAME$3, "can not inject sub menu");
		const items = ref({});
		const subMenus = ref({});
		let timeout;
		const mouseInChild = ref(false);
		const verticalTitleRef = ref();
		const vPopper = ref(null);
		const currentPlacement = computed(() => mode.value === "horizontal" && isFirstLevel.value ? "bottom-start" : "right-start");
		const subMenuTitleIcon = computed(() => {
			return mode.value === "horizontal" && isFirstLevel.value || mode.value === "vertical" && !rootMenu.props.collapse ? props.expandCloseIcon && props.expandOpenIcon ? opened.value ? props.expandOpenIcon : props.expandCloseIcon : arrow_down_default : props.collapseCloseIcon && props.collapseOpenIcon ? opened.value ? props.collapseOpenIcon : props.collapseCloseIcon : arrow_right_default;
		});
		const isFirstLevel = computed(() => {
			return subMenu.level === 0;
		});
		const appendToBody = computed(() => {
			var _a;
			const value = (_a = props.teleported) != null ? _a : props.popperAppendToBody;
			return value === void 0 ? isFirstLevel.value : value;
		});
		const menuTransitionName = computed(() => rootMenu.props.collapse ? `${nsMenu.namespace.value}-zoom-in-left` : `${nsMenu.namespace.value}-zoom-in-top`);
		const fallbackPlacements = computed(() => mode.value === "horizontal" && isFirstLevel.value ? [
			"bottom-start",
			"bottom-end",
			"top-start",
			"top-end",
			"right-start",
			"left-start"
		] : [
			"right-start",
			"right",
			"right-end",
			"left-start",
			"bottom-start",
			"bottom-end",
			"top-start",
			"top-end"
		]);
		const opened = computed(() => rootMenu.openedMenus.includes(props.index));
		const active$3 = computed(() => {
			let isActive = false;
			Object.values(items.value).forEach((item2) => {
				if (item2.active) isActive = true;
			});
			Object.values(subMenus.value).forEach((subItem) => {
				if (subItem.active) isActive = true;
			});
			return isActive;
		});
		const mode = computed(() => rootMenu.props.mode);
		const item$4 = reactive({
			index: props.index,
			indexPath,
			active: active$3
		});
		const ulStyle = useMenuCssVar(rootMenu.props, subMenu.level + 1);
		const doDestroy = () => {
			var _a, _b, _c;
			return (_c = (_b = (_a = vPopper.value) == null ? void 0 : _a.popperRef) == null ? void 0 : _b.popperInstanceRef) == null ? void 0 : _c.destroy();
		};
		const handleCollapseToggle = (value) => {
			if (!value) doDestroy();
		};
		const handleClick = () => {
			if (rootMenu.props.menuTrigger === "hover" && rootMenu.props.mode === "horizontal" || rootMenu.props.collapse && rootMenu.props.mode === "vertical" || props.disabled) return;
			rootMenu.handleSubMenuClick({
				index: props.index,
				indexPath: indexPath.value,
				active: active$3.value
			});
		};
		const handleMouseenter = (event, showTimeout = props.showTimeout) => {
			var _a;
			if (event.type === "focus") return;
			if (rootMenu.props.menuTrigger === "click" && rootMenu.props.mode === "horizontal" || !rootMenu.props.collapse && rootMenu.props.mode === "vertical" || props.disabled) return;
			subMenu.mouseInChild.value = true;
			timeout?.();
			({stop: timeout} = useTimeoutFn$1(() => {
				rootMenu.openMenu(props.index, indexPath.value);
			}, showTimeout));
			if (appendToBody.value) (_a = parentMenu.value.vnode.el) == null || _a.dispatchEvent(new MouseEvent("mouseenter"));
		};
		const handleMouseleave = (deepDispatch = false) => {
			var _a, _b;
			if (rootMenu.props.menuTrigger === "click" && rootMenu.props.mode === "horizontal" || !rootMenu.props.collapse && rootMenu.props.mode === "vertical") return;
			timeout?.();
			subMenu.mouseInChild.value = false;
			({stop: timeout} = useTimeoutFn$1(() => !mouseInChild.value && rootMenu.closeMenu(props.index, indexPath.value), props.hideTimeout));
			if (appendToBody.value && deepDispatch) {
				if (((_a = instance.parent) == null ? void 0 : _a.type.name) === "ElSubMenu") (_b = subMenu.handleMouseleave) == null || _b.call(subMenu, true);
			}
		};
		watch(() => rootMenu.props.collapse, (value) => handleCollapseToggle(Boolean(value)));
		{
			const addSubMenu = (item2) => {
				subMenus.value[item2.index] = item2;
			};
			const removeSubMenu = (item2) => {
				delete subMenus.value[item2.index];
			};
			provide(`subMenu:${instance.uid}`, {
				addSubMenu,
				removeSubMenu,
				handleMouseleave,
				mouseInChild,
				level: subMenu.level + 1
			});
		}
		expose({ opened });
		onMounted(() => {
			rootMenu.addSubMenu(item$4);
			subMenu.addSubMenu(item$4);
		});
		onBeforeUnmount(() => {
			subMenu.removeSubMenu(item$4);
			rootMenu.removeSubMenu(item$4);
		});
		return () => {
			var _a;
			const titleTag = [(_a = slots.title) == null ? void 0 : _a.call(slots), h(ElIcon, {
				class: nsSubMenu.e("icon-arrow"),
				style: { transform: opened.value ? props.expandCloseIcon && props.expandOpenIcon || props.collapseCloseIcon && props.collapseOpenIcon && rootMenu.props.collapse ? "none" : "rotateZ(180deg)" : "none" }
			}, { default: () => isString$2(subMenuTitleIcon.value) ? h(instance.appContext.components[subMenuTitleIcon.value]) : h(subMenuTitleIcon.value) })];
			const child$1 = rootMenu.isMenuPopup ? h(ElTooltip, {
				ref: vPopper,
				visible: opened.value,
				effect: "light",
				pure: true,
				offset: props.popperOffset,
				showArrow: false,
				persistent: true,
				popperClass: props.popperClass,
				placement: currentPlacement.value,
				teleported: appendToBody.value,
				fallbackPlacements: fallbackPlacements.value,
				transition: menuTransitionName.value,
				gpuAcceleration: false
			}, {
				content: () => {
					var _a2;
					return h("div", {
						class: [
							nsMenu.m(mode.value),
							nsMenu.m("popup-container"),
							props.popperClass
						],
						onMouseenter: (evt) => handleMouseenter(evt, 100),
						onMouseleave: () => handleMouseleave(true),
						onFocus: (evt) => handleMouseenter(evt, 100)
					}, [h("ul", {
						class: [
							nsMenu.b(),
							nsMenu.m("popup"),
							nsMenu.m(`popup-${currentPlacement.value}`)
						],
						style: ulStyle.value
					}, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)])]);
				},
				default: () => h("div", {
					class: nsSubMenu.e("title"),
					onClick: handleClick
				}, titleTag)
			}) : h(Fragment, {}, [h("div", {
				class: nsSubMenu.e("title"),
				ref: verticalTitleRef,
				onClick: handleClick
			}, titleTag), h(_CollapseTransition, {}, { default: () => {
				var _a2;
				return withDirectives(h("ul", {
					role: "menu",
					class: [nsMenu.b(), nsMenu.m("inline")],
					style: ulStyle.value
				}, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)]), [[vShow, opened.value]]);
			} })]);
			return h("li", {
				class: [
					nsSubMenu.b(),
					nsSubMenu.is("active", active$3.value),
					nsSubMenu.is("opened", opened.value),
					nsSubMenu.is("disabled", props.disabled)
				],
				role: "menuitem",
				ariaHaspopup: true,
				ariaExpanded: opened.value,
				onMouseenter: handleMouseenter,
				onMouseleave: () => handleMouseleave(true),
				onFocus: handleMouseenter
			}, [child$1]);
		};
	}
});
init_shared_esm_bundler();
var menuProps = buildProps({
	mode: {
		type: String,
		values: ["horizontal", "vertical"],
		default: "vertical"
	},
	defaultActive: {
		type: String,
		default: ""
	},
	defaultOpeneds: {
		type: definePropType(Array),
		default: () => mutable([])
	},
	uniqueOpened: Boolean,
	router: Boolean,
	menuTrigger: {
		type: String,
		values: ["hover", "click"],
		default: "hover"
	},
	collapse: Boolean,
	backgroundColor: String,
	textColor: String,
	activeTextColor: String,
	collapseTransition: {
		type: Boolean,
		default: true
	},
	ellipsis: {
		type: Boolean,
		default: true
	},
	popperEffect: {
		type: String,
		values: ["dark", "light"],
		default: "dark"
	}
});
var checkIndexPath = (indexPath) => Array.isArray(indexPath) && indexPath.every((path) => isString$2(path));
var Menu = defineComponent({
	name: "ElMenu",
	props: menuProps,
	emits: {
		close: (index, indexPath) => isString$2(index) && checkIndexPath(indexPath),
		open: (index, indexPath) => isString$2(index) && checkIndexPath(indexPath),
		select: (index, indexPath, item$4, routerResult) => isString$2(index) && checkIndexPath(indexPath) && isObject$2(item$4) && (routerResult === void 0 || routerResult instanceof Promise)
	},
	setup(props, { emit, slots, expose }) {
		const instance = getCurrentInstance();
		const router = instance.appContext.config.globalProperties.$router;
		const menu = ref();
		const nsMenu = useNamespace("menu");
		const nsSubMenu = useNamespace("sub-menu");
		const sliceIndex = ref(-1);
		const openedMenus = ref(props.defaultOpeneds && !props.collapse ? props.defaultOpeneds.slice(0) : []);
		const activeIndex = ref(props.defaultActive);
		const items = ref({});
		const subMenus = ref({});
		const isMenuPopup = computed(() => {
			return props.mode === "horizontal" || props.mode === "vertical" && props.collapse;
		});
		const initMenu = () => {
			const activeItem = activeIndex.value && items.value[activeIndex.value];
			if (!activeItem || props.mode === "horizontal" || props.collapse) return;
			activeItem.indexPath.forEach((index) => {
				const subMenu = subMenus.value[index];
				subMenu && openMenu(index, subMenu.indexPath);
			});
		};
		const openMenu = (index, indexPath) => {
			if (openedMenus.value.includes(index)) return;
			if (props.uniqueOpened) openedMenus.value = openedMenus.value.filter((index2) => indexPath.includes(index2));
			openedMenus.value.push(index);
			emit("open", index, indexPath);
		};
		const close = (index) => {
			const i$1 = openedMenus.value.indexOf(index);
			if (i$1 !== -1) openedMenus.value.splice(i$1, 1);
		};
		const closeMenu = (index, indexPath) => {
			close(index);
			emit("close", index, indexPath);
		};
		const handleSubMenuClick = ({ index, indexPath }) => {
			if (openedMenus.value.includes(index)) closeMenu(index, indexPath);
			else openMenu(index, indexPath);
		};
		const handleMenuItemClick = (menuItem$1) => {
			if (props.mode === "horizontal" || props.collapse) openedMenus.value = [];
			const { index, indexPath } = menuItem$1;
			if (isNil_default(index) || isNil_default(indexPath)) return;
			if (props.router && router) {
				const route = menuItem$1.route || index;
				const routerResult = router.push(route).then((res) => {
					if (!res) activeIndex.value = index;
					return res;
				});
				emit("select", index, indexPath, {
					index,
					indexPath,
					route
				}, routerResult);
			} else {
				activeIndex.value = index;
				emit("select", index, indexPath, {
					index,
					indexPath
				});
			}
		};
		const updateActiveIndex = (val) => {
			const itemsInData = items.value;
			const item$4 = itemsInData[val] || activeIndex.value && itemsInData[activeIndex.value] || itemsInData[props.defaultActive];
			if (item$4) activeIndex.value = item$4.index;
			else activeIndex.value = val;
		};
		const calcSliceIndex = () => {
			var _a, _b;
			if (!menu.value) return -1;
			const items2 = Array.from((_b = (_a = menu.value) == null ? void 0 : _a.childNodes) != null ? _b : []).filter((item$4) => item$4.nodeName !== "#comment" && (item$4.nodeName !== "#text" || item$4.nodeValue));
			const moreItemWidth = 64;
			const paddingLeft = Number.parseInt(getComputedStyle(menu.value).paddingLeft, 10);
			const paddingRight = Number.parseInt(getComputedStyle(menu.value).paddingRight, 10);
			const menuWidth = menu.value.clientWidth - paddingLeft - paddingRight;
			let calcWidth = 0;
			let sliceIndex2 = 0;
			items2.forEach((item$4, index) => {
				calcWidth += item$4.offsetWidth || 0;
				if (calcWidth <= menuWidth - moreItemWidth) sliceIndex2 = index + 1;
			});
			return sliceIndex2 === items2.length ? -1 : sliceIndex2;
		};
		const debounce$1 = (fn$1, wait = 33.34) => {
			let timmer;
			return () => {
				timmer && clearTimeout(timmer);
				timmer = setTimeout(() => {
					fn$1();
				}, wait);
			};
		};
		let isFirstTimeRender = true;
		const handleResize = () => {
			const callback = () => {
				sliceIndex.value = -1;
				nextTick(() => {
					sliceIndex.value = calcSliceIndex();
				});
			};
			isFirstTimeRender ? callback() : debounce$1(callback)();
			isFirstTimeRender = false;
		};
		watch(() => props.defaultActive, (currentActive) => {
			if (!items.value[currentActive]) activeIndex.value = "";
			updateActiveIndex(currentActive);
		});
		watch(() => props.collapse, (value) => {
			if (value) openedMenus.value = [];
		});
		watch(items.value, initMenu);
		let resizeStopper;
		watchEffect(() => {
			if (props.mode === "horizontal" && props.ellipsis) resizeStopper = useResizeObserver$2(menu, handleResize).stop;
			else resizeStopper?.();
		});
		{
			const addSubMenu = (item$4) => {
				subMenus.value[item$4.index] = item$4;
			};
			const removeSubMenu = (item$4) => {
				delete subMenus.value[item$4.index];
			};
			const addMenuItem = (item$4) => {
				items.value[item$4.index] = item$4;
			};
			const removeMenuItem = (item$4) => {
				delete items.value[item$4.index];
			};
			provide("rootMenu", reactive({
				props,
				openedMenus,
				items,
				subMenus,
				activeIndex,
				isMenuPopup,
				addMenuItem,
				removeMenuItem,
				addSubMenu,
				removeSubMenu,
				openMenu,
				closeMenu,
				handleMenuItemClick,
				handleSubMenuClick
			}));
			provide(`subMenu:${instance.uid}`, {
				addSubMenu,
				removeSubMenu,
				mouseInChild: ref(false),
				level: 0
			});
		}
		onMounted(() => {
			if (props.mode === "horizontal") new Menu$1(instance.vnode.el, nsMenu.namespace.value);
		});
		{
			const open = (index) => {
				const { indexPath } = subMenus.value[index];
				indexPath.forEach((i$1) => openMenu(i$1, indexPath));
			};
			expose({
				open,
				close,
				handleResize
			});
		}
		return () => {
			var _a, _b;
			let slot = (_b = (_a = slots.default) == null ? void 0 : _a.call(slots)) != null ? _b : [];
			const vShowMore = [];
			if (props.mode === "horizontal" && menu.value) {
				const originalSlot = flattedChildren(slot);
				const slotDefault = sliceIndex.value === -1 ? originalSlot : originalSlot.slice(0, sliceIndex.value);
				const slotMore = sliceIndex.value === -1 ? [] : originalSlot.slice(sliceIndex.value);
				if ((slotMore == null ? void 0 : slotMore.length) && props.ellipsis) {
					slot = slotDefault;
					vShowMore.push(h(SubMenu, {
						index: "sub-menu-more",
						class: nsSubMenu.e("hide-arrow")
					}, {
						title: () => h(ElIcon, { class: nsSubMenu.e("icon-more") }, { default: () => h(more_default) }),
						default: () => slotMore
					}));
				}
			}
			const ulStyle = useMenuCssVar(props, 0);
			const vMenu = h("ul", {
				key: String(props.collapse),
				role: "menubar",
				ref: menu,
				style: ulStyle.value,
				class: {
					[nsMenu.b()]: true,
					[nsMenu.m(props.mode)]: true,
					[nsMenu.m("collapse")]: props.collapse
				}
			}, [...slot, ...vShowMore]);
			if (props.collapseTransition && props.mode === "vertical") return h(ElMenuCollapseTransition, () => vMenu);
			return vMenu;
		};
	}
});
init_shared_esm_bundler();
var menuItemProps = buildProps({
	index: {
		type: definePropType([String, null]),
		default: null
	},
	route: { type: definePropType([String, Object]) },
	disabled: Boolean
});
var menuItemEmits = { click: (item$4) => isString$2(item$4.index) && Array.isArray(item$4.indexPath) };
var COMPONENT_NAME$2 = "ElMenuItem";
var _sfc_main$7 = defineComponent({
	name: COMPONENT_NAME$2,
	components: { ElTooltip },
	props: menuItemProps,
	emits: menuItemEmits,
	setup(props, { emit }) {
		const instance = getCurrentInstance();
		const rootMenu = inject("rootMenu");
		const nsMenu = useNamespace("menu");
		const nsMenuItem = useNamespace("menu-item");
		if (!rootMenu) throwError(COMPONENT_NAME$2, "can not inject root menu");
		const { parentMenu, indexPath } = useMenu(instance, toRef(props, "index"));
		const subMenu = inject(`subMenu:${parentMenu.value.uid}`);
		if (!subMenu) throwError(COMPONENT_NAME$2, "can not inject sub menu");
		const active$3 = computed(() => props.index === rootMenu.activeIndex);
		const item$4 = reactive({
			index: props.index,
			indexPath,
			active: active$3
		});
		const handleClick = () => {
			if (!props.disabled) {
				rootMenu.handleMenuItemClick({
					index: props.index,
					indexPath: indexPath.value,
					route: props.route
				});
				emit("click", item$4);
			}
		};
		onMounted(() => {
			subMenu.addSubMenu(item$4);
			rootMenu.addMenuItem(item$4);
		});
		onBeforeUnmount(() => {
			subMenu.removeSubMenu(item$4);
			rootMenu.removeMenuItem(item$4);
		});
		return {
			parentMenu,
			rootMenu,
			active: active$3,
			nsMenu,
			nsMenuItem,
			handleClick
		};
	}
});
function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
	const _component_el_tooltip = resolveComponent("el-tooltip");
	return openBlock(), createElementBlock("li", {
		class: normalizeClass([
			_ctx.nsMenuItem.b(),
			_ctx.nsMenuItem.is("active", _ctx.active),
			_ctx.nsMenuItem.is("disabled", _ctx.disabled)
		]),
		role: "menuitem",
		tabindex: "-1",
		onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
	}, [_ctx.parentMenu.type.name === "ElMenu" && _ctx.rootMenu.props.collapse && _ctx.$slots.title ? (openBlock(), createBlock(_component_el_tooltip, {
		key: 0,
		effect: _ctx.rootMenu.props.popperEffect,
		placement: "right",
		"fallback-placements": ["left"],
		persistent: ""
	}, {
		content: withCtx(() => [renderSlot(_ctx.$slots, "title")]),
		default: withCtx(() => [createBaseVNode("div", { class: normalizeClass(_ctx.nsMenu.be("tooltip", "trigger")) }, [renderSlot(_ctx.$slots, "default")], 2)]),
		_: 3
	}, 8, ["effect"])) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [renderSlot(_ctx.$slots, "default"), renderSlot(_ctx.$slots, "title")], 64))], 2);
}
var MenuItem = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["render", _sfc_render$7], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/menu/src/menu-item.vue"]]);
var _sfc_main$6 = defineComponent({
	name: "ElMenuItemGroup",
	props: { title: String },
	setup() {
		return { ns: useNamespace("menu-item-group") };
	}
});
function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
	return openBlock(), createElementBlock("li", { class: normalizeClass(_ctx.ns.b()) }, [createBaseVNode("div", { class: normalizeClass(_ctx.ns.e("title")) }, [!_ctx.$slots.title ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [createTextVNode(toDisplayString(_ctx.title), 1)], 64)) : renderSlot(_ctx.$slots, "title", { key: 1 })], 2), createBaseVNode("ul", null, [renderSlot(_ctx.$slots, "default")])], 2);
}
var MenuItemGroup = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["render", _sfc_render$6], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/menu/src/menu-item-group.vue"]]);
var ElMenu = withInstall(Menu, {
	MenuItem,
	MenuItemGroup,
	SubMenu
});
var ElMenuItem = withNoopInstall(MenuItem);
withNoopInstall(MenuItemGroup);
var ElSubMenu = withNoopInstall(SubMenu);
var elPaginationKey = Symbol("elPaginationKey");
var paginationPrevProps = buildProps({
	disabled: Boolean,
	currentPage: {
		type: Number,
		default: 1
	},
	prevText: { type: String },
	prevIcon: { type: iconPropType }
});
var paginationPrevEmits = { click: (evt) => evt instanceof MouseEvent };
var _hoisted_1$52 = [
	"disabled",
	"aria-label",
	"aria-disabled"
];
var _hoisted_2$31 = { key: 0 };
var Prev = /* @__PURE__ */ _export_sfc(/* @__PURE__ */ defineComponent({
	...defineComponent({ name: "ElPaginationPrev" }),
	props: paginationPrevProps,
	emits: paginationPrevEmits,
	setup(__props) {
		const props = __props;
		const { t: t$1 } = useLocale$1();
		const internalDisabled = computed(() => props.disabled || props.currentPage <= 1);
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("button", {
				type: "button",
				class: "btn-prev",
				disabled: unref(internalDisabled),
				"aria-label": _ctx.prevText || unref(t$1)("el.pagination.prev"),
				"aria-disabled": unref(internalDisabled),
				onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
			}, [_ctx.prevText ? (openBlock(), createElementBlock("span", _hoisted_2$31, toDisplayString(_ctx.prevText), 1)) : (openBlock(), createBlock(unref(ElIcon), { key: 1 }, {
				default: withCtx(() => [(openBlock(), createBlock(resolveDynamicComponent(_ctx.prevIcon)))]),
				_: 1
			}))], 8, _hoisted_1$52);
		};
	}
}), [["__file", "/home/runner/work/element-plus/element-plus/packages/components/pagination/src/components/prev.vue"]]);
var paginationNextProps = buildProps({
	disabled: Boolean,
	currentPage: {
		type: Number,
		default: 1
	},
	pageCount: {
		type: Number,
		default: 50
	},
	nextText: { type: String },
	nextIcon: { type: iconPropType }
});
var _hoisted_1$51 = [
	"disabled",
	"aria-label",
	"aria-disabled"
];
var _hoisted_2$30 = { key: 0 };
var Next = /* @__PURE__ */ _export_sfc(/* @__PURE__ */ defineComponent({
	...defineComponent({ name: "ElPaginationNext" }),
	props: paginationNextProps,
	emits: ["click"],
	setup(__props) {
		const props = __props;
		const { t: t$1 } = useLocale$1();
		const internalDisabled = computed(() => props.disabled || props.currentPage === props.pageCount || props.pageCount === 0);
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("button", {
				type: "button",
				class: "btn-next",
				disabled: unref(internalDisabled),
				"aria-label": _ctx.nextText || unref(t$1)("el.pagination.next"),
				"aria-disabled": unref(internalDisabled),
				onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
			}, [_ctx.nextText ? (openBlock(), createElementBlock("span", _hoisted_2$30, toDisplayString(_ctx.nextText), 1)) : (openBlock(), createBlock(unref(ElIcon), { key: 1 }, {
				default: withCtx(() => [(openBlock(), createBlock(resolveDynamicComponent(_ctx.nextIcon)))]),
				_: 1
			}))], 8, _hoisted_1$51);
		};
	}
}), [["__file", "/home/runner/work/element-plus/element-plus/packages/components/pagination/src/components/next.vue"]]);
var selectGroupKey = Symbol("ElSelectGroup");
var selectKey = Symbol("ElSelect");
init_shared_esm_bundler();
function useOption(props, states) {
	const select = inject(selectKey);
	const selectGroup = inject(selectGroupKey, { disabled: false });
	const isObject$1$1 = computed(() => isObject$2(props.value));
	const itemSelected = computed(() => {
		if (!select.props.multiple) return isEqual$2(props.value, select.props.modelValue);
		else return contains(select.props.modelValue, props.value);
	});
	const limitReached = computed(() => {
		if (select.props.multiple) {
			const modelValue = select.props.modelValue || [];
			return !itemSelected.value && modelValue.length >= select.props.multipleLimit && select.props.multipleLimit > 0;
		} else return false;
	});
	const currentLabel = computed(() => {
		return props.label || (isObject$1$1.value ? "" : props.value);
	});
	const currentValue = computed(() => {
		return props.value || props.label || "";
	});
	const isDisabled = computed(() => {
		return props.disabled || states.groupDisabled || limitReached.value;
	});
	const instance = getCurrentInstance();
	const contains = (arr = [], target$1) => {
		if (!isObject$1$1.value) return arr && arr.includes(target$1);
		else {
			const valueKey = select.props.valueKey;
			return arr && arr.some((item$4) => {
				return toRaw(get_default(item$4, valueKey)) === get_default(target$1, valueKey);
			});
		}
	};
	const isEqual$2 = (a$1, b$2) => {
		if (!isObject$1$1.value) return a$1 === b$2;
		else {
			const { valueKey } = select.props;
			return get_default(a$1, valueKey) === get_default(b$2, valueKey);
		}
	};
	const hoverItem = () => {
		if (!props.disabled && !selectGroup.disabled) select.hoverIndex = select.optionsArray.indexOf(instance.proxy);
	};
	watch(() => currentLabel.value, () => {
		if (!props.created && !select.props.remote) select.setSelected();
	});
	watch(() => props.value, (val, oldVal) => {
		const { remote, valueKey } = select.props;
		if (!Object.is(val, oldVal)) {
			select.onOptionDestroy(oldVal, instance.proxy);
			select.onOptionCreate(instance.proxy);
		}
		if (!props.created && !remote) {
			if (valueKey && isObject$2(val) && isObject$2(oldVal) && val[valueKey] === oldVal[valueKey]) return;
			select.setSelected();
		}
	});
	watch(() => selectGroup.disabled, () => {
		states.groupDisabled = selectGroup.disabled;
	}, { immediate: true });
	const { queryChange } = toRaw(select);
	watch(queryChange, (changes) => {
		const { query } = unref(changes);
		states.visible = new RegExp(escapeStringRegexp(query), "i").test(currentLabel.value) || props.created;
		if (!states.visible) select.filteredOptionsCount--;
	}, { immediate: true });
	return {
		select,
		currentLabel,
		currentValue,
		itemSelected,
		isDisabled,
		hoverItem
	};
}
var _sfc_main$5 = defineComponent({
	name: "ElOption",
	componentName: "ElOption",
	props: {
		value: {
			required: true,
			type: [
				String,
				Number,
				Boolean,
				Object
			]
		},
		label: [String, Number],
		created: Boolean,
		disabled: Boolean
	},
	setup(props) {
		const ns = useNamespace("select");
		const id$1 = useId$1();
		const containerKls = computed(() => [
			ns.be("dropdown", "item"),
			ns.is("disabled", unref(isDisabled)),
			{
				selected: unref(itemSelected),
				hover: unref(hover)
			}
		]);
		const states = reactive({
			index: -1,
			groupDisabled: false,
			visible: true,
			hitState: false,
			hover: false
		});
		const { currentLabel, itemSelected, isDisabled, select, hoverItem } = useOption(props, states);
		const { visible: visible$1, hover } = toRefs(states);
		const vm = getCurrentInstance().proxy;
		select.onOptionCreate(vm);
		onBeforeUnmount(() => {
			const key$2 = vm.value;
			const { selected: selected$1 } = select;
			const doesSelected = (select.props.multiple ? selected$1 : [selected$1]).some((item$4) => {
				return item$4.value === vm.value;
			});
			nextTick(() => {
				if (select.cachedOptions.get(key$2) === vm && !doesSelected) select.cachedOptions.delete(key$2);
			});
			select.onOptionDestroy(key$2, vm);
		});
		function selectOptionClick() {
			if (props.disabled !== true && states.groupDisabled !== true) select.handleOptionSelect(vm);
		}
		return {
			ns,
			id: id$1,
			containerKls,
			currentLabel,
			itemSelected,
			isDisabled,
			select,
			hoverItem,
			visible: visible$1,
			hover,
			selectOptionClick,
			states
		};
	}
});
var _hoisted_1$50 = [
	"id",
	"aria-disabled",
	"aria-selected"
];
function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
	return withDirectives((openBlock(), createElementBlock("li", {
		id: _ctx.id,
		class: normalizeClass(_ctx.containerKls),
		role: "option",
		"aria-disabled": _ctx.isDisabled || void 0,
		"aria-selected": _ctx.itemSelected,
		onMouseenter: _cache[0] || (_cache[0] = (...args) => _ctx.hoverItem && _ctx.hoverItem(...args)),
		onClick: _cache[1] || (_cache[1] = withModifiers((...args) => _ctx.selectOptionClick && _ctx.selectOptionClick(...args), ["stop"]))
	}, [renderSlot(_ctx.$slots, "default", {}, () => [createBaseVNode("span", null, toDisplayString(_ctx.currentLabel), 1)])], 42, _hoisted_1$50)), [[vShow, _ctx.visible]]);
}
var Option = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["render", _sfc_render$5], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/option.vue"]]);
var _sfc_main$4 = defineComponent({
	name: "ElSelectDropdown",
	componentName: "ElSelectDropdown",
	setup() {
		const select = inject(selectKey);
		const ns = useNamespace("select");
		const popperClass = computed(() => select.props.popperClass);
		const isMultiple = computed(() => select.props.multiple);
		const isFitInputWidth = computed(() => select.props.fitInputWidth);
		const minWidth = ref("");
		function updateMinWidth() {
			var _a;
			minWidth.value = `${(_a = select.selectWrapper) == null ? void 0 : _a.offsetWidth}px`;
		}
		onMounted(() => {
			updateMinWidth();
			useResizeObserver$2(select.selectWrapper, updateMinWidth);
		});
		return {
			ns,
			minWidth,
			popperClass,
			isMultiple,
			isFitInputWidth
		};
	}
});
function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
	return openBlock(), createElementBlock("div", {
		class: normalizeClass([
			_ctx.ns.b("dropdown"),
			_ctx.ns.is("multiple", _ctx.isMultiple),
			_ctx.popperClass
		]),
		style: normalizeStyle({ [_ctx.isFitInputWidth ? "width" : "minWidth"]: _ctx.minWidth })
	}, [
		_ctx.$slots.header ? (openBlock(), createElementBlock("div", {
			key: 0,
			class: normalizeClass(_ctx.ns.be("dropdown", "header"))
		}, [renderSlot(_ctx.$slots, "header")], 2)) : createCommentVNode("v-if", true),
		renderSlot(_ctx.$slots, "default"),
		_ctx.$slots.footer ? (openBlock(), createElementBlock("div", {
			key: 1,
			class: normalizeClass(_ctx.ns.be("dropdown", "footer"))
		}, [renderSlot(_ctx.$slots, "footer")], 2)) : createCommentVNode("v-if", true)
	], 6);
}
var ElSelectMenu = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["render", _sfc_render$4], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/select-dropdown.vue"]]);
init_shared_esm_bundler();
function useSelectStates(props) {
	const { t: t$1 } = useLocale$1();
	return reactive({
		options: /* @__PURE__ */ new Map(),
		cachedOptions: /* @__PURE__ */ new Map(),
		disabledOptions: /* @__PURE__ */ new Map(),
		createdLabel: null,
		createdSelected: false,
		selected: props.multiple ? [] : {},
		inputLength: 20,
		inputWidth: 0,
		optionsCount: 0,
		filteredOptionsCount: 0,
		visible: false,
		selectedLabel: "",
		hoverIndex: -1,
		query: "",
		previousQuery: null,
		inputHovering: false,
		cachedPlaceHolder: "",
		currentPlaceholder: t$1("el.select.placeholder"),
		menuVisibleOnFocus: false,
		isOnComposition: false,
		prefixWidth: 11,
		mouseEnter: false,
		focused: false
	});
}
var useSelect = (props, states, ctx) => {
	const { t: t$1 } = useLocale$1();
	const ns = useNamespace("select");
	useDeprecated({
		from: "suffixTransition",
		replacement: "override style scheme",
		version: "2.3.0",
		scope: "props",
		ref: "https://element-plus.org/en-US/component/select.html#select-attributes"
	}, computed(() => props.suffixTransition === false));
	const reference = ref(null);
	const input$4 = ref(null);
	const iOSInput = ref(null);
	const tooltipRef = ref(null);
	const tagTooltipRef = ref(null);
	const tags$1 = ref(null);
	const selectWrapper = ref(null);
	const scrollbar$1 = ref(null);
	const hoverOption = ref();
	const queryChange = shallowRef({ query: "" });
	const groupQueryChange = shallowRef("");
	const optionList = ref([]);
	let originClientHeight = 0;
	const { form, formItem } = useFormItem();
	const readonly$1 = computed(() => !props.filterable || props.multiple || !states.visible);
	const selectDisabled = computed(() => props.disabled || (form == null ? void 0 : form.disabled));
	const showClose = computed(() => {
		const hasValue = props.multiple ? Array.isArray(props.modelValue) && props.modelValue.length > 0 : props.modelValue !== void 0 && props.modelValue !== null && props.modelValue !== "";
		return props.clearable && !selectDisabled.value && states.inputHovering && hasValue;
	});
	const iconComponent = computed(() => props.remote && props.filterable && !props.remoteShowSuffix ? "" : props.suffixIcon);
	const iconReverse = computed(() => ns.is("reverse", iconComponent.value && states.visible && props.suffixTransition));
	const showStatusIconAndState = computed(() => (form == null ? void 0 : form.statusIcon) && (formItem == null ? void 0 : formItem.validateState) && ValidateComponentsMap[formItem == null ? void 0 : formItem.validateState]);
	const debounce$1 = computed(() => props.remote ? 300 : 0);
	const emptyText = computed(() => {
		if (props.loading) return props.loadingText || t$1("el.select.loading");
		else {
			if (props.remote && states.query === "" && states.options.size === 0) return false;
			if (props.filterable && states.query && states.options.size > 0 && states.filteredOptionsCount === 0) return props.noMatchText || t$1("el.select.noMatch");
			if (states.options.size === 0) return props.noDataText || t$1("el.select.noData");
		}
		return null;
	});
	const optionsArray = computed(() => {
		const list$1 = Array.from(states.options.values());
		const newList = [];
		optionList.value.forEach((item$4) => {
			const index = list$1.findIndex((i$1) => i$1.currentLabel === item$4);
			if (index > -1) newList.push(list$1[index]);
		});
		return newList.length >= list$1.length ? newList : list$1;
	});
	const cachedOptionsArray = computed(() => Array.from(states.cachedOptions.values()));
	const showNewOption = computed(() => {
		const hasExistingOption = optionsArray.value.filter((option) => {
			return !option.created;
		}).some((option) => {
			return option.currentLabel === states.query;
		});
		return props.filterable && props.allowCreate && states.query !== "" && !hasExistingOption;
	});
	const selectSize = useFormSize();
	const collapseTagSize = computed(() => ["small"].includes(selectSize.value) ? "small" : "default");
	const dropMenuVisible = computed({
		get() {
			return states.visible && emptyText.value !== false;
		},
		set(val) {
			states.visible = val;
		}
	});
	watch([
		() => selectDisabled.value,
		() => selectSize.value,
		() => form == null ? void 0 : form.size
	], () => {
		nextTick(() => {
			resetInputHeight();
		});
	});
	watch(() => props.placeholder, (val) => {
		states.cachedPlaceHolder = states.currentPlaceholder = val;
		if (props.multiple && Array.isArray(props.modelValue) && props.modelValue.length > 0) states.currentPlaceholder = "";
	});
	watch(() => props.modelValue, (val, oldVal) => {
		if (props.multiple) {
			resetInputHeight();
			if (val && val.length > 0 || input$4.value && states.query !== "") states.currentPlaceholder = "";
			else states.currentPlaceholder = states.cachedPlaceHolder;
			if (props.filterable && !props.reserveKeyword) {
				states.query = "";
				handleQueryChange(states.query);
			}
		}
		setSelected();
		if (props.filterable && !props.multiple) states.inputLength = 20;
		if (!isEqual_default(val, oldVal) && props.validateEvent) formItem?.validate("change").catch((err) => debugWarn(err));
	}, {
		flush: "post",
		deep: true
	});
	watch(() => states.visible, (val) => {
		var _a, _b, _c, _d, _e$1;
		if (!val) {
			if (props.filterable) {
				if (isFunction$2(props.filterMethod)) props.filterMethod("");
				if (isFunction$2(props.remoteMethod)) props.remoteMethod("");
			}
			states.query = "";
			states.previousQuery = null;
			states.selectedLabel = "";
			states.inputLength = 20;
			states.menuVisibleOnFocus = false;
			resetHoverIndex();
			nextTick(() => {
				if (input$4.value && input$4.value.value === "" && states.selected.length === 0) states.currentPlaceholder = states.cachedPlaceHolder;
			});
			if (!props.multiple) {
				if (states.selected) {
					if (props.filterable && props.allowCreate && states.createdSelected && states.createdLabel) states.selectedLabel = states.createdLabel;
					else states.selectedLabel = states.selected.currentLabel;
					if (props.filterable) states.query = states.selectedLabel;
				}
				if (props.filterable) states.currentPlaceholder = states.cachedPlaceHolder;
			}
		} else {
			(_b = (_a = tooltipRef.value) == null ? void 0 : _a.updatePopper) == null || _b.call(_a);
			if (props.filterable) {
				states.filteredOptionsCount = states.optionsCount;
				states.query = props.remote ? "" : states.selectedLabel;
				(_d = (_c = iOSInput.value) == null ? void 0 : _c.focus) == null || _d.call(_c);
				if (props.multiple) (_e$1 = input$4.value) == null || _e$1.focus();
				else if (states.selectedLabel) {
					states.currentPlaceholder = `${states.selectedLabel}`;
					states.selectedLabel = "";
				}
				handleQueryChange(states.query);
				if (!props.multiple && !props.remote) {
					queryChange.value.query = "";
					triggerRef(queryChange);
					triggerRef(groupQueryChange);
				}
			}
		}
		ctx.emit("visible-change", val);
	});
	watch(() => states.options.entries(), () => {
		var _a, _b, _c;
		if (!isClient$1) return;
		(_b = (_a = tooltipRef.value) == null ? void 0 : _a.updatePopper) == null || _b.call(_a);
		if (props.multiple) resetInputHeight();
		const inputs = ((_c = selectWrapper.value) == null ? void 0 : _c.querySelectorAll("input")) || [];
		if (!props.filterable && !props.defaultFirstOption && !isUndefined(props.modelValue) || !Array.from(inputs).includes(document.activeElement)) setSelected();
		if (props.defaultFirstOption && (props.filterable || props.remote) && states.filteredOptionsCount) checkDefaultFirstOption();
	}, { flush: "post" });
	watch(() => states.hoverIndex, (val) => {
		if (isNumber(val) && val > -1) hoverOption.value = optionsArray.value[val] || {};
		else hoverOption.value = {};
		optionsArray.value.forEach((option) => {
			option.hover = hoverOption.value === option;
		});
	});
	const resetInputHeight = () => {
		nextTick(() => {
			var _a, _b;
			if (!reference.value) return;
			const input2 = reference.value.$el.querySelector("input");
			originClientHeight = originClientHeight || (input2.clientHeight > 0 ? input2.clientHeight + 2 : 0);
			const _tags = tags$1.value;
			const cssVarOfSelectSize = getComputedStyle(input2).getPropertyValue(ns.cssVarName("input-height"));
			const gotSize = Number.parseFloat(cssVarOfSelectSize) || getComponentSize(selectSize.value || (form == null ? void 0 : form.size));
			const sizeInMap = selectSize.value || gotSize === originClientHeight || originClientHeight <= 0 ? gotSize : originClientHeight;
			!(input2.offsetParent === null) && (input2.style.height = `${(states.selected.length === 0 ? sizeInMap : Math.max(_tags ? _tags.clientHeight + (_tags.clientHeight > sizeInMap ? 6 : 0) : 0, sizeInMap)) - 2}px`);
			if (states.visible && emptyText.value !== false) (_b = (_a = tooltipRef.value) == null ? void 0 : _a.updatePopper) == null || _b.call(_a);
		});
	};
	const handleQueryChange = async (val) => {
		if (states.previousQuery === val || states.isOnComposition) return;
		if (states.previousQuery === null && (isFunction$2(props.filterMethod) || isFunction$2(props.remoteMethod))) {
			states.previousQuery = val;
			return;
		}
		states.previousQuery = val;
		nextTick(() => {
			var _a, _b;
			if (states.visible) (_b = (_a = tooltipRef.value) == null ? void 0 : _a.updatePopper) == null || _b.call(_a);
		});
		states.hoverIndex = -1;
		if (props.multiple && props.filterable) nextTick(() => {
			if (!selectDisabled.value) {
				const length = input$4.value.value.length * 15 + 20;
				states.inputLength = props.collapseTags ? Math.min(50, length) : length;
				managePlaceholder();
			}
			resetInputHeight();
		});
		if (props.remote && isFunction$2(props.remoteMethod)) {
			states.hoverIndex = -1;
			props.remoteMethod(val);
		} else if (isFunction$2(props.filterMethod)) {
			props.filterMethod(val);
			triggerRef(groupQueryChange);
		} else {
			states.filteredOptionsCount = states.optionsCount;
			queryChange.value.query = val;
			triggerRef(queryChange);
			triggerRef(groupQueryChange);
		}
		if (props.defaultFirstOption && (props.filterable || props.remote) && states.filteredOptionsCount) {
			await nextTick();
			checkDefaultFirstOption();
		}
	};
	const managePlaceholder = () => {
		if (states.currentPlaceholder !== "") states.currentPlaceholder = input$4.value.value ? "" : states.cachedPlaceHolder;
	};
	const checkDefaultFirstOption = () => {
		const optionsInDropdown = optionsArray.value.filter((n) => n.visible && !n.disabled && !n.states.groupDisabled);
		const userCreatedOption = optionsInDropdown.find((n) => n.created);
		const firstOriginOption = optionsInDropdown[0];
		states.hoverIndex = getValueIndex(optionsArray.value, userCreatedOption || firstOriginOption);
	};
	const setSelected = () => {
		var _a;
		if (!props.multiple) {
			const option = getOption(props.modelValue);
			if ((_a = option.props) == null ? void 0 : _a.created) {
				states.createdLabel = option.props.value;
				states.createdSelected = true;
			} else states.createdSelected = false;
			states.selectedLabel = option.currentLabel;
			states.selected = option;
			if (props.filterable) states.query = states.selectedLabel;
			return;
		} else states.selectedLabel = "";
		const result = [];
		if (Array.isArray(props.modelValue)) props.modelValue.forEach((value) => {
			result.push(getOption(value));
		});
		states.selected = result;
		nextTick(() => {
			resetInputHeight();
		});
	};
	const getOption = (value) => {
		let option;
		const isObjectValue = toRawType(value).toLowerCase() === "object";
		const isNull = toRawType(value).toLowerCase() === "null";
		const isUndefined2 = toRawType(value).toLowerCase() === "undefined";
		for (let i$1 = states.cachedOptions.size - 1; i$1 >= 0; i$1--) {
			const cachedOption = cachedOptionsArray.value[i$1];
			if (isObjectValue ? get_default(cachedOption.value, props.valueKey) === get_default(value, props.valueKey) : cachedOption.value === value) {
				option = {
					value,
					currentLabel: cachedOption.currentLabel,
					isDisabled: cachedOption.isDisabled
				};
				break;
			}
		}
		if (option) return option;
		const newOption = {
			value,
			currentLabel: isObjectValue ? value.label : !isNull && !isUndefined2 ? value : ""
		};
		if (props.multiple) newOption.hitState = false;
		return newOption;
	};
	const resetHoverIndex = () => {
		setTimeout(() => {
			const valueKey = props.valueKey;
			if (!props.multiple) states.hoverIndex = optionsArray.value.findIndex((item$4) => {
				return getValueKey(item$4) === getValueKey(states.selected);
			});
			else if (states.selected.length > 0) states.hoverIndex = Math.min.apply(null, states.selected.map((selected$1) => {
				return optionsArray.value.findIndex((item$4) => {
					return get_default(item$4, valueKey) === get_default(selected$1, valueKey);
				});
			}));
			else states.hoverIndex = -1;
		}, 300);
	};
	const handleResize = () => {
		var _a, _b;
		resetInputWidth();
		(_b = (_a = tooltipRef.value) == null ? void 0 : _a.updatePopper) == null || _b.call(_a);
		props.multiple && resetInputHeight();
	};
	const resetInputWidth = () => {
		var _a;
		states.inputWidth = (_a = reference.value) == null ? void 0 : _a.$el.offsetWidth;
	};
	const onInputChange = () => {
		if (props.filterable && states.query !== states.selectedLabel) {
			states.query = states.selectedLabel;
			handleQueryChange(states.query);
		}
	};
	const debouncedOnInputChange = debounce_default(() => {
		onInputChange();
	}, debounce$1.value);
	const debouncedQueryChange = debounce_default((e) => {
		handleQueryChange(e.target.value);
	}, debounce$1.value);
	const emitChange = (val) => {
		if (!isEqual_default(props.modelValue, val)) ctx.emit(CHANGE_EVENT, val);
	};
	const getLastNotDisabledIndex = (value) => findLastIndex_default(value, (it$4) => !states.disabledOptions.has(it$4));
	const deletePrevTag = (e) => {
		if (e.code === EVENT_CODE.delete) return;
		if (e.target.value.length <= 0 && !toggleLastOptionHitState()) {
			const value = props.modelValue.slice();
			const lastNotDisabledIndex = getLastNotDisabledIndex(value);
			if (lastNotDisabledIndex < 0) return;
			value.splice(lastNotDisabledIndex, 1);
			ctx.emit(UPDATE_MODEL_EVENT, value);
			emitChange(value);
		}
		if (e.target.value.length === 1 && props.modelValue.length === 0) states.currentPlaceholder = states.cachedPlaceHolder;
	};
	const deleteTag = (event, tag$2) => {
		const index = states.selected.indexOf(tag$2);
		if (index > -1 && !selectDisabled.value) {
			const value = props.modelValue.slice();
			value.splice(index, 1);
			ctx.emit(UPDATE_MODEL_EVENT, value);
			emitChange(value);
			ctx.emit("remove-tag", tag$2.value);
		}
		event.stopPropagation();
		focus$1();
	};
	const deleteSelected = (event) => {
		event.stopPropagation();
		const value = props.multiple ? [] : "";
		if (!isString$2(value)) {
			for (const item$4 of states.selected) if (item$4.isDisabled) value.push(item$4.value);
		}
		ctx.emit(UPDATE_MODEL_EVENT, value);
		emitChange(value);
		states.hoverIndex = -1;
		states.visible = false;
		ctx.emit("clear");
		focus$1();
	};
	const handleOptionSelect = (option) => {
		var _a;
		if (props.multiple) {
			const value = (props.modelValue || []).slice();
			const optionIndex = getValueIndex(value, option.value);
			if (optionIndex > -1) value.splice(optionIndex, 1);
			else if (props.multipleLimit <= 0 || value.length < props.multipleLimit) value.push(option.value);
			ctx.emit(UPDATE_MODEL_EVENT, value);
			emitChange(value);
			if (option.created) {
				states.query = "";
				handleQueryChange("");
				states.inputLength = 20;
			}
			if (props.filterable) (_a = input$4.value) == null || _a.focus();
		} else {
			ctx.emit(UPDATE_MODEL_EVENT, option.value);
			emitChange(option.value);
			states.visible = false;
		}
		setSoftFocus();
		if (states.visible) return;
		nextTick(() => {
			scrollToOption(option);
		});
	};
	const getValueIndex = (arr = [], value) => {
		if (!isObject$2(value)) return arr.indexOf(value);
		const valueKey = props.valueKey;
		let index = -1;
		arr.some((item$4, i$1) => {
			if (toRaw(get_default(item$4, valueKey)) === get_default(value, valueKey)) {
				index = i$1;
				return true;
			}
			return false;
		});
		return index;
	};
	const setSoftFocus = () => {
		const _input = input$4.value || reference.value;
		if (_input) _input?.focus();
	};
	const scrollToOption = (option) => {
		var _a, _b, _c, _d, _e$1;
		const targetOption = Array.isArray(option) ? option[0] : option;
		let target$1 = null;
		if (targetOption == null ? void 0 : targetOption.value) {
			const options$1 = optionsArray.value.filter((item$4) => item$4.value === targetOption.value);
			if (options$1.length > 0) target$1 = options$1[0].$el;
		}
		if (tooltipRef.value && target$1) {
			const menu = (_d = (_c = (_b = (_a = tooltipRef.value) == null ? void 0 : _a.popperRef) == null ? void 0 : _b.contentRef) == null ? void 0 : _c.querySelector) == null ? void 0 : _d.call(_c, `.${ns.be("dropdown", "wrap")}`);
			if (menu) scrollIntoView(menu, target$1);
		}
		(_e$1 = scrollbar$1.value) == null || _e$1.handleScroll();
	};
	const onOptionCreate = (vm) => {
		states.optionsCount++;
		states.filteredOptionsCount++;
		states.options.set(vm.value, vm);
		states.cachedOptions.set(vm.value, vm);
		vm.disabled && states.disabledOptions.set(vm.value, vm);
	};
	const onOptionDestroy = (key$2, vm) => {
		if (states.options.get(key$2) === vm) {
			states.optionsCount--;
			states.filteredOptionsCount--;
			states.options.delete(key$2);
		}
	};
	const resetInputState = (e) => {
		if (e.code !== EVENT_CODE.backspace) toggleLastOptionHitState(false);
		states.inputLength = input$4.value.value.length * 15 + 20;
		resetInputHeight();
	};
	const toggleLastOptionHitState = (hit) => {
		if (!Array.isArray(states.selected)) return;
		const lastNotDisabledIndex = getLastNotDisabledIndex(states.selected.map((it$4) => it$4.value));
		const option = states.selected[lastNotDisabledIndex];
		if (!option) return;
		if (hit === true || hit === false) {
			option.hitState = hit;
			return hit;
		}
		option.hitState = !option.hitState;
		return option.hitState;
	};
	const handleComposition = (event) => {
		const text$7 = event.target.value;
		if (event.type === "compositionend") {
			states.isOnComposition = false;
			nextTick(() => handleQueryChange(text$7));
		} else states.isOnComposition = !isKorean(text$7[text$7.length - 1] || "");
	};
	const handleMenuEnter = () => {
		nextTick(() => scrollToOption(states.selected));
	};
	const handleFocus = (event) => {
		if (!states.focused) {
			if (props.automaticDropdown || props.filterable) {
				if (props.filterable && !states.visible) states.menuVisibleOnFocus = true;
				states.visible = true;
			}
			states.focused = true;
			ctx.emit("focus", event);
		}
	};
	const focus$1 = () => {
		var _a, _b;
		if (states.visible) (_a = input$4.value || reference.value) == null || _a.focus();
		else (_b = reference.value) == null || _b.focus();
	};
	const blur = () => {
		var _a, _b, _c;
		states.visible = false;
		(_a = reference.value) == null || _a.blur();
		(_c = (_b = iOSInput.value) == null ? void 0 : _b.blur) == null || _c.call(_b);
	};
	const handleBlur = (event) => {
		var _a, _b, _c;
		if (((_a = tooltipRef.value) == null ? void 0 : _a.isFocusInsideContent(event)) || ((_b = tagTooltipRef.value) == null ? void 0 : _b.isFocusInsideContent(event)) || ((_c = selectWrapper.value) == null ? void 0 : _c.contains(event.relatedTarget))) return;
		states.visible && handleClose();
		states.focused = false;
		ctx.emit("blur", event);
	};
	const handleClearClick = (event) => {
		deleteSelected(event);
	};
	const handleClose = () => {
		states.visible = false;
	};
	const handleKeydownEscape = (event) => {
		if (states.visible) {
			event.preventDefault();
			event.stopPropagation();
			states.visible = false;
		}
	};
	const toggleMenu = (e) => {
		if (e && !states.mouseEnter) return;
		if (!selectDisabled.value) {
			if (states.menuVisibleOnFocus) states.menuVisibleOnFocus = false;
			else if (!tooltipRef.value || !tooltipRef.value.isFocusInsideContent()) states.visible = !states.visible;
			focus$1();
		}
	};
	const selectOption = () => {
		if (!states.visible) toggleMenu();
		else if (optionsArray.value[states.hoverIndex]) handleOptionSelect(optionsArray.value[states.hoverIndex]);
	};
	const getValueKey = (item$4) => {
		return isObject$2(item$4.value) ? get_default(item$4.value, props.valueKey) : item$4.value;
	};
	const optionsAllDisabled = computed(() => optionsArray.value.filter((option) => option.visible).every((option) => option.disabled));
	const showTagList = computed(() => props.multiple ? states.selected.slice(0, props.maxCollapseTags) : []);
	const collapseTagList = computed(() => props.multiple ? states.selected.slice(props.maxCollapseTags) : []);
	const navigateOptions = (direction) => {
		if (!states.visible) {
			states.visible = true;
			return;
		}
		if (states.options.size === 0 || states.filteredOptionsCount === 0) return;
		if (states.isOnComposition) return;
		if (!optionsAllDisabled.value) {
			if (direction === "next") {
				states.hoverIndex++;
				if (states.hoverIndex === states.options.size) states.hoverIndex = 0;
			} else if (direction === "prev") {
				states.hoverIndex--;
				if (states.hoverIndex < 0) states.hoverIndex = states.options.size - 1;
			}
			const option = optionsArray.value[states.hoverIndex];
			if (option.disabled === true || option.states.groupDisabled === true || !option.visible) navigateOptions(direction);
			nextTick(() => scrollToOption(hoverOption.value));
		}
	};
	const handleMouseEnter = () => {
		states.mouseEnter = true;
	};
	const handleMouseLeave = () => {
		states.mouseEnter = false;
	};
	const handleDeleteTooltipTag = (event, tag$2) => {
		var _a, _b;
		deleteTag(event, tag$2);
		(_b = (_a = tagTooltipRef.value) == null ? void 0 : _a.updatePopper) == null || _b.call(_a);
	};
	return {
		optionList,
		optionsArray,
		hoverOption,
		selectSize,
		handleResize,
		debouncedOnInputChange,
		debouncedQueryChange,
		deletePrevTag,
		deleteTag,
		deleteSelected,
		handleOptionSelect,
		scrollToOption,
		readonly: readonly$1,
		resetInputHeight,
		showClose,
		iconComponent,
		iconReverse,
		showNewOption,
		collapseTagSize,
		setSelected,
		managePlaceholder,
		selectDisabled,
		emptyText,
		toggleLastOptionHitState,
		resetInputState,
		handleComposition,
		onOptionCreate,
		onOptionDestroy,
		handleMenuEnter,
		handleFocus,
		focus: focus$1,
		blur,
		handleBlur,
		handleClearClick,
		handleClose,
		handleKeydownEscape,
		toggleMenu,
		selectOption,
		getValueKey,
		navigateOptions,
		handleDeleteTooltipTag,
		dropMenuVisible,
		queryChange,
		groupQueryChange,
		showTagList,
		collapseTagList,
		selectTagsStyle: computed(() => ({
			maxWidth: `${unref(states.inputWidth) - 32 - (showStatusIconAndState.value ? 22 : 0)}px`,
			width: "100%"
		})),
		reference,
		input: input$4,
		iOSInput,
		tooltipRef,
		tagTooltipRef,
		tags: tags$1,
		selectWrapper,
		scrollbar: scrollbar$1,
		handleMouseEnter,
		handleMouseLeave
	};
};
init_shared_esm_bundler();
var ElOptions = defineComponent({
	name: "ElOptions",
	emits: ["update-options"],
	setup(_, { slots, emit }) {
		let cachedOptions = [];
		function isSameOptions(a$1, b$2) {
			if (a$1.length !== b$2.length) return false;
			for (const [index] of a$1.entries()) if (a$1[index] != b$2[index]) return false;
			return true;
		}
		return () => {
			var _a, _b;
			const children = (_a = slots.default) == null ? void 0 : _a.call(slots);
			const filteredOptions = [];
			function filterOptions(children2) {
				if (!Array.isArray(children2)) return;
				children2.forEach((item$4) => {
					var _a2, _b2, _c, _d;
					const name$1 = (_a2 = (item$4 == null ? void 0 : item$4.type) || {}) == null ? void 0 : _a2.name;
					if (name$1 === "ElOptionGroup") filterOptions(!isString$2(item$4.children) && !Array.isArray(item$4.children) && isFunction$2((_b2 = item$4.children) == null ? void 0 : _b2.default) ? (_c = item$4.children) == null ? void 0 : _c.default() : item$4.children);
					else if (name$1 === "ElOption") filteredOptions.push((_d = item$4.props) == null ? void 0 : _d.label);
					else if (Array.isArray(item$4.children)) filterOptions(item$4.children);
				});
			}
			if (children.length) filterOptions((_b = children[0]) == null ? void 0 : _b.children);
			if (!isSameOptions(filteredOptions, cachedOptions)) {
				cachedOptions = filteredOptions;
				emit("update-options", filteredOptions);
			}
			return children;
		};
	}
});
var COMPONENT_NAME$1 = "ElSelect";
var _sfc_main$3 = defineComponent({
	name: COMPONENT_NAME$1,
	componentName: COMPONENT_NAME$1,
	components: {
		ElInput,
		ElSelectMenu,
		ElOption: Option,
		ElOptions,
		ElTag,
		ElScrollbar,
		ElTooltip,
		ElIcon
	},
	directives: { ClickOutside },
	props: {
		name: String,
		id: String,
		modelValue: {
			type: [
				Array,
				String,
				Number,
				Boolean,
				Object
			],
			default: void 0
		},
		autocomplete: {
			type: String,
			default: "off"
		},
		automaticDropdown: Boolean,
		size: {
			type: String,
			validator: isValidComponentSize
		},
		effect: {
			type: String,
			default: "light"
		},
		disabled: Boolean,
		clearable: Boolean,
		filterable: Boolean,
		allowCreate: Boolean,
		loading: Boolean,
		popperClass: {
			type: String,
			default: ""
		},
		popperOptions: {
			type: Object,
			default: () => ({})
		},
		remote: Boolean,
		loadingText: String,
		noMatchText: String,
		noDataText: String,
		remoteMethod: Function,
		filterMethod: Function,
		multiple: Boolean,
		multipleLimit: {
			type: Number,
			default: 0
		},
		placeholder: { type: String },
		defaultFirstOption: Boolean,
		reserveKeyword: {
			type: Boolean,
			default: true
		},
		valueKey: {
			type: String,
			default: "value"
		},
		collapseTags: Boolean,
		collapseTagsTooltip: Boolean,
		maxCollapseTags: {
			type: Number,
			default: 1
		},
		teleported: useTooltipContentProps.teleported,
		persistent: {
			type: Boolean,
			default: true
		},
		clearIcon: {
			type: iconPropType,
			default: circle_close_default
		},
		fitInputWidth: Boolean,
		suffixIcon: {
			type: iconPropType,
			default: arrow_down_default
		},
		tagType: {
			...tagProps.type,
			default: "info"
		},
		validateEvent: {
			type: Boolean,
			default: true
		},
		remoteShowSuffix: Boolean,
		suffixTransition: {
			type: Boolean,
			default: true
		},
		placement: {
			type: String,
			values: Ee$1,
			default: "bottom-start"
		},
		ariaLabel: {
			type: String,
			default: void 0
		}
	},
	emits: [
		UPDATE_MODEL_EVENT,
		CHANGE_EVENT,
		"remove-tag",
		"clear",
		"visible-change",
		"focus",
		"blur"
	],
	setup(props, ctx) {
		const nsSelect = useNamespace("select");
		const nsInput = useNamespace("input");
		const { t: t$1 } = useLocale$1();
		const contentId = useId$1();
		const states = useSelectStates(props);
		const { optionList, optionsArray, hoverOption, selectSize, readonly: readonly$1, handleResize, collapseTagSize, debouncedOnInputChange, debouncedQueryChange, deletePrevTag, deleteTag, deleteSelected, handleOptionSelect, scrollToOption, setSelected, resetInputHeight, managePlaceholder, showClose, selectDisabled, iconComponent, iconReverse, showNewOption, emptyText, toggleLastOptionHitState, resetInputState, handleComposition, onOptionCreate, onOptionDestroy, handleMenuEnter, handleFocus, focus: focus$1, blur, handleBlur, handleClearClick, handleClose, handleKeydownEscape, toggleMenu, selectOption, getValueKey, navigateOptions, handleDeleteTooltipTag, dropMenuVisible, reference, input: input$4, iOSInput, tooltipRef, tagTooltipRef, tags: tags$1, selectWrapper, scrollbar: scrollbar$1, queryChange, groupQueryChange, handleMouseEnter, handleMouseLeave, showTagList, collapseTagList, selectTagsStyle } = useSelect(props, states, ctx);
		const { inputWidth, selected: selected$1, inputLength, filteredOptionsCount, visible: visible$1, selectedLabel, hoverIndex, query, inputHovering, currentPlaceholder, menuVisibleOnFocus, isOnComposition, options: options$1, cachedOptions, optionsCount, prefixWidth } = toRefs(states);
		const wrapperKls = computed(() => {
			const classList = [nsSelect.b()];
			const _selectSize = unref(selectSize);
			if (_selectSize) classList.push(nsSelect.m(_selectSize));
			if (props.disabled) classList.push(nsSelect.m("disabled"));
			return classList;
		});
		const tagsKls = computed(() => [nsSelect.e("tags"), nsSelect.is("disabled", unref(selectDisabled))]);
		const tagWrapperKls = computed(() => [nsSelect.b("tags-wrapper"), { "has-prefix": unref(prefixWidth) && unref(selected$1).length }]);
		const inputKls = computed(() => [
			nsSelect.e("input"),
			nsSelect.is(unref(selectSize)),
			nsSelect.is("disabled", unref(selectDisabled))
		]);
		const iOSInputKls = computed(() => [
			nsSelect.e("input"),
			nsSelect.is(unref(selectSize)),
			nsSelect.em("input", "iOS")
		]);
		const scrollbarKls = computed(() => [nsSelect.is("empty", !props.allowCreate && Boolean(unref(query)) && unref(filteredOptionsCount) === 0)]);
		const tagTextStyle = computed(() => {
			return { maxWidth: `${unref(inputWidth) > 123 && unref(selected$1).length > props.maxCollapseTags ? unref(inputWidth) - 123 : unref(inputWidth) - 75}px` };
		});
		const inputStyle = computed(() => ({
			marginLeft: `${unref(prefixWidth)}px`,
			flexGrow: 1,
			width: `${unref(inputLength) / (unref(inputWidth) - 32)}%`,
			maxWidth: `${unref(inputWidth) - 42}px`
		}));
		provide(selectKey, reactive({
			props,
			options: options$1,
			optionsArray,
			cachedOptions,
			optionsCount,
			filteredOptionsCount,
			hoverIndex,
			handleOptionSelect,
			onOptionCreate,
			onOptionDestroy,
			selectWrapper,
			selected: selected$1,
			setSelected,
			queryChange,
			groupQueryChange
		}));
		onMounted(() => {
			states.cachedPlaceHolder = currentPlaceholder.value = props.placeholder || (() => t$1("el.select.placeholder"));
			if (props.multiple && Array.isArray(props.modelValue) && props.modelValue.length > 0) currentPlaceholder.value = "";
			useResizeObserver$2(selectWrapper, handleResize);
			if (props.remote && props.multiple) resetInputHeight();
			nextTick(() => {
				const refEl = reference.value && reference.value.$el;
				if (!refEl) return;
				inputWidth.value = refEl.getBoundingClientRect().width;
				if (ctx.slots.prefix) {
					const prefix$1 = refEl.querySelector(`.${nsInput.e("prefix")}`);
					prefixWidth.value = Math.max(prefix$1.getBoundingClientRect().width + 11, 30);
				}
			});
			setSelected();
		});
		if (props.multiple && !Array.isArray(props.modelValue)) ctx.emit(UPDATE_MODEL_EVENT, []);
		if (!props.multiple && Array.isArray(props.modelValue)) ctx.emit(UPDATE_MODEL_EVENT, "");
		const popperPaneRef = computed(() => {
			var _a, _b;
			return (_b = (_a = tooltipRef.value) == null ? void 0 : _a.popperRef) == null ? void 0 : _b.contentRef;
		});
		const onOptionsRendered = (v$1) => {
			optionList.value = v$1;
		};
		return {
			isIOS: isIOS$1,
			onOptionsRendered,
			prefixWidth,
			selectSize,
			readonly: readonly$1,
			handleResize,
			collapseTagSize,
			debouncedOnInputChange,
			debouncedQueryChange,
			deletePrevTag,
			deleteTag,
			handleDeleteTooltipTag,
			deleteSelected,
			handleOptionSelect,
			scrollToOption,
			inputWidth,
			selected: selected$1,
			inputLength,
			filteredOptionsCount,
			visible: visible$1,
			selectedLabel,
			hoverIndex,
			query,
			inputHovering,
			currentPlaceholder,
			menuVisibleOnFocus,
			isOnComposition,
			options: options$1,
			resetInputHeight,
			managePlaceholder,
			showClose,
			selectDisabled,
			iconComponent,
			iconReverse,
			showNewOption,
			emptyText,
			toggleLastOptionHitState,
			resetInputState,
			handleComposition,
			handleMenuEnter,
			handleFocus,
			focus: focus$1,
			blur,
			handleBlur,
			handleClearClick,
			handleClose,
			handleKeydownEscape,
			toggleMenu,
			selectOption,
			getValueKey,
			navigateOptions,
			dropMenuVisible,
			reference,
			input: input$4,
			iOSInput,
			tooltipRef,
			popperPaneRef,
			tags: tags$1,
			selectWrapper,
			scrollbar: scrollbar$1,
			wrapperKls,
			tagsKls,
			tagWrapperKls,
			inputKls,
			iOSInputKls,
			scrollbarKls,
			selectTagsStyle,
			nsSelect,
			tagTextStyle,
			inputStyle,
			handleMouseEnter,
			handleMouseLeave,
			showTagList,
			collapseTagList,
			tagTooltipRef,
			contentId,
			hoverOption
		};
	}
});
var _hoisted_1$49 = [
	"disabled",
	"autocomplete",
	"aria-activedescendant",
	"aria-controls",
	"aria-expanded",
	"aria-label"
];
var _hoisted_2$29 = ["disabled"];
var _hoisted_3$12 = { style: {
	"height": "100%",
	"display": "flex",
	"justify-content": "center",
	"align-items": "center"
} };
function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
	const _component_el_tag = resolveComponent("el-tag");
	const _component_el_tooltip = resolveComponent("el-tooltip");
	const _component_el_icon = resolveComponent("el-icon");
	const _component_el_input = resolveComponent("el-input");
	const _component_el_option = resolveComponent("el-option");
	const _component_el_options = resolveComponent("el-options");
	const _component_el_scrollbar = resolveComponent("el-scrollbar");
	const _component_el_select_menu = resolveComponent("el-select-menu");
	const _directive_click_outside = resolveDirective("click-outside");
	return withDirectives((openBlock(), createElementBlock("div", {
		ref: "selectWrapper",
		class: normalizeClass(_ctx.wrapperKls),
		onMouseenter: _cache[22] || (_cache[22] = (...args) => _ctx.handleMouseEnter && _ctx.handleMouseEnter(...args)),
		onMouseleave: _cache[23] || (_cache[23] = (...args) => _ctx.handleMouseLeave && _ctx.handleMouseLeave(...args)),
		onClick: _cache[24] || (_cache[24] = withModifiers((...args) => _ctx.toggleMenu && _ctx.toggleMenu(...args), ["stop"]))
	}, [createVNode(_component_el_tooltip, {
		ref: "tooltipRef",
		visible: _ctx.dropMenuVisible,
		placement: _ctx.placement,
		teleported: _ctx.teleported,
		"popper-class": [_ctx.nsSelect.e("popper"), _ctx.popperClass],
		"popper-options": _ctx.popperOptions,
		"fallback-placements": [
			"bottom-start",
			"top-start",
			"right",
			"left"
		],
		effect: _ctx.effect,
		pure: "",
		trigger: "click",
		transition: `${_ctx.nsSelect.namespace.value}-zoom-in-top`,
		"stop-popper-mouse-event": false,
		"gpu-acceleration": false,
		persistent: _ctx.persistent,
		onShow: _ctx.handleMenuEnter
	}, {
		default: withCtx(() => {
			var _a, _b;
			return [createBaseVNode("div", {
				class: "select-trigger",
				onMouseenter: _cache[20] || (_cache[20] = ($event) => _ctx.inputHovering = true),
				onMouseleave: _cache[21] || (_cache[21] = ($event) => _ctx.inputHovering = false)
			}, [
				_ctx.multiple ? (openBlock(), createElementBlock("div", {
					key: 0,
					ref: "tags",
					tabindex: "-1",
					class: normalizeClass(_ctx.tagsKls),
					style: normalizeStyle(_ctx.selectTagsStyle),
					onClick: _cache[15] || (_cache[15] = (...args) => _ctx.focus && _ctx.focus(...args))
				}, [
					_ctx.collapseTags && _ctx.selected.length ? (openBlock(), createBlock(Transition, {
						key: 0,
						onAfterLeave: _ctx.resetInputHeight
					}, {
						default: withCtx(() => [createBaseVNode("span", { class: normalizeClass(_ctx.tagWrapperKls) }, [(openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.showTagList, (item$4) => {
							return openBlock(), createBlock(_component_el_tag, {
								key: _ctx.getValueKey(item$4),
								closable: !_ctx.selectDisabled && !item$4.isDisabled,
								size: _ctx.collapseTagSize,
								hit: item$4.hitState,
								type: _ctx.tagType,
								"disable-transitions": "",
								onClose: ($event) => _ctx.deleteTag($event, item$4)
							}, {
								default: withCtx(() => [createBaseVNode("span", {
									class: normalizeClass(_ctx.nsSelect.e("tags-text")),
									style: normalizeStyle(_ctx.tagTextStyle)
								}, toDisplayString(item$4.currentLabel), 7)]),
								_: 2
							}, 1032, [
								"closable",
								"size",
								"hit",
								"type",
								"onClose"
							]);
						}), 128)), _ctx.selected.length > _ctx.maxCollapseTags ? (openBlock(), createBlock(_component_el_tag, {
							key: 0,
							closable: false,
							size: _ctx.collapseTagSize,
							type: _ctx.tagType,
							"disable-transitions": ""
						}, {
							default: withCtx(() => [_ctx.collapseTagsTooltip ? (openBlock(), createBlock(_component_el_tooltip, {
								key: 0,
								ref: "tagTooltipRef",
								disabled: _ctx.dropMenuVisible,
								"fallback-placements": [
									"bottom",
									"top",
									"right",
									"left"
								],
								effect: _ctx.effect,
								placement: "bottom",
								teleported: _ctx.teleported
							}, {
								default: withCtx(() => [createBaseVNode("span", { class: normalizeClass(_ctx.nsSelect.e("tags-text")) }, "+ " + toDisplayString(_ctx.selected.length - _ctx.maxCollapseTags), 3)]),
								content: withCtx(() => [createBaseVNode("div", { class: normalizeClass(_ctx.nsSelect.e("collapse-tags")) }, [(openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.collapseTagList, (item$4) => {
									return openBlock(), createElementBlock("div", {
										key: _ctx.getValueKey(item$4),
										class: normalizeClass(_ctx.nsSelect.e("collapse-tag"))
									}, [createVNode(_component_el_tag, {
										class: "in-tooltip",
										closable: !_ctx.selectDisabled && !item$4.isDisabled,
										size: _ctx.collapseTagSize,
										hit: item$4.hitState,
										type: _ctx.tagType,
										"disable-transitions": "",
										style: { margin: "2px" },
										onClose: ($event) => _ctx.handleDeleteTooltipTag($event, item$4)
									}, {
										default: withCtx(() => [createBaseVNode("span", {
											class: normalizeClass(_ctx.nsSelect.e("tags-text")),
											style: normalizeStyle({ maxWidth: _ctx.inputWidth - 75 + "px" })
										}, toDisplayString(item$4.currentLabel), 7)]),
										_: 2
									}, 1032, [
										"closable",
										"size",
										"hit",
										"type",
										"onClose"
									])], 2);
								}), 128))], 2)]),
								_: 1
							}, 8, [
								"disabled",
								"effect",
								"teleported"
							])) : (openBlock(), createElementBlock("span", {
								key: 1,
								class: normalizeClass(_ctx.nsSelect.e("tags-text"))
							}, "+ " + toDisplayString(_ctx.selected.length - _ctx.maxCollapseTags), 3))]),
							_: 1
						}, 8, ["size", "type"])) : createCommentVNode("v-if", true)], 2)]),
						_: 1
					}, 8, ["onAfterLeave"])) : createCommentVNode("v-if", true),
					!_ctx.collapseTags ? (openBlock(), createBlock(Transition, {
						key: 1,
						onAfterLeave: _ctx.resetInputHeight
					}, {
						default: withCtx(() => [createBaseVNode("span", {
							class: normalizeClass(_ctx.tagWrapperKls),
							style: normalizeStyle(_ctx.prefixWidth && _ctx.selected.length ? { marginLeft: `${_ctx.prefixWidth}px` } : "")
						}, [(openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.selected, (item$4) => {
							return openBlock(), createBlock(_component_el_tag, {
								key: _ctx.getValueKey(item$4),
								closable: !_ctx.selectDisabled && !item$4.isDisabled,
								size: _ctx.collapseTagSize,
								hit: item$4.hitState,
								type: _ctx.tagType,
								"disable-transitions": "",
								onClose: ($event) => _ctx.deleteTag($event, item$4)
							}, {
								default: withCtx(() => [createBaseVNode("span", {
									class: normalizeClass(_ctx.nsSelect.e("tags-text")),
									style: normalizeStyle({ maxWidth: _ctx.inputWidth - 75 + "px" })
								}, toDisplayString(item$4.currentLabel), 7)]),
								_: 2
							}, 1032, [
								"closable",
								"size",
								"hit",
								"type",
								"onClose"
							]);
						}), 128))], 6)]),
						_: 1
					}, 8, ["onAfterLeave"])) : createCommentVNode("v-if", true),
					_ctx.filterable && !_ctx.selectDisabled ? withDirectives((openBlock(), createElementBlock("input", {
						key: 2,
						ref: "input",
						"onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.query = $event),
						type: "text",
						class: normalizeClass(_ctx.inputKls),
						disabled: _ctx.selectDisabled,
						autocomplete: _ctx.autocomplete,
						style: normalizeStyle(_ctx.inputStyle),
						role: "combobox",
						"aria-activedescendant": ((_a = _ctx.hoverOption) == null ? void 0 : _a.id) || "",
						"aria-controls": _ctx.contentId,
						"aria-expanded": _ctx.dropMenuVisible,
						"aria-label": _ctx.ariaLabel,
						"aria-autocomplete": "none",
						"aria-haspopup": "listbox",
						onFocus: _cache[1] || (_cache[1] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
						onBlur: _cache[2] || (_cache[2] = (...args) => _ctx.handleBlur && _ctx.handleBlur(...args)),
						onKeyup: _cache[3] || (_cache[3] = (...args) => _ctx.managePlaceholder && _ctx.managePlaceholder(...args)),
						onKeydown: [
							_cache[4] || (_cache[4] = (...args) => _ctx.resetInputState && _ctx.resetInputState(...args)),
							_cache[5] || (_cache[5] = withKeys(withModifiers(($event) => _ctx.navigateOptions("next"), ["prevent"]), ["down"])),
							_cache[6] || (_cache[6] = withKeys(withModifiers(($event) => _ctx.navigateOptions("prev"), ["prevent"]), ["up"])),
							_cache[7] || (_cache[7] = withKeys((...args) => _ctx.handleKeydownEscape && _ctx.handleKeydownEscape(...args), ["esc"])),
							_cache[8] || (_cache[8] = withKeys(withModifiers((...args) => _ctx.selectOption && _ctx.selectOption(...args), ["stop", "prevent"]), ["enter"])),
							_cache[9] || (_cache[9] = withKeys((...args) => _ctx.deletePrevTag && _ctx.deletePrevTag(...args), ["delete"])),
							_cache[10] || (_cache[10] = withKeys(($event) => _ctx.visible = false, ["tab"]))
						],
						onCompositionstart: _cache[11] || (_cache[11] = (...args) => _ctx.handleComposition && _ctx.handleComposition(...args)),
						onCompositionupdate: _cache[12] || (_cache[12] = (...args) => _ctx.handleComposition && _ctx.handleComposition(...args)),
						onCompositionend: _cache[13] || (_cache[13] = (...args) => _ctx.handleComposition && _ctx.handleComposition(...args)),
						onInput: _cache[14] || (_cache[14] = (...args) => _ctx.debouncedQueryChange && _ctx.debouncedQueryChange(...args))
					}, null, 46, _hoisted_1$49)), [[vModelText, _ctx.query]]) : createCommentVNode("v-if", true)
				], 6)) : createCommentVNode("v-if", true),
				_ctx.isIOS && !_ctx.multiple && _ctx.filterable && _ctx.readonly ? (openBlock(), createElementBlock("input", {
					key: 1,
					ref: "iOSInput",
					class: normalizeClass(_ctx.iOSInputKls),
					disabled: _ctx.selectDisabled,
					type: "text"
				}, null, 10, _hoisted_2$29)) : createCommentVNode("v-if", true),
				createVNode(_component_el_input, {
					id: _ctx.id,
					ref: "reference",
					modelValue: _ctx.selectedLabel,
					"onUpdate:modelValue": _cache[16] || (_cache[16] = ($event) => _ctx.selectedLabel = $event),
					type: "text",
					placeholder: typeof _ctx.currentPlaceholder === "function" ? _ctx.currentPlaceholder() : _ctx.currentPlaceholder,
					name: _ctx.name,
					autocomplete: _ctx.autocomplete,
					size: _ctx.selectSize,
					disabled: _ctx.selectDisabled,
					readonly: _ctx.readonly,
					"validate-event": false,
					class: normalizeClass([_ctx.nsSelect.is("focus", _ctx.visible)]),
					tabindex: _ctx.multiple && _ctx.filterable ? -1 : void 0,
					role: "combobox",
					"aria-activedescendant": ((_b = _ctx.hoverOption) == null ? void 0 : _b.id) || "",
					"aria-controls": _ctx.contentId,
					"aria-expanded": _ctx.dropMenuVisible,
					label: _ctx.ariaLabel,
					"aria-autocomplete": "none",
					"aria-haspopup": "listbox",
					onFocus: _ctx.handleFocus,
					onBlur: _ctx.handleBlur,
					onInput: _ctx.debouncedOnInputChange,
					onPaste: _ctx.debouncedOnInputChange,
					onCompositionstart: _ctx.handleComposition,
					onCompositionupdate: _ctx.handleComposition,
					onCompositionend: _ctx.handleComposition,
					onKeydown: [
						_cache[17] || (_cache[17] = withKeys(withModifiers(($event) => _ctx.navigateOptions("next"), ["stop", "prevent"]), ["down"])),
						_cache[18] || (_cache[18] = withKeys(withModifiers(($event) => _ctx.navigateOptions("prev"), ["stop", "prevent"]), ["up"])),
						withKeys(withModifiers(_ctx.selectOption, ["stop", "prevent"]), ["enter"]),
						withKeys(_ctx.handleKeydownEscape, ["esc"]),
						_cache[19] || (_cache[19] = withKeys(($event) => _ctx.visible = false, ["tab"]))
					]
				}, createSlots({
					suffix: withCtx(() => [_ctx.iconComponent && !_ctx.showClose ? (openBlock(), createBlock(_component_el_icon, {
						key: 0,
						class: normalizeClass([
							_ctx.nsSelect.e("caret"),
							_ctx.nsSelect.e("icon"),
							_ctx.iconReverse
						])
					}, {
						default: withCtx(() => [(openBlock(), createBlock(resolveDynamicComponent(_ctx.iconComponent)))]),
						_: 1
					}, 8, ["class"])) : createCommentVNode("v-if", true), _ctx.showClose && _ctx.clearIcon ? (openBlock(), createBlock(_component_el_icon, {
						key: 1,
						class: normalizeClass([_ctx.nsSelect.e("caret"), _ctx.nsSelect.e("icon")]),
						onClick: _ctx.handleClearClick
					}, {
						default: withCtx(() => [(openBlock(), createBlock(resolveDynamicComponent(_ctx.clearIcon)))]),
						_: 1
					}, 8, ["class", "onClick"])) : createCommentVNode("v-if", true)]),
					_: 2
				}, [_ctx.$slots.prefix ? {
					name: "prefix",
					fn: withCtx(() => [createBaseVNode("div", _hoisted_3$12, [renderSlot(_ctx.$slots, "prefix")])])
				} : void 0]), 1032, [
					"id",
					"modelValue",
					"placeholder",
					"name",
					"autocomplete",
					"size",
					"disabled",
					"readonly",
					"class",
					"tabindex",
					"aria-activedescendant",
					"aria-controls",
					"aria-expanded",
					"label",
					"onFocus",
					"onBlur",
					"onInput",
					"onPaste",
					"onCompositionstart",
					"onCompositionupdate",
					"onCompositionend",
					"onKeydown"
				])
			], 32)];
		}),
		content: withCtx(() => [createVNode(_component_el_select_menu, null, createSlots({
			default: withCtx(() => [withDirectives(createVNode(_component_el_scrollbar, {
				id: _ctx.contentId,
				ref: "scrollbar",
				tag: "ul",
				"wrap-class": _ctx.nsSelect.be("dropdown", "wrap"),
				"view-class": _ctx.nsSelect.be("dropdown", "list"),
				class: normalizeClass(_ctx.scrollbarKls),
				role: "listbox",
				"aria-label": _ctx.ariaLabel,
				"aria-orientation": "vertical"
			}, {
				default: withCtx(() => [_ctx.showNewOption ? (openBlock(), createBlock(_component_el_option, {
					key: 0,
					value: _ctx.query,
					created: true
				}, null, 8, ["value"])) : createCommentVNode("v-if", true), createVNode(_component_el_options, { onUpdateOptions: _ctx.onOptionsRendered }, {
					default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
					_: 3
				}, 8, ["onUpdateOptions"])]),
				_: 3
			}, 8, [
				"id",
				"wrap-class",
				"view-class",
				"class",
				"aria-label"
			]), [[vShow, _ctx.options.size > 0 && !_ctx.loading]]), _ctx.emptyText && (!_ctx.allowCreate || _ctx.loading || _ctx.allowCreate && _ctx.options.size === 0) ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [_ctx.$slots.empty ? renderSlot(_ctx.$slots, "empty", { key: 0 }) : (openBlock(), createElementBlock("p", {
				key: 1,
				class: normalizeClass(_ctx.nsSelect.be("dropdown", "empty"))
			}, toDisplayString(_ctx.emptyText), 3))], 64)) : createCommentVNode("v-if", true)]),
			_: 2
		}, [_ctx.$slots.header ? {
			name: "header",
			fn: withCtx(() => [renderSlot(_ctx.$slots, "header")])
		} : void 0, _ctx.$slots.footer ? {
			name: "footer",
			fn: withCtx(() => [renderSlot(_ctx.$slots, "footer")])
		} : void 0]), 1024)]),
		_: 3
	}, 8, [
		"visible",
		"placement",
		"teleported",
		"popper-class",
		"popper-options",
		"effect",
		"transition",
		"persistent",
		"onShow"
	])], 34)), [[
		_directive_click_outside,
		_ctx.handleClose,
		_ctx.popperPaneRef
	]]);
}
var Select = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render$3], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/select.vue"]]);
var _sfc_main$2 = defineComponent({
	name: "ElOptionGroup",
	componentName: "ElOptionGroup",
	props: {
		label: String,
		disabled: Boolean
	},
	setup(props) {
		const ns = useNamespace("select");
		const visible$1 = ref(true);
		const instance = getCurrentInstance();
		const children = ref([]);
		provide(selectGroupKey, reactive({ ...toRefs(props) }));
		const select = inject(selectKey);
		onMounted(() => {
			children.value = flattedChildren$1(instance.subTree);
		});
		const flattedChildren$1 = (node) => {
			const children2 = [];
			if (Array.isArray(node.children)) node.children.forEach((child$1) => {
				var _a;
				if (child$1.type && child$1.type.name === "ElOption" && child$1.component && child$1.component.proxy) children2.push(child$1.component.proxy);
				else if ((_a = child$1.children) == null ? void 0 : _a.length) children2.push(...flattedChildren$1(child$1));
			});
			return children2;
		};
		const { groupQueryChange } = toRaw(select);
		watch(groupQueryChange, () => {
			visible$1.value = children.value.some((option) => option.visible === true);
		}, { flush: "post" });
		return {
			visible: visible$1,
			ns
		};
	}
});
function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
	return withDirectives((openBlock(), createElementBlock("ul", { class: normalizeClass(_ctx.ns.be("group", "wrap")) }, [createBaseVNode("li", { class: normalizeClass(_ctx.ns.be("group", "title")) }, toDisplayString(_ctx.label), 3), createBaseVNode("li", null, [createBaseVNode("ul", { class: normalizeClass(_ctx.ns.b("group")) }, [renderSlot(_ctx.$slots, "default")], 2)])], 2)), [[vShow, _ctx.visible]]);
}
var OptionGroup = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", _sfc_render$2], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/option-group.vue"]]);
var ElSelect = withInstall(Select, {
	Option,
	OptionGroup
});
var ElOption = withNoopInstall(Option);
var ElOptionGroup = withNoopInstall(OptionGroup);
var usePagination = () => inject(elPaginationKey, {});
var paginationSizesProps = buildProps({
	pageSize: {
		type: Number,
		required: true
	},
	pageSizes: {
		type: definePropType(Array),
		default: () => mutable([
			10,
			20,
			30,
			40,
			50,
			100
		])
	},
	popperClass: { type: String },
	disabled: Boolean,
	teleported: Boolean,
	size: {
		type: String,
		values: componentSizes
	}
});
var Sizes = /* @__PURE__ */ _export_sfc(/* @__PURE__ */ defineComponent({
	...defineComponent({ name: "ElPaginationSizes" }),
	props: paginationSizesProps,
	emits: ["page-size-change"],
	setup(__props, { emit }) {
		const props = __props;
		const { t: t$1 } = useLocale$1();
		const ns = useNamespace("pagination");
		const pagination = usePagination();
		const innerPageSize = ref(props.pageSize);
		watch(() => props.pageSizes, (newVal, oldVal) => {
			if (isEqual_default(newVal, oldVal)) return;
			if (Array.isArray(newVal)) emit("page-size-change", newVal.includes(props.pageSize) ? props.pageSize : props.pageSizes[0]);
		});
		watch(() => props.pageSize, (newVal) => {
			innerPageSize.value = newVal;
		});
		const innerPageSizes = computed(() => props.pageSizes);
		function handleChange(val) {
			var _a;
			if (val !== innerPageSize.value) {
				innerPageSize.value = val;
				(_a = pagination.handleSizeChange) == null || _a.call(pagination, Number(val));
			}
		}
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("span", { class: normalizeClass(unref(ns).e("sizes")) }, [createVNode(unref(ElSelect), {
				"model-value": innerPageSize.value,
				disabled: _ctx.disabled,
				"popper-class": _ctx.popperClass,
				size: _ctx.size,
				teleported: _ctx.teleported,
				"validate-event": false,
				onChange: handleChange
			}, {
				default: withCtx(() => [(openBlock(true), createElementBlock(Fragment, null, renderList(unref(innerPageSizes), (item$4) => {
					return openBlock(), createBlock(unref(ElOption), {
						key: item$4,
						value: item$4,
						label: item$4 + unref(t$1)("el.pagination.pagesize")
					}, null, 8, ["value", "label"]);
				}), 128))]),
				_: 1
			}, 8, [
				"model-value",
				"disabled",
				"popper-class",
				"size",
				"teleported"
			])], 2);
		};
	}
}), [["__file", "/home/runner/work/element-plus/element-plus/packages/components/pagination/src/components/sizes.vue"]]);
var paginationJumperProps = buildProps({ size: {
	type: String,
	values: componentSizes
} });
var _hoisted_1$48 = ["disabled"];
var Jumper = /* @__PURE__ */ _export_sfc(/* @__PURE__ */ defineComponent({
	...defineComponent({ name: "ElPaginationJumper" }),
	props: paginationJumperProps,
	setup(__props) {
		const { t: t$1 } = useLocale$1();
		const ns = useNamespace("pagination");
		const { pageCount, disabled: disabled$9, currentPage, changeEvent } = usePagination();
		const userInput = ref();
		const innerValue = computed(() => {
			var _a;
			return (_a = userInput.value) != null ? _a : currentPage == null ? void 0 : currentPage.value;
		});
		function handleInput(val) {
			userInput.value = val ? +val : "";
		}
		function handleChange(val) {
			val = Math.trunc(+val);
			changeEvent?.(val);
			userInput.value = void 0;
		}
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("span", {
				class: normalizeClass(unref(ns).e("jump")),
				disabled: unref(disabled$9)
			}, [
				createBaseVNode("span", { class: normalizeClass([unref(ns).e("goto")]) }, toDisplayString(unref(t$1)("el.pagination.goto")), 3),
				createVNode(unref(ElInput), {
					size: _ctx.size,
					class: normalizeClass([unref(ns).e("editor"), unref(ns).is("in-pagination")]),
					min: 1,
					max: unref(pageCount),
					disabled: unref(disabled$9),
					"model-value": unref(innerValue),
					"validate-event": false,
					label: unref(t$1)("el.pagination.page"),
					type: "number",
					"onUpdate:modelValue": handleInput,
					onChange: handleChange
				}, null, 8, [
					"size",
					"class",
					"max",
					"disabled",
					"model-value",
					"label"
				]),
				createBaseVNode("span", { class: normalizeClass([unref(ns).e("classifier")]) }, toDisplayString(unref(t$1)("el.pagination.pageClassifier")), 3)
			], 10, _hoisted_1$48);
		};
	}
}), [["__file", "/home/runner/work/element-plus/element-plus/packages/components/pagination/src/components/jumper.vue"]]);
var paginationTotalProps = buildProps({ total: {
	type: Number,
	default: 1e3
} });
var _hoisted_1$47 = ["disabled"];
var Total = /* @__PURE__ */ _export_sfc(/* @__PURE__ */ defineComponent({
	...defineComponent({ name: "ElPaginationTotal" }),
	props: paginationTotalProps,
	setup(__props) {
		const { t: t$1 } = useLocale$1();
		const ns = useNamespace("pagination");
		const { disabled: disabled$9 } = usePagination();
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("span", {
				class: normalizeClass(unref(ns).e("total")),
				disabled: unref(disabled$9)
			}, toDisplayString(unref(t$1)("el.pagination.total", { total: _ctx.total })), 11, _hoisted_1$47);
		};
	}
}), [["__file", "/home/runner/work/element-plus/element-plus/packages/components/pagination/src/components/total.vue"]]);
var paginationPagerProps = buildProps({
	currentPage: {
		type: Number,
		default: 1
	},
	pageCount: {
		type: Number,
		required: true
	},
	pagerCount: {
		type: Number,
		default: 7
	},
	disabled: Boolean
});
var _hoisted_1$46 = ["onKeyup"];
var _hoisted_2$28 = [
	"aria-current",
	"aria-label",
	"tabindex"
];
var _hoisted_3$11 = ["tabindex", "aria-label"];
var _hoisted_4$8 = [
	"aria-current",
	"aria-label",
	"tabindex"
];
var _hoisted_5$5 = ["tabindex", "aria-label"];
var _hoisted_6$1 = [
	"aria-current",
	"aria-label",
	"tabindex"
];
var Pager = /* @__PURE__ */ _export_sfc(/* @__PURE__ */ defineComponent({
	...defineComponent({ name: "ElPaginationPager" }),
	props: paginationPagerProps,
	emits: ["change"],
	setup(__props, { emit }) {
		const props = __props;
		const nsPager = useNamespace("pager");
		const nsIcon = useNamespace("icon");
		const { t: t$1 } = useLocale$1();
		const showPrevMore = ref(false);
		const showNextMore = ref(false);
		const quickPrevHover = ref(false);
		const quickNextHover = ref(false);
		const quickPrevFocus = ref(false);
		const quickNextFocus = ref(false);
		const pagers = computed(() => {
			const pagerCount = props.pagerCount;
			const halfPagerCount = (pagerCount - 1) / 2;
			const currentPage = Number(props.currentPage);
			const pageCount = Number(props.pageCount);
			let showPrevMore2 = false;
			let showNextMore2 = false;
			if (pageCount > pagerCount) {
				if (currentPage > pagerCount - halfPagerCount) showPrevMore2 = true;
				if (currentPage < pageCount - halfPagerCount) showNextMore2 = true;
			}
			const array = [];
			if (showPrevMore2 && !showNextMore2) {
				const startPage = pageCount - (pagerCount - 2);
				for (let i$1 = startPage; i$1 < pageCount; i$1++) array.push(i$1);
			} else if (!showPrevMore2 && showNextMore2) for (let i$1 = 2; i$1 < pagerCount; i$1++) array.push(i$1);
			else if (showPrevMore2 && showNextMore2) {
				const offset$2 = Math.floor(pagerCount / 2) - 1;
				for (let i$1 = currentPage - offset$2; i$1 <= currentPage + offset$2; i$1++) array.push(i$1);
			} else for (let i$1 = 2; i$1 < pageCount; i$1++) array.push(i$1);
			return array;
		});
		const prevMoreKls = computed(() => [
			"more",
			"btn-quickprev",
			nsIcon.b(),
			nsPager.is("disabled", props.disabled)
		]);
		const nextMoreKls = computed(() => [
			"more",
			"btn-quicknext",
			nsIcon.b(),
			nsPager.is("disabled", props.disabled)
		]);
		const tabindex = computed(() => props.disabled ? -1 : 0);
		watchEffect(() => {
			const halfPagerCount = (props.pagerCount - 1) / 2;
			showPrevMore.value = false;
			showNextMore.value = false;
			if (props.pageCount > props.pagerCount) {
				if (props.currentPage > props.pagerCount - halfPagerCount) showPrevMore.value = true;
				if (props.currentPage < props.pageCount - halfPagerCount) showNextMore.value = true;
			}
		});
		function onMouseEnter(forward = false) {
			if (props.disabled) return;
			if (forward) quickPrevHover.value = true;
			else quickNextHover.value = true;
		}
		function onFocus(forward = false) {
			if (forward) quickPrevFocus.value = true;
			else quickNextFocus.value = true;
		}
		function onEnter(e) {
			const target$1 = e.target;
			if (target$1.tagName.toLowerCase() === "li" && Array.from(target$1.classList).includes("number")) {
				const newPage = Number(target$1.textContent);
				if (newPage !== props.currentPage) emit("change", newPage);
			} else if (target$1.tagName.toLowerCase() === "li" && Array.from(target$1.classList).includes("more")) onPagerClick(e);
		}
		function onPagerClick(event) {
			const target$1 = event.target;
			if (target$1.tagName.toLowerCase() === "ul" || props.disabled) return;
			let newPage = Number(target$1.textContent);
			const pageCount = props.pageCount;
			const currentPage = props.currentPage;
			const pagerCountOffset = props.pagerCount - 2;
			if (target$1.className.includes("more")) {
				if (target$1.className.includes("quickprev")) newPage = currentPage - pagerCountOffset;
				else if (target$1.className.includes("quicknext")) newPage = currentPage + pagerCountOffset;
			}
			if (!Number.isNaN(+newPage)) {
				if (newPage < 1) newPage = 1;
				if (newPage > pageCount) newPage = pageCount;
			}
			if (newPage !== currentPage) emit("change", newPage);
		}
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("ul", {
				class: normalizeClass(unref(nsPager).b()),
				onClick: onPagerClick,
				onKeyup: withKeys(onEnter, ["enter"])
			}, [
				_ctx.pageCount > 0 ? (openBlock(), createElementBlock("li", {
					key: 0,
					class: normalizeClass([[unref(nsPager).is("active", _ctx.currentPage === 1), unref(nsPager).is("disabled", _ctx.disabled)], "number"]),
					"aria-current": _ctx.currentPage === 1,
					"aria-label": unref(t$1)("el.pagination.currentPage", { pager: 1 }),
					tabindex: unref(tabindex)
				}, " 1 ", 10, _hoisted_2$28)) : createCommentVNode("v-if", true),
				showPrevMore.value ? (openBlock(), createElementBlock("li", {
					key: 1,
					class: normalizeClass(unref(prevMoreKls)),
					tabindex: unref(tabindex),
					"aria-label": unref(t$1)("el.pagination.prevPages", { pager: _ctx.pagerCount - 2 }),
					onMouseenter: _cache[0] || (_cache[0] = ($event) => onMouseEnter(true)),
					onMouseleave: _cache[1] || (_cache[1] = ($event) => quickPrevHover.value = false),
					onFocus: _cache[2] || (_cache[2] = ($event) => onFocus(true)),
					onBlur: _cache[3] || (_cache[3] = ($event) => quickPrevFocus.value = false)
				}, [(quickPrevHover.value || quickPrevFocus.value) && !_ctx.disabled ? (openBlock(), createBlock(unref(d_arrow_left_default), { key: 0 })) : (openBlock(), createBlock(unref(more_filled_default), { key: 1 }))], 42, _hoisted_3$11)) : createCommentVNode("v-if", true),
				(openBlock(true), createElementBlock(Fragment, null, renderList(unref(pagers), (pager$1) => {
					return openBlock(), createElementBlock("li", {
						key: pager$1,
						class: normalizeClass([[unref(nsPager).is("active", _ctx.currentPage === pager$1), unref(nsPager).is("disabled", _ctx.disabled)], "number"]),
						"aria-current": _ctx.currentPage === pager$1,
						"aria-label": unref(t$1)("el.pagination.currentPage", { pager: pager$1 }),
						tabindex: unref(tabindex)
					}, toDisplayString(pager$1), 11, _hoisted_4$8);
				}), 128)),
				showNextMore.value ? (openBlock(), createElementBlock("li", {
					key: 2,
					class: normalizeClass(unref(nextMoreKls)),
					tabindex: unref(tabindex),
					"aria-label": unref(t$1)("el.pagination.nextPages", { pager: _ctx.pagerCount - 2 }),
					onMouseenter: _cache[4] || (_cache[4] = ($event) => onMouseEnter()),
					onMouseleave: _cache[5] || (_cache[5] = ($event) => quickNextHover.value = false),
					onFocus: _cache[6] || (_cache[6] = ($event) => onFocus()),
					onBlur: _cache[7] || (_cache[7] = ($event) => quickNextFocus.value = false)
				}, [(quickNextHover.value || quickNextFocus.value) && !_ctx.disabled ? (openBlock(), createBlock(unref(d_arrow_right_default), { key: 0 })) : (openBlock(), createBlock(unref(more_filled_default), { key: 1 }))], 42, _hoisted_5$5)) : createCommentVNode("v-if", true),
				_ctx.pageCount > 1 ? (openBlock(), createElementBlock("li", {
					key: 3,
					class: normalizeClass([[unref(nsPager).is("active", _ctx.currentPage === _ctx.pageCount), unref(nsPager).is("disabled", _ctx.disabled)], "number"]),
					"aria-current": _ctx.currentPage === _ctx.pageCount,
					"aria-label": unref(t$1)("el.pagination.currentPage", { pager: _ctx.pageCount }),
					tabindex: unref(tabindex)
				}, toDisplayString(_ctx.pageCount), 11, _hoisted_6$1)) : createCommentVNode("v-if", true)
			], 42, _hoisted_1$46);
		};
	}
}), [["__file", "/home/runner/work/element-plus/element-plus/packages/components/pagination/src/components/pager.vue"]]);
var isAbsent = (v$1) => typeof v$1 !== "number";
var paginationProps = buildProps({
	pageSize: Number,
	defaultPageSize: Number,
	total: Number,
	pageCount: Number,
	pagerCount: {
		type: Number,
		validator: (value) => {
			return isNumber(value) && Math.trunc(value) === value && value > 4 && value < 22 && value % 2 === 1;
		},
		default: 7
	},
	currentPage: Number,
	defaultCurrentPage: Number,
	layout: {
		type: String,
		default: [
			"prev",
			"pager",
			"next",
			"jumper",
			"->",
			"total"
		].join(", ")
	},
	pageSizes: {
		type: definePropType(Array),
		default: () => mutable([
			10,
			20,
			30,
			40,
			50,
			100
		])
	},
	popperClass: {
		type: String,
		default: ""
	},
	prevText: {
		type: String,
		default: ""
	},
	prevIcon: {
		type: iconPropType,
		default: () => arrow_left_default
	},
	nextText: {
		type: String,
		default: ""
	},
	nextIcon: {
		type: iconPropType,
		default: () => arrow_right_default
	},
	teleported: {
		type: Boolean,
		default: true
	},
	small: Boolean,
	background: Boolean,
	disabled: Boolean,
	hideOnSinglePage: Boolean
});
var paginationEmits = {
	"update:current-page": (val) => isNumber(val),
	"update:page-size": (val) => isNumber(val),
	"size-change": (val) => isNumber(val),
	"current-change": (val) => isNumber(val),
	"prev-click": (val) => isNumber(val),
	"next-click": (val) => isNumber(val)
};
var componentName = "ElPagination";
var ElPagination = withInstall(defineComponent({
	name: componentName,
	props: paginationProps,
	emits: paginationEmits,
	setup(props, { emit, slots }) {
		const { t: t$1 } = useLocale$1();
		const ns = useNamespace("pagination");
		const vnodeProps = getCurrentInstance().vnode.props || {};
		const hasCurrentPageListener = "onUpdate:currentPage" in vnodeProps || "onUpdate:current-page" in vnodeProps || "onCurrentChange" in vnodeProps;
		const hasPageSizeListener = "onUpdate:pageSize" in vnodeProps || "onUpdate:page-size" in vnodeProps || "onSizeChange" in vnodeProps;
		const assertValidUsage = computed(() => {
			if (isAbsent(props.total) && isAbsent(props.pageCount)) return false;
			if (!isAbsent(props.currentPage) && !hasCurrentPageListener) return false;
			if (props.layout.includes("sizes")) {
				if (!isAbsent(props.pageCount)) {
					if (!hasPageSizeListener) return false;
				} else if (!isAbsent(props.total)) {
					if (!isAbsent(props.pageSize)) {
						if (!hasPageSizeListener) return false;
					}
				}
			}
			return true;
		});
		const innerPageSize = ref(isAbsent(props.defaultPageSize) ? 10 : props.defaultPageSize);
		const innerCurrentPage = ref(isAbsent(props.defaultCurrentPage) ? 1 : props.defaultCurrentPage);
		const pageSizeBridge = computed({
			get() {
				return isAbsent(props.pageSize) ? innerPageSize.value : props.pageSize;
			},
			set(v$1) {
				if (isAbsent(props.pageSize)) innerPageSize.value = v$1;
				if (hasPageSizeListener) {
					emit("update:page-size", v$1);
					emit("size-change", v$1);
				}
			}
		});
		const pageCountBridge = computed(() => {
			let pageCount = 0;
			if (!isAbsent(props.pageCount)) pageCount = props.pageCount;
			else if (!isAbsent(props.total)) pageCount = Math.max(1, Math.ceil(props.total / pageSizeBridge.value));
			return pageCount;
		});
		const currentPageBridge = computed({
			get() {
				return isAbsent(props.currentPage) ? innerCurrentPage.value : props.currentPage;
			},
			set(v$1) {
				let newCurrentPage = v$1;
				if (v$1 < 1) newCurrentPage = 1;
				else if (v$1 > pageCountBridge.value) newCurrentPage = pageCountBridge.value;
				if (isAbsent(props.currentPage)) innerCurrentPage.value = newCurrentPage;
				if (hasCurrentPageListener) {
					emit("update:current-page", newCurrentPage);
					emit("current-change", newCurrentPage);
				}
			}
		});
		watch(pageCountBridge, (val) => {
			if (currentPageBridge.value > val) currentPageBridge.value = val;
		});
		function handleCurrentChange(val) {
			currentPageBridge.value = val;
		}
		function handleSizeChange(val) {
			pageSizeBridge.value = val;
			const newPageCount = pageCountBridge.value;
			if (currentPageBridge.value > newPageCount) currentPageBridge.value = newPageCount;
		}
		function prev() {
			if (props.disabled) return;
			currentPageBridge.value -= 1;
			emit("prev-click", currentPageBridge.value);
		}
		function next$1() {
			if (props.disabled) return;
			currentPageBridge.value += 1;
			emit("next-click", currentPageBridge.value);
		}
		function addClass$1(element, cls) {
			if (element) {
				if (!element.props) element.props = {};
				element.props.class = [element.props.class, cls].join(" ");
			}
		}
		provide(elPaginationKey, {
			pageCount: pageCountBridge,
			disabled: computed(() => props.disabled),
			currentPage: currentPageBridge,
			changeEvent: handleCurrentChange,
			handleSizeChange
		});
		return () => {
			var _a, _b;
			if (!assertValidUsage.value) {
				debugWarn(componentName, t$1("el.pagination.deprecationWarning"));
				return null;
			}
			if (!props.layout) return null;
			if (props.hideOnSinglePage && pageCountBridge.value <= 1) return null;
			const rootChildren = [];
			const rightWrapperChildren = [];
			const rightWrapperRoot = h("div", { class: ns.e("rightwrapper") }, rightWrapperChildren);
			const TEMPLATE_MAP = {
				prev: h(Prev, {
					disabled: props.disabled,
					currentPage: currentPageBridge.value,
					prevText: props.prevText,
					prevIcon: props.prevIcon,
					onClick: prev
				}),
				jumper: h(Jumper, { size: props.small ? "small" : "default" }),
				pager: h(Pager, {
					currentPage: currentPageBridge.value,
					pageCount: pageCountBridge.value,
					pagerCount: props.pagerCount,
					onChange: handleCurrentChange,
					disabled: props.disabled
				}),
				next: h(Next, {
					disabled: props.disabled,
					currentPage: currentPageBridge.value,
					pageCount: pageCountBridge.value,
					nextText: props.nextText,
					nextIcon: props.nextIcon,
					onClick: next$1
				}),
				sizes: h(Sizes, {
					pageSize: pageSizeBridge.value,
					pageSizes: props.pageSizes,
					popperClass: props.popperClass,
					disabled: props.disabled,
					teleported: props.teleported,
					size: props.small ? "small" : "default"
				}),
				slot: (_b = (_a = slots == null ? void 0 : slots.default) == null ? void 0 : _a.call(slots)) != null ? _b : null,
				total: h(Total, { total: isAbsent(props.total) ? 0 : props.total })
			};
			const components = props.layout.split(",").map((item$4) => item$4.trim());
			let haveRightWrapper = false;
			components.forEach((c$2) => {
				if (c$2 === "->") {
					haveRightWrapper = true;
					return;
				}
				if (!haveRightWrapper) rootChildren.push(TEMPLATE_MAP[c$2]);
				else rightWrapperChildren.push(TEMPLATE_MAP[c$2]);
			});
			addClass$1(rootChildren[0], ns.is("first"));
			addClass$1(rootChildren[rootChildren.length - 1], ns.is("last"));
			if (haveRightWrapper && rightWrapperChildren.length > 0) {
				addClass$1(rightWrapperChildren[0], ns.is("first"));
				addClass$1(rightWrapperChildren[rightWrapperChildren.length - 1], ns.is("last"));
				rootChildren.push(rightWrapperRoot);
			}
			return h("div", { class: [
				ns.b(),
				ns.is("background", props.background),
				{ [ns.m("small")]: props.small }
			] }, rootChildren);
		};
	}
}));
var popoverProps = buildProps({
	trigger: useTooltipTriggerProps.trigger,
	placement: dropdownProps.placement,
	disabled: useTooltipTriggerProps.disabled,
	visible: useTooltipContentProps.visible,
	transition: useTooltipContentProps.transition,
	popperOptions: dropdownProps.popperOptions,
	tabindex: dropdownProps.tabindex,
	content: useTooltipContentProps.content,
	popperStyle: useTooltipContentProps.popperStyle,
	popperClass: useTooltipContentProps.popperClass,
	enterable: {
		...useTooltipContentProps.enterable,
		default: true
	},
	effect: {
		...useTooltipContentProps.effect,
		default: "light"
	},
	teleported: useTooltipContentProps.teleported,
	title: String,
	width: {
		type: [String, Number],
		default: 150
	},
	offset: {
		type: Number,
		default: void 0
	},
	showAfter: {
		type: Number,
		default: 0
	},
	hideAfter: {
		type: Number,
		default: 200
	},
	autoClose: {
		type: Number,
		default: 0
	},
	showArrow: {
		type: Boolean,
		default: true
	},
	persistent: {
		type: Boolean,
		default: true
	},
	"onUpdate:visible": { type: Function }
});
var popoverEmits = {
	"update:visible": (value) => isBoolean(value),
	"before-enter": () => true,
	"before-leave": () => true,
	"after-enter": () => true,
	"after-leave": () => true
};
var updateEventKeyRaw = `onUpdate:visible`;
var Popover = /* @__PURE__ */ _export_sfc(/* @__PURE__ */ defineComponent({
	...defineComponent({ name: "ElPopover" }),
	props: popoverProps,
	emits: popoverEmits,
	setup(__props, { expose, emit }) {
		const props = __props;
		const onUpdateVisible = computed(() => {
			return props[updateEventKeyRaw];
		});
		const ns = useNamespace("popover");
		const tooltipRef = ref();
		const popperRef = computed(() => {
			var _a;
			return (_a = unref(tooltipRef)) == null ? void 0 : _a.popperRef;
		});
		const style = computed(() => {
			return [{ width: addUnit(props.width) }, props.popperStyle];
		});
		const kls = computed(() => {
			return [
				ns.b(),
				props.popperClass,
				{ [ns.m("plain")]: !!props.content }
			];
		});
		const gpuAcceleration = computed(() => {
			return props.transition === `${ns.namespace.value}-fade-in-linear`;
		});
		const hide$2 = () => {
			var _a;
			(_a = tooltipRef.value) == null || _a.hide();
		};
		const beforeEnter = () => {
			emit("before-enter");
		};
		const beforeLeave = () => {
			emit("before-leave");
		};
		const afterEnter = () => {
			emit("after-enter");
		};
		const afterLeave = () => {
			emit("update:visible", false);
			emit("after-leave");
		};
		expose({
			popperRef,
			hide: hide$2
		});
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(ElTooltip), mergeProps({
				ref_key: "tooltipRef",
				ref: tooltipRef
			}, _ctx.$attrs, {
				trigger: _ctx.trigger,
				placement: _ctx.placement,
				disabled: _ctx.disabled,
				visible: _ctx.visible,
				transition: _ctx.transition,
				"popper-options": _ctx.popperOptions,
				tabindex: _ctx.tabindex,
				content: _ctx.content,
				offset: _ctx.offset,
				"show-after": _ctx.showAfter,
				"hide-after": _ctx.hideAfter,
				"auto-close": _ctx.autoClose,
				"show-arrow": _ctx.showArrow,
				"aria-label": _ctx.title,
				effect: _ctx.effect,
				enterable: _ctx.enterable,
				"popper-class": unref(kls),
				"popper-style": unref(style),
				teleported: _ctx.teleported,
				persistent: _ctx.persistent,
				"gpu-acceleration": unref(gpuAcceleration),
				"onUpdate:visible": unref(onUpdateVisible),
				onBeforeShow: beforeEnter,
				onBeforeHide: beforeLeave,
				onShow: afterEnter,
				onHide: afterLeave
			}), {
				content: withCtx(() => [_ctx.title ? (openBlock(), createElementBlock("div", {
					key: 0,
					class: normalizeClass(unref(ns).e("title")),
					role: "title"
				}, toDisplayString(_ctx.title), 3)) : createCommentVNode("v-if", true), renderSlot(_ctx.$slots, "default", {}, () => [createTextVNode(toDisplayString(_ctx.content), 1)])]),
				default: withCtx(() => [_ctx.$slots.reference ? renderSlot(_ctx.$slots, "reference", { key: 0 }) : createCommentVNode("v-if", true)]),
				_: 3
			}, 16, [
				"trigger",
				"placement",
				"disabled",
				"visible",
				"transition",
				"popper-options",
				"tabindex",
				"content",
				"offset",
				"show-after",
				"hide-after",
				"auto-close",
				"show-arrow",
				"aria-label",
				"effect",
				"enterable",
				"popper-class",
				"popper-style",
				"teleported",
				"persistent",
				"gpu-acceleration",
				"onUpdate:visible"
			]);
		};
	}
}), [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popover/src/popover.vue"]]);
var attachEvents = (el$2, binding) => {
	const popperComponent = binding.arg || binding.value;
	const popover = popperComponent == null ? void 0 : popperComponent.popperRef;
	if (popover) popover.triggerRef = el$2;
};
var ElPopover = withInstall(Popover, { directive: withInstallDirective({
	mounted(el$2, binding) {
		attachEvents(el$2, binding);
	},
	updated(el$2, binding) {
		attachEvents(el$2, binding);
	}
}, "popover") });
var skeletonProps = buildProps({
	animated: {
		type: Boolean,
		default: false
	},
	count: {
		type: Number,
		default: 1
	},
	rows: {
		type: Number,
		default: 3
	},
	loading: {
		type: Boolean,
		default: true
	},
	throttle: { type: Number }
});
var skeletonItemProps = buildProps({ variant: {
	type: String,
	values: [
		"circle",
		"rect",
		"h1",
		"h3",
		"text",
		"caption",
		"p",
		"image",
		"button"
	],
	default: "text"
} });
var SkeletonItem = /* @__PURE__ */ _export_sfc(/* @__PURE__ */ defineComponent({
	...defineComponent({ name: "ElSkeletonItem" }),
	props: skeletonItemProps,
	setup(__props) {
		const ns = useNamespace("skeleton");
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", { class: normalizeClass([unref(ns).e("item"), unref(ns).e(_ctx.variant)]) }, [_ctx.variant === "image" ? (openBlock(), createBlock(unref(picture_filled_default), { key: 0 })) : createCommentVNode("v-if", true)], 2);
		};
	}
}), [["__file", "/home/runner/work/element-plus/element-plus/packages/components/skeleton/src/skeleton-item.vue"]]);
var ElSkeleton = withInstall(/* @__PURE__ */ _export_sfc(/* @__PURE__ */ defineComponent({
	...defineComponent({ name: "ElSkeleton" }),
	props: skeletonProps,
	setup(__props, { expose }) {
		const props = __props;
		const ns = useNamespace("skeleton");
		const uiLoading = useThrottleRender(toRef(props, "loading"), props.throttle);
		expose({ uiLoading });
		return (_ctx, _cache) => {
			return unref(uiLoading) ? (openBlock(), createElementBlock("div", mergeProps({
				key: 0,
				class: [unref(ns).b(), unref(ns).is("animated", _ctx.animated)]
			}, _ctx.$attrs), [(openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.count, (i$1) => {
				return openBlock(), createElementBlock(Fragment, { key: i$1 }, [_ctx.loading ? renderSlot(_ctx.$slots, "template", { key: i$1 }, () => [createVNode(SkeletonItem, {
					class: normalizeClass(unref(ns).is("first")),
					variant: "p"
				}, null, 8, ["class"]), (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.rows, (item$4) => {
					return openBlock(), createBlock(SkeletonItem, {
						key: item$4,
						class: normalizeClass([unref(ns).e("paragraph"), unref(ns).is("last", item$4 === _ctx.rows && _ctx.rows > 1)]),
						variant: "p"
					}, null, 8, ["class"]);
				}), 128))]) : createCommentVNode("v-if", true)], 64);
			}), 128))], 16)) : renderSlot(_ctx.$slots, "default", normalizeProps(mergeProps({ key: 1 }, _ctx.$attrs)));
		};
	}
}), [["__file", "/home/runner/work/element-plus/element-plus/packages/components/skeleton/src/skeleton.vue"]]), { SkeletonItem });
var ElSkeletonItem = withNoopInstall(SkeletonItem);
init_shared_esm_bundler();
var switchProps = buildProps({
	modelValue: {
		type: [
			Boolean,
			String,
			Number
		],
		default: false
	},
	disabled: {
		type: Boolean,
		default: false
	},
	loading: {
		type: Boolean,
		default: false
	},
	size: {
		type: String,
		validator: isValidComponentSize
	},
	width: {
		type: [String, Number],
		default: ""
	},
	inlinePrompt: {
		type: Boolean,
		default: false
	},
	inactiveActionIcon: { type: iconPropType },
	activeActionIcon: { type: iconPropType },
	activeIcon: { type: iconPropType },
	inactiveIcon: { type: iconPropType },
	activeText: {
		type: String,
		default: ""
	},
	inactiveText: {
		type: String,
		default: ""
	},
	activeValue: {
		type: [
			Boolean,
			String,
			Number
		],
		default: true
	},
	inactiveValue: {
		type: [
			Boolean,
			String,
			Number
		],
		default: false
	},
	activeColor: {
		type: String,
		default: ""
	},
	inactiveColor: {
		type: String,
		default: ""
	},
	borderColor: {
		type: String,
		default: ""
	},
	name: {
		type: String,
		default: ""
	},
	validateEvent: {
		type: Boolean,
		default: true
	},
	beforeChange: { type: definePropType(Function) },
	id: String,
	tabindex: { type: [String, Number] },
	value: {
		type: [
			Boolean,
			String,
			Number
		],
		default: false
	},
	label: {
		type: String,
		default: void 0
	}
});
var switchEmits = {
	[UPDATE_MODEL_EVENT]: (val) => isBoolean(val) || isString$2(val) || isNumber(val),
	[CHANGE_EVENT]: (val) => isBoolean(val) || isString$2(val) || isNumber(val),
	[INPUT_EVENT]: (val) => isBoolean(val) || isString$2(val) || isNumber(val)
};
init_shared_esm_bundler();
var _hoisted_1$45 = ["onClick"];
var _hoisted_2$27 = [
	"id",
	"aria-checked",
	"aria-disabled",
	"aria-label",
	"name",
	"true-value",
	"false-value",
	"disabled",
	"tabindex",
	"onKeydown"
];
var _hoisted_3$10 = ["aria-hidden"];
var _hoisted_4$7 = ["aria-hidden"];
var _hoisted_5$4 = ["aria-hidden"];
var COMPONENT_NAME = "ElSwitch";
var ElSwitch = withInstall(/* @__PURE__ */ _export_sfc(/* @__PURE__ */ defineComponent({
	...defineComponent({ name: COMPONENT_NAME }),
	props: switchProps,
	emits: switchEmits,
	setup(__props, { expose, emit }) {
		const props = __props;
		const vm = getCurrentInstance();
		const { formItem } = useFormItem();
		const switchSize = useFormSize();
		const ns = useNamespace("switch");
		const useBatchDeprecated = (list$1) => {
			list$1.forEach((param) => {
				useDeprecated({
					from: param[0],
					replacement: param[1],
					scope: COMPONENT_NAME,
					version: "2.3.0",
					ref: "https://element-plus.org/en-US/component/switch.html#attributes",
					type: "Attribute"
				}, computed(() => {
					var _a;
					return !!((_a = vm.vnode.props) == null ? void 0 : _a[param[2]]);
				}));
			});
		};
		useBatchDeprecated([
			[
				"\"value\"",
				"\"model-value\" or \"v-model\"",
				"value"
			],
			[
				"\"active-color\"",
				"CSS var `--el-switch-on-color`",
				"activeColor"
			],
			[
				"\"inactive-color\"",
				"CSS var `--el-switch-off-color`",
				"inactiveColor"
			],
			[
				"\"border-color\"",
				"CSS var `--el-switch-border-color`",
				"borderColor"
			]
		]);
		const { inputId } = useFormItemInputId(props, { formItemContext: formItem });
		const switchDisabled = useFormDisabled(computed(() => props.loading));
		const isControlled = ref(props.modelValue !== false);
		const input$4 = ref();
		const core = ref();
		const switchKls = computed(() => [
			ns.b(),
			ns.m(switchSize.value),
			ns.is("disabled", switchDisabled.value),
			ns.is("checked", checked.value)
		]);
		const labelLeftKls = computed(() => [
			ns.e("label"),
			ns.em("label", "left"),
			ns.is("active", !checked.value)
		]);
		const labelRightKls = computed(() => [
			ns.e("label"),
			ns.em("label", "right"),
			ns.is("active", checked.value)
		]);
		const coreStyle = computed(() => ({ width: addUnit(props.width) }));
		watch(() => props.modelValue, () => {
			isControlled.value = true;
		});
		watch(() => props.value, () => {
			isControlled.value = false;
		});
		const actualValue = computed(() => {
			return isControlled.value ? props.modelValue : props.value;
		});
		const checked = computed(() => actualValue.value === props.activeValue);
		if (![props.activeValue, props.inactiveValue].includes(actualValue.value)) {
			emit(UPDATE_MODEL_EVENT, props.inactiveValue);
			emit(CHANGE_EVENT, props.inactiveValue);
			emit(INPUT_EVENT, props.inactiveValue);
		}
		watch(checked, (val) => {
			var _a;
			input$4.value.checked = val;
			if (props.validateEvent) (_a = formItem == null ? void 0 : formItem.validate) == null || _a.call(formItem, "change").catch((err) => debugWarn(err));
		});
		const handleChange = () => {
			const val = checked.value ? props.inactiveValue : props.activeValue;
			emit(UPDATE_MODEL_EVENT, val);
			emit(CHANGE_EVENT, val);
			emit(INPUT_EVENT, val);
			nextTick(() => {
				input$4.value.checked = checked.value;
			});
		};
		const switchValue = () => {
			if (switchDisabled.value) return;
			const { beforeChange } = props;
			if (!beforeChange) {
				handleChange();
				return;
			}
			const shouldChange = beforeChange();
			if (![isPromise(shouldChange), isBoolean(shouldChange)].includes(true)) throwError(COMPONENT_NAME, "beforeChange must return type `Promise<boolean>` or `boolean`");
			if (isPromise(shouldChange)) shouldChange.then((result) => {
				if (result) handleChange();
			}).catch((e) => {
				debugWarn(COMPONENT_NAME, `some error occurred: ${e}`);
			});
			else if (shouldChange) handleChange();
		};
		const styles = computed(() => {
			return ns.cssVarBlock({
				...props.activeColor ? { "on-color": props.activeColor } : null,
				...props.inactiveColor ? { "off-color": props.inactiveColor } : null,
				...props.borderColor ? { "border-color": props.borderColor } : null
			});
		});
		const focus$1 = () => {
			var _a, _b;
			(_b = (_a = input$4.value) == null ? void 0 : _a.focus) == null || _b.call(_a);
		};
		onMounted(() => {
			input$4.value.checked = checked.value;
		});
		expose({
			focus: focus$1,
			checked
		});
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", {
				class: normalizeClass(unref(switchKls)),
				style: normalizeStyle(unref(styles)),
				onClick: withModifiers(switchValue, ["prevent"])
			}, [
				createBaseVNode("input", {
					id: unref(inputId),
					ref_key: "input",
					ref: input$4,
					class: normalizeClass(unref(ns).e("input")),
					type: "checkbox",
					role: "switch",
					"aria-checked": unref(checked),
					"aria-disabled": unref(switchDisabled),
					"aria-label": _ctx.label,
					name: _ctx.name,
					"true-value": _ctx.activeValue,
					"false-value": _ctx.inactiveValue,
					disabled: unref(switchDisabled),
					tabindex: _ctx.tabindex,
					onChange: handleChange,
					onKeydown: withKeys(switchValue, ["enter"])
				}, null, 42, _hoisted_2$27),
				!_ctx.inlinePrompt && (_ctx.inactiveIcon || _ctx.inactiveText) ? (openBlock(), createElementBlock("span", {
					key: 0,
					class: normalizeClass(unref(labelLeftKls))
				}, [_ctx.inactiveIcon ? (openBlock(), createBlock(unref(ElIcon), { key: 0 }, {
					default: withCtx(() => [(openBlock(), createBlock(resolveDynamicComponent(_ctx.inactiveIcon)))]),
					_: 1
				})) : createCommentVNode("v-if", true), !_ctx.inactiveIcon && _ctx.inactiveText ? (openBlock(), createElementBlock("span", {
					key: 1,
					"aria-hidden": unref(checked)
				}, toDisplayString(_ctx.inactiveText), 9, _hoisted_3$10)) : createCommentVNode("v-if", true)], 2)) : createCommentVNode("v-if", true),
				createBaseVNode("span", {
					ref_key: "core",
					ref: core,
					class: normalizeClass(unref(ns).e("core")),
					style: normalizeStyle(unref(coreStyle))
				}, [_ctx.inlinePrompt ? (openBlock(), createElementBlock("div", {
					key: 0,
					class: normalizeClass(unref(ns).e("inner"))
				}, [_ctx.activeIcon || _ctx.inactiveIcon ? (openBlock(), createBlock(unref(ElIcon), {
					key: 0,
					class: normalizeClass(unref(ns).is("icon"))
				}, {
					default: withCtx(() => [(openBlock(), createBlock(resolveDynamicComponent(unref(checked) ? _ctx.activeIcon : _ctx.inactiveIcon)))]),
					_: 1
				}, 8, ["class"])) : _ctx.activeText || _ctx.inactiveText ? (openBlock(), createElementBlock("span", {
					key: 1,
					class: normalizeClass(unref(ns).is("text")),
					"aria-hidden": !unref(checked)
				}, toDisplayString(unref(checked) ? _ctx.activeText : _ctx.inactiveText), 11, _hoisted_4$7)) : createCommentVNode("v-if", true)], 2)) : createCommentVNode("v-if", true), createBaseVNode("div", { class: normalizeClass(unref(ns).e("action")) }, [_ctx.loading ? (openBlock(), createBlock(unref(ElIcon), {
					key: 0,
					class: normalizeClass(unref(ns).is("loading"))
				}, {
					default: withCtx(() => [createVNode(unref(loading_default))]),
					_: 1
				}, 8, ["class"])) : _ctx.activeActionIcon && unref(checked) ? (openBlock(), createBlock(unref(ElIcon), { key: 1 }, {
					default: withCtx(() => [(openBlock(), createBlock(resolveDynamicComponent(_ctx.activeActionIcon)))]),
					_: 1
				})) : _ctx.inactiveActionIcon && !unref(checked) ? (openBlock(), createBlock(unref(ElIcon), { key: 2 }, {
					default: withCtx(() => [(openBlock(), createBlock(resolveDynamicComponent(_ctx.inactiveActionIcon)))]),
					_: 1
				})) : createCommentVNode("v-if", true)], 2)], 6),
				!_ctx.inlinePrompt && (_ctx.activeIcon || _ctx.activeText) ? (openBlock(), createElementBlock("span", {
					key: 1,
					class: normalizeClass(unref(labelRightKls))
				}, [_ctx.activeIcon ? (openBlock(), createBlock(unref(ElIcon), { key: 0 }, {
					default: withCtx(() => [(openBlock(), createBlock(resolveDynamicComponent(_ctx.activeIcon)))]),
					_: 1
				})) : createCommentVNode("v-if", true), !_ctx.activeIcon && _ctx.activeText ? (openBlock(), createElementBlock("span", {
					key: 1,
					"aria-hidden": !unref(checked)
				}, toDisplayString(_ctx.activeText), 9, _hoisted_5$4)) : createCommentVNode("v-if", true)], 2)) : createCommentVNode("v-if", true)
			], 14, _hoisted_1$45);
		};
	}
}), [["__file", "/home/runner/work/element-plus/element-plus/packages/components/switch/src/switch.vue"]]));
var TOOLTIP_APPEND_TO = "TOOLTIP_APPEND_TO";
function useProvideTooltipAppendTo(el$2) {
	provide(TOOLTIP_APPEND_TO, el$2);
}
function useInjectTooltipAppendTo() {
	return inject(TOOLTIP_APPEND_TO, computed(() => void 0));
}
var Tooltip_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	inheritAttrs: false,
	__name: "Tooltip",
	props: {
		...ElTooltip.props,
		content: {
			type: String,
			default: ""
		},
		justifyButtons: {
			type: String,
			default: "flex-end"
		},
		buttons: {
			type: Array,
			default: () => []
		}
	},
	setup(__props) {
		const props = __props;
		const appendTo = useInjectTooltipAppendTo();
		return (_ctx, _cache) => {
			const _directive_n8n_html = resolveDirective("n8n-html");
			return openBlock(), createBlock(unref(ElTooltip), mergeProps({
				...props,
				..._ctx.$attrs
			}, {
				"append-to": props.appendTo ?? unref(appendTo),
				"popper-class": props.popperClass ?? "n8n-tooltip"
			}), {
				content: withCtx(() => [renderSlot(_ctx.$slots, "content", {}, () => [withDirectives(createBaseVNode("div", null, null, 512), [[_directive_n8n_html, props.content]])]), props.buttons.length ? (openBlock(), createElementBlock("div", {
					key: 0,
					class: normalizeClass(_ctx.$style.buttons),
					style: normalizeStyle({ justifyContent: props.justifyButtons })
				}, [(openBlock(true), createElementBlock(Fragment, null, renderList(props.buttons, (button$7) => {
					return openBlock(), createBlock(unref(N8nButton_default), mergeProps({
						key: button$7.attrs.label,
						ref_for: true
					}, {
						...button$7.attrs,
						...button$7.listeners
					}), null, 16);
				}), 128))], 6)) : createCommentVNode("", true)]),
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 16, ["append-to", "popper-class"]);
		};
	}
});
var Tooltip_vue_vue_type_style_index_0_lang_module_default = { buttons: "_buttons_136k4_123" };
var Tooltip_default = /* @__PURE__ */ __plugin_vue_export_helper_default(Tooltip_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": Tooltip_vue_vue_type_style_index_0_lang_module_default }]]);
var _hoisted_1$44 = { key: 1 };
var _hoisted_2$26 = { size: "small" };
var ActionBox_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	name: "N8nActionBox",
	__name: "ActionBox",
	props: {
		icon: {},
		heading: {},
		buttonText: {},
		buttonType: {},
		buttonDisabled: { type: Boolean },
		buttonIcon: { default: void 0 },
		description: {},
		calloutText: {},
		calloutTheme: { default: "info" },
		calloutIcon: {}
	},
	setup(__props) {
		return (_ctx, _cache) => {
			const _directive_n8n_html = resolveDirective("n8n-html");
			return openBlock(), createElementBlock("div", {
				class: normalizeClass(["n8n-action-box", _ctx.$style.container]),
				"data-test-id": "action-box"
			}, [
				_ctx.icon ? (openBlock(), createElementBlock("div", {
					key: 0,
					class: normalizeClass(_ctx.$style.icon)
				}, [_ctx.icon.type === "icon" ? (openBlock(), createBlock(unref(N8nIcon_default), {
					key: 0,
					icon: _ctx.icon.value,
					size: 40,
					"stroke-width": 1.5,
					color: "foreground-xdark"
				}, null, 8, ["icon"])) : (openBlock(), createElementBlock("span", _hoisted_1$44, toDisplayString(_ctx.icon.value), 1))], 2)) : createCommentVNode("", true),
				_ctx.heading || _ctx.$slots.heading ? (openBlock(), createElementBlock("div", {
					key: 1,
					class: normalizeClass(_ctx.$style.heading)
				}, [createVNode(unref(N8nHeading_default), {
					size: "xlarge",
					align: "center"
				}, {
					default: withCtx(() => [renderSlot(_ctx.$slots, "heading", {}, () => [createTextVNode(toDisplayString(_ctx.heading), 1)])]),
					_: 3
				})], 2)) : createCommentVNode("", true),
				_ctx.description ? (openBlock(), createElementBlock("div", {
					key: 2,
					class: normalizeClass(_ctx.$style.description),
					onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("descriptionClick", $event))
				}, [createVNode(unref(N8nText_default), { color: "text-base" }, {
					default: withCtx(() => [renderSlot(_ctx.$slots, "description", {}, () => [withDirectives(createBaseVNode("span", null, null, 512), [[_directive_n8n_html, _ctx.description]])])]),
					_: 3
				})], 2)) : createCommentVNode("", true),
				createVNode(Tooltip_default, { disabled: !_ctx.buttonDisabled }, {
					content: withCtx(() => [renderSlot(_ctx.$slots, "disabledButtonTooltip")]),
					default: withCtx(() => [_ctx.buttonText ? (openBlock(), createBlock(unref(N8nButton_default), {
						key: 0,
						label: _ctx.buttonText,
						type: _ctx.buttonType,
						disabled: _ctx.buttonDisabled,
						icon: _ctx.buttonIcon,
						size: "large",
						role: "button",
						onClick: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("click:button", $event))
					}, null, 8, [
						"label",
						"type",
						"disabled",
						"icon"
					])) : createCommentVNode("", true)]),
					_: 3
				}, 8, ["disabled"]),
				_ctx.$slots.additionalContent ? (openBlock(), createElementBlock("div", {
					key: 3,
					class: normalizeClass(_ctx.$style["additional-content"])
				}, [renderSlot(_ctx.$slots, "additionalContent")], 2)) : createCommentVNode("", true),
				_ctx.calloutText ? (openBlock(), createBlock(unref(N8nCallout_default), {
					key: 4,
					theme: _ctx.calloutTheme,
					icon: _ctx.calloutIcon,
					class: normalizeClass(_ctx.$style.callout)
				}, {
					default: withCtx(() => [createVNode(unref(N8nText_default), { color: "text-base" }, {
						default: withCtx(() => [withDirectives(createBaseVNode("span", _hoisted_2$26, null, 512), [[_directive_n8n_html, _ctx.calloutText]])]),
						_: 1
					})]),
					_: 1
				}, 8, [
					"theme",
					"icon",
					"class"
				])) : createCommentVNode("", true)
			], 2);
		};
	}
});
var ActionBox_vue_vue_type_style_index_0_lang_module_default = {
	container: "_container_17sde_123",
	icon: "_icon_17sde_138",
	heading: "_heading_17sde_142",
	description: "_description_17sde_147",
	callout: "_callout_17sde_153",
	"additional-content": "_additional-content_17sde_158"
};
var N8nActionBox_default = /* @__PURE__ */ __plugin_vue_export_helper_default(ActionBox_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": ActionBox_vue_vue_type_style_index_0_lang_module_default }]]);
function useI18n() {
	return { t: (path, options$1) => t(path, options$1) };
}
var _hoisted_1$43 = ["width", "height"];
var _hoisted_2$25 = ["fill"];
var AssistantIcon_default = /* @__PURE__ */ defineComponent({
	__name: "AssistantIcon",
	props: {
		size: { default: "medium" },
		theme: { default: "default" }
	},
	setup(__props) {
		const props = __props;
		const sizes = {
			mini: 8,
			small: 10,
			medium: 12,
			large: 18
		};
		const svgFill = computed(() => {
			if (props.theme === "blank") return "white";
			else if (props.theme === "disabled") return "var(--color--text--tint-1)";
			return "url(#paint0_linear_173_12825)";
		});
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("svg", {
				width: sizes[_ctx.size],
				height: sizes[_ctx.size],
				viewBox: "0 0 24 24",
				fill: "none",
				xmlns: "http://www.w3.org/2000/svg"
			}, [createBaseVNode("path", {
				d: "M19.9658 14.0171C19.9679 14.3549 19.8654 14.6851 19.6722 14.9622C19.479 15.2393 19.2046 15.4497 18.8869 15.5645L13.5109 17.5451L11.5303 22.9211C11.4137 23.2376 11.2028 23.5107 10.9261 23.7037C10.6494 23.8966 10.3202 24 9.9829 24C9.64559 24 9.3164 23.8966 9.0397 23.7037C8.76301 23.5107 8.55212 23.2376 8.43549 22.9211L6.45487 17.5451L1.07888 15.5645C0.762384 15.4479 0.489262 15.237 0.296347 14.9603C0.103431 14.6836 0 14.3544 0 14.0171C0 13.6798 0.103431 13.3506 0.296347 13.0739C0.489262 12.7972 0.762384 12.5863 1.07888 12.4697L6.45487 10.4891L8.43549 5.11309C8.55212 4.79659 8.76301 4.52347 9.0397 4.33055C9.3164 4.13764 9.64559 4.0342 9.9829 4.0342C10.3202 4.0342 10.6494 4.13764 10.9261 4.33055C11.2028 4.52347 11.4137 4.79659 11.5303 5.11309L13.5109 10.4891L18.8869 12.4697C19.2046 12.5845 19.479 12.7949 19.6722 13.072C19.8654 13.3491 19.9679 13.6793 19.9658 14.0171ZM14.1056 4.12268H15.7546V5.77175C15.7546 5.99043 15.8415 6.20015 15.9961 6.35478C16.1508 6.50941 16.3605 6.59628 16.5792 6.59628C16.7979 6.59628 17.0076 6.50941 17.1622 6.35478C17.3168 6.20015 17.4037 5.99043 17.4037 5.77175V4.12268H19.0528C19.2715 4.12268 19.4812 4.03581 19.6358 3.88118C19.7905 3.72655 19.8773 3.51682 19.8773 3.29814C19.8773 3.07946 19.7905 2.86974 19.6358 2.71511C19.4812 2.56048 19.2715 2.47361 19.0528 2.47361H17.4037V0.824535C17.4037 0.605855 17.3168 0.396131 17.1622 0.241501C17.0076 0.0868704 16.7979 0 16.5792 0C16.3605 0 16.1508 0.0868704 15.9961 0.241501C15.8415 0.396131 15.7546 0.605855 15.7546 0.824535V2.47361H14.1056C13.8869 2.47361 13.6772 2.56048 13.5225 2.71511C13.3679 2.86974 13.281 3.07946 13.281 3.29814C13.281 3.51682 13.3679 3.72655 13.5225 3.88118C13.6772 4.03581 13.8869 4.12268 14.1056 4.12268ZM23.1755 7.42082H22.3509V6.59628C22.3509 6.3776 22.2641 6.16788 22.1094 6.01325C21.9548 5.85862 21.7451 5.77175 21.5264 5.77175C21.3077 5.77175 21.098 5.85862 20.9434 6.01325C20.7887 6.16788 20.7019 6.3776 20.7019 6.59628V7.42082H19.8773C19.6586 7.42082 19.4489 7.50769 19.2943 7.66232C19.1397 7.81695 19.0528 8.02667 19.0528 8.24535C19.0528 8.46404 19.1397 8.67376 19.2943 8.82839C19.4489 8.98302 19.6586 9.06989 19.8773 9.06989H20.7019V9.89443C20.7019 10.1131 20.7887 10.3228 20.9434 10.4775C21.098 10.6321 21.3077 10.719 21.5264 10.719C21.7451 10.719 21.9548 10.6321 22.1094 10.4775C22.2641 10.3228 22.3509 10.1131 22.3509 9.89443V9.06989H23.1755C23.3941 9.06989 23.6039 8.98302 23.7585 8.82839C23.9131 8.67376 24 8.46404 24 8.24535C24 8.02667 23.9131 7.81695 23.7585 7.66232C23.6039 7.50769 23.3941 7.42082 23.1755 7.42082Z",
				fill: svgFill.value
			}, null, 8, _hoisted_2$25), _cache[0] || (_cache[0] = createBaseVNode("defs", null, [createBaseVNode("linearGradient", {
				id: "paint0_linear_173_12825",
				x1: "-3.67094e-07",
				y1: "-0.000120994",
				x2: "28.8315",
				y2: "9.82667",
				gradientUnits: "userSpaceOnUse"
			}, [
				createBaseVNode("stop", { "stop-color": "var(--assistant--color--highlight-1)" }),
				createBaseVNode("stop", {
					offset: "0.495",
					"stop-color": "var(--assistant--color--highlight-2)"
				}),
				createBaseVNode("stop", {
					offset: "1",
					"stop-color": "var(--assistant--color--highlight-3)"
				})
			])], -1))], 8, _hoisted_1$43);
		};
	}
});
var AssistantText_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "AssistantText",
	props: {
		text: { default: "" },
		size: { default: "medium" }
	},
	setup(__props) {
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("span", { class: normalizeClass([_ctx.$style.text, _ctx.$style[_ctx.size]]) }, toDisplayString(_ctx.text), 3);
		};
	}
});
var AssistantText_vue_vue_type_style_index_0_lang_module_default = {
	text: "_text_1tvkz_123",
	small: "_small_1tvkz_131",
	medium: "_medium_1tvkz_136",
	large: "_large_1tvkz_141",
	xlarge: "_xlarge_1tvkz_146"
};
var AssistantText_default = /* @__PURE__ */ __plugin_vue_export_helper_default(AssistantText_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": AssistantText_vue_vue_type_style_index_0_lang_module_default }]]);
var AskAssistantButton_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "AskAssistantButton",
	props: {
		unreadCount: {},
		type: {}
	},
	emits: ["click"],
	setup(__props, { emit: __emit }) {
		const { t: t$1 } = useI18n();
		const hovering = ref(false);
		const props = __props;
		const emit = __emit;
		const onClick = (e) => emit("click", e);
		function onMouseEnter() {
			hovering.value = true;
		}
		function onMouseLeave() {
			hovering.value = false;
		}
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("button", {
				class: normalizeClass(_ctx.$style.button),
				onMouseenter: onMouseEnter,
				onMouseleave: onMouseLeave,
				onClick
			}, [props.unreadCount ? (openBlock(), createElementBlock("div", {
				key: 0,
				class: normalizeClass(_ctx.$style.num)
			}, toDisplayString(props.unreadCount), 3)) : (openBlock(), createBlock(AssistantIcon_default, {
				key: 1,
				size: "large",
				theme: hovering.value ? "blank" : "default"
			}, null, 8, ["theme"])), withDirectives(createBaseVNode("div", { class: normalizeClass(_ctx.$style.text) }, [createBaseVNode("div", null, [createVNode(AssistantText_default, { text: _ctx.type === "builder" ? unref(t$1)("assistantChat.builder.name") : unref(t$1)("askAssistantButton.askAssistant") }, null, 8, ["text"])])], 2), [[vShow, hovering.value]])], 34);
		};
	}
});
var AskAssistantButton_vue_vue_type_style_index_0_lang_module_default = {
	button: "_button_149dz_123",
	num: "_num_149dz_143",
	text: "_text_149dz_155"
};
var AskAssistantButton_default = /* @__PURE__ */ __plugin_vue_export_helper_default(AskAssistantButton_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": AskAssistantButton_vue_vue_type_style_index_0_lang_module_default }]]);
var N8nIconButton_default = /* @__PURE__ */ defineComponent({
	name: "N8nIconButton",
	__name: "IconButton",
	props: {
		active: {
			type: Boolean,
			default: false
		},
		disabled: {
			type: Boolean,
			default: false
		},
		float: {},
		icon: {},
		loading: {
			type: Boolean,
			default: false
		},
		outline: {
			type: Boolean,
			default: false
		},
		size: { default: "medium" },
		iconSize: {},
		text: {
			type: Boolean,
			default: false
		},
		type: { default: "primary" },
		nativeType: {}
	},
	setup(__props) {
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(N8nButton_default), mergeProps({ square: "" }, {
				..._ctx.$attrs,
				..._ctx.$props
			}), null, 16);
		};
	}
});
const createFormEventBus = createEventBus;
var import_lib$1 = /* @__PURE__ */ __toESM(require_lib$1());
var checkedRegEx = /(\*|-) \[x\]/;
var uncheckedRegEx = /(\*|-) \[\s\]/;
const toggleCheckbox = (markdown$1, index) => {
	let cursor = 0;
	const lines = markdown$1.split("\n");
	for (let lineNumber$1 = 0; lineNumber$1 < lines.length; lineNumber$1++) {
		const line = lines[lineNumber$1];
		const checked = checkedRegEx.test(line);
		const unchecked = uncheckedRegEx.test(line);
		if (checked || unchecked) {
			if (cursor === index) {
				const regExp = checked ? checkedRegEx : uncheckedRegEx;
				const replacement = checked ? "[ ]" : "[x]";
				lines[lineNumber$1] = line.replace(regExp, `$1 ${replacement}`);
				break;
			}
			cursor++;
		}
	}
	return lines.join("\n");
};
function serializeAttr(tag$2, name$1, value) {
	const safe = (0, import_lib$1.safeAttrValue)(tag$2, name$1, value, { process: (v$1) => v$1 });
	return safe ? `${name$1}="${safe}"` : "";
}
function isEventBindingElementAttribute(_attributeValue, attributeName) {
	return /^on[A-Z]/.test(attributeName);
}
function uid(baseId) {
	return `${baseId ? `${baseId}-` : ""}${Math.random().toString(36).substring(2, 11)}`;
}
function getValueByPath(object, path) {
	return path.split(".").reduce((acc, part$1) => {
		return acc?.[part$1];
	}, object);
}
var Input_vue_vue_type_script_setup_true_lang_default$1 = /* @__PURE__ */ defineComponent({
	name: "N8nInput",
	__name: "Input",
	props: {
		modelValue: { default: "" },
		type: { default: "text" },
		size: { default: "large" },
		placeholder: { default: "" },
		disabled: {
			type: Boolean,
			default: false
		},
		readonly: {
			type: Boolean,
			default: false
		},
		clearable: {
			type: Boolean,
			default: false
		},
		rows: { default: 2 },
		maxlength: { default: void 0 },
		title: { default: "" },
		name: { default: () => uid("input") },
		autocomplete: { default: "off" }
	},
	setup(__props, { expose: __expose }) {
		const props = __props;
		const resolvedSize = computed(() => props.size === "medium" ? "default" : props.size);
		const classes = computed(() => {
			const applied = [];
			if (props.size === "xlarge") applied.push("xlarge");
			if (props.type === "password") applied.push("ph-no-capture");
			return applied;
		});
		const innerInput = ref();
		const inputElement = computed(() => {
			if (!innerInput?.value) return;
			const inputType = props.type === "textarea" ? "textarea" : "input";
			return innerInput.value.$el.querySelector(inputType);
		});
		const focus$1 = () => inputElement.value?.focus();
		const blur = () => inputElement.value?.blur();
		const select = () => inputElement.value?.select();
		__expose({
			focus: focus$1,
			blur,
			select
		});
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(ElInput), mergeProps({
				ref_key: "innerInput",
				ref: innerInput,
				"model-value": _ctx.modelValue,
				type: _ctx.type,
				size: resolvedSize.value,
				class: ["n8n-input", ...classes.value],
				autocomplete: _ctx.autocomplete,
				name: _ctx.name,
				placeholder: _ctx.placeholder,
				disabled: _ctx.disabled,
				readonly: _ctx.readonly,
				clearable: _ctx.clearable,
				rows: _ctx.rows,
				title: _ctx.title,
				maxlength: _ctx.maxlength
			}, _ctx.$attrs), createSlots({ _: 2 }, [
				_ctx.$slots.prepend ? {
					name: "prepend",
					fn: withCtx(() => [renderSlot(_ctx.$slots, "prepend")]),
					key: "0"
				} : void 0,
				_ctx.$slots.append ? {
					name: "append",
					fn: withCtx(() => [renderSlot(_ctx.$slots, "append")]),
					key: "1"
				} : void 0,
				_ctx.$slots.prefix ? {
					name: "prefix",
					fn: withCtx(() => [renderSlot(_ctx.$slots, "prefix")]),
					key: "2"
				} : void 0,
				_ctx.$slots.suffix ? {
					name: "suffix",
					fn: withCtx(() => [renderSlot(_ctx.$slots, "suffix")]),
					key: "3"
				} : void 0
			]), 1040, [
				"model-value",
				"type",
				"size",
				"class",
				"autocomplete",
				"name",
				"placeholder",
				"disabled",
				"readonly",
				"clearable",
				"rows",
				"title",
				"maxlength"
			]);
		};
	}
});
var Input_vue_vue_type_style_index_0_lang_module_default$1 = { xlarge: "_xlarge_3f5j8_123" };
var N8nInput_default = /* @__PURE__ */ __plugin_vue_export_helper_default(Input_vue_vue_type_script_setup_true_lang_default$1, [["__cssModules", { "$style": Input_vue_vue_type_style_index_0_lang_module_default$1 }]]);
var MessageRating_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "MessageRating",
	props: {
		style: { default: "regular" },
		showFeedback: {
			type: Boolean,
			default: true
		}
	},
	emits: ["feedback"],
	setup(__props, { emit: __emit }) {
		const props = __props;
		const emit = __emit;
		const { t: t$1 } = useI18n();
		const showRatingButtons = ref(true);
		const showFeedbackArea = ref(false);
		const feedbackInput$1 = ref(null);
		const showSuccess = ref(false);
		const selectedRating = ref(null);
		const feedback = ref("");
		function onRateButton(rating$1) {
			selectedRating.value = rating$1;
			showRatingButtons.value = false;
			emit("feedback", { rating: rating$1 });
			if (props.showFeedback && rating$1 === "down") {
				showFeedbackArea.value = true;
				setTimeout(() => {
					if (feedbackInput$1.value) feedbackInput$1.value.focus();
				}, 0);
			} else showSuccess.value = true;
		}
		function onSubmitFeedback() {
			if (selectedRating.value) {
				emit("feedback", { feedback: feedback.value });
				showFeedbackArea.value = false;
				showSuccess.value = true;
			}
		}
		function onCancelFeedback() {
			showFeedbackArea.value = false;
			showRatingButtons.value = true;
			selectedRating.value = null;
			feedback.value = "";
		}
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", { class: normalizeClass([_ctx.$style.rating, _ctx.$style[_ctx.style]]) }, [
				showRatingButtons.value ? (openBlock(), createElementBlock("div", {
					key: 0,
					class: normalizeClass(_ctx.$style.buttons)
				}, [_ctx.style === "regular" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [createVNode(unref(N8nButton_default), {
					type: "secondary",
					size: "small",
					label: unref(t$1)("assistantChat.builder.thumbsUp"),
					"data-test-id": "message-thumbs-up-button",
					icon: "thumbs-up",
					onClick: _cache[0] || (_cache[0] = ($event) => onRateButton("up"))
				}, null, 8, ["label"]), createVNode(unref(N8nButton_default), {
					type: "secondary",
					size: "small",
					"data-test-id": "message-thumbs-down-button",
					label: unref(t$1)("assistantChat.builder.thumbsDown"),
					icon: "thumbs-down",
					onClick: _cache[1] || (_cache[1] = ($event) => onRateButton("down"))
				}, null, 8, ["label"])], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [createVNode(unref(N8nIconButton_default), {
					type: "tertiary",
					size: "small",
					text: "",
					icon: "thumbs-up",
					"icon-size": "large",
					class: normalizeClass(_ctx.$style.ratingButton),
					"data-test-id": "message-thumbs-up-button",
					onClick: _cache[2] || (_cache[2] = ($event) => onRateButton("up"))
				}, null, 8, ["class"]), createVNode(unref(N8nIconButton_default), {
					type: "tertiary",
					size: "small",
					text: "",
					icon: "thumbs-down",
					"icon-size": "large",
					class: normalizeClass(_ctx.$style.ratingButton),
					"data-test-id": "message-thumbs-down-button",
					onClick: _cache[3] || (_cache[3] = ($event) => onRateButton("down"))
				}, null, 8, ["class"])], 64))], 2)) : createCommentVNode("", true),
				showFeedbackArea.value ? (openBlock(), createElementBlock("div", {
					key: 1,
					class: normalizeClass(_ctx.$style.feedbackContainer)
				}, [createVNode(unref(N8nInput_default), {
					ref_key: "feedbackInput",
					ref: feedbackInput$1,
					modelValue: feedback.value,
					"onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => feedback.value = $event),
					class: normalizeClass(_ctx.$style.feedbackInput),
					type: "textarea",
					placeholder: unref(t$1)("assistantChat.builder.feedbackPlaceholder"),
					"data-test-id": "message-feedback-input",
					"read-only": false,
					resize: "none"
				}, null, 8, [
					"modelValue",
					"class",
					"placeholder"
				]), createBaseVNode("div", { class: normalizeClass(_ctx.$style.feedbackActions) }, [createVNode(unref(N8nButton_default), {
					type: "secondary",
					size: "small",
					label: unref(t$1)("generic.cancel"),
					onClick: onCancelFeedback
				}, null, 8, ["label"]), createVNode(unref(N8nButton_default), {
					type: "primary",
					size: "small",
					"data-test-id": "message-submit-feedback-button",
					label: unref(t$1)("assistantChat.builder.feedbackSubmit"),
					onClick: onSubmitFeedback
				}, null, 8, ["label"])], 2)], 2)) : createCommentVNode("", true),
				showSuccess.value ? (openBlock(), createElementBlock("p", {
					key: 2,
					class: normalizeClass(_ctx.$style.success)
				}, toDisplayString(unref(t$1)("assistantChat.builder.success")), 3)) : createCommentVNode("", true)
			], 2);
		};
	}
});
var MessageRating_vue_vue_type_style_index_0_lang_module_default = {
	rating: "_rating_12d3z_123",
	buttons: "_buttons_12d3z_130",
	feedbackContainer: "_feedbackContainer_12d3z_135",
	feedbackInput: "_feedbackInput_12d3z_141",
	feedbackActions: "_feedbackActions_12d3z_150",
	success: "_success_12d3z_156",
	minimal: "_minimal_12d3z_163",
	ratingButton: "_ratingButton_12d3z_169"
};
var MessageRating_default = /* @__PURE__ */ __plugin_vue_export_helper_default(MessageRating_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": MessageRating_vue_vue_type_style_index_0_lang_module_default }]]);
var BaseMessage_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "BaseMessage",
	props: {
		message: {},
		isFirstOfRole: { type: Boolean },
		user: {}
	},
	emits: ["feedback"],
	setup(__props, { emit: __emit }) {
		const props = __props;
		const emit = __emit;
		const isUserMessage = computed(() => props.message.role === "user");
		function onRate(rating$1) {
			emit("feedback", rating$1);
		}
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", { class: normalizeClass(_ctx.$style.message) }, [renderSlot(_ctx.$slots, "default"), _ctx.message.showRating && !isUserMessage.value ? (openBlock(), createBlock(MessageRating_default, {
				key: 0,
				style: normalizeStyle(_ctx.message.ratingStyle),
				"show-feedback": _ctx.message.showFeedback,
				onFeedback: onRate
			}, null, 8, ["style", "show-feedback"])) : createCommentVNode("", true)], 2);
		};
	}
});
var BaseMessage_vue_vue_type_style_index_0_lang_module_default = { message: "_message_qxggn_123" };
var BaseMessage_default = /* @__PURE__ */ __plugin_vue_export_helper_default(BaseMessage_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": BaseMessage_vue_vue_type_style_index_0_lang_module_default }]]);
var entities_exports = /* @__PURE__ */ __export({
	AElig: () => "",
	AMP: () => "&",
	Aacute: () => "",
	Abreve: () => "",
	Acirc: () => "",
	Acy: () => "",
	Afr: () => Afr,
	Agrave: () => "",
	Alpha: () => "",
	Amacr: () => "",
	And: () => "",
	Aogon: () => "",
	Aopf: () => Aopf,
	ApplyFunction: () => "",
	Aring: () => "",
	Ascr: () => Ascr,
	Assign: () => "",
	Atilde: () => "",
	Auml: () => "",
	Backslash: () => "",
	Barv: () => "",
	Barwed: () => "",
	Bcy: () => "",
	Because: () => "",
	Bernoullis: () => "",
	Beta: () => "",
	Bfr: () => Bfr,
	Bopf: () => Bopf,
	Breve: () => "",
	Bscr: () => "",
	Bumpeq: () => "",
	CHcy: () => "",
	COPY: () => "",
	Cacute: () => "",
	Cap: () => "",
	CapitalDifferentialD: () => "",
	Cayleys: () => "",
	Ccaron: () => "",
	Ccedil: () => "",
	Ccirc: () => "",
	Cconint: () => "",
	Cdot: () => "",
	Cedilla: () => "",
	CenterDot: () => "",
	Cfr: () => "",
	Chi: () => "",
	CircleDot: () => "",
	CircleMinus: () => "",
	CirclePlus: () => "",
	CircleTimes: () => "",
	ClockwiseContourIntegral: () => "",
	CloseCurlyDoubleQuote: () => "",
	CloseCurlyQuote: () => "",
	Colon: () => "",
	Colone: () => "",
	Congruent: () => "",
	Conint: () => "",
	ContourIntegral: () => "",
	Copf: () => "",
	Coproduct: () => "",
	CounterClockwiseContourIntegral: () => "",
	Cross: () => "",
	Cscr: () => Cscr,
	Cup: () => "",
	CupCap: () => "",
	DD: () => "",
	DDotrahd: () => "",
	DJcy: () => "",
	DScy: () => "",
	DZcy: () => "",
	Dagger: () => "",
	Darr: () => "",
	Dashv: () => "",
	Dcaron: () => "",
	Dcy: () => "",
	Del: () => "",
	Delta: () => "",
	Dfr: () => Dfr,
	DiacriticalAcute: () => "",
	DiacriticalDot: () => "",
	DiacriticalDoubleAcute: () => "",
	DiacriticalGrave: () => "`",
	DiacriticalTilde: () => "",
	Diamond: () => "",
	DifferentialD: () => "",
	Dopf: () => Dopf,
	Dot: () => "",
	DotDot: () => "",
	DotEqual: () => "",
	DoubleContourIntegral: () => "",
	DoubleDot: () => "",
	DoubleDownArrow: () => "",
	DoubleLeftArrow: () => "",
	DoubleLeftRightArrow: () => "",
	DoubleLeftTee: () => "",
	DoubleLongLeftArrow: () => "",
	DoubleLongLeftRightArrow: () => "",
	DoubleLongRightArrow: () => "",
	DoubleRightArrow: () => "",
	DoubleRightTee: () => "",
	DoubleUpArrow: () => "",
	DoubleUpDownArrow: () => "",
	DoubleVerticalBar: () => "",
	DownArrow: () => "",
	DownArrowBar: () => "",
	DownArrowUpArrow: () => "",
	DownBreve: () => "",
	DownLeftRightVector: () => "",
	DownLeftTeeVector: () => "",
	DownLeftVector: () => "",
	DownLeftVectorBar: () => "",
	DownRightTeeVector: () => "",
	DownRightVector: () => "",
	DownRightVectorBar: () => "",
	DownTee: () => "",
	DownTeeArrow: () => "",
	Downarrow: () => "",
	Dscr: () => Dscr,
	Dstrok: () => "",
	ENG: () => "",
	ETH: () => "",
	Eacute: () => "",
	Ecaron: () => "",
	Ecirc: () => "",
	Ecy: () => "",
	Edot: () => "",
	Efr: () => Efr,
	Egrave: () => "",
	Element: () => "",
	Emacr: () => "",
	EmptySmallSquare: () => "",
	EmptyVerySmallSquare: () => "",
	Eogon: () => "",
	Eopf: () => Eopf,
	Epsilon: () => "",
	Equal: () => "",
	EqualTilde: () => "",
	Equilibrium: () => "",
	Escr: () => "",
	Esim: () => "",
	Eta: () => "",
	Euml: () => "",
	Exists: () => "",
	ExponentialE: () => "",
	Fcy: () => "",
	Ffr: () => Ffr,
	FilledSmallSquare: () => "",
	FilledVerySmallSquare: () => "",
	Fopf: () => Fopf,
	ForAll: () => "",
	Fouriertrf: () => "",
	Fscr: () => "",
	GJcy: () => "",
	GT: () => ">",
	Gamma: () => "",
	Gammad: () => "",
	Gbreve: () => "",
	Gcedil: () => "",
	Gcirc: () => "",
	Gcy: () => "",
	Gdot: () => "",
	Gfr: () => Gfr,
	Gg: () => "",
	Gopf: () => Gopf,
	GreaterEqual: () => "",
	GreaterEqualLess: () => "",
	GreaterFullEqual: () => "",
	GreaterGreater: () => "",
	GreaterLess: () => "",
	GreaterSlantEqual: () => "",
	GreaterTilde: () => "",
	Gscr: () => Gscr,
	Gt: () => "",
	HARDcy: () => "",
	Hacek: () => "",
	Hat: () => "^",
	Hcirc: () => "",
	Hfr: () => "",
	HilbertSpace: () => "",
	Hopf: () => "",
	HorizontalLine: () => "",
	Hscr: () => "",
	Hstrok: () => "",
	HumpDownHump: () => "",
	HumpEqual: () => "",
	IEcy: () => "",
	IJlig: () => "",
	IOcy: () => "",
	Iacute: () => "",
	Icirc: () => "",
	Icy: () => "",
	Idot: () => "",
	Ifr: () => "",
	Igrave: () => "",
	Im: () => "",
	Imacr: () => "",
	ImaginaryI: () => "",
	Implies: () => "",
	Int: () => "",
	Integral: () => "",
	Intersection: () => "",
	InvisibleComma: () => "",
	InvisibleTimes: () => "",
	Iogon: () => "",
	Iopf: () => Iopf,
	Iota: () => "",
	Iscr: () => "",
	Itilde: () => "",
	Iukcy: () => "",
	Iuml: () => "",
	Jcirc: () => "",
	Jcy: () => "",
	Jfr: () => Jfr,
	Jopf: () => Jopf,
	Jscr: () => Jscr,
	Jsercy: () => "",
	Jukcy: () => "",
	KHcy: () => "",
	KJcy: () => "",
	Kappa: () => "",
	Kcedil: () => "",
	Kcy: () => "",
	Kfr: () => Kfr,
	Kopf: () => Kopf,
	Kscr: () => Kscr,
	LJcy: () => "",
	LT: () => "<",
	Lacute: () => "",
	Lambda: () => "",
	Lang: () => "",
	Laplacetrf: () => "",
	Larr: () => "",
	Lcaron: () => "",
	Lcedil: () => "",
	Lcy: () => "",
	LeftAngleBracket: () => "",
	LeftArrow: () => "",
	LeftArrowBar: () => "",
	LeftArrowRightArrow: () => "",
	LeftCeiling: () => "",
	LeftDoubleBracket: () => "",
	LeftDownTeeVector: () => "",
	LeftDownVector: () => "",
	LeftDownVectorBar: () => "",
	LeftFloor: () => "",
	LeftRightArrow: () => "",
	LeftRightVector: () => "",
	LeftTee: () => "",
	LeftTeeArrow: () => "",
	LeftTeeVector: () => "",
	LeftTriangle: () => "",
	LeftTriangleBar: () => "",
	LeftTriangleEqual: () => "",
	LeftUpDownVector: () => "",
	LeftUpTeeVector: () => "",
	LeftUpVector: () => "",
	LeftUpVectorBar: () => "",
	LeftVector: () => "",
	LeftVectorBar: () => "",
	Leftarrow: () => "",
	Leftrightarrow: () => "",
	LessEqualGreater: () => "",
	LessFullEqual: () => "",
	LessGreater: () => "",
	LessLess: () => "",
	LessSlantEqual: () => "",
	LessTilde: () => "",
	Lfr: () => Lfr,
	Ll: () => "",
	Lleftarrow: () => "",
	Lmidot: () => "",
	LongLeftArrow: () => "",
	LongLeftRightArrow: () => "",
	LongRightArrow: () => "",
	Longleftarrow: () => "",
	Longleftrightarrow: () => "",
	Longrightarrow: () => "",
	Lopf: () => Lopf,
	LowerLeftArrow: () => "",
	LowerRightArrow: () => "",
	Lscr: () => "",
	Lsh: () => "",
	Lstrok: () => "",
	Lt: () => "",
	Map: () => "",
	Mcy: () => "",
	MediumSpace: () => "",
	Mellintrf: () => "",
	Mfr: () => Mfr,
	MinusPlus: () => "",
	Mopf: () => Mopf,
	Mscr: () => "",
	Mu: () => "",
	NJcy: () => "",
	Nacute: () => "",
	Ncaron: () => "",
	Ncedil: () => "",
	Ncy: () => "",
	NegativeMediumSpace: () => "",
	NegativeThickSpace: () => "",
	NegativeThinSpace: () => "",
	NegativeVeryThinSpace: () => "",
	NestedGreaterGreater: () => "",
	NestedLessLess: () => "",
	NewLine: () => "\n",
	Nfr: () => Nfr,
	NoBreak: () => "",
	NonBreakingSpace: () => "\xA0",
	Nopf: () => "",
	Not: () => "",
	NotCongruent: () => "",
	NotCupCap: () => "",
	NotDoubleVerticalBar: () => "",
	NotElement: () => "",
	NotEqual: () => "",
	NotEqualTilde: () => NotEqualTilde,
	NotExists: () => "",
	NotGreater: () => "",
	NotGreaterEqual: () => "",
	NotGreaterFullEqual: () => NotGreaterFullEqual,
	NotGreaterGreater: () => NotGreaterGreater,
	NotGreaterLess: () => "",
	NotGreaterSlantEqual: () => NotGreaterSlantEqual,
	NotGreaterTilde: () => "",
	NotHumpDownHump: () => NotHumpDownHump,
	NotHumpEqual: () => NotHumpEqual,
	NotLeftTriangle: () => "",
	NotLeftTriangleBar: () => NotLeftTriangleBar,
	NotLeftTriangleEqual: () => "",
	NotLess: () => "",
	NotLessEqual: () => "",
	NotLessGreater: () => "",
	NotLessLess: () => NotLessLess,
	NotLessSlantEqual: () => NotLessSlantEqual,
	NotLessTilde: () => "",
	NotNestedGreaterGreater: () => NotNestedGreaterGreater,
	NotNestedLessLess: () => NotNestedLessLess,
	NotPrecedes: () => "",
	NotPrecedesEqual: () => NotPrecedesEqual,
	NotPrecedesSlantEqual: () => "",
	NotReverseElement: () => "",
	NotRightTriangle: () => "",
	NotRightTriangleBar: () => NotRightTriangleBar,
	NotRightTriangleEqual: () => "",
	NotSquareSubset: () => NotSquareSubset,
	NotSquareSubsetEqual: () => "",
	NotSquareSuperset: () => NotSquareSuperset,
	NotSquareSupersetEqual: () => "",
	NotSubset: () => NotSubset,
	NotSubsetEqual: () => "",
	NotSucceeds: () => "",
	NotSucceedsEqual: () => NotSucceedsEqual,
	NotSucceedsSlantEqual: () => "",
	NotSucceedsTilde: () => NotSucceedsTilde,
	NotSuperset: () => NotSuperset,
	NotSupersetEqual: () => "",
	NotTilde: () => "",
	NotTildeEqual: () => "",
	NotTildeFullEqual: () => "",
	NotTildeTilde: () => "",
	NotVerticalBar: () => "",
	Nscr: () => Nscr,
	Ntilde: () => "",
	Nu: () => "",
	OElig: () => "",
	Oacute: () => "",
	Ocirc: () => "",
	Ocy: () => "",
	Odblac: () => "",
	Ofr: () => Ofr,
	Ograve: () => "",
	Omacr: () => "",
	Omega: () => "",
	Omicron: () => "",
	Oopf: () => Oopf,
	OpenCurlyDoubleQuote: () => "",
	OpenCurlyQuote: () => "",
	Or: () => "",
	Oscr: () => Oscr,
	Oslash: () => "",
	Otilde: () => "",
	Otimes: () => "",
	Ouml: () => "",
	OverBar: () => "",
	OverBrace: () => "",
	OverBracket: () => "",
	OverParenthesis: () => "",
	PartialD: () => "",
	Pcy: () => "",
	Pfr: () => Pfr,
	Phi: () => "",
	Pi: () => "",
	PlusMinus: () => "",
	Poincareplane: () => "",
	Popf: () => "",
	Pr: () => "",
	Precedes: () => "",
	PrecedesEqual: () => "",
	PrecedesSlantEqual: () => "",
	PrecedesTilde: () => "",
	Prime: () => "",
	Product: () => "",
	Proportion: () => "",
	Proportional: () => "",
	Pscr: () => Pscr,
	Psi: () => "",
	QUOT: () => "\"",
	Qfr: () => Qfr,
	Qopf: () => "",
	Qscr: () => Qscr,
	RBarr: () => "",
	REG: () => "",
	Racute: () => "",
	Rang: () => "",
	Rarr: () => "",
	Rarrtl: () => "",
	Rcaron: () => "",
	Rcedil: () => "",
	Rcy: () => "",
	Re: () => "",
	ReverseElement: () => "",
	ReverseEquilibrium: () => "",
	ReverseUpEquilibrium: () => "",
	Rfr: () => "",
	Rho: () => "",
	RightAngleBracket: () => "",
	RightArrow: () => "",
	RightArrowBar: () => "",
	RightArrowLeftArrow: () => "",
	RightCeiling: () => "",
	RightDoubleBracket: () => "",
	RightDownTeeVector: () => "",
	RightDownVector: () => "",
	RightDownVectorBar: () => "",
	RightFloor: () => "",
	RightTee: () => "",
	RightTeeArrow: () => "",
	RightTeeVector: () => "",
	RightTriangle: () => "",
	RightTriangleBar: () => "",
	RightTriangleEqual: () => "",
	RightUpDownVector: () => "",
	RightUpTeeVector: () => "",
	RightUpVector: () => "",
	RightUpVectorBar: () => "",
	RightVector: () => "",
	RightVectorBar: () => "",
	Rightarrow: () => "",
	Ropf: () => "",
	RoundImplies: () => "",
	Rrightarrow: () => "",
	Rscr: () => "",
	Rsh: () => "",
	RuleDelayed: () => "",
	SHCHcy: () => "",
	SHcy: () => "",
	SOFTcy: () => "",
	Sacute: () => "",
	Sc: () => "",
	Scaron: () => "",
	Scedil: () => "",
	Scirc: () => "",
	Scy: () => "",
	Sfr: () => Sfr,
	ShortDownArrow: () => "",
	ShortLeftArrow: () => "",
	ShortRightArrow: () => "",
	ShortUpArrow: () => "",
	Sigma: () => "",
	SmallCircle: () => "",
	Sopf: () => Sopf,
	Sqrt: () => "",
	Square: () => "",
	SquareIntersection: () => "",
	SquareSubset: () => "",
	SquareSubsetEqual: () => "",
	SquareSuperset: () => "",
	SquareSupersetEqual: () => "",
	SquareUnion: () => "",
	Sscr: () => Sscr,
	Star: () => "",
	Sub: () => "",
	Subset: () => "",
	SubsetEqual: () => "",
	Succeeds: () => "",
	SucceedsEqual: () => "",
	SucceedsSlantEqual: () => "",
	SucceedsTilde: () => "",
	SuchThat: () => "",
	Sum: () => "",
	Sup: () => "",
	Superset: () => "",
	SupersetEqual: () => "",
	Supset: () => "",
	THORN: () => "",
	TRADE: () => "",
	TSHcy: () => "",
	TScy: () => "",
	Tab: () => "	",
	Tau: () => "",
	Tcaron: () => "",
	Tcedil: () => "",
	Tcy: () => "",
	Tfr: () => Tfr,
	Therefore: () => "",
	Theta: () => "",
	ThickSpace: () => ThickSpace,
	ThinSpace: () => "",
	Tilde: () => "",
	TildeEqual: () => "",
	TildeFullEqual: () => "",
	TildeTilde: () => "",
	Topf: () => Topf,
	TripleDot: () => "",
	Tscr: () => Tscr,
	Tstrok: () => "",
	Uacute: () => "",
	Uarr: () => "",
	Uarrocir: () => "",
	Ubrcy: () => "",
	Ubreve: () => "",
	Ucirc: () => "",
	Ucy: () => "",
	Udblac: () => "",
	Ufr: () => Ufr,
	Ugrave: () => "",
	Umacr: () => "",
	UnderBar: () => "_",
	UnderBrace: () => "",
	UnderBracket: () => "",
	UnderParenthesis: () => "",
	Union: () => "",
	UnionPlus: () => "",
	Uogon: () => "",
	Uopf: () => Uopf,
	UpArrow: () => "",
	UpArrowBar: () => "",
	UpArrowDownArrow: () => "",
	UpDownArrow: () => "",
	UpEquilibrium: () => "",
	UpTee: () => "",
	UpTeeArrow: () => "",
	Uparrow: () => "",
	Updownarrow: () => "",
	UpperLeftArrow: () => "",
	UpperRightArrow: () => "",
	Upsi: () => "",
	Upsilon: () => "",
	Uring: () => "",
	Uscr: () => Uscr,
	Utilde: () => "",
	Uuml: () => "",
	VDash: () => "",
	Vbar: () => "",
	Vcy: () => "",
	Vdash: () => "",
	Vdashl: () => "",
	Vee: () => "",
	Verbar: () => "",
	Vert: () => "",
	VerticalBar: () => "",
	VerticalLine: () => "|",
	VerticalSeparator: () => "",
	VerticalTilde: () => "",
	VeryThinSpace: () => "",
	Vfr: () => Vfr,
	Vopf: () => Vopf,
	Vscr: () => Vscr,
	Vvdash: () => "",
	Wcirc: () => "",
	Wedge: () => "",
	Wfr: () => Wfr,
	Wopf: () => Wopf,
	Wscr: () => Wscr,
	Xfr: () => Xfr,
	Xi: () => "",
	Xopf: () => Xopf,
	Xscr: () => Xscr,
	YAcy: () => "",
	YIcy: () => "",
	YUcy: () => "",
	Yacute: () => "",
	Ycirc: () => "",
	Ycy: () => "",
	Yfr: () => Yfr,
	Yopf: () => Yopf,
	Yscr: () => Yscr,
	Yuml: () => "",
	ZHcy: () => "",
	Zacute: () => "",
	Zcaron: () => "",
	Zcy: () => "",
	Zdot: () => "",
	ZeroWidthSpace: () => "",
	Zeta: () => "",
	Zfr: () => "",
	Zopf: () => "",
	Zscr: () => Zscr,
	aacute: () => "",
	abreve: () => "",
	ac: () => "",
	acE: () => acE,
	acd: () => "",
	acirc: () => "",
	acute: () => "",
	acy: () => "",
	aelig: () => "",
	af: () => "",
	afr: () => afr,
	agrave: () => "",
	alefsym: () => "",
	aleph: () => "",
	alpha: () => "",
	amacr: () => "",
	amalg: () => "",
	amp: () => "&",
	and: () => "",
	andand: () => "",
	andd: () => "",
	andslope: () => "",
	andv: () => "",
	ang: () => "",
	ange: () => "",
	angle: () => "",
	angmsd: () => "",
	angmsdaa: () => "",
	angmsdab: () => "",
	angmsdac: () => "",
	angmsdad: () => "",
	angmsdae: () => "",
	angmsdaf: () => "",
	angmsdag: () => "",
	angmsdah: () => "",
	angrt: () => "",
	angrtvb: () => "",
	angrtvbd: () => "",
	angsph: () => "",
	angst: () => "",
	angzarr: () => "",
	aogon: () => "",
	aopf: () => aopf,
	ap: () => "",
	apE: () => "",
	apacir: () => "",
	ape: () => "",
	apid: () => "",
	apos: () => "'",
	approx: () => "",
	approxeq: () => "",
	aring: () => "",
	ascr: () => ascr,
	ast: () => "*",
	asymp: () => "",
	asympeq: () => "",
	atilde: () => "",
	auml: () => "",
	awconint: () => "",
	awint: () => "",
	bNot: () => "",
	backcong: () => "",
	backepsilon: () => "",
	backprime: () => "",
	backsim: () => "",
	backsimeq: () => "",
	barvee: () => "",
	barwed: () => "",
	barwedge: () => "",
	bbrk: () => "",
	bbrktbrk: () => "",
	bcong: () => "",
	bcy: () => "",
	bdquo: () => "",
	becaus: () => "",
	because: () => "",
	bemptyv: () => "",
	bepsi: () => "",
	bernou: () => "",
	beta: () => "",
	beth: () => "",
	between: () => "",
	bfr: () => bfr,
	bigcap: () => "",
	bigcirc: () => "",
	bigcup: () => "",
	bigodot: () => "",
	bigoplus: () => "",
	bigotimes: () => "",
	bigsqcup: () => "",
	bigstar: () => "",
	bigtriangledown: () => "",
	bigtriangleup: () => "",
	biguplus: () => "",
	bigvee: () => "",
	bigwedge: () => "",
	bkarow: () => "",
	blacklozenge: () => "",
	blacksquare: () => "",
	blacktriangle: () => "",
	blacktriangledown: () => "",
	blacktriangleleft: () => "",
	blacktriangleright: () => "",
	blank: () => "",
	blk12: () => "",
	blk14: () => "",
	blk34: () => "",
	block: () => "",
	bne: () => bne,
	bnequiv: () => bnequiv,
	bnot: () => "",
	bopf: () => bopf,
	bot: () => "",
	bottom: () => "",
	bowtie: () => "",
	boxDL: () => "",
	boxDR: () => "",
	boxDl: () => "",
	boxDr: () => "",
	boxH: () => "",
	boxHD: () => "",
	boxHU: () => "",
	boxHd: () => "",
	boxHu: () => "",
	boxUL: () => "",
	boxUR: () => "",
	boxUl: () => "",
	boxUr: () => "",
	boxV: () => "",
	boxVH: () => "",
	boxVL: () => "",
	boxVR: () => "",
	boxVh: () => "",
	boxVl: () => "",
	boxVr: () => "",
	boxbox: () => "",
	boxdL: () => "",
	boxdR: () => "",
	boxdl: () => "",
	boxdr: () => "",
	boxh: () => "",
	boxhD: () => "",
	boxhU: () => "",
	boxhd: () => "",
	boxhu: () => "",
	boxminus: () => "",
	boxplus: () => "",
	boxtimes: () => "",
	boxuL: () => "",
	boxuR: () => "",
	boxul: () => "",
	boxur: () => "",
	boxv: () => "",
	boxvH: () => "",
	boxvL: () => "",
	boxvR: () => "",
	boxvh: () => "",
	boxvl: () => "",
	boxvr: () => "",
	bprime: () => "",
	breve: () => "",
	brvbar: () => "",
	bscr: () => bscr,
	bsemi: () => "",
	bsim: () => "",
	bsime: () => "",
	bsol: () => "\\",
	bsolb: () => "",
	bsolhsub: () => "",
	bull: () => "",
	bullet: () => "",
	bump: () => "",
	bumpE: () => "",
	bumpe: () => "",
	bumpeq: () => "",
	cacute: () => "",
	cap: () => "",
	capand: () => "",
	capbrcup: () => "",
	capcap: () => "",
	capcup: () => "",
	capdot: () => "",
	caps: () => caps,
	caret: () => "",
	caron: () => "",
	ccaps: () => "",
	ccaron: () => "",
	ccedil: () => "",
	ccirc: () => "",
	ccups: () => "",
	ccupssm: () => "",
	cdot: () => "",
	cedil: () => "",
	cemptyv: () => "",
	cent: () => "",
	centerdot: () => "",
	cfr: () => cfr,
	chcy: () => "",
	check: () => "",
	checkmark: () => "",
	chi: () => "",
	cir: () => "",
	cirE: () => "",
	circ: () => "",
	circeq: () => "",
	circlearrowleft: () => "",
	circlearrowright: () => "",
	circledR: () => "",
	circledS: () => "",
	circledast: () => "",
	circledcirc: () => "",
	circleddash: () => "",
	cire: () => "",
	cirfnint: () => "",
	cirmid: () => "",
	cirscir: () => "",
	clubs: () => "",
	clubsuit: () => "",
	colon: () => ":",
	colone: () => "",
	coloneq: () => "",
	comma: () => ",",
	commat: () => "@",
	comp: () => "",
	compfn: () => "",
	complement: () => "",
	complexes: () => "",
	cong: () => "",
	congdot: () => "",
	conint: () => "",
	copf: () => copf,
	coprod: () => "",
	copy: () => "",
	copysr: () => "",
	crarr: () => "",
	cross: () => "",
	cscr: () => cscr,
	csub: () => "",
	csube: () => "",
	csup: () => "",
	csupe: () => "",
	ctdot: () => "",
	cudarrl: () => "",
	cudarrr: () => "",
	cuepr: () => "",
	cuesc: () => "",
	cularr: () => "",
	cularrp: () => "",
	cup: () => "",
	cupbrcap: () => "",
	cupcap: () => "",
	cupcup: () => "",
	cupdot: () => "",
	cupor: () => "",
	cups: () => cups,
	curarr: () => "",
	curarrm: () => "",
	curlyeqprec: () => "",
	curlyeqsucc: () => "",
	curlyvee: () => "",
	curlywedge: () => "",
	curren: () => "",
	curvearrowleft: () => "",
	curvearrowright: () => "",
	cuvee: () => "",
	cuwed: () => "",
	cwconint: () => "",
	cwint: () => "",
	cylcty: () => "",
	dArr: () => "",
	dHar: () => "",
	dagger: () => "",
	daleth: () => "",
	darr: () => "",
	dash: () => "",
	dashv: () => "",
	dbkarow: () => "",
	dblac: () => "",
	dcaron: () => "",
	dcy: () => "",
	dd: () => "",
	ddagger: () => "",
	ddarr: () => "",
	ddotseq: () => "",
	default: () => entities_default,
	deg: () => "",
	delta: () => "",
	demptyv: () => "",
	dfisht: () => "",
	dfr: () => dfr,
	dharl: () => "",
	dharr: () => "",
	diam: () => "",
	diamond: () => "",
	diamondsuit: () => "",
	diams: () => "",
	die: () => "",
	digamma: () => "",
	disin: () => "",
	div: () => "",
	divide: () => "",
	divideontimes: () => "",
	divonx: () => "",
	djcy: () => "",
	dlcorn: () => "",
	dlcrop: () => "",
	dollar: () => "$",
	dopf: () => dopf,
	dot: () => "",
	doteq: () => "",
	doteqdot: () => "",
	dotminus: () => "",
	dotplus: () => "",
	dotsquare: () => "",
	doublebarwedge: () => "",
	downarrow: () => "",
	downdownarrows: () => "",
	downharpoonleft: () => "",
	downharpoonright: () => "",
	drbkarow: () => "",
	drcorn: () => "",
	drcrop: () => "",
	dscr: () => dscr,
	dscy: () => "",
	dsol: () => "",
	dstrok: () => "",
	dtdot: () => "",
	dtri: () => "",
	dtrif: () => "",
	duarr: () => "",
	duhar: () => "",
	dwangle: () => "",
	dzcy: () => "",
	dzigrarr: () => "",
	eDDot: () => "",
	eDot: () => "",
	eacute: () => "",
	easter: () => "",
	ecaron: () => "",
	ecir: () => "",
	ecirc: () => "",
	ecolon: () => "",
	ecy: () => "",
	edot: () => "",
	ee: () => "",
	efDot: () => "",
	efr: () => efr,
	eg: () => "",
	egrave: () => "",
	egs: () => "",
	egsdot: () => "",
	el: () => "",
	elinters: () => "",
	ell: () => "",
	els: () => "",
	elsdot: () => "",
	emacr: () => "",
	empty: () => "",
	emptyset: () => "",
	emptyv: () => "",
	emsp: () => "",
	emsp13: () => "",
	emsp14: () => "",
	eng: () => "",
	ensp: () => "",
	eogon: () => "",
	eopf: () => eopf,
	epar: () => "",
	eparsl: () => "",
	eplus: () => "",
	epsi: () => "",
	epsilon: () => "",
	epsiv: () => "",
	eqcirc: () => "",
	eqcolon: () => "",
	eqsim: () => "",
	eqslantgtr: () => "",
	eqslantless: () => "",
	equals: () => "=",
	equest: () => "",
	equiv: () => "",
	equivDD: () => "",
	eqvparsl: () => "",
	erDot: () => "",
	erarr: () => "",
	escr: () => "",
	esdot: () => "",
	esim: () => "",
	eta: () => "",
	eth: () => "",
	euml: () => "",
	euro: () => "",
	excl: () => "!",
	exist: () => "",
	expectation: () => "",
	exponentiale: () => "",
	fallingdotseq: () => "",
	fcy: () => "",
	female: () => "",
	ffilig: () => "",
	fflig: () => "",
	ffllig: () => "",
	ffr: () => ffr,
	filig: () => "",
	fjlig: () => "fj",
	flat: () => "",
	fllig: () => "",
	fltns: () => "",
	fnof: () => "",
	fopf: () => fopf,
	forall: () => "",
	fork: () => "",
	forkv: () => "",
	fpartint: () => "",
	frac12: () => "",
	frac13: () => "",
	frac14: () => "",
	frac15: () => "",
	frac16: () => "",
	frac18: () => "",
	frac23: () => "",
	frac25: () => "",
	frac34: () => "",
	frac35: () => "",
	frac38: () => "",
	frac45: () => "",
	frac56: () => "",
	frac58: () => "",
	frac78: () => "",
	frasl: () => "",
	frown: () => "",
	fscr: () => fscr,
	gE: () => "",
	gEl: () => "",
	gacute: () => "",
	gamma: () => "",
	gammad: () => "",
	gap: () => "",
	gbreve: () => "",
	gcirc: () => "",
	gcy: () => "",
	gdot: () => "",
	ge: () => "",
	gel: () => "",
	geq: () => "",
	geqq: () => "",
	geqslant: () => "",
	ges: () => "",
	gescc: () => "",
	gesdot: () => "",
	gesdoto: () => "",
	gesdotol: () => "",
	gesl: () => gesl,
	gesles: () => "",
	gfr: () => gfr,
	gg: () => "",
	ggg: () => "",
	gimel: () => "",
	gjcy: () => "",
	gl: () => "",
	glE: () => "",
	gla: () => "",
	glj: () => "",
	gnE: () => "",
	gnap: () => "",
	gnapprox: () => "",
	gne: () => "",
	gneq: () => "",
	gneqq: () => "",
	gnsim: () => "",
	gopf: () => gopf,
	grave: () => "`",
	gscr: () => "",
	gsim: () => "",
	gsime: () => "",
	gsiml: () => "",
	gt: () => ">",
	gtcc: () => "",
	gtcir: () => "",
	gtdot: () => "",
	gtlPar: () => "",
	gtquest: () => "",
	gtrapprox: () => "",
	gtrarr: () => "",
	gtrdot: () => "",
	gtreqless: () => "",
	gtreqqless: () => "",
	gtrless: () => "",
	gtrsim: () => "",
	gvertneqq: () => gvertneqq,
	gvnE: () => gvnE,
	hArr: () => "",
	hairsp: () => "",
	half: () => "",
	hamilt: () => "",
	hardcy: () => "",
	harr: () => "",
	harrcir: () => "",
	harrw: () => "",
	hbar: () => "",
	hcirc: () => "",
	hearts: () => "",
	heartsuit: () => "",
	hellip: () => "",
	hercon: () => "",
	hfr: () => hfr,
	hksearow: () => "",
	hkswarow: () => "",
	hoarr: () => "",
	homtht: () => "",
	hookleftarrow: () => "",
	hookrightarrow: () => "",
	hopf: () => hopf,
	horbar: () => "",
	hscr: () => hscr,
	hslash: () => "",
	hstrok: () => "",
	hybull: () => "",
	hyphen: () => "",
	iacute: () => "",
	ic: () => "",
	icirc: () => "",
	icy: () => "",
	iecy: () => "",
	iexcl: () => "",
	iff: () => "",
	ifr: () => ifr,
	igrave: () => "",
	ii: () => "",
	iiiint: () => "",
	iiint: () => "",
	iinfin: () => "",
	iiota: () => "",
	ijlig: () => "",
	imacr: () => "",
	image: () => "",
	imagline: () => "",
	imagpart: () => "",
	imath: () => "",
	imof: () => "",
	imped: () => "",
	incare: () => "",
	infin: () => "",
	infintie: () => "",
	inodot: () => "",
	int: () => "",
	intcal: () => "",
	integers: () => "",
	intercal: () => "",
	intlarhk: () => "",
	intprod: () => "",
	iocy: () => "",
	iogon: () => "",
	iopf: () => iopf,
	iota: () => "",
	iprod: () => "",
	iquest: () => "",
	iscr: () => iscr,
	isin: () => "",
	isinE: () => "",
	isindot: () => "",
	isins: () => "",
	isinsv: () => "",
	isinv: () => "",
	it: () => "",
	itilde: () => "",
	iukcy: () => "",
	iuml: () => "",
	jcirc: () => "",
	jcy: () => "",
	jfr: () => jfr,
	jmath: () => "",
	jopf: () => jopf,
	jscr: () => jscr,
	jsercy: () => "",
	jukcy: () => "",
	kappa: () => "",
	kappav: () => "",
	kcedil: () => "",
	kcy: () => "",
	kfr: () => kfr,
	kgreen: () => "",
	khcy: () => "",
	kjcy: () => "",
	kopf: () => kopf,
	kscr: () => kscr,
	lAarr: () => "",
	lArr: () => "",
	lAtail: () => "",
	lBarr: () => "",
	lE: () => "",
	lEg: () => "",
	lHar: () => "",
	lacute: () => "",
	laemptyv: () => "",
	lagran: () => "",
	lambda: () => "",
	lang: () => "",
	langd: () => "",
	langle: () => "",
	lap: () => "",
	laquo: () => "",
	larr: () => "",
	larrb: () => "",
	larrbfs: () => "",
	larrfs: () => "",
	larrhk: () => "",
	larrlp: () => "",
	larrpl: () => "",
	larrsim: () => "",
	larrtl: () => "",
	lat: () => "",
	latail: () => "",
	late: () => "",
	lates: () => lates,
	lbarr: () => "",
	lbbrk: () => "",
	lbrace: () => "{",
	lbrack: () => "[",
	lbrke: () => "",
	lbrksld: () => "",
	lbrkslu: () => "",
	lcaron: () => "",
	lcedil: () => "",
	lceil: () => "",
	lcub: () => "{",
	lcy: () => "",
	ldca: () => "",
	ldquo: () => "",
	ldquor: () => "",
	ldrdhar: () => "",
	ldrushar: () => "",
	ldsh: () => "",
	le: () => "",
	leftarrow: () => "",
	leftarrowtail: () => "",
	leftharpoondown: () => "",
	leftharpoonup: () => "",
	leftleftarrows: () => "",
	leftrightarrow: () => "",
	leftrightarrows: () => "",
	leftrightharpoons: () => "",
	leftrightsquigarrow: () => "",
	leftthreetimes: () => "",
	leg: () => "",
	leq: () => "",
	leqq: () => "",
	leqslant: () => "",
	les: () => "",
	lescc: () => "",
	lesdot: () => "",
	lesdoto: () => "",
	lesdotor: () => "",
	lesg: () => lesg,
	lesges: () => "",
	lessapprox: () => "",
	lessdot: () => "",
	lesseqgtr: () => "",
	lesseqqgtr: () => "",
	lessgtr: () => "",
	lesssim: () => "",
	lfisht: () => "",
	lfloor: () => "",
	lfr: () => lfr,
	lg: () => "",
	lgE: () => "",
	lhard: () => "",
	lharu: () => "",
	lharul: () => "",
	lhblk: () => "",
	ljcy: () => "",
	ll: () => "",
	llarr: () => "",
	llcorner: () => "",
	llhard: () => "",
	lltri: () => "",
	lmidot: () => "",
	lmoust: () => "",
	lmoustache: () => "",
	lnE: () => "",
	lnap: () => "",
	lnapprox: () => "",
	lne: () => "",
	lneq: () => "",
	lneqq: () => "",
	lnsim: () => "",
	loang: () => "",
	loarr: () => "",
	lobrk: () => "",
	longleftarrow: () => "",
	longleftrightarrow: () => "",
	longmapsto: () => "",
	longrightarrow: () => "",
	looparrowleft: () => "",
	looparrowright: () => "",
	lopar: () => "",
	lopf: () => lopf,
	loplus: () => "",
	lotimes: () => "",
	lowast: () => "",
	lowbar: () => "_",
	loz: () => "",
	lozenge: () => "",
	lozf: () => "",
	lpar: () => "(",
	lparlt: () => "",
	lrarr: () => "",
	lrcorner: () => "",
	lrhar: () => "",
	lrhard: () => "",
	lrm: () => "",
	lrtri: () => "",
	lsaquo: () => "",
	lscr: () => lscr,
	lsh: () => "",
	lsim: () => "",
	lsime: () => "",
	lsimg: () => "",
	lsqb: () => "[",
	lsquo: () => "",
	lsquor: () => "",
	lstrok: () => "",
	lt: () => "<",
	ltcc: () => "",
	ltcir: () => "",
	ltdot: () => "",
	lthree: () => "",
	ltimes: () => "",
	ltlarr: () => "",
	ltquest: () => "",
	ltrPar: () => "",
	ltri: () => "",
	ltrie: () => "",
	ltrif: () => "",
	lurdshar: () => "",
	luruhar: () => "",
	lvertneqq: () => lvertneqq,
	lvnE: () => lvnE,
	mDDot: () => "",
	macr: () => "",
	male: () => "",
	malt: () => "",
	maltese: () => "",
	map: () => "",
	mapsto: () => "",
	mapstodown: () => "",
	mapstoleft: () => "",
	mapstoup: () => "",
	marker: () => "",
	mcomma: () => "",
	mcy: () => "",
	mdash: () => "",
	measuredangle: () => "",
	mfr: () => mfr,
	mho: () => "",
	micro: () => "",
	mid: () => "",
	midast: () => "*",
	midcir: () => "",
	middot: () => "",
	minus: () => "",
	minusb: () => "",
	minusd: () => "",
	minusdu: () => "",
	mlcp: () => "",
	mldr: () => "",
	mnplus: () => "",
	models: () => "",
	mopf: () => mopf,
	mp: () => "",
	mscr: () => mscr,
	mstpos: () => "",
	mu: () => "",
	multimap: () => "",
	mumap: () => "",
	nGg: () => nGg,
	nGt: () => nGt,
	nGtv: () => nGtv,
	nLeftarrow: () => "",
	nLeftrightarrow: () => "",
	nLl: () => nLl,
	nLt: () => nLt,
	nLtv: () => nLtv,
	nRightarrow: () => "",
	nVDash: () => "",
	nVdash: () => "",
	nabla: () => "",
	nacute: () => "",
	nang: () => nang,
	nap: () => "",
	napE: () => napE,
	napid: () => napid,
	napos: () => "",
	napprox: () => "",
	natur: () => "",
	natural: () => "",
	naturals: () => "",
	nbsp: () => "\xA0",
	nbump: () => nbump,
	nbumpe: () => nbumpe,
	ncap: () => "",
	ncaron: () => "",
	ncedil: () => "",
	ncong: () => "",
	ncongdot: () => ncongdot,
	ncup: () => "",
	ncy: () => "",
	ndash: () => "",
	ne: () => "",
	neArr: () => "",
	nearhk: () => "",
	nearr: () => "",
	nearrow: () => "",
	nedot: () => nedot,
	nequiv: () => "",
	nesear: () => "",
	nesim: () => nesim,
	nexist: () => "",
	nexists: () => "",
	nfr: () => nfr,
	ngE: () => ngE,
	nge: () => "",
	ngeq: () => "",
	ngeqq: () => ngeqq,
	ngeqslant: () => ngeqslant,
	nges: () => nges,
	ngsim: () => "",
	ngt: () => "",
	ngtr: () => "",
	nhArr: () => "",
	nharr: () => "",
	nhpar: () => "",
	ni: () => "",
	nis: () => "",
	nisd: () => "",
	niv: () => "",
	njcy: () => "",
	nlArr: () => "",
	nlE: () => nlE,
	nlarr: () => "",
	nldr: () => "",
	nle: () => "",
	nleftarrow: () => "",
	nleftrightarrow: () => "",
	nleq: () => "",
	nleqq: () => nleqq,
	nleqslant: () => nleqslant,
	nles: () => nles,
	nless: () => "",
	nlsim: () => "",
	nlt: () => "",
	nltri: () => "",
	nltrie: () => "",
	nmid: () => "",
	nopf: () => nopf,
	not: () => "",
	notin: () => "",
	notinE: () => notinE,
	notindot: () => notindot,
	notinva: () => "",
	notinvb: () => "",
	notinvc: () => "",
	notni: () => "",
	notniva: () => "",
	notnivb: () => "",
	notnivc: () => "",
	npar: () => "",
	nparallel: () => "",
	nparsl: () => nparsl,
	npart: () => npart,
	npolint: () => "",
	npr: () => "",
	nprcue: () => "",
	npre: () => npre,
	nprec: () => "",
	npreceq: () => npreceq,
	nrArr: () => "",
	nrarr: () => "",
	nrarrc: () => nrarrc,
	nrarrw: () => nrarrw,
	nrightarrow: () => "",
	nrtri: () => "",
	nrtrie: () => "",
	nsc: () => "",
	nsccue: () => "",
	nsce: () => nsce,
	nscr: () => nscr,
	nshortmid: () => "",
	nshortparallel: () => "",
	nsim: () => "",
	nsime: () => "",
	nsimeq: () => "",
	nsmid: () => "",
	nspar: () => "",
	nsqsube: () => "",
	nsqsupe: () => "",
	nsub: () => "",
	nsubE: () => nsubE,
	nsube: () => "",
	nsubset: () => nsubset,
	nsubseteq: () => "",
	nsubseteqq: () => nsubseteqq,
	nsucc: () => "",
	nsucceq: () => nsucceq,
	nsup: () => "",
	nsupE: () => nsupE,
	nsupe: () => "",
	nsupset: () => nsupset,
	nsupseteq: () => "",
	nsupseteqq: () => nsupseteqq,
	ntgl: () => "",
	ntilde: () => "",
	ntlg: () => "",
	ntriangleleft: () => "",
	ntrianglelefteq: () => "",
	ntriangleright: () => "",
	ntrianglerighteq: () => "",
	nu: () => "",
	num: () => "#",
	numero: () => "",
	numsp: () => "",
	nvDash: () => "",
	nvHarr: () => "",
	nvap: () => nvap,
	nvdash: () => "",
	nvge: () => nvge,
	nvgt: () => nvgt,
	nvinfin: () => "",
	nvlArr: () => "",
	nvle: () => nvle,
	nvlt: () => nvlt,
	nvltrie: () => nvltrie,
	nvrArr: () => "",
	nvrtrie: () => nvrtrie,
	nvsim: () => nvsim,
	nwArr: () => "",
	nwarhk: () => "",
	nwarr: () => "",
	nwarrow: () => "",
	nwnear: () => "",
	oS: () => "",
	oacute: () => "",
	oast: () => "",
	ocir: () => "",
	ocirc: () => "",
	ocy: () => "",
	odash: () => "",
	odblac: () => "",
	odiv: () => "",
	odot: () => "",
	odsold: () => "",
	oelig: () => "",
	ofcir: () => "",
	ofr: () => ofr,
	ogon: () => "",
	ograve: () => "",
	ogt: () => "",
	ohbar: () => "",
	ohm: () => "",
	oint: () => "",
	olarr: () => "",
	olcir: () => "",
	olcross: () => "",
	oline: () => "",
	olt: () => "",
	omacr: () => "",
	omega: () => "",
	omicron: () => "",
	omid: () => "",
	ominus: () => "",
	oopf: () => oopf,
	opar: () => "",
	operp: () => "",
	oplus: () => "",
	or: () => "",
	orarr: () => "",
	ord: () => "",
	order: () => "",
	orderof: () => "",
	ordf: () => "",
	ordm: () => "",
	origof: () => "",
	oror: () => "",
	orslope: () => "",
	orv: () => "",
	oscr: () => "",
	oslash: () => "",
	osol: () => "",
	otilde: () => "",
	otimes: () => "",
	otimesas: () => "",
	ouml: () => "",
	ovbar: () => "",
	par: () => "",
	para: () => "",
	parallel: () => "",
	parsim: () => "",
	parsl: () => "",
	part: () => "",
	pcy: () => "",
	percnt: () => "%",
	period: () => ".",
	permil: () => "",
	perp: () => "",
	pertenk: () => "",
	pfr: () => pfr,
	phi: () => "",
	phiv: () => "",
	phmmat: () => "",
	phone: () => "",
	pi: () => "",
	pitchfork: () => "",
	piv: () => "",
	planck: () => "",
	planckh: () => "",
	plankv: () => "",
	plus: () => "+",
	plusacir: () => "",
	plusb: () => "",
	pluscir: () => "",
	plusdo: () => "",
	plusdu: () => "",
	pluse: () => "",
	plusmn: () => "",
	plussim: () => "",
	plustwo: () => "",
	pm: () => "",
	pointint: () => "",
	popf: () => popf,
	pound: () => "",
	pr: () => "",
	prE: () => "",
	prap: () => "",
	prcue: () => "",
	pre: () => "",
	prec: () => "",
	precapprox: () => "",
	preccurlyeq: () => "",
	preceq: () => "",
	precnapprox: () => "",
	precneqq: () => "",
	precnsim: () => "",
	precsim: () => "",
	prime: () => "",
	primes: () => "",
	prnE: () => "",
	prnap: () => "",
	prnsim: () => "",
	prod: () => "",
	profalar: () => "",
	profline: () => "",
	profsurf: () => "",
	prop: () => "",
	propto: () => "",
	prsim: () => "",
	prurel: () => "",
	pscr: () => pscr,
	psi: () => "",
	puncsp: () => "",
	qfr: () => qfr,
	qint: () => "",
	qopf: () => qopf,
	qprime: () => "",
	qscr: () => qscr,
	quaternions: () => "",
	quatint: () => "",
	quest: () => "?",
	questeq: () => "",
	quot: () => "\"",
	rAarr: () => "",
	rArr: () => "",
	rAtail: () => "",
	rBarr: () => "",
	rHar: () => "",
	race: () => race,
	racute: () => "",
	radic: () => "",
	raemptyv: () => "",
	rang: () => "",
	rangd: () => "",
	range: () => "",
	rangle: () => "",
	raquo: () => "",
	rarr: () => "",
	rarrap: () => "",
	rarrb: () => "",
	rarrbfs: () => "",
	rarrc: () => "",
	rarrfs: () => "",
	rarrhk: () => "",
	rarrlp: () => "",
	rarrpl: () => "",
	rarrsim: () => "",
	rarrtl: () => "",
	rarrw: () => "",
	ratail: () => "",
	ratio: () => "",
	rationals: () => "",
	rbarr: () => "",
	rbbrk: () => "",
	rbrace: () => "}",
	rbrack: () => "]",
	rbrke: () => "",
	rbrksld: () => "",
	rbrkslu: () => "",
	rcaron: () => "",
	rcedil: () => "",
	rceil: () => "",
	rcub: () => "}",
	rcy: () => "",
	rdca: () => "",
	rdldhar: () => "",
	rdquo: () => "",
	rdquor: () => "",
	rdsh: () => "",
	real: () => "",
	realine: () => "",
	realpart: () => "",
	reals: () => "",
	rect: () => "",
	reg: () => "",
	rfisht: () => "",
	rfloor: () => "",
	rfr: () => rfr,
	rhard: () => "",
	rharu: () => "",
	rharul: () => "",
	rho: () => "",
	rhov: () => "",
	rightarrow: () => "",
	rightarrowtail: () => "",
	rightharpoondown: () => "",
	rightharpoonup: () => "",
	rightleftarrows: () => "",
	rightleftharpoons: () => "",
	rightrightarrows: () => "",
	rightsquigarrow: () => "",
	rightthreetimes: () => "",
	ring: () => "",
	risingdotseq: () => "",
	rlarr: () => "",
	rlhar: () => "",
	rlm: () => "",
	rmoust: () => "",
	rmoustache: () => "",
	rnmid: () => "",
	roang: () => "",
	roarr: () => "",
	robrk: () => "",
	ropar: () => "",
	ropf: () => ropf,
	roplus: () => "",
	rotimes: () => "",
	rpar: () => ")",
	rpargt: () => "",
	rppolint: () => "",
	rrarr: () => "",
	rsaquo: () => "",
	rscr: () => rscr,
	rsh: () => "",
	rsqb: () => "]",
	rsquo: () => "",
	rsquor: () => "",
	rthree: () => "",
	rtimes: () => "",
	rtri: () => "",
	rtrie: () => "",
	rtrif: () => "",
	rtriltri: () => "",
	ruluhar: () => "",
	rx: () => "",
	sacute: () => "",
	sbquo: () => "",
	sc: () => "",
	scE: () => "",
	scap: () => "",
	scaron: () => "",
	sccue: () => "",
	sce: () => "",
	scedil: () => "",
	scirc: () => "",
	scnE: () => "",
	scnap: () => "",
	scnsim: () => "",
	scpolint: () => "",
	scsim: () => "",
	scy: () => "",
	sdot: () => "",
	sdotb: () => "",
	sdote: () => "",
	seArr: () => "",
	searhk: () => "",
	searr: () => "",
	searrow: () => "",
	sect: () => "",
	semi: () => ";",
	seswar: () => "",
	setminus: () => "",
	setmn: () => "",
	sext: () => "",
	sfr: () => sfr,
	sfrown: () => "",
	sharp: () => "",
	shchcy: () => "",
	shcy: () => "",
	shortmid: () => "",
	shortparallel: () => "",
	shy: () => "",
	sigma: () => "",
	sigmaf: () => "",
	sigmav: () => "",
	sim: () => "",
	simdot: () => "",
	sime: () => "",
	simeq: () => "",
	simg: () => "",
	simgE: () => "",
	siml: () => "",
	simlE: () => "",
	simne: () => "",
	simplus: () => "",
	simrarr: () => "",
	slarr: () => "",
	smallsetminus: () => "",
	smashp: () => "",
	smeparsl: () => "",
	smid: () => "",
	smile: () => "",
	smt: () => "",
	smte: () => "",
	smtes: () => smtes,
	softcy: () => "",
	sol: () => "/",
	solb: () => "",
	solbar: () => "",
	sopf: () => sopf,
	spades: () => "",
	spadesuit: () => "",
	spar: () => "",
	sqcap: () => "",
	sqcaps: () => sqcaps,
	sqcup: () => "",
	sqcups: () => sqcups,
	sqsub: () => "",
	sqsube: () => "",
	sqsubset: () => "",
	sqsubseteq: () => "",
	sqsup: () => "",
	sqsupe: () => "",
	sqsupset: () => "",
	sqsupseteq: () => "",
	squ: () => "",
	square: () => "",
	squarf: () => "",
	squf: () => "",
	srarr: () => "",
	sscr: () => sscr,
	ssetmn: () => "",
	ssmile: () => "",
	sstarf: () => "",
	star: () => "",
	starf: () => "",
	straightepsilon: () => "",
	straightphi: () => "",
	strns: () => "",
	sub: () => "",
	subE: () => "",
	subdot: () => "",
	sube: () => "",
	subedot: () => "",
	submult: () => "",
	subnE: () => "",
	subne: () => "",
	subplus: () => "",
	subrarr: () => "",
	subset: () => "",
	subseteq: () => "",
	subseteqq: () => "",
	subsetneq: () => "",
	subsetneqq: () => "",
	subsim: () => "",
	subsub: () => "",
	subsup: () => "",
	succ: () => "",
	succapprox: () => "",
	succcurlyeq: () => "",
	succeq: () => "",
	succnapprox: () => "",
	succneqq: () => "",
	succnsim: () => "",
	succsim: () => "",
	sum: () => "",
	sung: () => "",
	sup: () => "",
	sup1: () => "",
	sup2: () => "",
	sup3: () => "",
	supE: () => "",
	supdot: () => "",
	supdsub: () => "",
	supe: () => "",
	supedot: () => "",
	suphsol: () => "",
	suphsub: () => "",
	suplarr: () => "",
	supmult: () => "",
	supnE: () => "",
	supne: () => "",
	supplus: () => "",
	supset: () => "",
	supseteq: () => "",
	supseteqq: () => "",
	supsetneq: () => "",
	supsetneqq: () => "",
	supsim: () => "",
	supsub: () => "",
	supsup: () => "",
	swArr: () => "",
	swarhk: () => "",
	swarr: () => "",
	swarrow: () => "",
	swnwar: () => "",
	szlig: () => "",
	target: () => "",
	tau: () => "",
	tbrk: () => "",
	tcaron: () => "",
	tcedil: () => "",
	tcy: () => "",
	tdot: () => "",
	telrec: () => "",
	tfr: () => tfr,
	there4: () => "",
	therefore: () => "",
	theta: () => "",
	thetasym: () => "",
	thetav: () => "",
	thickapprox: () => "",
	thicksim: () => "",
	thinsp: () => "",
	thkap: () => "",
	thksim: () => "",
	thorn: () => "",
	tilde: () => "",
	times: () => "",
	timesb: () => "",
	timesbar: () => "",
	timesd: () => "",
	tint: () => "",
	toea: () => "",
	top: () => "",
	topbot: () => "",
	topcir: () => "",
	topf: () => topf,
	topfork: () => "",
	tosa: () => "",
	tprime: () => "",
	trade: () => "",
	triangle: () => "",
	triangledown: () => "",
	triangleleft: () => "",
	trianglelefteq: () => "",
	triangleq: () => "",
	triangleright: () => "",
	trianglerighteq: () => "",
	tridot: () => "",
	trie: () => "",
	triminus: () => "",
	triplus: () => "",
	trisb: () => "",
	tritime: () => "",
	trpezium: () => "",
	tscr: () => tscr,
	tscy: () => "",
	tshcy: () => "",
	tstrok: () => "",
	twixt: () => "",
	twoheadleftarrow: () => "",
	twoheadrightarrow: () => "",
	uArr: () => "",
	uHar: () => "",
	uacute: () => "",
	uarr: () => "",
	ubrcy: () => "",
	ubreve: () => "",
	ucirc: () => "",
	ucy: () => "",
	udarr: () => "",
	udblac: () => "",
	udhar: () => "",
	ufisht: () => "",
	ufr: () => ufr,
	ugrave: () => "",
	uharl: () => "",
	uharr: () => "",
	uhblk: () => "",
	ulcorn: () => "",
	ulcorner: () => "",
	ulcrop: () => "",
	ultri: () => "",
	umacr: () => "",
	uml: () => "",
	uogon: () => "",
	uopf: () => uopf,
	uparrow: () => "",
	updownarrow: () => "",
	upharpoonleft: () => "",
	upharpoonright: () => "",
	uplus: () => "",
	upsi: () => "",
	upsih: () => "",
	upsilon: () => "",
	upuparrows: () => "",
	urcorn: () => "",
	urcorner: () => "",
	urcrop: () => "",
	uring: () => "",
	urtri: () => "",
	uscr: () => uscr,
	utdot: () => "",
	utilde: () => "",
	utri: () => "",
	utrif: () => "",
	uuarr: () => "",
	uuml: () => "",
	uwangle: () => "",
	vArr: () => "",
	vBar: () => "",
	vBarv: () => "",
	vDash: () => "",
	vangrt: () => "",
	varepsilon: () => "",
	varkappa: () => "",
	varnothing: () => "",
	varphi: () => "",
	varpi: () => "",
	varpropto: () => "",
	varr: () => "",
	varrho: () => "",
	varsigma: () => "",
	varsubsetneq: () => varsubsetneq,
	varsubsetneqq: () => varsubsetneqq,
	varsupsetneq: () => varsupsetneq,
	varsupsetneqq: () => varsupsetneqq,
	vartheta: () => "",
	vartriangleleft: () => "",
	vartriangleright: () => "",
	vcy: () => "",
	vdash: () => "",
	vee: () => "",
	veebar: () => "",
	veeeq: () => "",
	vellip: () => "",
	verbar: () => "|",
	vert: () => "|",
	vfr: () => vfr,
	vltri: () => "",
	vnsub: () => vnsub,
	vnsup: () => vnsup,
	vopf: () => vopf,
	vprop: () => "",
	vrtri: () => "",
	vscr: () => vscr,
	vsubnE: () => vsubnE,
	vsubne: () => vsubne,
	vsupnE: () => vsupnE,
	vsupne: () => vsupne,
	vzigzag: () => "",
	wcirc: () => "",
	wedbar: () => "",
	wedge: () => "",
	wedgeq: () => "",
	weierp: () => "",
	wfr: () => wfr,
	wopf: () => wopf,
	wp: () => "",
	wr: () => "",
	wreath: () => "",
	wscr: () => wscr,
	xcap: () => "",
	xcirc: () => "",
	xcup: () => "",
	xdtri: () => "",
	xfr: () => xfr,
	xhArr: () => "",
	xharr: () => "",
	xi: () => "",
	xlArr: () => "",
	xlarr: () => "",
	xmap: () => "",
	xnis: () => "",
	xodot: () => "",
	xopf: () => xopf,
	xoplus: () => "",
	xotime: () => "",
	xrArr: () => "",
	xrarr: () => "",
	xscr: () => xscr,
	xsqcup: () => "",
	xuplus: () => "",
	xutri: () => "",
	xvee: () => "",
	xwedge: () => "",
	yacute: () => "",
	yacy: () => "",
	ycirc: () => "",
	ycy: () => "",
	yen: () => "",
	yfr: () => yfr,
	yicy: () => "",
	yopf: () => yopf,
	yscr: () => yscr,
	yucy: () => "",
	yuml: () => "",
	zacute: () => "",
	zcaron: () => "",
	zcy: () => "",
	zdot: () => "",
	zeetrf: () => "",
	zeta: () => "",
	zfr: () => zfr,
	zhcy: () => "",
	zigrarr: () => "",
	zopf: () => zopf,
	zscr: () => zscr,
	zwj: () => "",
	zwnj: () => ""
}), acE, Afr, afr, Aopf, aopf, Ascr, ascr, Bfr, bfr, bne, bnequiv, Bopf, bopf, bscr, caps, cfr, copf, Cscr, cscr, cups, Dfr, dfr, Dopf, dopf, Dscr, dscr, Efr, efr, Eopf, eopf, Ffr, ffr, Fopf, fopf, fscr, gesl, Gfr, gfr, Gopf, gopf, Gscr, gvertneqq, gvnE, hfr, hopf, hscr, ifr, Iopf, iopf, iscr, Jfr, jfr, Jopf, jopf, Jscr, jscr, Kfr, kfr, Kopf, kopf, Kscr, kscr, lates, lesg, Lfr, lfr, Lopf, lopf, lscr, lvertneqq, lvnE, Mfr, mfr, Mopf, mopf, mscr, nang, napE, napid, nbump, nbumpe, ncongdot, nedot, nesim, Nfr, nfr, ngE, ngeqq, ngeqslant, nges, nGg, nGt, nGtv, nlE, nleqq, nleqslant, nles, nLl, nLt, nLtv, nopf, NotEqualTilde, NotGreaterFullEqual, NotGreaterGreater, NotGreaterSlantEqual, NotHumpDownHump, NotHumpEqual, notindot, notinE, NotLeftTriangleBar, NotLessLess, NotLessSlantEqual, NotNestedGreaterGreater, NotNestedLessLess, NotPrecedesEqual, NotRightTriangleBar, NotSquareSubset, NotSquareSuperset, NotSubset, NotSucceedsEqual, NotSucceedsTilde, NotSuperset, nparsl, npart, npreceq, npre, nrarrc, nrarrw, nsce, Nscr, nscr, nsubE, nsubset, nsubseteqq, nsucceq, nsupE, nsupset, nsupseteqq, nvap, nvge, nvgt, nvle, nvlt, nvltrie, nvrtrie, nvsim, Ofr, ofr, Oopf, oopf, Oscr, Pfr, pfr, popf, Pscr, pscr, Qfr, qfr, qopf, Qscr, qscr, race, rfr, ropf, rscr, Sfr, sfr, smtes, Sopf, sopf, sqcaps, sqcups, Sscr, sscr, Tfr, tfr, ThickSpace, Topf, topf, Tscr, tscr, Ufr, ufr, Uopf, uopf, Uscr, uscr, varsubsetneq, varsubsetneqq, varsupsetneq, varsupsetneqq, Vfr, vfr, vnsub, vnsup, Vopf, vopf, Vscr, vscr, vsubnE, vsubne, vsupnE, vsupne, Wfr, wfr, Wopf, wopf, Wscr, wscr, Xfr, xfr, Xopf, xopf, Xscr, xscr, Yfr, yfr, Yopf, yopf, Yscr, yscr, zfr, zopf, Zscr, zscr, entities_default;
var init_entities = __esmMin((() => {
	acE = "";
	Afr = "";
	afr = "";
	Aopf = "";
	aopf = "";
	Ascr = "";
	ascr = "";
	Bfr = "";
	bfr = "";
	bne = "=";
	bnequiv = "";
	Bopf = "";
	bopf = "";
	bscr = "";
	caps = "";
	cfr = "";
	copf = "";
	Cscr = "";
	cscr = "";
	cups = "";
	Dfr = "";
	dfr = "";
	Dopf = "";
	dopf = "";
	Dscr = "";
	dscr = "";
	Efr = "";
	efr = "";
	Eopf = "";
	eopf = "";
	Ffr = "";
	ffr = "";
	Fopf = "";
	fopf = "";
	fscr = "";
	gesl = "";
	Gfr = "";
	gfr = "";
	Gopf = "";
	gopf = "";
	Gscr = "";
	gvertneqq = "";
	gvnE = "";
	hfr = "";
	hopf = "";
	hscr = "";
	ifr = "";
	Iopf = "";
	iopf = "";
	iscr = "";
	Jfr = "";
	jfr = "";
	Jopf = "";
	jopf = "";
	Jscr = "";
	jscr = "";
	Kfr = "";
	kfr = "";
	Kopf = "";
	kopf = "";
	Kscr = "";
	kscr = "";
	lates = "";
	lesg = "";
	Lfr = "";
	lfr = "";
	Lopf = "";
	lopf = "";
	lscr = "";
	lvertneqq = "";
	lvnE = "";
	Mfr = "";
	mfr = "";
	Mopf = "";
	mopf = "";
	mscr = "";
	nang = "";
	napE = "";
	napid = "";
	nbump = "";
	nbumpe = "";
	ncongdot = "";
	nedot = "";
	nesim = "";
	Nfr = "";
	nfr = "";
	ngE = "";
	ngeqq = "";
	ngeqslant = "";
	nges = "";
	nGg = "";
	nGt = "";
	nGtv = "";
	nlE = "";
	nleqq = "";
	nleqslant = "";
	nles = "";
	nLl = "";
	nLt = "";
	nLtv = "";
	nopf = "";
	NotEqualTilde = "";
	NotGreaterFullEqual = "";
	NotGreaterGreater = "";
	NotGreaterSlantEqual = "";
	NotHumpDownHump = "";
	NotHumpEqual = "";
	notindot = "";
	notinE = "";
	NotLeftTriangleBar = "";
	NotLessLess = "";
	NotLessSlantEqual = "";
	NotNestedGreaterGreater = "";
	NotNestedLessLess = "";
	NotPrecedesEqual = "";
	NotRightTriangleBar = "";
	NotSquareSubset = "";
	NotSquareSuperset = "";
	NotSubset = "";
	NotSucceedsEqual = "";
	NotSucceedsTilde = "";
	NotSuperset = "";
	nparsl = "";
	npart = "";
	npreceq = "";
	npre = "";
	nrarrc = "";
	nrarrw = "";
	nsce = "";
	Nscr = "";
	nscr = "";
	nsubE = "";
	nsubset = "";
	nsubseteqq = "";
	nsucceq = "";
	nsupE = "";
	nsupset = "";
	nsupseteqq = "";
	nvap = "";
	nvge = "";
	nvgt = ">";
	nvle = "";
	nvlt = "<";
	nvltrie = "";
	nvrtrie = "";
	nvsim = "";
	Ofr = "";
	ofr = "";
	Oopf = "";
	oopf = "";
	Oscr = "";
	Pfr = "";
	pfr = "";
	popf = "";
	Pscr = "";
	pscr = "";
	Qfr = "";
	qfr = "";
	qopf = "";
	Qscr = "";
	qscr = "";
	race = "";
	rfr = "";
	ropf = "";
	rscr = "";
	Sfr = "";
	sfr = "";
	smtes = "";
	Sopf = "";
	sopf = "";
	sqcaps = "";
	sqcups = "";
	Sscr = "";
	sscr = "";
	Tfr = "";
	tfr = "";
	ThickSpace = "";
	Topf = "";
	topf = "";
	Tscr = "";
	tscr = "";
	Ufr = "";
	ufr = "";
	Uopf = "";
	uopf = "";
	Uscr = "";
	uscr = "";
	varsubsetneq = "";
	varsubsetneqq = "";
	varsupsetneq = "";
	varsupsetneqq = "";
	Vfr = "";
	vfr = "";
	vnsub = "";
	vnsup = "";
	Vopf = "";
	vopf = "";
	Vscr = "";
	vscr = "";
	vsubnE = "";
	vsubne = "";
	vsupnE = "";
	vsupne = "";
	Wfr = "";
	wfr = "";
	Wopf = "";
	wopf = "";
	Wscr = "";
	wscr = "";
	Xfr = "";
	xfr = "";
	Xopf = "";
	xopf = "";
	Xscr = "";
	xscr = "";
	Yfr = "";
	yfr = "";
	Yopf = "";
	yopf = "";
	Yscr = "";
	yscr = "";
	zfr = "";
	zopf = "";
	Zscr = "";
	zscr = "";
	entities_default = {
		Aacute: "",
		aacute: "",
		Abreve: "",
		abreve: "",
		ac: "",
		acd: "",
		acE,
		Acirc: "",
		acirc: "",
		acute: "",
		Acy: "",
		acy: "",
		AElig: "",
		aelig: "",
		af: "",
		Afr,
		afr,
		Agrave: "",
		agrave: "",
		alefsym: "",
		aleph: "",
		Alpha: "",
		alpha: "",
		Amacr: "",
		amacr: "",
		amalg: "",
		amp: "&",
		AMP: "&",
		andand: "",
		And: "",
		and: "",
		andd: "",
		andslope: "",
		andv: "",
		ang: "",
		ange: "",
		angle: "",
		angmsdaa: "",
		angmsdab: "",
		angmsdac: "",
		angmsdad: "",
		angmsdae: "",
		angmsdaf: "",
		angmsdag: "",
		angmsdah: "",
		angmsd: "",
		angrt: "",
		angrtvb: "",
		angrtvbd: "",
		angsph: "",
		angst: "",
		angzarr: "",
		Aogon: "",
		aogon: "",
		Aopf,
		aopf,
		apacir: "",
		ap: "",
		apE: "",
		ape: "",
		apid: "",
		apos: "'",
		ApplyFunction: "",
		approx: "",
		approxeq: "",
		Aring: "",
		aring: "",
		Ascr,
		ascr,
		Assign: "",
		ast: "*",
		asymp: "",
		asympeq: "",
		Atilde: "",
		atilde: "",
		Auml: "",
		auml: "",
		awconint: "",
		awint: "",
		backcong: "",
		backepsilon: "",
		backprime: "",
		backsim: "",
		backsimeq: "",
		Backslash: "",
		Barv: "",
		barvee: "",
		barwed: "",
		Barwed: "",
		barwedge: "",
		bbrk: "",
		bbrktbrk: "",
		bcong: "",
		Bcy: "",
		bcy: "",
		bdquo: "",
		becaus: "",
		because: "",
		Because: "",
		bemptyv: "",
		bepsi: "",
		bernou: "",
		Bernoullis: "",
		Beta: "",
		beta: "",
		beth: "",
		between: "",
		Bfr,
		bfr,
		bigcap: "",
		bigcirc: "",
		bigcup: "",
		bigodot: "",
		bigoplus: "",
		bigotimes: "",
		bigsqcup: "",
		bigstar: "",
		bigtriangledown: "",
		bigtriangleup: "",
		biguplus: "",
		bigvee: "",
		bigwedge: "",
		bkarow: "",
		blacklozenge: "",
		blacksquare: "",
		blacktriangle: "",
		blacktriangledown: "",
		blacktriangleleft: "",
		blacktriangleright: "",
		blank: "",
		blk12: "",
		blk14: "",
		blk34: "",
		block: "",
		bne,
		bnequiv,
		bNot: "",
		bnot: "",
		Bopf,
		bopf,
		bot: "",
		bottom: "",
		bowtie: "",
		boxbox: "",
		boxdl: "",
		boxdL: "",
		boxDl: "",
		boxDL: "",
		boxdr: "",
		boxdR: "",
		boxDr: "",
		boxDR: "",
		boxh: "",
		boxH: "",
		boxhd: "",
		boxHd: "",
		boxhD: "",
		boxHD: "",
		boxhu: "",
		boxHu: "",
		boxhU: "",
		boxHU: "",
		boxminus: "",
		boxplus: "",
		boxtimes: "",
		boxul: "",
		boxuL: "",
		boxUl: "",
		boxUL: "",
		boxur: "",
		boxuR: "",
		boxUr: "",
		boxUR: "",
		boxv: "",
		boxV: "",
		boxvh: "",
		boxvH: "",
		boxVh: "",
		boxVH: "",
		boxvl: "",
		boxvL: "",
		boxVl: "",
		boxVL: "",
		boxvr: "",
		boxvR: "",
		boxVr: "",
		boxVR: "",
		bprime: "",
		breve: "",
		Breve: "",
		brvbar: "",
		bscr,
		Bscr: "",
		bsemi: "",
		bsim: "",
		bsime: "",
		bsolb: "",
		bsol: "\\",
		bsolhsub: "",
		bull: "",
		bullet: "",
		bump: "",
		bumpE: "",
		bumpe: "",
		Bumpeq: "",
		bumpeq: "",
		Cacute: "",
		cacute: "",
		capand: "",
		capbrcup: "",
		capcap: "",
		cap: "",
		Cap: "",
		capcup: "",
		capdot: "",
		CapitalDifferentialD: "",
		caps,
		caret: "",
		caron: "",
		Cayleys: "",
		ccaps: "",
		Ccaron: "",
		ccaron: "",
		Ccedil: "",
		ccedil: "",
		Ccirc: "",
		ccirc: "",
		Cconint: "",
		ccups: "",
		ccupssm: "",
		Cdot: "",
		cdot: "",
		cedil: "",
		Cedilla: "",
		cemptyv: "",
		cent: "",
		centerdot: "",
		CenterDot: "",
		cfr,
		Cfr: "",
		CHcy: "",
		chcy: "",
		check: "",
		checkmark: "",
		Chi: "",
		chi: "",
		circ: "",
		circeq: "",
		circlearrowleft: "",
		circlearrowright: "",
		circledast: "",
		circledcirc: "",
		circleddash: "",
		CircleDot: "",
		circledR: "",
		circledS: "",
		CircleMinus: "",
		CirclePlus: "",
		CircleTimes: "",
		cir: "",
		cirE: "",
		cire: "",
		cirfnint: "",
		cirmid: "",
		cirscir: "",
		ClockwiseContourIntegral: "",
		CloseCurlyDoubleQuote: "",
		CloseCurlyQuote: "",
		clubs: "",
		clubsuit: "",
		colon: ":",
		Colon: "",
		Colone: "",
		colone: "",
		coloneq: "",
		comma: ",",
		commat: "@",
		comp: "",
		compfn: "",
		complement: "",
		complexes: "",
		cong: "",
		congdot: "",
		Congruent: "",
		conint: "",
		Conint: "",
		ContourIntegral: "",
		copf,
		Copf: "",
		coprod: "",
		Coproduct: "",
		copy: "",
		COPY: "",
		copysr: "",
		CounterClockwiseContourIntegral: "",
		crarr: "",
		cross: "",
		Cross: "",
		Cscr,
		cscr,
		csub: "",
		csube: "",
		csup: "",
		csupe: "",
		ctdot: "",
		cudarrl: "",
		cudarrr: "",
		cuepr: "",
		cuesc: "",
		cularr: "",
		cularrp: "",
		cupbrcap: "",
		cupcap: "",
		CupCap: "",
		cup: "",
		Cup: "",
		cupcup: "",
		cupdot: "",
		cupor: "",
		cups,
		curarr: "",
		curarrm: "",
		curlyeqprec: "",
		curlyeqsucc: "",
		curlyvee: "",
		curlywedge: "",
		curren: "",
		curvearrowleft: "",
		curvearrowright: "",
		cuvee: "",
		cuwed: "",
		cwconint: "",
		cwint: "",
		cylcty: "",
		dagger: "",
		Dagger: "",
		daleth: "",
		darr: "",
		Darr: "",
		dArr: "",
		dash: "",
		Dashv: "",
		dashv: "",
		dbkarow: "",
		dblac: "",
		Dcaron: "",
		dcaron: "",
		Dcy: "",
		dcy: "",
		ddagger: "",
		ddarr: "",
		DD: "",
		dd: "",
		DDotrahd: "",
		ddotseq: "",
		deg: "",
		Del: "",
		Delta: "",
		delta: "",
		demptyv: "",
		dfisht: "",
		Dfr,
		dfr,
		dHar: "",
		dharl: "",
		dharr: "",
		DiacriticalAcute: "",
		DiacriticalDot: "",
		DiacriticalDoubleAcute: "",
		DiacriticalGrave: "`",
		DiacriticalTilde: "",
		diam: "",
		diamond: "",
		Diamond: "",
		diamondsuit: "",
		diams: "",
		die: "",
		DifferentialD: "",
		digamma: "",
		disin: "",
		div: "",
		divide: "",
		divideontimes: "",
		divonx: "",
		DJcy: "",
		djcy: "",
		dlcorn: "",
		dlcrop: "",
		dollar: "$",
		Dopf,
		dopf,
		Dot: "",
		dot: "",
		DotDot: "",
		doteq: "",
		doteqdot: "",
		DotEqual: "",
		dotminus: "",
		dotplus: "",
		dotsquare: "",
		doublebarwedge: "",
		DoubleContourIntegral: "",
		DoubleDot: "",
		DoubleDownArrow: "",
		DoubleLeftArrow: "",
		DoubleLeftRightArrow: "",
		DoubleLeftTee: "",
		DoubleLongLeftArrow: "",
		DoubleLongLeftRightArrow: "",
		DoubleLongRightArrow: "",
		DoubleRightArrow: "",
		DoubleRightTee: "",
		DoubleUpArrow: "",
		DoubleUpDownArrow: "",
		DoubleVerticalBar: "",
		DownArrowBar: "",
		downarrow: "",
		DownArrow: "",
		Downarrow: "",
		DownArrowUpArrow: "",
		DownBreve: "",
		downdownarrows: "",
		downharpoonleft: "",
		downharpoonright: "",
		DownLeftRightVector: "",
		DownLeftTeeVector: "",
		DownLeftVectorBar: "",
		DownLeftVector: "",
		DownRightTeeVector: "",
		DownRightVectorBar: "",
		DownRightVector: "",
		DownTeeArrow: "",
		DownTee: "",
		drbkarow: "",
		drcorn: "",
		drcrop: "",
		Dscr,
		dscr,
		DScy: "",
		dscy: "",
		dsol: "",
		Dstrok: "",
		dstrok: "",
		dtdot: "",
		dtri: "",
		dtrif: "",
		duarr: "",
		duhar: "",
		dwangle: "",
		DZcy: "",
		dzcy: "",
		dzigrarr: "",
		Eacute: "",
		eacute: "",
		easter: "",
		Ecaron: "",
		ecaron: "",
		Ecirc: "",
		ecirc: "",
		ecir: "",
		ecolon: "",
		Ecy: "",
		ecy: "",
		eDDot: "",
		Edot: "",
		edot: "",
		eDot: "",
		ee: "",
		efDot: "",
		Efr,
		efr,
		eg: "",
		Egrave: "",
		egrave: "",
		egs: "",
		egsdot: "",
		el: "",
		Element: "",
		elinters: "",
		ell: "",
		els: "",
		elsdot: "",
		Emacr: "",
		emacr: "",
		empty: "",
		emptyset: "",
		EmptySmallSquare: "",
		emptyv: "",
		EmptyVerySmallSquare: "",
		emsp13: "",
		emsp14: "",
		emsp: "",
		ENG: "",
		eng: "",
		ensp: "",
		Eogon: "",
		eogon: "",
		Eopf,
		eopf,
		epar: "",
		eparsl: "",
		eplus: "",
		epsi: "",
		Epsilon: "",
		epsilon: "",
		epsiv: "",
		eqcirc: "",
		eqcolon: "",
		eqsim: "",
		eqslantgtr: "",
		eqslantless: "",
		Equal: "",
		equals: "=",
		EqualTilde: "",
		equest: "",
		Equilibrium: "",
		equiv: "",
		equivDD: "",
		eqvparsl: "",
		erarr: "",
		erDot: "",
		escr: "",
		Escr: "",
		esdot: "",
		Esim: "",
		esim: "",
		Eta: "",
		eta: "",
		ETH: "",
		eth: "",
		Euml: "",
		euml: "",
		euro: "",
		excl: "!",
		exist: "",
		Exists: "",
		expectation: "",
		exponentiale: "",
		ExponentialE: "",
		fallingdotseq: "",
		Fcy: "",
		fcy: "",
		female: "",
		ffilig: "",
		fflig: "",
		ffllig: "",
		Ffr,
		ffr,
		filig: "",
		FilledSmallSquare: "",
		FilledVerySmallSquare: "",
		fjlig: "fj",
		flat: "",
		fllig: "",
		fltns: "",
		fnof: "",
		Fopf,
		fopf,
		forall: "",
		ForAll: "",
		fork: "",
		forkv: "",
		Fouriertrf: "",
		fpartint: "",
		frac12: "",
		frac13: "",
		frac14: "",
		frac15: "",
		frac16: "",
		frac18: "",
		frac23: "",
		frac25: "",
		frac34: "",
		frac35: "",
		frac38: "",
		frac45: "",
		frac56: "",
		frac58: "",
		frac78: "",
		frasl: "",
		frown: "",
		fscr,
		Fscr: "",
		gacute: "",
		Gamma: "",
		gamma: "",
		Gammad: "",
		gammad: "",
		gap: "",
		Gbreve: "",
		gbreve: "",
		Gcedil: "",
		Gcirc: "",
		gcirc: "",
		Gcy: "",
		gcy: "",
		Gdot: "",
		gdot: "",
		ge: "",
		gE: "",
		gEl: "",
		gel: "",
		geq: "",
		geqq: "",
		geqslant: "",
		gescc: "",
		ges: "",
		gesdot: "",
		gesdoto: "",
		gesdotol: "",
		gesl,
		gesles: "",
		Gfr,
		gfr,
		gg: "",
		Gg: "",
		ggg: "",
		gimel: "",
		GJcy: "",
		gjcy: "",
		gla: "",
		gl: "",
		glE: "",
		glj: "",
		gnap: "",
		gnapprox: "",
		gne: "",
		gnE: "",
		gneq: "",
		gneqq: "",
		gnsim: "",
		Gopf,
		gopf,
		grave: "`",
		GreaterEqual: "",
		GreaterEqualLess: "",
		GreaterFullEqual: "",
		GreaterGreater: "",
		GreaterLess: "",
		GreaterSlantEqual: "",
		GreaterTilde: "",
		Gscr,
		gscr: "",
		gsim: "",
		gsime: "",
		gsiml: "",
		gtcc: "",
		gtcir: "",
		gt: ">",
		GT: ">",
		Gt: "",
		gtdot: "",
		gtlPar: "",
		gtquest: "",
		gtrapprox: "",
		gtrarr: "",
		gtrdot: "",
		gtreqless: "",
		gtreqqless: "",
		gtrless: "",
		gtrsim: "",
		gvertneqq,
		gvnE,
		Hacek: "",
		hairsp: "",
		half: "",
		hamilt: "",
		HARDcy: "",
		hardcy: "",
		harrcir: "",
		harr: "",
		hArr: "",
		harrw: "",
		Hat: "^",
		hbar: "",
		Hcirc: "",
		hcirc: "",
		hearts: "",
		heartsuit: "",
		hellip: "",
		hercon: "",
		hfr,
		Hfr: "",
		HilbertSpace: "",
		hksearow: "",
		hkswarow: "",
		hoarr: "",
		homtht: "",
		hookleftarrow: "",
		hookrightarrow: "",
		hopf,
		Hopf: "",
		horbar: "",
		HorizontalLine: "",
		hscr,
		Hscr: "",
		hslash: "",
		Hstrok: "",
		hstrok: "",
		HumpDownHump: "",
		HumpEqual: "",
		hybull: "",
		hyphen: "",
		Iacute: "",
		iacute: "",
		ic: "",
		Icirc: "",
		icirc: "",
		Icy: "",
		icy: "",
		Idot: "",
		IEcy: "",
		iecy: "",
		iexcl: "",
		iff: "",
		ifr,
		Ifr: "",
		Igrave: "",
		igrave: "",
		ii: "",
		iiiint: "",
		iiint: "",
		iinfin: "",
		iiota: "",
		IJlig: "",
		ijlig: "",
		Imacr: "",
		imacr: "",
		image: "",
		ImaginaryI: "",
		imagline: "",
		imagpart: "",
		imath: "",
		Im: "",
		imof: "",
		imped: "",
		Implies: "",
		incare: "",
		"in": "",
		infin: "",
		infintie: "",
		inodot: "",
		intcal: "",
		int: "",
		Int: "",
		integers: "",
		Integral: "",
		intercal: "",
		Intersection: "",
		intlarhk: "",
		intprod: "",
		InvisibleComma: "",
		InvisibleTimes: "",
		IOcy: "",
		iocy: "",
		Iogon: "",
		iogon: "",
		Iopf,
		iopf,
		Iota: "",
		iota: "",
		iprod: "",
		iquest: "",
		iscr,
		Iscr: "",
		isin: "",
		isindot: "",
		isinE: "",
		isins: "",
		isinsv: "",
		isinv: "",
		it: "",
		Itilde: "",
		itilde: "",
		Iukcy: "",
		iukcy: "",
		Iuml: "",
		iuml: "",
		Jcirc: "",
		jcirc: "",
		Jcy: "",
		jcy: "",
		Jfr,
		jfr,
		jmath: "",
		Jopf,
		jopf,
		Jscr,
		jscr,
		Jsercy: "",
		jsercy: "",
		Jukcy: "",
		jukcy: "",
		Kappa: "",
		kappa: "",
		kappav: "",
		Kcedil: "",
		kcedil: "",
		Kcy: "",
		kcy: "",
		Kfr,
		kfr,
		kgreen: "",
		KHcy: "",
		khcy: "",
		KJcy: "",
		kjcy: "",
		Kopf,
		kopf,
		Kscr,
		kscr,
		lAarr: "",
		Lacute: "",
		lacute: "",
		laemptyv: "",
		lagran: "",
		Lambda: "",
		lambda: "",
		lang: "",
		Lang: "",
		langd: "",
		langle: "",
		lap: "",
		Laplacetrf: "",
		laquo: "",
		larrb: "",
		larrbfs: "",
		larr: "",
		Larr: "",
		lArr: "",
		larrfs: "",
		larrhk: "",
		larrlp: "",
		larrpl: "",
		larrsim: "",
		larrtl: "",
		latail: "",
		lAtail: "",
		lat: "",
		late: "",
		lates,
		lbarr: "",
		lBarr: "",
		lbbrk: "",
		lbrace: "{",
		lbrack: "[",
		lbrke: "",
		lbrksld: "",
		lbrkslu: "",
		Lcaron: "",
		lcaron: "",
		Lcedil: "",
		lcedil: "",
		lceil: "",
		lcub: "{",
		Lcy: "",
		lcy: "",
		ldca: "",
		ldquo: "",
		ldquor: "",
		ldrdhar: "",
		ldrushar: "",
		ldsh: "",
		le: "",
		lE: "",
		LeftAngleBracket: "",
		LeftArrowBar: "",
		leftarrow: "",
		LeftArrow: "",
		Leftarrow: "",
		LeftArrowRightArrow: "",
		leftarrowtail: "",
		LeftCeiling: "",
		LeftDoubleBracket: "",
		LeftDownTeeVector: "",
		LeftDownVectorBar: "",
		LeftDownVector: "",
		LeftFloor: "",
		leftharpoondown: "",
		leftharpoonup: "",
		leftleftarrows: "",
		leftrightarrow: "",
		LeftRightArrow: "",
		Leftrightarrow: "",
		leftrightarrows: "",
		leftrightharpoons: "",
		leftrightsquigarrow: "",
		LeftRightVector: "",
		LeftTeeArrow: "",
		LeftTee: "",
		LeftTeeVector: "",
		leftthreetimes: "",
		LeftTriangleBar: "",
		LeftTriangle: "",
		LeftTriangleEqual: "",
		LeftUpDownVector: "",
		LeftUpTeeVector: "",
		LeftUpVectorBar: "",
		LeftUpVector: "",
		LeftVectorBar: "",
		LeftVector: "",
		lEg: "",
		leg: "",
		leq: "",
		leqq: "",
		leqslant: "",
		lescc: "",
		les: "",
		lesdot: "",
		lesdoto: "",
		lesdotor: "",
		lesg,
		lesges: "",
		lessapprox: "",
		lessdot: "",
		lesseqgtr: "",
		lesseqqgtr: "",
		LessEqualGreater: "",
		LessFullEqual: "",
		LessGreater: "",
		lessgtr: "",
		LessLess: "",
		lesssim: "",
		LessSlantEqual: "",
		LessTilde: "",
		lfisht: "",
		lfloor: "",
		Lfr,
		lfr,
		lg: "",
		lgE: "",
		lHar: "",
		lhard: "",
		lharu: "",
		lharul: "",
		lhblk: "",
		LJcy: "",
		ljcy: "",
		llarr: "",
		ll: "",
		Ll: "",
		llcorner: "",
		Lleftarrow: "",
		llhard: "",
		lltri: "",
		Lmidot: "",
		lmidot: "",
		lmoustache: "",
		lmoust: "",
		lnap: "",
		lnapprox: "",
		lne: "",
		lnE: "",
		lneq: "",
		lneqq: "",
		lnsim: "",
		loang: "",
		loarr: "",
		lobrk: "",
		longleftarrow: "",
		LongLeftArrow: "",
		Longleftarrow: "",
		longleftrightarrow: "",
		LongLeftRightArrow: "",
		Longleftrightarrow: "",
		longmapsto: "",
		longrightarrow: "",
		LongRightArrow: "",
		Longrightarrow: "",
		looparrowleft: "",
		looparrowright: "",
		lopar: "",
		Lopf,
		lopf,
		loplus: "",
		lotimes: "",
		lowast: "",
		lowbar: "_",
		LowerLeftArrow: "",
		LowerRightArrow: "",
		loz: "",
		lozenge: "",
		lozf: "",
		lpar: "(",
		lparlt: "",
		lrarr: "",
		lrcorner: "",
		lrhar: "",
		lrhard: "",
		lrm: "",
		lrtri: "",
		lsaquo: "",
		lscr,
		Lscr: "",
		lsh: "",
		Lsh: "",
		lsim: "",
		lsime: "",
		lsimg: "",
		lsqb: "[",
		lsquo: "",
		lsquor: "",
		Lstrok: "",
		lstrok: "",
		ltcc: "",
		ltcir: "",
		lt: "<",
		LT: "<",
		Lt: "",
		ltdot: "",
		lthree: "",
		ltimes: "",
		ltlarr: "",
		ltquest: "",
		ltri: "",
		ltrie: "",
		ltrif: "",
		ltrPar: "",
		lurdshar: "",
		luruhar: "",
		lvertneqq,
		lvnE,
		macr: "",
		male: "",
		malt: "",
		maltese: "",
		Map: "",
		map: "",
		mapsto: "",
		mapstodown: "",
		mapstoleft: "",
		mapstoup: "",
		marker: "",
		mcomma: "",
		Mcy: "",
		mcy: "",
		mdash: "",
		mDDot: "",
		measuredangle: "",
		MediumSpace: "",
		Mellintrf: "",
		Mfr,
		mfr,
		mho: "",
		micro: "",
		midast: "*",
		midcir: "",
		mid: "",
		middot: "",
		minusb: "",
		minus: "",
		minusd: "",
		minusdu: "",
		MinusPlus: "",
		mlcp: "",
		mldr: "",
		mnplus: "",
		models: "",
		Mopf,
		mopf,
		mp: "",
		mscr,
		Mscr: "",
		mstpos: "",
		Mu: "",
		mu: "",
		multimap: "",
		mumap: "",
		nabla: "",
		Nacute: "",
		nacute: "",
		nang,
		nap: "",
		napE,
		napid,
		napos: "",
		napprox: "",
		natural: "",
		naturals: "",
		natur: "",
		nbsp: "\xA0",
		nbump,
		nbumpe,
		ncap: "",
		Ncaron: "",
		ncaron: "",
		Ncedil: "",
		ncedil: "",
		ncong: "",
		ncongdot,
		ncup: "",
		Ncy: "",
		ncy: "",
		ndash: "",
		nearhk: "",
		nearr: "",
		neArr: "",
		nearrow: "",
		ne: "",
		nedot,
		NegativeMediumSpace: "",
		NegativeThickSpace: "",
		NegativeThinSpace: "",
		NegativeVeryThinSpace: "",
		nequiv: "",
		nesear: "",
		nesim,
		NestedGreaterGreater: "",
		NestedLessLess: "",
		NewLine: "\n",
		nexist: "",
		nexists: "",
		Nfr,
		nfr,
		ngE,
		nge: "",
		ngeq: "",
		ngeqq,
		ngeqslant,
		nges,
		nGg,
		ngsim: "",
		nGt,
		ngt: "",
		ngtr: "",
		nGtv,
		nharr: "",
		nhArr: "",
		nhpar: "",
		ni: "",
		nis: "",
		nisd: "",
		niv: "",
		NJcy: "",
		njcy: "",
		nlarr: "",
		nlArr: "",
		nldr: "",
		nlE,
		nle: "",
		nleftarrow: "",
		nLeftarrow: "",
		nleftrightarrow: "",
		nLeftrightarrow: "",
		nleq: "",
		nleqq,
		nleqslant,
		nles,
		nless: "",
		nLl,
		nlsim: "",
		nLt,
		nlt: "",
		nltri: "",
		nltrie: "",
		nLtv,
		nmid: "",
		NoBreak: "",
		NonBreakingSpace: "\xA0",
		nopf,
		Nopf: "",
		Not: "",
		not: "",
		NotCongruent: "",
		NotCupCap: "",
		NotDoubleVerticalBar: "",
		NotElement: "",
		NotEqual: "",
		NotEqualTilde,
		NotExists: "",
		NotGreater: "",
		NotGreaterEqual: "",
		NotGreaterFullEqual,
		NotGreaterGreater,
		NotGreaterLess: "",
		NotGreaterSlantEqual,
		NotGreaterTilde: "",
		NotHumpDownHump,
		NotHumpEqual,
		notin: "",
		notindot,
		notinE,
		notinva: "",
		notinvb: "",
		notinvc: "",
		NotLeftTriangleBar,
		NotLeftTriangle: "",
		NotLeftTriangleEqual: "",
		NotLess: "",
		NotLessEqual: "",
		NotLessGreater: "",
		NotLessLess,
		NotLessSlantEqual,
		NotLessTilde: "",
		NotNestedGreaterGreater,
		NotNestedLessLess,
		notni: "",
		notniva: "",
		notnivb: "",
		notnivc: "",
		NotPrecedes: "",
		NotPrecedesEqual,
		NotPrecedesSlantEqual: "",
		NotReverseElement: "",
		NotRightTriangleBar,
		NotRightTriangle: "",
		NotRightTriangleEqual: "",
		NotSquareSubset,
		NotSquareSubsetEqual: "",
		NotSquareSuperset,
		NotSquareSupersetEqual: "",
		NotSubset,
		NotSubsetEqual: "",
		NotSucceeds: "",
		NotSucceedsEqual,
		NotSucceedsSlantEqual: "",
		NotSucceedsTilde,
		NotSuperset,
		NotSupersetEqual: "",
		NotTilde: "",
		NotTildeEqual: "",
		NotTildeFullEqual: "",
		NotTildeTilde: "",
		NotVerticalBar: "",
		nparallel: "",
		npar: "",
		nparsl,
		npart,
		npolint: "",
		npr: "",
		nprcue: "",
		nprec: "",
		npreceq,
		npre,
		nrarrc,
		nrarr: "",
		nrArr: "",
		nrarrw,
		nrightarrow: "",
		nRightarrow: "",
		nrtri: "",
		nrtrie: "",
		nsc: "",
		nsccue: "",
		nsce,
		Nscr,
		nscr,
		nshortmid: "",
		nshortparallel: "",
		nsim: "",
		nsime: "",
		nsimeq: "",
		nsmid: "",
		nspar: "",
		nsqsube: "",
		nsqsupe: "",
		nsub: "",
		nsubE,
		nsube: "",
		nsubset,
		nsubseteq: "",
		nsubseteqq,
		nsucc: "",
		nsucceq,
		nsup: "",
		nsupE,
		nsupe: "",
		nsupset,
		nsupseteq: "",
		nsupseteqq,
		ntgl: "",
		Ntilde: "",
		ntilde: "",
		ntlg: "",
		ntriangleleft: "",
		ntrianglelefteq: "",
		ntriangleright: "",
		ntrianglerighteq: "",
		Nu: "",
		nu: "",
		num: "#",
		numero: "",
		numsp: "",
		nvap,
		nvdash: "",
		nvDash: "",
		nVdash: "",
		nVDash: "",
		nvge,
		nvgt,
		nvHarr: "",
		nvinfin: "",
		nvlArr: "",
		nvle,
		nvlt,
		nvltrie,
		nvrArr: "",
		nvrtrie,
		nvsim,
		nwarhk: "",
		nwarr: "",
		nwArr: "",
		nwarrow: "",
		nwnear: "",
		Oacute: "",
		oacute: "",
		oast: "",
		Ocirc: "",
		ocirc: "",
		ocir: "",
		Ocy: "",
		ocy: "",
		odash: "",
		Odblac: "",
		odblac: "",
		odiv: "",
		odot: "",
		odsold: "",
		OElig: "",
		oelig: "",
		ofcir: "",
		Ofr,
		ofr,
		ogon: "",
		Ograve: "",
		ograve: "",
		ogt: "",
		ohbar: "",
		ohm: "",
		oint: "",
		olarr: "",
		olcir: "",
		olcross: "",
		oline: "",
		olt: "",
		Omacr: "",
		omacr: "",
		Omega: "",
		omega: "",
		Omicron: "",
		omicron: "",
		omid: "",
		ominus: "",
		Oopf,
		oopf,
		opar: "",
		OpenCurlyDoubleQuote: "",
		OpenCurlyQuote: "",
		operp: "",
		oplus: "",
		orarr: "",
		Or: "",
		or: "",
		ord: "",
		order: "",
		orderof: "",
		ordf: "",
		ordm: "",
		origof: "",
		oror: "",
		orslope: "",
		orv: "",
		oS: "",
		Oscr,
		oscr: "",
		Oslash: "",
		oslash: "",
		osol: "",
		Otilde: "",
		otilde: "",
		otimesas: "",
		Otimes: "",
		otimes: "",
		Ouml: "",
		ouml: "",
		ovbar: "",
		OverBar: "",
		OverBrace: "",
		OverBracket: "",
		OverParenthesis: "",
		para: "",
		parallel: "",
		par: "",
		parsim: "",
		parsl: "",
		part: "",
		PartialD: "",
		Pcy: "",
		pcy: "",
		percnt: "%",
		period: ".",
		permil: "",
		perp: "",
		pertenk: "",
		Pfr,
		pfr,
		Phi: "",
		phi: "",
		phiv: "",
		phmmat: "",
		phone: "",
		Pi: "",
		pi: "",
		pitchfork: "",
		piv: "",
		planck: "",
		planckh: "",
		plankv: "",
		plusacir: "",
		plusb: "",
		pluscir: "",
		plus: "+",
		plusdo: "",
		plusdu: "",
		pluse: "",
		PlusMinus: "",
		plusmn: "",
		plussim: "",
		plustwo: "",
		pm: "",
		Poincareplane: "",
		pointint: "",
		popf,
		Popf: "",
		pound: "",
		prap: "",
		Pr: "",
		pr: "",
		prcue: "",
		precapprox: "",
		prec: "",
		preccurlyeq: "",
		Precedes: "",
		PrecedesEqual: "",
		PrecedesSlantEqual: "",
		PrecedesTilde: "",
		preceq: "",
		precnapprox: "",
		precneqq: "",
		precnsim: "",
		pre: "",
		prE: "",
		precsim: "",
		prime: "",
		Prime: "",
		primes: "",
		prnap: "",
		prnE: "",
		prnsim: "",
		prod: "",
		Product: "",
		profalar: "",
		profline: "",
		profsurf: "",
		prop: "",
		Proportional: "",
		Proportion: "",
		propto: "",
		prsim: "",
		prurel: "",
		Pscr,
		pscr,
		Psi: "",
		psi: "",
		puncsp: "",
		Qfr,
		qfr,
		qint: "",
		qopf,
		Qopf: "",
		qprime: "",
		Qscr,
		qscr,
		quaternions: "",
		quatint: "",
		quest: "?",
		questeq: "",
		quot: "\"",
		QUOT: "\"",
		rAarr: "",
		race,
		Racute: "",
		racute: "",
		radic: "",
		raemptyv: "",
		rang: "",
		Rang: "",
		rangd: "",
		range: "",
		rangle: "",
		raquo: "",
		rarrap: "",
		rarrb: "",
		rarrbfs: "",
		rarrc: "",
		rarr: "",
		Rarr: "",
		rArr: "",
		rarrfs: "",
		rarrhk: "",
		rarrlp: "",
		rarrpl: "",
		rarrsim: "",
		Rarrtl: "",
		rarrtl: "",
		rarrw: "",
		ratail: "",
		rAtail: "",
		ratio: "",
		rationals: "",
		rbarr: "",
		rBarr: "",
		RBarr: "",
		rbbrk: "",
		rbrace: "}",
		rbrack: "]",
		rbrke: "",
		rbrksld: "",
		rbrkslu: "",
		Rcaron: "",
		rcaron: "",
		Rcedil: "",
		rcedil: "",
		rceil: "",
		rcub: "}",
		Rcy: "",
		rcy: "",
		rdca: "",
		rdldhar: "",
		rdquo: "",
		rdquor: "",
		rdsh: "",
		real: "",
		realine: "",
		realpart: "",
		reals: "",
		Re: "",
		rect: "",
		reg: "",
		REG: "",
		ReverseElement: "",
		ReverseEquilibrium: "",
		ReverseUpEquilibrium: "",
		rfisht: "",
		rfloor: "",
		rfr,
		Rfr: "",
		rHar: "",
		rhard: "",
		rharu: "",
		rharul: "",
		Rho: "",
		rho: "",
		rhov: "",
		RightAngleBracket: "",
		RightArrowBar: "",
		rightarrow: "",
		RightArrow: "",
		Rightarrow: "",
		RightArrowLeftArrow: "",
		rightarrowtail: "",
		RightCeiling: "",
		RightDoubleBracket: "",
		RightDownTeeVector: "",
		RightDownVectorBar: "",
		RightDownVector: "",
		RightFloor: "",
		rightharpoondown: "",
		rightharpoonup: "",
		rightleftarrows: "",
		rightleftharpoons: "",
		rightrightarrows: "",
		rightsquigarrow: "",
		RightTeeArrow: "",
		RightTee: "",
		RightTeeVector: "",
		rightthreetimes: "",
		RightTriangleBar: "",
		RightTriangle: "",
		RightTriangleEqual: "",
		RightUpDownVector: "",
		RightUpTeeVector: "",
		RightUpVectorBar: "",
		RightUpVector: "",
		RightVectorBar: "",
		RightVector: "",
		ring: "",
		risingdotseq: "",
		rlarr: "",
		rlhar: "",
		rlm: "",
		rmoustache: "",
		rmoust: "",
		rnmid: "",
		roang: "",
		roarr: "",
		robrk: "",
		ropar: "",
		ropf,
		Ropf: "",
		roplus: "",
		rotimes: "",
		RoundImplies: "",
		rpar: ")",
		rpargt: "",
		rppolint: "",
		rrarr: "",
		Rrightarrow: "",
		rsaquo: "",
		rscr,
		Rscr: "",
		rsh: "",
		Rsh: "",
		rsqb: "]",
		rsquo: "",
		rsquor: "",
		rthree: "",
		rtimes: "",
		rtri: "",
		rtrie: "",
		rtrif: "",
		rtriltri: "",
		RuleDelayed: "",
		ruluhar: "",
		rx: "",
		Sacute: "",
		sacute: "",
		sbquo: "",
		scap: "",
		Scaron: "",
		scaron: "",
		Sc: "",
		sc: "",
		sccue: "",
		sce: "",
		scE: "",
		Scedil: "",
		scedil: "",
		Scirc: "",
		scirc: "",
		scnap: "",
		scnE: "",
		scnsim: "",
		scpolint: "",
		scsim: "",
		Scy: "",
		scy: "",
		sdotb: "",
		sdot: "",
		sdote: "",
		searhk: "",
		searr: "",
		seArr: "",
		searrow: "",
		sect: "",
		semi: ";",
		seswar: "",
		setminus: "",
		setmn: "",
		sext: "",
		Sfr,
		sfr,
		sfrown: "",
		sharp: "",
		SHCHcy: "",
		shchcy: "",
		SHcy: "",
		shcy: "",
		ShortDownArrow: "",
		ShortLeftArrow: "",
		shortmid: "",
		shortparallel: "",
		ShortRightArrow: "",
		ShortUpArrow: "",
		shy: "",
		Sigma: "",
		sigma: "",
		sigmaf: "",
		sigmav: "",
		sim: "",
		simdot: "",
		sime: "",
		simeq: "",
		simg: "",
		simgE: "",
		siml: "",
		simlE: "",
		simne: "",
		simplus: "",
		simrarr: "",
		slarr: "",
		SmallCircle: "",
		smallsetminus: "",
		smashp: "",
		smeparsl: "",
		smid: "",
		smile: "",
		smt: "",
		smte: "",
		smtes,
		SOFTcy: "",
		softcy: "",
		solbar: "",
		solb: "",
		sol: "/",
		Sopf,
		sopf,
		spades: "",
		spadesuit: "",
		spar: "",
		sqcap: "",
		sqcaps,
		sqcup: "",
		sqcups,
		Sqrt: "",
		sqsub: "",
		sqsube: "",
		sqsubset: "",
		sqsubseteq: "",
		sqsup: "",
		sqsupe: "",
		sqsupset: "",
		sqsupseteq: "",
		square: "",
		Square: "",
		SquareIntersection: "",
		SquareSubset: "",
		SquareSubsetEqual: "",
		SquareSuperset: "",
		SquareSupersetEqual: "",
		SquareUnion: "",
		squarf: "",
		squ: "",
		squf: "",
		srarr: "",
		Sscr,
		sscr,
		ssetmn: "",
		ssmile: "",
		sstarf: "",
		Star: "",
		star: "",
		starf: "",
		straightepsilon: "",
		straightphi: "",
		strns: "",
		sub: "",
		Sub: "",
		subdot: "",
		subE: "",
		sube: "",
		subedot: "",
		submult: "",
		subnE: "",
		subne: "",
		subplus: "",
		subrarr: "",
		subset: "",
		Subset: "",
		subseteq: "",
		subseteqq: "",
		SubsetEqual: "",
		subsetneq: "",
		subsetneqq: "",
		subsim: "",
		subsub: "",
		subsup: "",
		succapprox: "",
		succ: "",
		succcurlyeq: "",
		Succeeds: "",
		SucceedsEqual: "",
		SucceedsSlantEqual: "",
		SucceedsTilde: "",
		succeq: "",
		succnapprox: "",
		succneqq: "",
		succnsim: "",
		succsim: "",
		SuchThat: "",
		sum: "",
		Sum: "",
		sung: "",
		sup1: "",
		sup2: "",
		sup3: "",
		sup: "",
		Sup: "",
		supdot: "",
		supdsub: "",
		supE: "",
		supe: "",
		supedot: "",
		Superset: "",
		SupersetEqual: "",
		suphsol: "",
		suphsub: "",
		suplarr: "",
		supmult: "",
		supnE: "",
		supne: "",
		supplus: "",
		supset: "",
		Supset: "",
		supseteq: "",
		supseteqq: "",
		supsetneq: "",
		supsetneqq: "",
		supsim: "",
		supsub: "",
		supsup: "",
		swarhk: "",
		swarr: "",
		swArr: "",
		swarrow: "",
		swnwar: "",
		szlig: "",
		Tab: "	",
		target: "",
		Tau: "",
		tau: "",
		tbrk: "",
		Tcaron: "",
		tcaron: "",
		Tcedil: "",
		tcedil: "",
		Tcy: "",
		tcy: "",
		tdot: "",
		telrec: "",
		Tfr,
		tfr,
		there4: "",
		therefore: "",
		Therefore: "",
		Theta: "",
		theta: "",
		thetasym: "",
		thetav: "",
		thickapprox: "",
		thicksim: "",
		ThickSpace,
		ThinSpace: "",
		thinsp: "",
		thkap: "",
		thksim: "",
		THORN: "",
		thorn: "",
		tilde: "",
		Tilde: "",
		TildeEqual: "",
		TildeFullEqual: "",
		TildeTilde: "",
		timesbar: "",
		timesb: "",
		times: "",
		timesd: "",
		tint: "",
		toea: "",
		topbot: "",
		topcir: "",
		top: "",
		Topf,
		topf,
		topfork: "",
		tosa: "",
		tprime: "",
		trade: "",
		TRADE: "",
		triangle: "",
		triangledown: "",
		triangleleft: "",
		trianglelefteq: "",
		triangleq: "",
		triangleright: "",
		trianglerighteq: "",
		tridot: "",
		trie: "",
		triminus: "",
		TripleDot: "",
		triplus: "",
		trisb: "",
		tritime: "",
		trpezium: "",
		Tscr,
		tscr,
		TScy: "",
		tscy: "",
		TSHcy: "",
		tshcy: "",
		Tstrok: "",
		tstrok: "",
		twixt: "",
		twoheadleftarrow: "",
		twoheadrightarrow: "",
		Uacute: "",
		uacute: "",
		uarr: "",
		Uarr: "",
		uArr: "",
		Uarrocir: "",
		Ubrcy: "",
		ubrcy: "",
		Ubreve: "",
		ubreve: "",
		Ucirc: "",
		ucirc: "",
		Ucy: "",
		ucy: "",
		udarr: "",
		Udblac: "",
		udblac: "",
		udhar: "",
		ufisht: "",
		Ufr,
		ufr,
		Ugrave: "",
		ugrave: "",
		uHar: "",
		uharl: "",
		uharr: "",
		uhblk: "",
		ulcorn: "",
		ulcorner: "",
		ulcrop: "",
		ultri: "",
		Umacr: "",
		umacr: "",
		uml: "",
		UnderBar: "_",
		UnderBrace: "",
		UnderBracket: "",
		UnderParenthesis: "",
		Union: "",
		UnionPlus: "",
		Uogon: "",
		uogon: "",
		Uopf,
		uopf,
		UpArrowBar: "",
		uparrow: "",
		UpArrow: "",
		Uparrow: "",
		UpArrowDownArrow: "",
		updownarrow: "",
		UpDownArrow: "",
		Updownarrow: "",
		UpEquilibrium: "",
		upharpoonleft: "",
		upharpoonright: "",
		uplus: "",
		UpperLeftArrow: "",
		UpperRightArrow: "",
		upsi: "",
		Upsi: "",
		upsih: "",
		Upsilon: "",
		upsilon: "",
		UpTeeArrow: "",
		UpTee: "",
		upuparrows: "",
		urcorn: "",
		urcorner: "",
		urcrop: "",
		Uring: "",
		uring: "",
		urtri: "",
		Uscr,
		uscr,
		utdot: "",
		Utilde: "",
		utilde: "",
		utri: "",
		utrif: "",
		uuarr: "",
		Uuml: "",
		uuml: "",
		uwangle: "",
		vangrt: "",
		varepsilon: "",
		varkappa: "",
		varnothing: "",
		varphi: "",
		varpi: "",
		varpropto: "",
		varr: "",
		vArr: "",
		varrho: "",
		varsigma: "",
		varsubsetneq,
		varsubsetneqq,
		varsupsetneq,
		varsupsetneqq,
		vartheta: "",
		vartriangleleft: "",
		vartriangleright: "",
		vBar: "",
		Vbar: "",
		vBarv: "",
		Vcy: "",
		vcy: "",
		vdash: "",
		vDash: "",
		Vdash: "",
		VDash: "",
		Vdashl: "",
		veebar: "",
		vee: "",
		Vee: "",
		veeeq: "",
		vellip: "",
		verbar: "|",
		Verbar: "",
		vert: "|",
		Vert: "",
		VerticalBar: "",
		VerticalLine: "|",
		VerticalSeparator: "",
		VerticalTilde: "",
		VeryThinSpace: "",
		Vfr,
		vfr,
		vltri: "",
		vnsub,
		vnsup,
		Vopf,
		vopf,
		vprop: "",
		vrtri: "",
		Vscr,
		vscr,
		vsubnE,
		vsubne,
		vsupnE,
		vsupne,
		Vvdash: "",
		vzigzag: "",
		Wcirc: "",
		wcirc: "",
		wedbar: "",
		wedge: "",
		Wedge: "",
		wedgeq: "",
		weierp: "",
		Wfr,
		wfr,
		Wopf,
		wopf,
		wp: "",
		wr: "",
		wreath: "",
		Wscr,
		wscr,
		xcap: "",
		xcirc: "",
		xcup: "",
		xdtri: "",
		Xfr,
		xfr,
		xharr: "",
		xhArr: "",
		Xi: "",
		xi: "",
		xlarr: "",
		xlArr: "",
		xmap: "",
		xnis: "",
		xodot: "",
		Xopf,
		xopf,
		xoplus: "",
		xotime: "",
		xrarr: "",
		xrArr: "",
		Xscr,
		xscr,
		xsqcup: "",
		xuplus: "",
		xutri: "",
		xvee: "",
		xwedge: "",
		Yacute: "",
		yacute: "",
		YAcy: "",
		yacy: "",
		Ycirc: "",
		ycirc: "",
		Ycy: "",
		ycy: "",
		yen: "",
		Yfr,
		yfr,
		YIcy: "",
		yicy: "",
		Yopf,
		yopf,
		Yscr,
		yscr,
		YUcy: "",
		yucy: "",
		yuml: "",
		Yuml: "",
		Zacute: "",
		zacute: "",
		Zcaron: "",
		zcaron: "",
		Zcy: "",
		zcy: "",
		Zdot: "",
		zdot: "",
		zeetrf: "",
		ZeroWidthSpace: "",
		Zeta: "",
		zeta: "",
		zfr,
		Zfr: "",
		ZHcy: "",
		zhcy: "",
		zigrarr: "",
		zopf,
		Zopf: "",
		Zscr,
		zscr,
		zwj: "",
		zwnj: ""
	};
}));
var require_entities = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = (init_entities(), __toCommonJS(entities_exports).default);
}));
var require_regex$4 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4E\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;
}));
var require_encode = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var encodeCache = {};
	function getEncodeCache(exclude) {
		var i$1, ch, cache$1 = encodeCache[exclude];
		if (cache$1) return cache$1;
		cache$1 = encodeCache[exclude] = [];
		for (i$1 = 0; i$1 < 128; i$1++) {
			ch = String.fromCharCode(i$1);
			if (/^[0-9a-z]$/i.test(ch)) cache$1.push(ch);
			else cache$1.push("%" + ("0" + i$1.toString(16).toUpperCase()).slice(-2));
		}
		for (i$1 = 0; i$1 < exclude.length; i$1++) cache$1[exclude.charCodeAt(i$1)] = exclude[i$1];
		return cache$1;
	}
	function encode(string, exclude, keepEscaped) {
		var i$1, l, code, nextCode, cache$1, result = "";
		if (typeof exclude !== "string") {
			keepEscaped = exclude;
			exclude = encode.defaultChars;
		}
		if (typeof keepEscaped === "undefined") keepEscaped = true;
		cache$1 = getEncodeCache(exclude);
		for (i$1 = 0, l = string.length; i$1 < l; i$1++) {
			code = string.charCodeAt(i$1);
			if (keepEscaped && code === 37 && i$1 + 2 < l) {
				if (/^[0-9a-f]{2}$/i.test(string.slice(i$1 + 1, i$1 + 3))) {
					result += string.slice(i$1, i$1 + 3);
					i$1 += 2;
					continue;
				}
			}
			if (code < 128) {
				result += cache$1[code];
				continue;
			}
			if (code >= 55296 && code <= 57343) {
				if (code >= 55296 && code <= 56319 && i$1 + 1 < l) {
					nextCode = string.charCodeAt(i$1 + 1);
					if (nextCode >= 56320 && nextCode <= 57343) {
						result += encodeURIComponent(string[i$1] + string[i$1 + 1]);
						i$1++;
						continue;
					}
				}
				result += "%EF%BF%BD";
				continue;
			}
			result += encodeURIComponent(string[i$1]);
		}
		return result;
	}
	encode.defaultChars = ";/?:@&=+$,-_.!~*'()#";
	encode.componentChars = "-_.!~*'()";
	module.exports = encode;
}));
var require_decode = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var decodeCache = {};
	function getDecodeCache(exclude) {
		var i$1, ch, cache$1 = decodeCache[exclude];
		if (cache$1) return cache$1;
		cache$1 = decodeCache[exclude] = [];
		for (i$1 = 0; i$1 < 128; i$1++) {
			ch = String.fromCharCode(i$1);
			cache$1.push(ch);
		}
		for (i$1 = 0; i$1 < exclude.length; i$1++) {
			ch = exclude.charCodeAt(i$1);
			cache$1[ch] = "%" + ("0" + ch.toString(16).toUpperCase()).slice(-2);
		}
		return cache$1;
	}
	function decode(string, exclude) {
		var cache$1;
		if (typeof exclude !== "string") exclude = decode.defaultChars;
		cache$1 = getDecodeCache(exclude);
		return string.replace(/(%[a-f0-9]{2})+/gi, function(seq) {
			var i$1, l, b1, b2, b3, b4, chr, result = "";
			for (i$1 = 0, l = seq.length; i$1 < l; i$1 += 3) {
				b1 = parseInt(seq.slice(i$1 + 1, i$1 + 3), 16);
				if (b1 < 128) {
					result += cache$1[b1];
					continue;
				}
				if ((b1 & 224) === 192 && i$1 + 3 < l) {
					b2 = parseInt(seq.slice(i$1 + 4, i$1 + 6), 16);
					if ((b2 & 192) === 128) {
						chr = b1 << 6 & 1984 | b2 & 63;
						if (chr < 128) result += "";
						else result += String.fromCharCode(chr);
						i$1 += 3;
						continue;
					}
				}
				if ((b1 & 240) === 224 && i$1 + 6 < l) {
					b2 = parseInt(seq.slice(i$1 + 4, i$1 + 6), 16);
					b3 = parseInt(seq.slice(i$1 + 7, i$1 + 9), 16);
					if ((b2 & 192) === 128 && (b3 & 192) === 128) {
						chr = b1 << 12 & 61440 | b2 << 6 & 4032 | b3 & 63;
						if (chr < 2048 || chr >= 55296 && chr <= 57343) result += "";
						else result += String.fromCharCode(chr);
						i$1 += 6;
						continue;
					}
				}
				if ((b1 & 248) === 240 && i$1 + 9 < l) {
					b2 = parseInt(seq.slice(i$1 + 4, i$1 + 6), 16);
					b3 = parseInt(seq.slice(i$1 + 7, i$1 + 9), 16);
					b4 = parseInt(seq.slice(i$1 + 10, i$1 + 12), 16);
					if ((b2 & 192) === 128 && (b3 & 192) === 128 && (b4 & 192) === 128) {
						chr = b1 << 18 & 1835008 | b2 << 12 & 258048 | b3 << 6 & 4032 | b4 & 63;
						if (chr < 65536 || chr > 1114111) result += "";
						else {
							chr -= 65536;
							result += String.fromCharCode(55296 + (chr >> 10), 56320 + (chr & 1023));
						}
						i$1 += 9;
						continue;
					}
				}
				result += "";
			}
			return result;
		});
	}
	decode.defaultChars = ";/?:@&=+$,#";
	decode.componentChars = "";
	module.exports = decode;
}));
var require_format = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = function format$1(url) {
		var result = "";
		result += url.protocol || "";
		result += url.slashes ? "//" : "";
		result += url.auth ? url.auth + "@" : "";
		if (url.hostname && url.hostname.indexOf(":") !== -1) result += "[" + url.hostname + "]";
		else result += url.hostname || "";
		result += url.port ? ":" + url.port : "";
		result += url.pathname || "";
		result += url.search || "";
		result += url.hash || "";
		return result;
	};
}));
var require_parse = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function Url() {
		this.protocol = null;
		this.slashes = null;
		this.auth = null;
		this.port = null;
		this.hostname = null;
		this.hash = null;
		this.search = null;
		this.pathname = null;
	}
	var protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/, simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, unwise = [
		"{",
		"}",
		"|",
		"\\",
		"^",
		"`"
	].concat([
		"<",
		">",
		"\"",
		"`",
		" ",
		"\r",
		"\n",
		"	"
	]), autoEscape = ["'"].concat(unwise), nonHostChars = [
		"%",
		"/",
		"?",
		";",
		"#"
	].concat(autoEscape), hostEndingChars = [
		"/",
		"?",
		"#"
	], hostnameMaxLen = 255, hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, hostlessProtocol = {
		"javascript": true,
		"javascript:": true
	}, slashedProtocol = {
		"http": true,
		"https": true,
		"ftp": true,
		"gopher": true,
		"file": true,
		"http:": true,
		"https:": true,
		"ftp:": true,
		"gopher:": true,
		"file:": true
	};
	function urlParse(url, slashesDenoteHost) {
		if (url && url instanceof Url) return url;
		var u$1 = new Url();
		u$1.parse(url, slashesDenoteHost);
		return u$1;
	}
	Url.prototype.parse = function(url, slashesDenoteHost) {
		var i$1, l, lowerProto, hec, slashes, rest = url;
		rest = rest.trim();
		if (!slashesDenoteHost && url.split("#").length === 1) {
			var simplePath = simplePathPattern.exec(rest);
			if (simplePath) {
				this.pathname = simplePath[1];
				if (simplePath[2]) this.search = simplePath[2];
				return this;
			}
		}
		var proto = protocolPattern.exec(rest);
		if (proto) {
			proto = proto[0];
			lowerProto = proto.toLowerCase();
			this.protocol = proto;
			rest = rest.substr(proto.length);
		}
		if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
			slashes = rest.substr(0, 2) === "//";
			if (slashes && !(proto && hostlessProtocol[proto])) {
				rest = rest.substr(2);
				this.slashes = true;
			}
		}
		if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
			var hostEnd = -1;
			for (i$1 = 0; i$1 < hostEndingChars.length; i$1++) {
				hec = rest.indexOf(hostEndingChars[i$1]);
				if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
			}
			var auth, atSign;
			if (hostEnd === -1) atSign = rest.lastIndexOf("@");
			else atSign = rest.lastIndexOf("@", hostEnd);
			if (atSign !== -1) {
				auth = rest.slice(0, atSign);
				rest = rest.slice(atSign + 1);
				this.auth = auth;
			}
			hostEnd = -1;
			for (i$1 = 0; i$1 < nonHostChars.length; i$1++) {
				hec = rest.indexOf(nonHostChars[i$1]);
				if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
			}
			if (hostEnd === -1) hostEnd = rest.length;
			if (rest[hostEnd - 1] === ":") hostEnd--;
			var host = rest.slice(0, hostEnd);
			rest = rest.slice(hostEnd);
			this.parseHost(host);
			this.hostname = this.hostname || "";
			var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
			if (!ipv6Hostname) {
				var hostparts = this.hostname.split(/\./);
				for (i$1 = 0, l = hostparts.length; i$1 < l; i$1++) {
					var part$1 = hostparts[i$1];
					if (!part$1) continue;
					if (!part$1.match(hostnamePartPattern)) {
						var newpart = "";
						for (var j$1 = 0, k = part$1.length; j$1 < k; j$1++) if (part$1.charCodeAt(j$1) > 127) newpart += "x";
						else newpart += part$1[j$1];
						if (!newpart.match(hostnamePartPattern)) {
							var validParts = hostparts.slice(0, i$1);
							var notHost = hostparts.slice(i$1 + 1);
							var bit = part$1.match(hostnamePartStart);
							if (bit) {
								validParts.push(bit[1]);
								notHost.unshift(bit[2]);
							}
							if (notHost.length) rest = notHost.join(".") + rest;
							this.hostname = validParts.join(".");
							break;
						}
					}
				}
			}
			if (this.hostname.length > hostnameMaxLen) this.hostname = "";
			if (ipv6Hostname) this.hostname = this.hostname.substr(1, this.hostname.length - 2);
		}
		var hash$1 = rest.indexOf("#");
		if (hash$1 !== -1) {
			this.hash = rest.substr(hash$1);
			rest = rest.slice(0, hash$1);
		}
		var qm = rest.indexOf("?");
		if (qm !== -1) {
			this.search = rest.substr(qm);
			rest = rest.slice(0, qm);
		}
		if (rest) this.pathname = rest;
		if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) this.pathname = "";
		return this;
	};
	Url.prototype.parseHost = function(host) {
		var port = portPattern.exec(host);
		if (port) {
			port = port[0];
			if (port !== ":") this.port = port.substr(1);
			host = host.substr(0, host.length - port.length);
		}
		if (host) this.hostname = host;
	};
	module.exports = urlParse;
}));
var require_mdurl = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports.encode = require_encode();
	module.exports.decode = require_decode();
	module.exports.format = require_format();
	module.exports.parse = require_parse();
}));
var require_regex$3 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
}));
var require_regex$2 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = /[\0-\x1F\x7F-\x9F]/;
}));
var require_regex$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;
}));
var require_regex = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
}));
var require_uc = /* @__PURE__ */ __commonJSMin(((exports) => {
	exports.Any = require_regex$3();
	exports.Cc = require_regex$2();
	exports.Cf = require_regex$1();
	exports.P = require_regex$4();
	exports.Z = require_regex();
}));
var require_utils = /* @__PURE__ */ __commonJSMin(((exports) => {
	function _class$1(obj) {
		return Object.prototype.toString.call(obj);
	}
	function isString$1(obj) {
		return _class$1(obj) === "[object String]";
	}
	var _hasOwnProperty = Object.prototype.hasOwnProperty;
	function has$1(object, key$2) {
		return _hasOwnProperty.call(object, key$2);
	}
	function assign$2(obj) {
		Array.prototype.slice.call(arguments, 1).forEach(function(source) {
			if (!source) return;
			if (typeof source !== "object") throw new TypeError(source + "must be object");
			Object.keys(source).forEach(function(key$2) {
				obj[key$2] = source[key$2];
			});
		});
		return obj;
	}
	function arrayReplaceAt$1(src, pos, newElements) {
		return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));
	}
	function isValidEntityCode$1(c$2) {
		if (c$2 >= 55296 && c$2 <= 57343) return false;
		if (c$2 >= 64976 && c$2 <= 65007) return false;
		if ((c$2 & 65535) === 65535 || (c$2 & 65535) === 65534) return false;
		if (c$2 >= 0 && c$2 <= 8) return false;
		if (c$2 === 11) return false;
		if (c$2 >= 14 && c$2 <= 31) return false;
		if (c$2 >= 127 && c$2 <= 159) return false;
		if (c$2 > 1114111) return false;
		return true;
	}
	function fromCodePoint$1(c$2) {
		if (c$2 > 65535) {
			c$2 -= 65536;
			var surrogate1 = 55296 + (c$2 >> 10), surrogate2 = 56320 + (c$2 & 1023);
			return String.fromCharCode(surrogate1, surrogate2);
		}
		return String.fromCharCode(c$2);
	}
	var UNESCAPE_MD_RE = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g;
	var UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + "|" + /&([a-z#][a-z0-9]{1,31});/gi.source, "gi");
	var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))$/i;
	var entities$1 = require_entities();
	function replaceEntityPattern(match, name$1) {
		var code;
		if (has$1(entities$1, name$1)) return entities$1[name$1];
		if (name$1.charCodeAt(0) === 35 && DIGITAL_ENTITY_TEST_RE.test(name$1)) {
			code = name$1[1].toLowerCase() === "x" ? parseInt(name$1.slice(2), 16) : parseInt(name$1.slice(1), 10);
			if (isValidEntityCode$1(code)) return fromCodePoint$1(code);
		}
		return match;
	}
	function unescapeMd(str) {
		if (str.indexOf("\\") < 0) return str;
		return str.replace(UNESCAPE_MD_RE, "$1");
	}
	function unescapeAll$3(str) {
		if (str.indexOf("\\") < 0 && str.indexOf("&") < 0) return str;
		return str.replace(UNESCAPE_ALL_RE, function(match, escaped, entity) {
			if (escaped) return escaped;
			return replaceEntityPattern(match, entity);
		});
	}
	var HTML_ESCAPE_TEST_RE = /[&<>"]/;
	var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
	var HTML_REPLACEMENTS = {
		"&": "&amp;",
		"<": "&lt;",
		">": "&gt;",
		"\"": "&quot;"
	};
	function replaceUnsafeChar(ch) {
		return HTML_REPLACEMENTS[ch];
	}
	function escapeHtml$1(str) {
		if (HTML_ESCAPE_TEST_RE.test(str)) return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
		return str;
	}
	var REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;
	function escapeRE$1(str) {
		return str.replace(REGEXP_ESCAPE_RE, "\\$&");
	}
	function isSpace$11(code) {
		switch (code) {
			case 9:
			case 32: return true;
		}
		return false;
	}
	function isWhiteSpace$2(code) {
		if (code >= 8192 && code <= 8202) return true;
		switch (code) {
			case 9:
			case 10:
			case 11:
			case 12:
			case 13:
			case 32:
			case 160:
			case 5760:
			case 8239:
			case 8287:
			case 12288: return true;
		}
		return false;
	}
	var UNICODE_PUNCT_RE = require_regex$4();
	function isPunctChar$2(ch) {
		return UNICODE_PUNCT_RE.test(ch);
	}
	function isMdAsciiPunct$2(ch) {
		switch (ch) {
			case 33:
			case 34:
			case 35:
			case 36:
			case 37:
			case 38:
			case 39:
			case 40:
			case 41:
			case 42:
			case 43:
			case 44:
			case 45:
			case 46:
			case 47:
			case 58:
			case 59:
			case 60:
			case 61:
			case 62:
			case 63:
			case 64:
			case 91:
			case 92:
			case 93:
			case 94:
			case 95:
			case 96:
			case 123:
			case 124:
			case 125:
			case 126: return true;
			default: return false;
		}
	}
	function normalizeReference$3(str) {
		str = str.trim().replace(/\s+/g, " ");
		if ("".toLowerCase() === "") str = str.replace(//g, "");
		return str.toLowerCase().toUpperCase();
	}
	exports.lib = {};
	exports.lib.mdurl = require_mdurl();
	exports.lib.ucmicro = require_uc();
	exports.assign = assign$2;
	exports.isString = isString$1;
	exports.has = has$1;
	exports.unescapeMd = unescapeMd;
	exports.unescapeAll = unescapeAll$3;
	exports.isValidEntityCode = isValidEntityCode$1;
	exports.fromCodePoint = fromCodePoint$1;
	exports.escapeHtml = escapeHtml$1;
	exports.arrayReplaceAt = arrayReplaceAt$1;
	exports.isSpace = isSpace$11;
	exports.isWhiteSpace = isWhiteSpace$2;
	exports.isMdAsciiPunct = isMdAsciiPunct$2;
	exports.isPunctChar = isPunctChar$2;
	exports.escapeRE = escapeRE$1;
	exports.normalizeReference = normalizeReference$3;
}));
var require_parse_link_label = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = function parseLinkLabel(state, start, disableNested) {
		var level, found, marker$1, prevPos, labelEnd = -1, max$2 = state.posMax, oldPos = state.pos;
		state.pos = start + 1;
		level = 1;
		while (state.pos < max$2) {
			marker$1 = state.src.charCodeAt(state.pos);
			if (marker$1 === 93) {
				level--;
				if (level === 0) {
					found = true;
					break;
				}
			}
			prevPos = state.pos;
			state.md.inline.skipToken(state);
			if (marker$1 === 91) {
				if (prevPos === state.pos - 1) level++;
				else if (disableNested) {
					state.pos = oldPos;
					return -1;
				}
			}
		}
		if (found) labelEnd = state.pos;
		state.pos = oldPos;
		return labelEnd;
	};
}));
var require_parse_link_destination = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var unescapeAll$2 = require_utils().unescapeAll;
	module.exports = function parseLinkDestination(str, start, max$2) {
		var code, level, pos = start, result = {
			ok: false,
			pos: 0,
			lines: 0,
			str: ""
		};
		if (str.charCodeAt(pos) === 60) {
			pos++;
			while (pos < max$2) {
				code = str.charCodeAt(pos);
				if (code === 10) return result;
				if (code === 60) return result;
				if (code === 62) {
					result.pos = pos + 1;
					result.str = unescapeAll$2(str.slice(start + 1, pos));
					result.ok = true;
					return result;
				}
				if (code === 92 && pos + 1 < max$2) {
					pos += 2;
					continue;
				}
				pos++;
			}
			return result;
		}
		level = 0;
		while (pos < max$2) {
			code = str.charCodeAt(pos);
			if (code === 32) break;
			if (code < 32 || code === 127) break;
			if (code === 92 && pos + 1 < max$2) {
				if (str.charCodeAt(pos + 1) === 32) break;
				pos += 2;
				continue;
			}
			if (code === 40) {
				level++;
				if (level > 32) return result;
			}
			if (code === 41) {
				if (level === 0) break;
				level--;
			}
			pos++;
		}
		if (start === pos) return result;
		if (level !== 0) return result;
		result.str = unescapeAll$2(str.slice(start, pos));
		result.pos = pos;
		result.ok = true;
		return result;
	};
}));
var require_parse_link_title = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var unescapeAll$1 = require_utils().unescapeAll;
	module.exports = function parseLinkTitle(str, start, max$2) {
		var code, marker$1, lines = 0, pos = start, result = {
			ok: false,
			pos: 0,
			lines: 0,
			str: ""
		};
		if (pos >= max$2) return result;
		marker$1 = str.charCodeAt(pos);
		if (marker$1 !== 34 && marker$1 !== 39 && marker$1 !== 40) return result;
		pos++;
		if (marker$1 === 40) marker$1 = 41;
		while (pos < max$2) {
			code = str.charCodeAt(pos);
			if (code === marker$1) {
				result.pos = pos + 1;
				result.lines = lines;
				result.str = unescapeAll$1(str.slice(start + 1, pos));
				result.ok = true;
				return result;
			} else if (code === 40 && marker$1 === 41) return result;
			else if (code === 10) lines++;
			else if (code === 92 && pos + 1 < max$2) {
				pos++;
				if (str.charCodeAt(pos) === 10) lines++;
			}
			pos++;
		}
		return result;
	};
}));
var require_helpers = /* @__PURE__ */ __commonJSMin(((exports) => {
	exports.parseLinkLabel = require_parse_link_label();
	exports.parseLinkDestination = require_parse_link_destination();
	exports.parseLinkTitle = require_parse_link_title();
}));
var require_renderer = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var assign$1 = require_utils().assign;
	var unescapeAll = require_utils().unescapeAll;
	var escapeHtml = require_utils().escapeHtml;
	var default_rules = {};
	default_rules.code_inline = function(tokens, idx, options$1, env, slf) {
		var token = tokens[idx];
		return "<code" + slf.renderAttrs(token) + ">" + escapeHtml(token.content) + "</code>";
	};
	default_rules.code_block = function(tokens, idx, options$1, env, slf) {
		var token = tokens[idx];
		return "<pre" + slf.renderAttrs(token) + "><code>" + escapeHtml(tokens[idx].content) + "</code></pre>\n";
	};
	default_rules.fence = function(tokens, idx, options$1, env, slf) {
		var token = tokens[idx], info$3 = token.info ? unescapeAll(token.info).trim() : "", langName = "", langAttrs = "", highlighted, i$1, arr, tmpAttrs, tmpToken;
		if (info$3) {
			arr = info$3.split(/(\s+)/g);
			langName = arr[0];
			langAttrs = arr.slice(2).join("");
		}
		if (options$1.highlight) highlighted = options$1.highlight(token.content, langName, langAttrs) || escapeHtml(token.content);
		else highlighted = escapeHtml(token.content);
		if (highlighted.indexOf("<pre") === 0) return highlighted + "\n";
		if (info$3) {
			i$1 = token.attrIndex("class");
			tmpAttrs = token.attrs ? token.attrs.slice() : [];
			if (i$1 < 0) tmpAttrs.push(["class", options$1.langPrefix + langName]);
			else {
				tmpAttrs[i$1] = tmpAttrs[i$1].slice();
				tmpAttrs[i$1][1] += " " + options$1.langPrefix + langName;
			}
			tmpToken = { attrs: tmpAttrs };
			return "<pre><code" + slf.renderAttrs(tmpToken) + ">" + highlighted + "</code></pre>\n";
		}
		return "<pre><code" + slf.renderAttrs(token) + ">" + highlighted + "</code></pre>\n";
	};
	default_rules.image = function(tokens, idx, options$1, env, slf) {
		var token = tokens[idx];
		token.attrs[token.attrIndex("alt")][1] = slf.renderInlineAsText(token.children, options$1, env);
		return slf.renderToken(tokens, idx, options$1);
	};
	default_rules.hardbreak = function(tokens, idx, options$1) {
		return options$1.xhtmlOut ? "<br />\n" : "<br>\n";
	};
	default_rules.softbreak = function(tokens, idx, options$1) {
		return options$1.breaks ? options$1.xhtmlOut ? "<br />\n" : "<br>\n" : "\n";
	};
	default_rules.text = function(tokens, idx) {
		return escapeHtml(tokens[idx].content);
	};
	default_rules.html_block = function(tokens, idx) {
		return tokens[idx].content;
	};
	default_rules.html_inline = function(tokens, idx) {
		return tokens[idx].content;
	};
	function Renderer$1() {
		this.rules = assign$1({}, default_rules);
	}
	Renderer$1.prototype.renderAttrs = function renderAttrs(token) {
		var i$1, l, result;
		if (!token.attrs) return "";
		result = "";
		for (i$1 = 0, l = token.attrs.length; i$1 < l; i$1++) result += " " + escapeHtml(token.attrs[i$1][0]) + "=\"" + escapeHtml(token.attrs[i$1][1]) + "\"";
		return result;
	};
	Renderer$1.prototype.renderToken = function renderToken(tokens, idx, options$1) {
		var nextToken, result = "", needLf = false, token = tokens[idx];
		if (token.hidden) return "";
		if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) result += "\n";
		result += (token.nesting === -1 ? "</" : "<") + token.tag;
		result += this.renderAttrs(token);
		if (token.nesting === 0 && options$1.xhtmlOut) result += " /";
		if (token.block) {
			needLf = true;
			if (token.nesting === 1) {
				if (idx + 1 < tokens.length) {
					nextToken = tokens[idx + 1];
					if (nextToken.type === "inline" || nextToken.hidden) needLf = false;
					else if (nextToken.nesting === -1 && nextToken.tag === token.tag) needLf = false;
				}
			}
		}
		result += needLf ? ">\n" : ">";
		return result;
	};
	Renderer$1.prototype.renderInline = function(tokens, options$1, env) {
		var type, result = "", rules = this.rules;
		for (var i$1 = 0, len = tokens.length; i$1 < len; i$1++) {
			type = tokens[i$1].type;
			if (typeof rules[type] !== "undefined") result += rules[type](tokens, i$1, options$1, env, this);
			else result += this.renderToken(tokens, i$1, options$1);
		}
		return result;
	};
	Renderer$1.prototype.renderInlineAsText = function(tokens, options$1, env) {
		var result = "";
		for (var i$1 = 0, len = tokens.length; i$1 < len; i$1++) if (tokens[i$1].type === "text") result += tokens[i$1].content;
		else if (tokens[i$1].type === "image") result += this.renderInlineAsText(tokens[i$1].children, options$1, env);
		else if (tokens[i$1].type === "softbreak") result += "\n";
		return result;
	};
	Renderer$1.prototype.render = function(tokens, options$1, env) {
		var i$1, len, type, result = "", rules = this.rules;
		for (i$1 = 0, len = tokens.length; i$1 < len; i$1++) {
			type = tokens[i$1].type;
			if (type === "inline") result += this.renderInline(tokens[i$1].children, options$1, env);
			else if (typeof rules[type] !== "undefined") result += rules[type](tokens, i$1, options$1, env, this);
			else result += this.renderToken(tokens, i$1, options$1, env);
		}
		return result;
	};
	module.exports = Renderer$1;
}));
var require_ruler = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function Ruler$3() {
		this.__rules__ = [];
		this.__cache__ = null;
	}
	Ruler$3.prototype.__find__ = function(name$1) {
		for (var i$1 = 0; i$1 < this.__rules__.length; i$1++) if (this.__rules__[i$1].name === name$1) return i$1;
		return -1;
	};
	Ruler$3.prototype.__compile__ = function() {
		var self$1 = this;
		var chains$1 = [""];
		self$1.__rules__.forEach(function(rule) {
			if (!rule.enabled) return;
			rule.alt.forEach(function(altName) {
				if (chains$1.indexOf(altName) < 0) chains$1.push(altName);
			});
		});
		self$1.__cache__ = {};
		chains$1.forEach(function(chain) {
			self$1.__cache__[chain] = [];
			self$1.__rules__.forEach(function(rule) {
				if (!rule.enabled) return;
				if (chain && rule.alt.indexOf(chain) < 0) return;
				self$1.__cache__[chain].push(rule.fn);
			});
		});
	};
	Ruler$3.prototype.at = function(name$1, fn$1, options$1) {
		var index = this.__find__(name$1);
		var opt = options$1 || {};
		if (index === -1) throw new Error("Parser rule not found: " + name$1);
		this.__rules__[index].fn = fn$1;
		this.__rules__[index].alt = opt.alt || [];
		this.__cache__ = null;
	};
	Ruler$3.prototype.before = function(beforeName, ruleName, fn$1, options$1) {
		var index = this.__find__(beforeName);
		var opt = options$1 || {};
		if (index === -1) throw new Error("Parser rule not found: " + beforeName);
		this.__rules__.splice(index, 0, {
			name: ruleName,
			enabled: true,
			fn: fn$1,
			alt: opt.alt || []
		});
		this.__cache__ = null;
	};
	Ruler$3.prototype.after = function(afterName, ruleName, fn$1, options$1) {
		var index = this.__find__(afterName);
		var opt = options$1 || {};
		if (index === -1) throw new Error("Parser rule not found: " + afterName);
		this.__rules__.splice(index + 1, 0, {
			name: ruleName,
			enabled: true,
			fn: fn$1,
			alt: opt.alt || []
		});
		this.__cache__ = null;
	};
	Ruler$3.prototype.push = function(ruleName, fn$1, options$1) {
		var opt = options$1 || {};
		this.__rules__.push({
			name: ruleName,
			enabled: true,
			fn: fn$1,
			alt: opt.alt || []
		});
		this.__cache__ = null;
	};
	Ruler$3.prototype.enable = function(list$1, ignoreInvalid) {
		if (!Array.isArray(list$1)) list$1 = [list$1];
		var result = [];
		list$1.forEach(function(name$1) {
			var idx = this.__find__(name$1);
			if (idx < 0) {
				if (ignoreInvalid) return;
				throw new Error("Rules manager: invalid rule name " + name$1);
			}
			this.__rules__[idx].enabled = true;
			result.push(name$1);
		}, this);
		this.__cache__ = null;
		return result;
	};
	Ruler$3.prototype.enableOnly = function(list$1, ignoreInvalid) {
		if (!Array.isArray(list$1)) list$1 = [list$1];
		this.__rules__.forEach(function(rule) {
			rule.enabled = false;
		});
		this.enable(list$1, ignoreInvalid);
	};
	Ruler$3.prototype.disable = function(list$1, ignoreInvalid) {
		if (!Array.isArray(list$1)) list$1 = [list$1];
		var result = [];
		list$1.forEach(function(name$1) {
			var idx = this.__find__(name$1);
			if (idx < 0) {
				if (ignoreInvalid) return;
				throw new Error("Rules manager: invalid rule name " + name$1);
			}
			this.__rules__[idx].enabled = false;
			result.push(name$1);
		}, this);
		this.__cache__ = null;
		return result;
	};
	Ruler$3.prototype.getRules = function(chainName) {
		if (this.__cache__ === null) this.__compile__();
		return this.__cache__[chainName] || [];
	};
	module.exports = Ruler$3;
}));
var require_normalize = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var NEWLINES_RE = /\r\n?|\n/g;
	var NULL_RE = /\0/g;
	module.exports = function normalize(state) {
		var str = state.src.replace(NEWLINES_RE, "\n");
		str = str.replace(NULL_RE, "");
		state.src = str;
	};
}));
var require_block = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = function block$3(state) {
		var token;
		if (state.inlineMode) {
			token = new state.Token("inline", "", 0);
			token.content = state.src;
			token.map = [0, 1];
			token.children = [];
			state.tokens.push(token);
		} else state.md.block.parse(state.src, state.md, state.env, state.tokens);
	};
}));
var require_inline = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = function inline$2(state) {
		var tokens = state.tokens, tok, i$1, l;
		for (i$1 = 0, l = tokens.length; i$1 < l; i$1++) {
			tok = tokens[i$1];
			if (tok.type === "inline") state.md.inline.parse(tok.content, state.md, state.env, tok.children);
		}
	};
}));
var require_linkify$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var arrayReplaceAt = require_utils().arrayReplaceAt;
	function isLinkOpen$1(str) {
		return /^<a[>\s]/i.test(str);
	}
	function isLinkClose$1(str) {
		return /^<\/a\s*>/i.test(str);
	}
	module.exports = function linkify(state) {
		var i$1, j$1, l, tokens, token, currentToken, nodes, ln$1, text$7, pos, lastPos, level, htmlLinkLevel, url, fullUrl, urlText, blockTokens = state.tokens, links;
		if (!state.md.options.linkify) return;
		for (j$1 = 0, l = blockTokens.length; j$1 < l; j$1++) {
			if (blockTokens[j$1].type !== "inline" || !state.md.linkify.pretest(blockTokens[j$1].content)) continue;
			tokens = blockTokens[j$1].children;
			htmlLinkLevel = 0;
			for (i$1 = tokens.length - 1; i$1 >= 0; i$1--) {
				currentToken = tokens[i$1];
				if (currentToken.type === "link_close") {
					i$1--;
					while (tokens[i$1].level !== currentToken.level && tokens[i$1].type !== "link_open") i$1--;
					continue;
				}
				if (currentToken.type === "html_inline") {
					if (isLinkOpen$1(currentToken.content) && htmlLinkLevel > 0) htmlLinkLevel--;
					if (isLinkClose$1(currentToken.content)) htmlLinkLevel++;
				}
				if (htmlLinkLevel > 0) continue;
				if (currentToken.type === "text" && state.md.linkify.test(currentToken.content)) {
					text$7 = currentToken.content;
					links = state.md.linkify.match(text$7);
					nodes = [];
					level = currentToken.level;
					lastPos = 0;
					if (links.length > 0 && links[0].index === 0 && i$1 > 0 && tokens[i$1 - 1].type === "text_special") links = links.slice(1);
					for (ln$1 = 0; ln$1 < links.length; ln$1++) {
						url = links[ln$1].url;
						fullUrl = state.md.normalizeLink(url);
						if (!state.md.validateLink(fullUrl)) continue;
						urlText = links[ln$1].text;
						if (!links[ln$1].schema) urlText = state.md.normalizeLinkText("http://" + urlText).replace(/^http:\/\//, "");
						else if (links[ln$1].schema === "mailto:" && !/^mailto:/i.test(urlText)) urlText = state.md.normalizeLinkText("mailto:" + urlText).replace(/^mailto:/, "");
						else urlText = state.md.normalizeLinkText(urlText);
						pos = links[ln$1].index;
						if (pos > lastPos) {
							token = new state.Token("text", "", 0);
							token.content = text$7.slice(lastPos, pos);
							token.level = level;
							nodes.push(token);
						}
						token = new state.Token("link_open", "a", 1);
						token.attrs = [["href", fullUrl]];
						token.level = level++;
						token.markup = "linkify";
						token.info = "auto";
						nodes.push(token);
						token = new state.Token("text", "", 0);
						token.content = urlText;
						token.level = level;
						nodes.push(token);
						token = new state.Token("link_close", "a", -1);
						token.level = --level;
						token.markup = "linkify";
						token.info = "auto";
						nodes.push(token);
						lastPos = links[ln$1].lastIndex;
					}
					if (lastPos < text$7.length) {
						token = new state.Token("text", "", 0);
						token.content = text$7.slice(lastPos);
						token.level = level;
						nodes.push(token);
					}
					blockTokens[j$1].children = tokens = arrayReplaceAt(tokens, i$1, nodes);
				}
			}
		}
	};
}));
var require_replacements = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;
	var SCOPED_ABBR_TEST_RE = /\((c|tm|r)\)/i;
	var SCOPED_ABBR_RE = /\((c|tm|r)\)/gi;
	var SCOPED_ABBR = {
		c: "",
		r: "",
		tm: ""
	};
	function replaceFn(match, name$1) {
		return SCOPED_ABBR[name$1.toLowerCase()];
	}
	function replace_scoped(inlineTokens) {
		var i$1, token, inside_autolink = 0;
		for (i$1 = inlineTokens.length - 1; i$1 >= 0; i$1--) {
			token = inlineTokens[i$1];
			if (token.type === "text" && !inside_autolink) token.content = token.content.replace(SCOPED_ABBR_RE, replaceFn);
			if (token.type === "link_open" && token.info === "auto") inside_autolink--;
			if (token.type === "link_close" && token.info === "auto") inside_autolink++;
		}
	}
	function replace_rare(inlineTokens) {
		var i$1, token, inside_autolink = 0;
		for (i$1 = inlineTokens.length - 1; i$1 >= 0; i$1--) {
			token = inlineTokens[i$1];
			if (token.type === "text" && !inside_autolink) {
				if (RARE_RE.test(token.content)) token.content = token.content.replace(/\+-/g, "").replace(/\.{2,}/g, "").replace(/([?!])/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/gm, "$1").replace(/(^|\s)--(?=\s|$)/gm, "$1").replace(/(^|[^-\s])--(?=[^-\s]|$)/gm, "$1");
			}
			if (token.type === "link_open" && token.info === "auto") inside_autolink--;
			if (token.type === "link_close" && token.info === "auto") inside_autolink++;
		}
	}
	module.exports = function replace(state) {
		var blkIdx;
		if (!state.md.options.typographer) return;
		for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
			if (state.tokens[blkIdx].type !== "inline") continue;
			if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) replace_scoped(state.tokens[blkIdx].children);
			if (RARE_RE.test(state.tokens[blkIdx].content)) replace_rare(state.tokens[blkIdx].children);
		}
	};
}));
var require_smartquotes = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var isWhiteSpace$1 = require_utils().isWhiteSpace;
	var isPunctChar$1 = require_utils().isPunctChar;
	var isMdAsciiPunct$1 = require_utils().isMdAsciiPunct;
	var QUOTE_TEST_RE = /['"]/;
	var QUOTE_RE = /['"]/g;
	var APOSTROPHE = "";
	function replaceAt(str, index, ch) {
		return str.slice(0, index) + ch + str.slice(index + 1);
	}
	function process_inlines(tokens, state) {
		var i$1, token, text$7, t$1, pos, max$2, thisLevel, item$4, lastChar, nextChar, isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace, canOpen, canClose, j$1, isSingle, stack = [], openQuote, closeQuote;
		for (i$1 = 0; i$1 < tokens.length; i$1++) {
			token = tokens[i$1];
			thisLevel = tokens[i$1].level;
			for (j$1 = stack.length - 1; j$1 >= 0; j$1--) if (stack[j$1].level <= thisLevel) break;
			stack.length = j$1 + 1;
			if (token.type !== "text") continue;
			text$7 = token.content;
			pos = 0;
			max$2 = text$7.length;
			OUTER: while (pos < max$2) {
				QUOTE_RE.lastIndex = pos;
				t$1 = QUOTE_RE.exec(text$7);
				if (!t$1) break;
				canOpen = canClose = true;
				pos = t$1.index + 1;
				isSingle = t$1[0] === "'";
				lastChar = 32;
				if (t$1.index - 1 >= 0) lastChar = text$7.charCodeAt(t$1.index - 1);
				else for (j$1 = i$1 - 1; j$1 >= 0; j$1--) {
					if (tokens[j$1].type === "softbreak" || tokens[j$1].type === "hardbreak") break;
					if (!tokens[j$1].content) continue;
					lastChar = tokens[j$1].content.charCodeAt(tokens[j$1].content.length - 1);
					break;
				}
				nextChar = 32;
				if (pos < max$2) nextChar = text$7.charCodeAt(pos);
				else for (j$1 = i$1 + 1; j$1 < tokens.length; j$1++) {
					if (tokens[j$1].type === "softbreak" || tokens[j$1].type === "hardbreak") break;
					if (!tokens[j$1].content) continue;
					nextChar = tokens[j$1].content.charCodeAt(0);
					break;
				}
				isLastPunctChar = isMdAsciiPunct$1(lastChar) || isPunctChar$1(String.fromCharCode(lastChar));
				isNextPunctChar = isMdAsciiPunct$1(nextChar) || isPunctChar$1(String.fromCharCode(nextChar));
				isLastWhiteSpace = isWhiteSpace$1(lastChar);
				isNextWhiteSpace = isWhiteSpace$1(nextChar);
				if (isNextWhiteSpace) canOpen = false;
				else if (isNextPunctChar) {
					if (!(isLastWhiteSpace || isLastPunctChar)) canOpen = false;
				}
				if (isLastWhiteSpace) canClose = false;
				else if (isLastPunctChar) {
					if (!(isNextWhiteSpace || isNextPunctChar)) canClose = false;
				}
				if (nextChar === 34 && t$1[0] === "\"") {
					if (lastChar >= 48 && lastChar <= 57) canClose = canOpen = false;
				}
				if (canOpen && canClose) {
					canOpen = isLastPunctChar;
					canClose = isNextPunctChar;
				}
				if (!canOpen && !canClose) {
					if (isSingle) token.content = replaceAt(token.content, t$1.index, APOSTROPHE);
					continue;
				}
				if (canClose) for (j$1 = stack.length - 1; j$1 >= 0; j$1--) {
					item$4 = stack[j$1];
					if (stack[j$1].level < thisLevel) break;
					if (item$4.single === isSingle && stack[j$1].level === thisLevel) {
						item$4 = stack[j$1];
						if (isSingle) {
							openQuote = state.md.options.quotes[2];
							closeQuote = state.md.options.quotes[3];
						} else {
							openQuote = state.md.options.quotes[0];
							closeQuote = state.md.options.quotes[1];
						}
						token.content = replaceAt(token.content, t$1.index, closeQuote);
						tokens[item$4.token].content = replaceAt(tokens[item$4.token].content, item$4.pos, openQuote);
						pos += closeQuote.length - 1;
						if (item$4.token === i$1) pos += openQuote.length - 1;
						text$7 = token.content;
						max$2 = text$7.length;
						stack.length = j$1;
						continue OUTER;
					}
				}
				if (canOpen) stack.push({
					token: i$1,
					pos: t$1.index,
					single: isSingle,
					level: thisLevel
				});
				else if (canClose && isSingle) token.content = replaceAt(token.content, t$1.index, APOSTROPHE);
			}
		}
	}
	module.exports = function smartquotes(state) {
		var blkIdx;
		if (!state.md.options.typographer) return;
		for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
			if (state.tokens[blkIdx].type !== "inline" || !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) continue;
			process_inlines(state.tokens[blkIdx].children, state);
		}
	};
}));
var require_text_join = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = function text_join(state) {
		var j$1, l, tokens, curr, max$2, last, blockTokens = state.tokens;
		for (j$1 = 0, l = blockTokens.length; j$1 < l; j$1++) {
			if (blockTokens[j$1].type !== "inline") continue;
			tokens = blockTokens[j$1].children;
			max$2 = tokens.length;
			for (curr = 0; curr < max$2; curr++) if (tokens[curr].type === "text_special") tokens[curr].type = "text";
			for (curr = last = 0; curr < max$2; curr++) if (tokens[curr].type === "text" && curr + 1 < max$2 && tokens[curr + 1].type === "text") tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
			else {
				if (curr !== last) tokens[last] = tokens[curr];
				last++;
			}
			if (curr !== last) tokens.length = last;
		}
	};
}));
var require_token = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function Token$3(type, tag$2, nesting) {
		this.type = type;
		this.tag = tag$2;
		this.attrs = null;
		this.map = null;
		this.nesting = nesting;
		this.level = 0;
		this.children = null;
		this.content = "";
		this.markup = "";
		this.info = "";
		this.meta = null;
		this.block = false;
		this.hidden = false;
	}
	Token$3.prototype.attrIndex = function attrIndex(name$1) {
		var attrs, i$1, len;
		if (!this.attrs) return -1;
		attrs = this.attrs;
		for (i$1 = 0, len = attrs.length; i$1 < len; i$1++) if (attrs[i$1][0] === name$1) return i$1;
		return -1;
	};
	Token$3.prototype.attrPush = function attrPush(attrData) {
		if (this.attrs) this.attrs.push(attrData);
		else this.attrs = [attrData];
	};
	Token$3.prototype.attrSet = function attrSet$1(name$1, value) {
		var idx = this.attrIndex(name$1), attrData = [name$1, value];
		if (idx < 0) this.attrPush(attrData);
		else this.attrs[idx] = attrData;
	};
	Token$3.prototype.attrGet = function attrGet(name$1) {
		var idx = this.attrIndex(name$1), value = null;
		if (idx >= 0) value = this.attrs[idx][1];
		return value;
	};
	Token$3.prototype.attrJoin = function attrJoin(name$1, value) {
		var idx = this.attrIndex(name$1);
		if (idx < 0) this.attrPush([name$1, value]);
		else this.attrs[idx][1] = this.attrs[idx][1] + " " + value;
	};
	module.exports = Token$3;
}));
var require_state_core = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Token$2 = require_token();
	function StateCore(src, md, env) {
		this.src = src;
		this.env = env;
		this.tokens = [];
		this.inlineMode = false;
		this.md = md;
	}
	StateCore.prototype.Token = Token$2;
	module.exports = StateCore;
}));
var require_parser_core = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Ruler$2 = require_ruler();
	var _rules$2 = [
		["normalize", require_normalize()],
		["block", require_block()],
		["inline", require_inline()],
		["linkify", require_linkify$1()],
		["replacements", require_replacements()],
		["smartquotes", require_smartquotes()],
		["text_join", require_text_join()]
	];
	function Core() {
		this.ruler = new Ruler$2();
		for (var i$1 = 0; i$1 < _rules$2.length; i$1++) this.ruler.push(_rules$2[i$1][0], _rules$2[i$1][1]);
	}
	Core.prototype.process = function(state) {
		var i$1, l, rules = this.ruler.getRules("");
		for (i$1 = 0, l = rules.length; i$1 < l; i$1++) rules[i$1](state);
	};
	Core.prototype.State = require_state_core();
	module.exports = Core;
}));
var require_table = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var isSpace$10 = require_utils().isSpace;
	function getLine(state, line) {
		var pos = state.bMarks[line] + state.tShift[line], max$2 = state.eMarks[line];
		return state.src.slice(pos, max$2);
	}
	function escapedSplit(str) {
		var result = [], pos = 0, max$2 = str.length, ch, isEscaped = false, lastPos = 0, current$1 = "";
		ch = str.charCodeAt(pos);
		while (pos < max$2) {
			if (ch === 124) if (!isEscaped) {
				result.push(current$1 + str.substring(lastPos, pos));
				current$1 = "";
				lastPos = pos + 1;
			} else {
				current$1 += str.substring(lastPos, pos - 1);
				lastPos = pos;
			}
			isEscaped = ch === 92;
			pos++;
			ch = str.charCodeAt(pos);
		}
		result.push(current$1 + str.substring(lastPos));
		return result;
	}
	module.exports = function table(state, startLine, endLine, silent) {
		var ch, lineText, pos, i$1, l, nextLine, columns, columnCount, token, aligns, t$1, tableLines, tbodyLines, oldParentType, terminate, terminatorRules, firstCh, secondCh;
		if (startLine + 2 > endLine) return false;
		nextLine = startLine + 1;
		if (state.sCount[nextLine] < state.blkIndent) return false;
		if (state.sCount[nextLine] - state.blkIndent >= 4) return false;
		pos = state.bMarks[nextLine] + state.tShift[nextLine];
		if (pos >= state.eMarks[nextLine]) return false;
		firstCh = state.src.charCodeAt(pos++);
		if (firstCh !== 124 && firstCh !== 45 && firstCh !== 58) return false;
		if (pos >= state.eMarks[nextLine]) return false;
		secondCh = state.src.charCodeAt(pos++);
		if (secondCh !== 124 && secondCh !== 45 && secondCh !== 58 && !isSpace$10(secondCh)) return false;
		if (firstCh === 45 && isSpace$10(secondCh)) return false;
		while (pos < state.eMarks[nextLine]) {
			ch = state.src.charCodeAt(pos);
			if (ch !== 124 && ch !== 45 && ch !== 58 && !isSpace$10(ch)) return false;
			pos++;
		}
		lineText = getLine(state, startLine + 1);
		columns = lineText.split("|");
		aligns = [];
		for (i$1 = 0; i$1 < columns.length; i$1++) {
			t$1 = columns[i$1].trim();
			if (!t$1) if (i$1 === 0 || i$1 === columns.length - 1) continue;
			else return false;
			if (!/^:?-+:?$/.test(t$1)) return false;
			if (t$1.charCodeAt(t$1.length - 1) === 58) aligns.push(t$1.charCodeAt(0) === 58 ? "center" : "right");
			else if (t$1.charCodeAt(0) === 58) aligns.push("left");
			else aligns.push("");
		}
		lineText = getLine(state, startLine).trim();
		if (lineText.indexOf("|") === -1) return false;
		if (state.sCount[startLine] - state.blkIndent >= 4) return false;
		columns = escapedSplit(lineText);
		if (columns.length && columns[0] === "") columns.shift();
		if (columns.length && columns[columns.length - 1] === "") columns.pop();
		columnCount = columns.length;
		if (columnCount === 0 || columnCount !== aligns.length) return false;
		if (silent) return true;
		oldParentType = state.parentType;
		state.parentType = "table";
		terminatorRules = state.md.block.ruler.getRules("blockquote");
		token = state.push("table_open", "table", 1);
		token.map = tableLines = [startLine, 0];
		token = state.push("thead_open", "thead", 1);
		token.map = [startLine, startLine + 1];
		token = state.push("tr_open", "tr", 1);
		token.map = [startLine, startLine + 1];
		for (i$1 = 0; i$1 < columns.length; i$1++) {
			token = state.push("th_open", "th", 1);
			if (aligns[i$1]) token.attrs = [["style", "text-align:" + aligns[i$1]]];
			token = state.push("inline", "", 0);
			token.content = columns[i$1].trim();
			token.children = [];
			token = state.push("th_close", "th", -1);
		}
		token = state.push("tr_close", "tr", -1);
		token = state.push("thead_close", "thead", -1);
		for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
			if (state.sCount[nextLine] < state.blkIndent) break;
			terminate = false;
			for (i$1 = 0, l = terminatorRules.length; i$1 < l; i$1++) if (terminatorRules[i$1](state, nextLine, endLine, true)) {
				terminate = true;
				break;
			}
			if (terminate) break;
			lineText = getLine(state, nextLine).trim();
			if (!lineText) break;
			if (state.sCount[nextLine] - state.blkIndent >= 4) break;
			columns = escapedSplit(lineText);
			if (columns.length && columns[0] === "") columns.shift();
			if (columns.length && columns[columns.length - 1] === "") columns.pop();
			if (nextLine === startLine + 2) {
				token = state.push("tbody_open", "tbody", 1);
				token.map = tbodyLines = [startLine + 2, 0];
			}
			token = state.push("tr_open", "tr", 1);
			token.map = [nextLine, nextLine + 1];
			for (i$1 = 0; i$1 < columnCount; i$1++) {
				token = state.push("td_open", "td", 1);
				if (aligns[i$1]) token.attrs = [["style", "text-align:" + aligns[i$1]]];
				token = state.push("inline", "", 0);
				token.content = columns[i$1] ? columns[i$1].trim() : "";
				token.children = [];
				token = state.push("td_close", "td", -1);
			}
			token = state.push("tr_close", "tr", -1);
		}
		if (tbodyLines) {
			token = state.push("tbody_close", "tbody", -1);
			tbodyLines[1] = nextLine;
		}
		token = state.push("table_close", "table", -1);
		tableLines[1] = nextLine;
		state.parentType = oldParentType;
		state.line = nextLine;
		return true;
	};
}));
var require_code = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = function code(state, startLine, endLine) {
		var nextLine, last, token;
		if (state.sCount[startLine] - state.blkIndent < 4) return false;
		last = nextLine = startLine + 1;
		while (nextLine < endLine) {
			if (state.isEmpty(nextLine)) {
				nextLine++;
				continue;
			}
			if (state.sCount[nextLine] - state.blkIndent >= 4) {
				nextLine++;
				last = nextLine;
				continue;
			}
			break;
		}
		state.line = last;
		token = state.push("code_block", "code", 0);
		token.content = state.getLines(startLine, last, 4 + state.blkIndent, false) + "\n";
		token.map = [startLine, state.line];
		return true;
	};
}));
var require_fence = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = function fence(state, startLine, endLine, silent) {
		var marker$1, len, params, nextLine, mem, token, markup, haveEndMarker = false, pos = state.bMarks[startLine] + state.tShift[startLine], max$2 = state.eMarks[startLine];
		if (state.sCount[startLine] - state.blkIndent >= 4) return false;
		if (pos + 3 > max$2) return false;
		marker$1 = state.src.charCodeAt(pos);
		if (marker$1 !== 126 && marker$1 !== 96) return false;
		mem = pos;
		pos = state.skipChars(pos, marker$1);
		len = pos - mem;
		if (len < 3) return false;
		markup = state.src.slice(mem, pos);
		params = state.src.slice(pos, max$2);
		if (marker$1 === 96) {
			if (params.indexOf(String.fromCharCode(marker$1)) >= 0) return false;
		}
		if (silent) return true;
		nextLine = startLine;
		for (;;) {
			nextLine++;
			if (nextLine >= endLine) break;
			pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
			max$2 = state.eMarks[nextLine];
			if (pos < max$2 && state.sCount[nextLine] < state.blkIndent) break;
			if (state.src.charCodeAt(pos) !== marker$1) continue;
			if (state.sCount[nextLine] - state.blkIndent >= 4) continue;
			pos = state.skipChars(pos, marker$1);
			if (pos - mem < len) continue;
			pos = state.skipSpaces(pos);
			if (pos < max$2) continue;
			haveEndMarker = true;
			break;
		}
		len = state.sCount[startLine];
		state.line = nextLine + (haveEndMarker ? 1 : 0);
		token = state.push("fence", "code", 0);
		token.info = params;
		token.content = state.getLines(startLine + 1, nextLine, len, true);
		token.markup = markup;
		token.map = [startLine, state.line];
		return true;
	};
}));
var require_blockquote = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var isSpace$9 = require_utils().isSpace;
	module.exports = function blockquote(state, startLine, endLine, silent) {
		var adjustTab, ch, i$1, initial, l, lastLineEmpty, lines, nextLine, offset$2, oldBMarks, oldBSCount, oldIndent, oldParentType, oldSCount, oldTShift, spaceAfterMarker, terminate, terminatorRules, token, isOutdented, oldLineMax = state.lineMax, pos = state.bMarks[startLine] + state.tShift[startLine], max$2 = state.eMarks[startLine];
		if (state.sCount[startLine] - state.blkIndent >= 4) return false;
		if (state.src.charCodeAt(pos) !== 62) return false;
		if (silent) return true;
		oldBMarks = [];
		oldBSCount = [];
		oldSCount = [];
		oldTShift = [];
		terminatorRules = state.md.block.ruler.getRules("blockquote");
		oldParentType = state.parentType;
		state.parentType = "blockquote";
		for (nextLine = startLine; nextLine < endLine; nextLine++) {
			isOutdented = state.sCount[nextLine] < state.blkIndent;
			pos = state.bMarks[nextLine] + state.tShift[nextLine];
			max$2 = state.eMarks[nextLine];
			if (pos >= max$2) break;
			if (state.src.charCodeAt(pos++) === 62 && !isOutdented) {
				initial = state.sCount[nextLine] + 1;
				if (state.src.charCodeAt(pos) === 32) {
					pos++;
					initial++;
					adjustTab = false;
					spaceAfterMarker = true;
				} else if (state.src.charCodeAt(pos) === 9) {
					spaceAfterMarker = true;
					if ((state.bsCount[nextLine] + initial) % 4 === 3) {
						pos++;
						initial++;
						adjustTab = false;
					} else adjustTab = true;
				} else spaceAfterMarker = false;
				offset$2 = initial;
				oldBMarks.push(state.bMarks[nextLine]);
				state.bMarks[nextLine] = pos;
				while (pos < max$2) {
					ch = state.src.charCodeAt(pos);
					if (isSpace$9(ch)) if (ch === 9) offset$2 += 4 - (offset$2 + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;
					else offset$2++;
					else break;
					pos++;
				}
				lastLineEmpty = pos >= max$2;
				oldBSCount.push(state.bsCount[nextLine]);
				state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);
				oldSCount.push(state.sCount[nextLine]);
				state.sCount[nextLine] = offset$2 - initial;
				oldTShift.push(state.tShift[nextLine]);
				state.tShift[nextLine] = pos - state.bMarks[nextLine];
				continue;
			}
			if (lastLineEmpty) break;
			terminate = false;
			for (i$1 = 0, l = terminatorRules.length; i$1 < l; i$1++) if (terminatorRules[i$1](state, nextLine, endLine, true)) {
				terminate = true;
				break;
			}
			if (terminate) {
				state.lineMax = nextLine;
				if (state.blkIndent !== 0) {
					oldBMarks.push(state.bMarks[nextLine]);
					oldBSCount.push(state.bsCount[nextLine]);
					oldTShift.push(state.tShift[nextLine]);
					oldSCount.push(state.sCount[nextLine]);
					state.sCount[nextLine] -= state.blkIndent;
				}
				break;
			}
			oldBMarks.push(state.bMarks[nextLine]);
			oldBSCount.push(state.bsCount[nextLine]);
			oldTShift.push(state.tShift[nextLine]);
			oldSCount.push(state.sCount[nextLine]);
			state.sCount[nextLine] = -1;
		}
		oldIndent = state.blkIndent;
		state.blkIndent = 0;
		token = state.push("blockquote_open", "blockquote", 1);
		token.markup = ">";
		token.map = lines = [startLine, 0];
		state.md.block.tokenize(state, startLine, nextLine);
		token = state.push("blockquote_close", "blockquote", -1);
		token.markup = ">";
		state.lineMax = oldLineMax;
		state.parentType = oldParentType;
		lines[1] = state.line;
		for (i$1 = 0; i$1 < oldTShift.length; i$1++) {
			state.bMarks[i$1 + startLine] = oldBMarks[i$1];
			state.tShift[i$1 + startLine] = oldTShift[i$1];
			state.sCount[i$1 + startLine] = oldSCount[i$1];
			state.bsCount[i$1 + startLine] = oldBSCount[i$1];
		}
		state.blkIndent = oldIndent;
		return true;
	};
}));
var require_hr = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var isSpace$8 = require_utils().isSpace;
	module.exports = function hr(state, startLine, endLine, silent) {
		var marker$1, cnt, ch, token, pos = state.bMarks[startLine] + state.tShift[startLine], max$2 = state.eMarks[startLine];
		if (state.sCount[startLine] - state.blkIndent >= 4) return false;
		marker$1 = state.src.charCodeAt(pos++);
		if (marker$1 !== 42 && marker$1 !== 45 && marker$1 !== 95) return false;
		cnt = 1;
		while (pos < max$2) {
			ch = state.src.charCodeAt(pos++);
			if (ch !== marker$1 && !isSpace$8(ch)) return false;
			if (ch === marker$1) cnt++;
		}
		if (cnt < 3) return false;
		if (silent) return true;
		state.line = startLine + 1;
		token = state.push("hr", "hr", 0);
		token.map = [startLine, state.line];
		token.markup = Array(cnt + 1).join(String.fromCharCode(marker$1));
		return true;
	};
}));
var require_list = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var isSpace$7 = require_utils().isSpace;
	function skipBulletListMarker(state, startLine) {
		var marker$1, pos = state.bMarks[startLine] + state.tShift[startLine], max$2 = state.eMarks[startLine], ch;
		marker$1 = state.src.charCodeAt(pos++);
		if (marker$1 !== 42 && marker$1 !== 45 && marker$1 !== 43) return -1;
		if (pos < max$2) {
			ch = state.src.charCodeAt(pos);
			if (!isSpace$7(ch)) return -1;
		}
		return pos;
	}
	function skipOrderedListMarker(state, startLine) {
		var ch, start = state.bMarks[startLine] + state.tShift[startLine], pos = start, max$2 = state.eMarks[startLine];
		if (pos + 1 >= max$2) return -1;
		ch = state.src.charCodeAt(pos++);
		if (ch < 48 || ch > 57) return -1;
		for (;;) {
			if (pos >= max$2) return -1;
			ch = state.src.charCodeAt(pos++);
			if (ch >= 48 && ch <= 57) {
				if (pos - start >= 10) return -1;
				continue;
			}
			if (ch === 41 || ch === 46) break;
			return -1;
		}
		if (pos < max$2) {
			ch = state.src.charCodeAt(pos);
			if (!isSpace$7(ch)) return -1;
		}
		return pos;
	}
	function markTightParagraphs(state, idx) {
		var i$1, l, level = state.level + 2;
		for (i$1 = idx + 2, l = state.tokens.length - 2; i$1 < l; i$1++) if (state.tokens[i$1].level === level && state.tokens[i$1].type === "paragraph_open") {
			state.tokens[i$1 + 2].hidden = true;
			state.tokens[i$1].hidden = true;
			i$1 += 2;
		}
	}
	module.exports = function list$1(state, startLine, endLine, silent) {
		var ch, contentStart, i$1, indent$1, indentAfterMarker, initial, isOrdered, itemLines, l, listLines, listTokIdx, markerCharCode, markerValue, max$2, offset$2, oldListIndent, oldParentType, oldSCount, oldTShift, oldTight, pos, posAfterMarker, prevEmptyEnd, start, terminate, terminatorRules, token, nextLine = startLine, isTerminatingParagraph = false, tight = true;
		if (state.sCount[nextLine] - state.blkIndent >= 4) return false;
		if (state.listIndent >= 0 && state.sCount[nextLine] - state.listIndent >= 4 && state.sCount[nextLine] < state.blkIndent) return false;
		if (silent && state.parentType === "paragraph") {
			if (state.sCount[nextLine] >= state.blkIndent) isTerminatingParagraph = true;
		}
		if ((posAfterMarker = skipOrderedListMarker(state, nextLine)) >= 0) {
			isOrdered = true;
			start = state.bMarks[nextLine] + state.tShift[nextLine];
			markerValue = Number(state.src.slice(start, posAfterMarker - 1));
			if (isTerminatingParagraph && markerValue !== 1) return false;
		} else if ((posAfterMarker = skipBulletListMarker(state, nextLine)) >= 0) isOrdered = false;
		else return false;
		if (isTerminatingParagraph) {
			if (state.skipSpaces(posAfterMarker) >= state.eMarks[nextLine]) return false;
		}
		if (silent) return true;
		markerCharCode = state.src.charCodeAt(posAfterMarker - 1);
		listTokIdx = state.tokens.length;
		if (isOrdered) {
			token = state.push("ordered_list_open", "ol", 1);
			if (markerValue !== 1) token.attrs = [["start", markerValue]];
		} else token = state.push("bullet_list_open", "ul", 1);
		token.map = listLines = [nextLine, 0];
		token.markup = String.fromCharCode(markerCharCode);
		prevEmptyEnd = false;
		terminatorRules = state.md.block.ruler.getRules("list");
		oldParentType = state.parentType;
		state.parentType = "list";
		while (nextLine < endLine) {
			pos = posAfterMarker;
			max$2 = state.eMarks[nextLine];
			initial = offset$2 = state.sCount[nextLine] + posAfterMarker - (state.bMarks[nextLine] + state.tShift[nextLine]);
			while (pos < max$2) {
				ch = state.src.charCodeAt(pos);
				if (ch === 9) offset$2 += 4 - (offset$2 + state.bsCount[nextLine]) % 4;
				else if (ch === 32) offset$2++;
				else break;
				pos++;
			}
			contentStart = pos;
			if (contentStart >= max$2) indentAfterMarker = 1;
			else indentAfterMarker = offset$2 - initial;
			if (indentAfterMarker > 4) indentAfterMarker = 1;
			indent$1 = initial + indentAfterMarker;
			token = state.push("list_item_open", "li", 1);
			token.markup = String.fromCharCode(markerCharCode);
			token.map = itemLines = [nextLine, 0];
			if (isOrdered) token.info = state.src.slice(start, posAfterMarker - 1);
			oldTight = state.tight;
			oldTShift = state.tShift[nextLine];
			oldSCount = state.sCount[nextLine];
			oldListIndent = state.listIndent;
			state.listIndent = state.blkIndent;
			state.blkIndent = indent$1;
			state.tight = true;
			state.tShift[nextLine] = contentStart - state.bMarks[nextLine];
			state.sCount[nextLine] = offset$2;
			if (contentStart >= max$2 && state.isEmpty(nextLine + 1)) state.line = Math.min(state.line + 2, endLine);
			else state.md.block.tokenize(state, nextLine, endLine, true);
			if (!state.tight || prevEmptyEnd) tight = false;
			prevEmptyEnd = state.line - nextLine > 1 && state.isEmpty(state.line - 1);
			state.blkIndent = state.listIndent;
			state.listIndent = oldListIndent;
			state.tShift[nextLine] = oldTShift;
			state.sCount[nextLine] = oldSCount;
			state.tight = oldTight;
			token = state.push("list_item_close", "li", -1);
			token.markup = String.fromCharCode(markerCharCode);
			nextLine = state.line;
			itemLines[1] = nextLine;
			if (nextLine >= endLine) break;
			if (state.sCount[nextLine] < state.blkIndent) break;
			if (state.sCount[nextLine] - state.blkIndent >= 4) break;
			terminate = false;
			for (i$1 = 0, l = terminatorRules.length; i$1 < l; i$1++) if (terminatorRules[i$1](state, nextLine, endLine, true)) {
				terminate = true;
				break;
			}
			if (terminate) break;
			if (isOrdered) {
				posAfterMarker = skipOrderedListMarker(state, nextLine);
				if (posAfterMarker < 0) break;
				start = state.bMarks[nextLine] + state.tShift[nextLine];
			} else {
				posAfterMarker = skipBulletListMarker(state, nextLine);
				if (posAfterMarker < 0) break;
			}
			if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) break;
		}
		if (isOrdered) token = state.push("ordered_list_close", "ol", -1);
		else token = state.push("bullet_list_close", "ul", -1);
		token.markup = String.fromCharCode(markerCharCode);
		listLines[1] = nextLine;
		state.line = nextLine;
		state.parentType = oldParentType;
		if (tight) markTightParagraphs(state, listTokIdx);
		return true;
	};
}));
var require_reference = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var normalizeReference$2 = require_utils().normalizeReference;
	var isSpace$6 = require_utils().isSpace;
	module.exports = function reference(state, startLine, _endLine, silent) {
		var ch, destEndPos, destEndLineNo, endLine, href, i$1, l, label$3, labelEnd, oldParentType, res, start, str, terminate, terminatorRules, title$3, lines = 0, pos = state.bMarks[startLine] + state.tShift[startLine], max$2 = state.eMarks[startLine], nextLine = startLine + 1;
		if (state.sCount[startLine] - state.blkIndent >= 4) return false;
		if (state.src.charCodeAt(pos) !== 91) return false;
		while (++pos < max$2) if (state.src.charCodeAt(pos) === 93 && state.src.charCodeAt(pos - 1) !== 92) {
			if (pos + 1 === max$2) return false;
			if (state.src.charCodeAt(pos + 1) !== 58) return false;
			break;
		}
		endLine = state.lineMax;
		terminatorRules = state.md.block.ruler.getRules("reference");
		oldParentType = state.parentType;
		state.parentType = "reference";
		for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
			if (state.sCount[nextLine] - state.blkIndent > 3) continue;
			if (state.sCount[nextLine] < 0) continue;
			terminate = false;
			for (i$1 = 0, l = terminatorRules.length; i$1 < l; i$1++) if (terminatorRules[i$1](state, nextLine, endLine, true)) {
				terminate = true;
				break;
			}
			if (terminate) break;
		}
		str = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
		max$2 = str.length;
		for (pos = 1; pos < max$2; pos++) {
			ch = str.charCodeAt(pos);
			if (ch === 91) return false;
			else if (ch === 93) {
				labelEnd = pos;
				break;
			} else if (ch === 10) lines++;
			else if (ch === 92) {
				pos++;
				if (pos < max$2 && str.charCodeAt(pos) === 10) lines++;
			}
		}
		if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 58) return false;
		for (pos = labelEnd + 2; pos < max$2; pos++) {
			ch = str.charCodeAt(pos);
			if (ch === 10) lines++;
			else if (isSpace$6(ch)) {} else break;
		}
		res = state.md.helpers.parseLinkDestination(str, pos, max$2);
		if (!res.ok) return false;
		href = state.md.normalizeLink(res.str);
		if (!state.md.validateLink(href)) return false;
		pos = res.pos;
		lines += res.lines;
		destEndPos = pos;
		destEndLineNo = lines;
		start = pos;
		for (; pos < max$2; pos++) {
			ch = str.charCodeAt(pos);
			if (ch === 10) lines++;
			else if (isSpace$6(ch)) {} else break;
		}
		res = state.md.helpers.parseLinkTitle(str, pos, max$2);
		if (pos < max$2 && start !== pos && res.ok) {
			title$3 = res.str;
			pos = res.pos;
			lines += res.lines;
		} else {
			title$3 = "";
			pos = destEndPos;
			lines = destEndLineNo;
		}
		while (pos < max$2) {
			ch = str.charCodeAt(pos);
			if (!isSpace$6(ch)) break;
			pos++;
		}
		if (pos < max$2 && str.charCodeAt(pos) !== 10) {
			if (title$3) {
				title$3 = "";
				pos = destEndPos;
				lines = destEndLineNo;
				while (pos < max$2) {
					ch = str.charCodeAt(pos);
					if (!isSpace$6(ch)) break;
					pos++;
				}
			}
		}
		if (pos < max$2 && str.charCodeAt(pos) !== 10) return false;
		label$3 = normalizeReference$2(str.slice(1, labelEnd));
		if (!label$3) return false;
		/*istanbul ignore if*/
		if (silent) return true;
		if (typeof state.env.references === "undefined") state.env.references = {};
		if (typeof state.env.references[label$3] === "undefined") state.env.references[label$3] = {
			title: title$3,
			href
		};
		state.parentType = oldParentType;
		state.line = startLine + lines + 1;
		return true;
	};
}));
var require_html_blocks = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = [
		"address",
		"article",
		"aside",
		"base",
		"basefont",
		"blockquote",
		"body",
		"caption",
		"center",
		"col",
		"colgroup",
		"dd",
		"details",
		"dialog",
		"dir",
		"div",
		"dl",
		"dt",
		"fieldset",
		"figcaption",
		"figure",
		"footer",
		"form",
		"frame",
		"frameset",
		"h1",
		"h2",
		"h3",
		"h4",
		"h5",
		"h6",
		"head",
		"header",
		"hr",
		"html",
		"iframe",
		"legend",
		"li",
		"link",
		"main",
		"menu",
		"menuitem",
		"nav",
		"noframes",
		"ol",
		"optgroup",
		"option",
		"p",
		"param",
		"section",
		"source",
		"summary",
		"table",
		"tbody",
		"td",
		"tfoot",
		"th",
		"thead",
		"title",
		"tr",
		"track",
		"ul"
	];
}));
var require_html_re = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var open_tag = "<[A-Za-z][A-Za-z0-9\\-]*(?:\\s+[a-zA-Z_:][a-zA-Z0-9:._-]*(?:\\s*=\\s*(?:[^\"'=<>`\\x00-\\x20]+|'[^']*'|\"[^\"]*\"))?)*\\s*\\/?>";
	var close_tag = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>";
	var HTML_TAG_RE$1 = /* @__PURE__ */ new RegExp("^(?:" + open_tag + "|" + close_tag + "|<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->|<[?][\\s\\S]*?[?]>|<![A-Z]+\\s+[^>]*>|<!\\[CDATA\\[[\\s\\S]*?\\]\\]>)");
	var HTML_OPEN_CLOSE_TAG_RE$1 = /* @__PURE__ */ new RegExp("^(?:" + open_tag + "|" + close_tag + ")");
	module.exports.HTML_TAG_RE = HTML_TAG_RE$1;
	module.exports.HTML_OPEN_CLOSE_TAG_RE = HTML_OPEN_CLOSE_TAG_RE$1;
}));
var require_html_block = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var block_names = require_html_blocks();
	var HTML_OPEN_CLOSE_TAG_RE = require_html_re().HTML_OPEN_CLOSE_TAG_RE;
	var HTML_SEQUENCES = [
		[
			/^<(script|pre|style|textarea)(?=(\s|>|$))/i,
			/<\/(script|pre|style|textarea)>/i,
			true
		],
		[
			/^<!--/,
			/-->/,
			true
		],
		[
			/^<\?/,
			/\?>/,
			true
		],
		[
			/^<![A-Z]/,
			/>/,
			true
		],
		[
			/^<!\[CDATA\[/,
			/\]\]>/,
			true
		],
		[
			new RegExp("^</?(" + block_names.join("|") + ")(?=(\\s|/?>|$))", "i"),
			/^$/,
			true
		],
		[
			/* @__PURE__ */ new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + "\\s*$"),
			/^$/,
			false
		]
	];
	module.exports = function html_block(state, startLine, endLine, silent) {
		var i$1, nextLine, token, lineText, pos = state.bMarks[startLine] + state.tShift[startLine], max$2 = state.eMarks[startLine];
		if (state.sCount[startLine] - state.blkIndent >= 4) return false;
		if (!state.md.options.html) return false;
		if (state.src.charCodeAt(pos) !== 60) return false;
		lineText = state.src.slice(pos, max$2);
		for (i$1 = 0; i$1 < HTML_SEQUENCES.length; i$1++) if (HTML_SEQUENCES[i$1][0].test(lineText)) break;
		if (i$1 === HTML_SEQUENCES.length) return false;
		if (silent) return HTML_SEQUENCES[i$1][2];
		nextLine = startLine + 1;
		if (!HTML_SEQUENCES[i$1][1].test(lineText)) for (; nextLine < endLine; nextLine++) {
			if (state.sCount[nextLine] < state.blkIndent) break;
			pos = state.bMarks[nextLine] + state.tShift[nextLine];
			max$2 = state.eMarks[nextLine];
			lineText = state.src.slice(pos, max$2);
			if (HTML_SEQUENCES[i$1][1].test(lineText)) {
				if (lineText.length !== 0) nextLine++;
				break;
			}
		}
		state.line = nextLine;
		token = state.push("html_block", "", 0);
		token.map = [startLine, nextLine];
		token.content = state.getLines(startLine, nextLine, state.blkIndent, true);
		return true;
	};
}));
var require_heading = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var isSpace$5 = require_utils().isSpace;
	module.exports = function heading$3(state, startLine, endLine, silent) {
		var ch, level, tmp, token, pos = state.bMarks[startLine] + state.tShift[startLine], max$2 = state.eMarks[startLine];
		if (state.sCount[startLine] - state.blkIndent >= 4) return false;
		ch = state.src.charCodeAt(pos);
		if (ch !== 35 || pos >= max$2) return false;
		level = 1;
		ch = state.src.charCodeAt(++pos);
		while (ch === 35 && pos < max$2 && level <= 6) {
			level++;
			ch = state.src.charCodeAt(++pos);
		}
		if (level > 6 || pos < max$2 && !isSpace$5(ch)) return false;
		if (silent) return true;
		max$2 = state.skipSpacesBack(max$2, pos);
		tmp = state.skipCharsBack(max$2, 35, pos);
		if (tmp > pos && isSpace$5(state.src.charCodeAt(tmp - 1))) max$2 = tmp;
		state.line = startLine + 1;
		token = state.push("heading_open", "h" + String(level), 1);
		token.markup = "########".slice(0, level);
		token.map = [startLine, state.line];
		token = state.push("inline", "", 0);
		token.content = state.src.slice(pos, max$2).trim();
		token.map = [startLine, state.line];
		token.children = [];
		token = state.push("heading_close", "h" + String(level), -1);
		token.markup = "########".slice(0, level);
		return true;
	};
}));
var require_lheading = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = function lheading(state, startLine, endLine) {
		var content$4, terminate, i$1, l, token, pos, max$2, level, marker$1, nextLine = startLine + 1, oldParentType, terminatorRules = state.md.block.ruler.getRules("paragraph");
		if (state.sCount[startLine] - state.blkIndent >= 4) return false;
		oldParentType = state.parentType;
		state.parentType = "paragraph";
		for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
			if (state.sCount[nextLine] - state.blkIndent > 3) continue;
			if (state.sCount[nextLine] >= state.blkIndent) {
				pos = state.bMarks[nextLine] + state.tShift[nextLine];
				max$2 = state.eMarks[nextLine];
				if (pos < max$2) {
					marker$1 = state.src.charCodeAt(pos);
					if (marker$1 === 45 || marker$1 === 61) {
						pos = state.skipChars(pos, marker$1);
						pos = state.skipSpaces(pos);
						if (pos >= max$2) {
							level = marker$1 === 61 ? 1 : 2;
							break;
						}
					}
				}
			}
			if (state.sCount[nextLine] < 0) continue;
			terminate = false;
			for (i$1 = 0, l = terminatorRules.length; i$1 < l; i$1++) if (terminatorRules[i$1](state, nextLine, endLine, true)) {
				terminate = true;
				break;
			}
			if (terminate) break;
		}
		if (!level) return false;
		content$4 = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
		state.line = nextLine + 1;
		token = state.push("heading_open", "h" + String(level), 1);
		token.markup = String.fromCharCode(marker$1);
		token.map = [startLine, state.line];
		token = state.push("inline", "", 0);
		token.content = content$4;
		token.map = [startLine, state.line - 1];
		token.children = [];
		token = state.push("heading_close", "h" + String(level), -1);
		token.markup = String.fromCharCode(marker$1);
		state.parentType = oldParentType;
		return true;
	};
}));
var require_paragraph = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = function paragraph(state, startLine, endLine) {
		var content$4, terminate, i$1, l, token, oldParentType, nextLine = startLine + 1, terminatorRules = state.md.block.ruler.getRules("paragraph");
		oldParentType = state.parentType;
		state.parentType = "paragraph";
		for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
			if (state.sCount[nextLine] - state.blkIndent > 3) continue;
			if (state.sCount[nextLine] < 0) continue;
			terminate = false;
			for (i$1 = 0, l = terminatorRules.length; i$1 < l; i$1++) if (terminatorRules[i$1](state, nextLine, endLine, true)) {
				terminate = true;
				break;
			}
			if (terminate) break;
		}
		content$4 = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
		state.line = nextLine;
		token = state.push("paragraph_open", "p", 1);
		token.map = [startLine, state.line];
		token = state.push("inline", "", 0);
		token.content = content$4;
		token.map = [startLine, state.line];
		token.children = [];
		token = state.push("paragraph_close", "p", -1);
		state.parentType = oldParentType;
		return true;
	};
}));
var require_state_block = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Token$1 = require_token();
	var isSpace$4 = require_utils().isSpace;
	function StateBlock(src, md, env, tokens) {
		var ch, s, start, pos, len, indent$1, offset$2, indent_found;
		this.src = src;
		this.md = md;
		this.env = env;
		this.tokens = tokens;
		this.bMarks = [];
		this.eMarks = [];
		this.tShift = [];
		this.sCount = [];
		this.bsCount = [];
		this.blkIndent = 0;
		this.line = 0;
		this.lineMax = 0;
		this.tight = false;
		this.ddIndent = -1;
		this.listIndent = -1;
		this.parentType = "root";
		this.level = 0;
		this.result = "";
		s = this.src;
		indent_found = false;
		for (start = pos = indent$1 = offset$2 = 0, len = s.length; pos < len; pos++) {
			ch = s.charCodeAt(pos);
			if (!indent_found) if (isSpace$4(ch)) {
				indent$1++;
				if (ch === 9) offset$2 += 4 - offset$2 % 4;
				else offset$2++;
				continue;
			} else indent_found = true;
			if (ch === 10 || pos === len - 1) {
				if (ch !== 10) pos++;
				this.bMarks.push(start);
				this.eMarks.push(pos);
				this.tShift.push(indent$1);
				this.sCount.push(offset$2);
				this.bsCount.push(0);
				indent_found = false;
				indent$1 = 0;
				offset$2 = 0;
				start = pos + 1;
			}
		}
		this.bMarks.push(s.length);
		this.eMarks.push(s.length);
		this.tShift.push(0);
		this.sCount.push(0);
		this.bsCount.push(0);
		this.lineMax = this.bMarks.length - 1;
	}
	StateBlock.prototype.push = function(type, tag$2, nesting) {
		var token = new Token$1(type, tag$2, nesting);
		token.block = true;
		if (nesting < 0) this.level--;
		token.level = this.level;
		if (nesting > 0) this.level++;
		this.tokens.push(token);
		return token;
	};
	StateBlock.prototype.isEmpty = function isEmpty(line) {
		return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
	};
	StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {
		for (var max$2 = this.lineMax; from < max$2; from++) if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) break;
		return from;
	};
	StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
		var ch;
		for (var max$2 = this.src.length; pos < max$2; pos++) {
			ch = this.src.charCodeAt(pos);
			if (!isSpace$4(ch)) break;
		}
		return pos;
	};
	StateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min$2) {
		if (pos <= min$2) return pos;
		while (pos > min$2) if (!isSpace$4(this.src.charCodeAt(--pos))) return pos + 1;
		return pos;
	};
	StateBlock.prototype.skipChars = function skipChars(pos, code) {
		for (var max$2 = this.src.length; pos < max$2; pos++) if (this.src.charCodeAt(pos) !== code) break;
		return pos;
	};
	StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min$2) {
		if (pos <= min$2) return pos;
		while (pos > min$2) if (code !== this.src.charCodeAt(--pos)) return pos + 1;
		return pos;
	};
	StateBlock.prototype.getLines = function getLines(begin, end$1, indent$1, keepLastLF) {
		var i$1, lineIndent, ch, first, last, queue, lineStart, line = begin;
		if (begin >= end$1) return "";
		queue = new Array(end$1 - begin);
		for (i$1 = 0; line < end$1; line++, i$1++) {
			lineIndent = 0;
			lineStart = first = this.bMarks[line];
			if (line + 1 < end$1 || keepLastLF) last = this.eMarks[line] + 1;
			else last = this.eMarks[line];
			while (first < last && lineIndent < indent$1) {
				ch = this.src.charCodeAt(first);
				if (isSpace$4(ch)) if (ch === 9) lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;
				else lineIndent++;
				else if (first - lineStart < this.tShift[line]) lineIndent++;
				else break;
				first++;
			}
			if (lineIndent > indent$1) queue[i$1] = new Array(lineIndent - indent$1 + 1).join(" ") + this.src.slice(first, last);
			else queue[i$1] = this.src.slice(first, last);
		}
		return queue.join("");
	};
	StateBlock.prototype.Token = Token$1;
	module.exports = StateBlock;
}));
var require_parser_block = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Ruler$1 = require_ruler();
	var _rules$1 = [
		[
			"table",
			require_table(),
			["paragraph", "reference"]
		],
		["code", require_code()],
		[
			"fence",
			require_fence(),
			[
				"paragraph",
				"reference",
				"blockquote",
				"list"
			]
		],
		[
			"blockquote",
			require_blockquote(),
			[
				"paragraph",
				"reference",
				"blockquote",
				"list"
			]
		],
		[
			"hr",
			require_hr(),
			[
				"paragraph",
				"reference",
				"blockquote",
				"list"
			]
		],
		[
			"list",
			require_list(),
			[
				"paragraph",
				"reference",
				"blockquote"
			]
		],
		["reference", require_reference()],
		[
			"html_block",
			require_html_block(),
			[
				"paragraph",
				"reference",
				"blockquote"
			]
		],
		[
			"heading",
			require_heading(),
			[
				"paragraph",
				"reference",
				"blockquote"
			]
		],
		["lheading", require_lheading()],
		["paragraph", require_paragraph()]
	];
	function ParserBlock$1() {
		this.ruler = new Ruler$1();
		for (var i$1 = 0; i$1 < _rules$1.length; i$1++) this.ruler.push(_rules$1[i$1][0], _rules$1[i$1][1], { alt: (_rules$1[i$1][2] || []).slice() });
	}
	ParserBlock$1.prototype.tokenize = function(state, startLine, endLine) {
		var ok$1, i$1, prevLine, rules = this.ruler.getRules(""), len = rules.length, line = startLine, hasEmptyLines = false, maxNesting = state.md.options.maxNesting;
		while (line < endLine) {
			state.line = line = state.skipEmptyLines(line);
			if (line >= endLine) break;
			if (state.sCount[line] < state.blkIndent) break;
			if (state.level >= maxNesting) {
				state.line = endLine;
				break;
			}
			prevLine = state.line;
			for (i$1 = 0; i$1 < len; i$1++) {
				ok$1 = rules[i$1](state, line, endLine, false);
				if (ok$1) {
					if (prevLine >= state.line) throw new Error("block rule didn't increment state.line");
					break;
				}
			}
			if (!ok$1) throw new Error("none of the block rules matched");
			state.tight = !hasEmptyLines;
			if (state.isEmpty(state.line - 1)) hasEmptyLines = true;
			line = state.line;
			if (line < endLine && state.isEmpty(line)) {
				hasEmptyLines = true;
				line++;
				state.line = line;
			}
		}
	};
	ParserBlock$1.prototype.parse = function(src, md, env, outTokens) {
		var state;
		if (!src) return;
		state = new this.State(src, md, env, outTokens);
		this.tokenize(state, state.line, state.lineMax);
	};
	ParserBlock$1.prototype.State = require_state_block();
	module.exports = ParserBlock$1;
}));
var require_text = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function isTerminatorChar(ch) {
		switch (ch) {
			case 10:
			case 33:
			case 35:
			case 36:
			case 37:
			case 38:
			case 42:
			case 43:
			case 45:
			case 58:
			case 60:
			case 61:
			case 62:
			case 64:
			case 91:
			case 92:
			case 93:
			case 94:
			case 95:
			case 96:
			case 123:
			case 125:
			case 126: return true;
			default: return false;
		}
	}
	module.exports = function text$7(state, silent) {
		var pos = state.pos;
		while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) pos++;
		if (pos === state.pos) return false;
		if (!silent) state.pending += state.src.slice(state.pos, pos);
		state.pos = pos;
		return true;
	};
}));
var require_linkify = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var SCHEME_RE = /(?:^|[^a-z0-9.+-])([a-z][a-z0-9.+-]*)$/i;
	module.exports = function linkify(state, silent) {
		var pos, max$2, match, proto, link$3, url, fullUrl, token;
		if (!state.md.options.linkify) return false;
		if (state.linkLevel > 0) return false;
		pos = state.pos;
		max$2 = state.posMax;
		if (pos + 3 > max$2) return false;
		if (state.src.charCodeAt(pos) !== 58) return false;
		if (state.src.charCodeAt(pos + 1) !== 47) return false;
		if (state.src.charCodeAt(pos + 2) !== 47) return false;
		match = state.pending.match(SCHEME_RE);
		if (!match) return false;
		proto = match[1];
		link$3 = state.md.linkify.matchAtStart(state.src.slice(pos - proto.length));
		if (!link$3) return false;
		url = link$3.url;
		if (url.length <= proto.length) return false;
		url = url.replace(/\*+$/, "");
		fullUrl = state.md.normalizeLink(url);
		if (!state.md.validateLink(fullUrl)) return false;
		if (!silent) {
			state.pending = state.pending.slice(0, -proto.length);
			token = state.push("link_open", "a", 1);
			token.attrs = [["href", fullUrl]];
			token.markup = "linkify";
			token.info = "auto";
			token = state.push("text", "", 0);
			token.content = state.md.normalizeLinkText(url);
			token = state.push("link_close", "a", -1);
			token.markup = "linkify";
			token.info = "auto";
		}
		state.pos += url.length - proto.length;
		return true;
	};
}));
var require_newline = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var isSpace$3 = require_utils().isSpace;
	module.exports = function newline(state, silent) {
		var pmax, max$2, ws, pos = state.pos;
		if (state.src.charCodeAt(pos) !== 10) return false;
		pmax = state.pending.length - 1;
		max$2 = state.posMax;
		if (!silent) if (pmax >= 0 && state.pending.charCodeAt(pmax) === 32) if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 32) {
			ws = pmax - 1;
			while (ws >= 1 && state.pending.charCodeAt(ws - 1) === 32) ws--;
			state.pending = state.pending.slice(0, ws);
			state.push("hardbreak", "br", 0);
		} else {
			state.pending = state.pending.slice(0, -1);
			state.push("softbreak", "br", 0);
		}
		else state.push("softbreak", "br", 0);
		pos++;
		while (pos < max$2 && isSpace$3(state.src.charCodeAt(pos))) pos++;
		state.pos = pos;
		return true;
	};
}));
var require_escape = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var isSpace$2 = require_utils().isSpace;
	var ESCAPED = [];
	for (var i = 0; i < 256; i++) ESCAPED.push(0);
	"\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(ch) {
		ESCAPED[ch.charCodeAt(0)] = 1;
	});
	module.exports = function escape(state, silent) {
		var ch1, ch2, origStr, escapedStr, token, pos = state.pos, max$2 = state.posMax;
		if (state.src.charCodeAt(pos) !== 92) return false;
		pos++;
		if (pos >= max$2) return false;
		ch1 = state.src.charCodeAt(pos);
		if (ch1 === 10) {
			if (!silent) state.push("hardbreak", "br", 0);
			pos++;
			while (pos < max$2) {
				ch1 = state.src.charCodeAt(pos);
				if (!isSpace$2(ch1)) break;
				pos++;
			}
			state.pos = pos;
			return true;
		}
		escapedStr = state.src[pos];
		if (ch1 >= 55296 && ch1 <= 56319 && pos + 1 < max$2) {
			ch2 = state.src.charCodeAt(pos + 1);
			if (ch2 >= 56320 && ch2 <= 57343) {
				escapedStr += state.src[pos + 1];
				pos++;
			}
		}
		origStr = "\\" + escapedStr;
		if (!silent) {
			token = state.push("text_special", "", 0);
			if (ch1 < 256 && ESCAPED[ch1] !== 0) token.content = escapedStr;
			else token.content = origStr;
			token.markup = origStr;
			token.info = "escape";
		}
		state.pos = pos + 1;
		return true;
	};
}));
var require_backticks = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = function backtick(state, silent) {
		var start, max$2, marker$1, token, matchStart, matchEnd, openerLength, closerLength, pos = state.pos;
		if (state.src.charCodeAt(pos) !== 96) return false;
		start = pos;
		pos++;
		max$2 = state.posMax;
		while (pos < max$2 && state.src.charCodeAt(pos) === 96) pos++;
		marker$1 = state.src.slice(start, pos);
		openerLength = marker$1.length;
		if (state.backticksScanned && (state.backticks[openerLength] || 0) <= start) {
			if (!silent) state.pending += marker$1;
			state.pos += openerLength;
			return true;
		}
		matchEnd = pos;
		while ((matchStart = state.src.indexOf("`", matchEnd)) !== -1) {
			matchEnd = matchStart + 1;
			while (matchEnd < max$2 && state.src.charCodeAt(matchEnd) === 96) matchEnd++;
			closerLength = matchEnd - matchStart;
			if (closerLength === openerLength) {
				if (!silent) {
					token = state.push("code_inline", "code", 0);
					token.markup = marker$1;
					token.content = state.src.slice(pos, matchStart).replace(/\n/g, " ").replace(/^ (.+) $/, "$1");
				}
				state.pos = matchEnd;
				return true;
			}
			state.backticks[closerLength] = matchStart;
		}
		state.backticksScanned = true;
		if (!silent) state.pending += marker$1;
		state.pos += openerLength;
		return true;
	};
}));
var require_strikethrough = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports.tokenize = function strikethrough(state, silent) {
		var i$1, scanned, token, len, ch, start = state.pos, marker$1 = state.src.charCodeAt(start);
		if (silent) return false;
		if (marker$1 !== 126) return false;
		scanned = state.scanDelims(state.pos, true);
		len = scanned.length;
		ch = String.fromCharCode(marker$1);
		if (len < 2) return false;
		if (len % 2) {
			token = state.push("text", "", 0);
			token.content = ch;
			len--;
		}
		for (i$1 = 0; i$1 < len; i$1 += 2) {
			token = state.push("text", "", 0);
			token.content = ch + ch;
			state.delimiters.push({
				marker: marker$1,
				length: 0,
				token: state.tokens.length - 1,
				end: -1,
				open: scanned.can_open,
				close: scanned.can_close
			});
		}
		state.pos += scanned.length;
		return true;
	};
	function postProcess$1(state, delimiters) {
		var i$1, j$1, startDelim, endDelim, token, loneMarkers = [], max$2 = delimiters.length;
		for (i$1 = 0; i$1 < max$2; i$1++) {
			startDelim = delimiters[i$1];
			if (startDelim.marker !== 126) continue;
			if (startDelim.end === -1) continue;
			endDelim = delimiters[startDelim.end];
			token = state.tokens[startDelim.token];
			token.type = "s_open";
			token.tag = "s";
			token.nesting = 1;
			token.markup = "~~";
			token.content = "";
			token = state.tokens[endDelim.token];
			token.type = "s_close";
			token.tag = "s";
			token.nesting = -1;
			token.markup = "~~";
			token.content = "";
			if (state.tokens[endDelim.token - 1].type === "text" && state.tokens[endDelim.token - 1].content === "~") loneMarkers.push(endDelim.token - 1);
		}
		while (loneMarkers.length) {
			i$1 = loneMarkers.pop();
			j$1 = i$1 + 1;
			while (j$1 < state.tokens.length && state.tokens[j$1].type === "s_close") j$1++;
			j$1--;
			if (i$1 !== j$1) {
				token = state.tokens[j$1];
				state.tokens[j$1] = state.tokens[i$1];
				state.tokens[i$1] = token;
			}
		}
	}
	module.exports.postProcess = function strikethrough(state) {
		var curr, tokens_meta = state.tokens_meta, max$2 = state.tokens_meta.length;
		postProcess$1(state, state.delimiters);
		for (curr = 0; curr < max$2; curr++) if (tokens_meta[curr] && tokens_meta[curr].delimiters) postProcess$1(state, tokens_meta[curr].delimiters);
	};
}));
var require_emphasis = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports.tokenize = function emphasis(state, silent) {
		var i$1, scanned, token, start = state.pos, marker$1 = state.src.charCodeAt(start);
		if (silent) return false;
		if (marker$1 !== 95 && marker$1 !== 42) return false;
		scanned = state.scanDelims(state.pos, marker$1 === 42);
		for (i$1 = 0; i$1 < scanned.length; i$1++) {
			token = state.push("text", "", 0);
			token.content = String.fromCharCode(marker$1);
			state.delimiters.push({
				marker: marker$1,
				length: scanned.length,
				token: state.tokens.length - 1,
				end: -1,
				open: scanned.can_open,
				close: scanned.can_close
			});
		}
		state.pos += scanned.length;
		return true;
	};
	function postProcess(state, delimiters) {
		var i$1, startDelim, endDelim, token, ch, isStrong;
		for (i$1 = delimiters.length - 1; i$1 >= 0; i$1--) {
			startDelim = delimiters[i$1];
			if (startDelim.marker !== 95 && startDelim.marker !== 42) continue;
			if (startDelim.end === -1) continue;
			endDelim = delimiters[startDelim.end];
			isStrong = i$1 > 0 && delimiters[i$1 - 1].end === startDelim.end + 1 && delimiters[i$1 - 1].marker === startDelim.marker && delimiters[i$1 - 1].token === startDelim.token - 1 && delimiters[startDelim.end + 1].token === endDelim.token + 1;
			ch = String.fromCharCode(startDelim.marker);
			token = state.tokens[startDelim.token];
			token.type = isStrong ? "strong_open" : "em_open";
			token.tag = isStrong ? "strong" : "em";
			token.nesting = 1;
			token.markup = isStrong ? ch + ch : ch;
			token.content = "";
			token = state.tokens[endDelim.token];
			token.type = isStrong ? "strong_close" : "em_close";
			token.tag = isStrong ? "strong" : "em";
			token.nesting = -1;
			token.markup = isStrong ? ch + ch : ch;
			token.content = "";
			if (isStrong) {
				state.tokens[delimiters[i$1 - 1].token].content = "";
				state.tokens[delimiters[startDelim.end + 1].token].content = "";
				i$1--;
			}
		}
	}
	module.exports.postProcess = function emphasis(state) {
		var curr, tokens_meta = state.tokens_meta, max$2 = state.tokens_meta.length;
		postProcess(state, state.delimiters);
		for (curr = 0; curr < max$2; curr++) if (tokens_meta[curr] && tokens_meta[curr].delimiters) postProcess(state, tokens_meta[curr].delimiters);
	};
}));
var require_link = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var normalizeReference$1 = require_utils().normalizeReference;
	var isSpace$1 = require_utils().isSpace;
	module.exports = function link$3(state, silent) {
		var attrs, code, label$3, labelEnd, labelStart, pos, res, ref$1, token, href = "", title$3 = "", oldPos = state.pos, max$2 = state.posMax, start = state.pos, parseReference = true;
		if (state.src.charCodeAt(state.pos) !== 91) return false;
		labelStart = state.pos + 1;
		labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);
		if (labelEnd < 0) return false;
		pos = labelEnd + 1;
		if (pos < max$2 && state.src.charCodeAt(pos) === 40) {
			parseReference = false;
			pos++;
			for (; pos < max$2; pos++) {
				code = state.src.charCodeAt(pos);
				if (!isSpace$1(code) && code !== 10) break;
			}
			if (pos >= max$2) return false;
			start = pos;
			res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
			if (res.ok) {
				href = state.md.normalizeLink(res.str);
				if (state.md.validateLink(href)) pos = res.pos;
				else href = "";
				start = pos;
				for (; pos < max$2; pos++) {
					code = state.src.charCodeAt(pos);
					if (!isSpace$1(code) && code !== 10) break;
				}
				res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
				if (pos < max$2 && start !== pos && res.ok) {
					title$3 = res.str;
					pos = res.pos;
					for (; pos < max$2; pos++) {
						code = state.src.charCodeAt(pos);
						if (!isSpace$1(code) && code !== 10) break;
					}
				}
			}
			if (pos >= max$2 || state.src.charCodeAt(pos) !== 41) parseReference = true;
			pos++;
		}
		if (parseReference) {
			if (typeof state.env.references === "undefined") return false;
			if (pos < max$2 && state.src.charCodeAt(pos) === 91) {
				start = pos + 1;
				pos = state.md.helpers.parseLinkLabel(state, pos);
				if (pos >= 0) label$3 = state.src.slice(start, pos++);
				else pos = labelEnd + 1;
			} else pos = labelEnd + 1;
			if (!label$3) label$3 = state.src.slice(labelStart, labelEnd);
			ref$1 = state.env.references[normalizeReference$1(label$3)];
			if (!ref$1) {
				state.pos = oldPos;
				return false;
			}
			href = ref$1.href;
			title$3 = ref$1.title;
		}
		if (!silent) {
			state.pos = labelStart;
			state.posMax = labelEnd;
			token = state.push("link_open", "a", 1);
			token.attrs = attrs = [["href", href]];
			if (title$3) attrs.push(["title", title$3]);
			state.linkLevel++;
			state.md.inline.tokenize(state);
			state.linkLevel--;
			token = state.push("link_close", "a", -1);
		}
		state.pos = pos;
		state.posMax = max$2;
		return true;
	};
}));
var require_image = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var normalizeReference = require_utils().normalizeReference;
	var isSpace = require_utils().isSpace;
	module.exports = function image$2(state, silent) {
		var attrs, code, content$4, label$3, labelEnd, labelStart, pos, ref$1, res, title$3, token, tokens, start, href = "", oldPos = state.pos, max$2 = state.posMax;
		if (state.src.charCodeAt(state.pos) !== 33) return false;
		if (state.src.charCodeAt(state.pos + 1) !== 91) return false;
		labelStart = state.pos + 2;
		labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);
		if (labelEnd < 0) return false;
		pos = labelEnd + 1;
		if (pos < max$2 && state.src.charCodeAt(pos) === 40) {
			pos++;
			for (; pos < max$2; pos++) {
				code = state.src.charCodeAt(pos);
				if (!isSpace(code) && code !== 10) break;
			}
			if (pos >= max$2) return false;
			start = pos;
			res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
			if (res.ok) {
				href = state.md.normalizeLink(res.str);
				if (state.md.validateLink(href)) pos = res.pos;
				else href = "";
			}
			start = pos;
			for (; pos < max$2; pos++) {
				code = state.src.charCodeAt(pos);
				if (!isSpace(code) && code !== 10) break;
			}
			res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
			if (pos < max$2 && start !== pos && res.ok) {
				title$3 = res.str;
				pos = res.pos;
				for (; pos < max$2; pos++) {
					code = state.src.charCodeAt(pos);
					if (!isSpace(code) && code !== 10) break;
				}
			} else title$3 = "";
			if (pos >= max$2 || state.src.charCodeAt(pos) !== 41) {
				state.pos = oldPos;
				return false;
			}
			pos++;
		} else {
			if (typeof state.env.references === "undefined") return false;
			if (pos < max$2 && state.src.charCodeAt(pos) === 91) {
				start = pos + 1;
				pos = state.md.helpers.parseLinkLabel(state, pos);
				if (pos >= 0) label$3 = state.src.slice(start, pos++);
				else pos = labelEnd + 1;
			} else pos = labelEnd + 1;
			if (!label$3) label$3 = state.src.slice(labelStart, labelEnd);
			ref$1 = state.env.references[normalizeReference(label$3)];
			if (!ref$1) {
				state.pos = oldPos;
				return false;
			}
			href = ref$1.href;
			title$3 = ref$1.title;
		}
		if (!silent) {
			content$4 = state.src.slice(labelStart, labelEnd);
			state.md.inline.parse(content$4, state.md, state.env, tokens = []);
			token = state.push("image", "img", 0);
			token.attrs = attrs = [["src", href], ["alt", ""]];
			token.children = tokens;
			token.content = content$4;
			if (title$3) attrs.push(["title", title$3]);
		}
		state.pos = pos;
		state.posMax = max$2;
		return true;
	};
}));
var require_autolink = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var EMAIL_RE = /^([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/;
	var AUTOLINK_RE = /^([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)$/;
	module.exports = function autolink(state, silent) {
		var url, fullUrl, token, ch, start, max$2, pos = state.pos;
		if (state.src.charCodeAt(pos) !== 60) return false;
		start = state.pos;
		max$2 = state.posMax;
		for (;;) {
			if (++pos >= max$2) return false;
			ch = state.src.charCodeAt(pos);
			if (ch === 60) return false;
			if (ch === 62) break;
		}
		url = state.src.slice(start + 1, pos);
		if (AUTOLINK_RE.test(url)) {
			fullUrl = state.md.normalizeLink(url);
			if (!state.md.validateLink(fullUrl)) return false;
			if (!silent) {
				token = state.push("link_open", "a", 1);
				token.attrs = [["href", fullUrl]];
				token.markup = "autolink";
				token.info = "auto";
				token = state.push("text", "", 0);
				token.content = state.md.normalizeLinkText(url);
				token = state.push("link_close", "a", -1);
				token.markup = "autolink";
				token.info = "auto";
			}
			state.pos += url.length + 2;
			return true;
		}
		if (EMAIL_RE.test(url)) {
			fullUrl = state.md.normalizeLink("mailto:" + url);
			if (!state.md.validateLink(fullUrl)) return false;
			if (!silent) {
				token = state.push("link_open", "a", 1);
				token.attrs = [["href", fullUrl]];
				token.markup = "autolink";
				token.info = "auto";
				token = state.push("text", "", 0);
				token.content = state.md.normalizeLinkText(url);
				token = state.push("link_close", "a", -1);
				token.markup = "autolink";
				token.info = "auto";
			}
			state.pos += url.length + 2;
			return true;
		}
		return false;
	};
}));
var require_html_inline = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var HTML_TAG_RE = require_html_re().HTML_TAG_RE;
	function isLinkOpen(str) {
		return /^<a[>\s]/i.test(str);
	}
	function isLinkClose(str) {
		return /^<\/a\s*>/i.test(str);
	}
	function isLetter(ch) {
		var lc = ch | 32;
		return lc >= 97 && lc <= 122;
	}
	module.exports = function html_inline(state, silent) {
		var ch, match, max$2, token, pos = state.pos;
		if (!state.md.options.html) return false;
		max$2 = state.posMax;
		if (state.src.charCodeAt(pos) !== 60 || pos + 2 >= max$2) return false;
		ch = state.src.charCodeAt(pos + 1);
		if (ch !== 33 && ch !== 63 && ch !== 47 && !isLetter(ch)) return false;
		match = state.src.slice(pos).match(HTML_TAG_RE);
		if (!match) return false;
		if (!silent) {
			token = state.push("html_inline", "", 0);
			token.content = match[0];
			if (isLinkOpen(token.content)) state.linkLevel++;
			if (isLinkClose(token.content)) state.linkLevel--;
		}
		state.pos += match[0].length;
		return true;
	};
}));
var require_entity = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var entities = require_entities();
	var has = require_utils().has;
	var isValidEntityCode = require_utils().isValidEntityCode;
	var fromCodePoint = require_utils().fromCodePoint;
	var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i;
	var NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;
	module.exports = function entity(state, silent) {
		var ch, code, match, token, pos = state.pos, max$2 = state.posMax;
		if (state.src.charCodeAt(pos) !== 38) return false;
		if (pos + 1 >= max$2) return false;
		ch = state.src.charCodeAt(pos + 1);
		if (ch === 35) {
			match = state.src.slice(pos).match(DIGITAL_RE);
			if (match) {
				if (!silent) {
					code = match[1][0].toLowerCase() === "x" ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);
					token = state.push("text_special", "", 0);
					token.content = isValidEntityCode(code) ? fromCodePoint(code) : fromCodePoint(65533);
					token.markup = match[0];
					token.info = "entity";
				}
				state.pos += match[0].length;
				return true;
			}
		} else {
			match = state.src.slice(pos).match(NAMED_RE);
			if (match) {
				if (has(entities, match[1])) {
					if (!silent) {
						token = state.push("text_special", "", 0);
						token.content = entities[match[1]];
						token.markup = match[0];
						token.info = "entity";
					}
					state.pos += match[0].length;
					return true;
				}
			}
		}
		return false;
	};
}));
var require_balance_pairs = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function processDelimiters(delimiters) {
		var closerIdx, openerIdx, closer, opener, minOpenerIdx, newMinOpenerIdx, isOddMatch, lastJump, openersBottom = {}, max$2 = delimiters.length;
		if (!max$2) return;
		var headerIdx = 0;
		var lastTokenIdx = -2;
		var jumps = [];
		for (closerIdx = 0; closerIdx < max$2; closerIdx++) {
			closer = delimiters[closerIdx];
			jumps.push(0);
			if (delimiters[headerIdx].marker !== closer.marker || lastTokenIdx !== closer.token - 1) headerIdx = closerIdx;
			lastTokenIdx = closer.token;
			closer.length = closer.length || 0;
			if (!closer.close) continue;
			if (!openersBottom.hasOwnProperty(closer.marker)) openersBottom[closer.marker] = [
				-1,
				-1,
				-1,
				-1,
				-1,
				-1
			];
			minOpenerIdx = openersBottom[closer.marker][(closer.open ? 3 : 0) + closer.length % 3];
			openerIdx = headerIdx - jumps[headerIdx] - 1;
			newMinOpenerIdx = openerIdx;
			for (; openerIdx > minOpenerIdx; openerIdx -= jumps[openerIdx] + 1) {
				opener = delimiters[openerIdx];
				if (opener.marker !== closer.marker) continue;
				if (opener.open && opener.end < 0) {
					isOddMatch = false;
					if (opener.close || closer.open) {
						if ((opener.length + closer.length) % 3 === 0) {
							if (opener.length % 3 !== 0 || closer.length % 3 !== 0) isOddMatch = true;
						}
					}
					if (!isOddMatch) {
						lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open ? jumps[openerIdx - 1] + 1 : 0;
						jumps[closerIdx] = closerIdx - openerIdx + lastJump;
						jumps[openerIdx] = lastJump;
						closer.open = false;
						opener.end = closerIdx;
						opener.close = false;
						newMinOpenerIdx = -1;
						lastTokenIdx = -2;
						break;
					}
				}
			}
			if (newMinOpenerIdx !== -1) openersBottom[closer.marker][(closer.open ? 3 : 0) + (closer.length || 0) % 3] = newMinOpenerIdx;
		}
	}
	module.exports = function link_pairs(state) {
		var curr, tokens_meta = state.tokens_meta, max$2 = state.tokens_meta.length;
		processDelimiters(state.delimiters);
		for (curr = 0; curr < max$2; curr++) if (tokens_meta[curr] && tokens_meta[curr].delimiters) processDelimiters(tokens_meta[curr].delimiters);
	};
}));
var require_fragments_join = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = function fragments_join(state) {
		var curr, last, level = 0, tokens = state.tokens, max$2 = state.tokens.length;
		for (curr = last = 0; curr < max$2; curr++) {
			if (tokens[curr].nesting < 0) level--;
			tokens[curr].level = level;
			if (tokens[curr].nesting > 0) level++;
			if (tokens[curr].type === "text" && curr + 1 < max$2 && tokens[curr + 1].type === "text") tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
			else {
				if (curr !== last) tokens[last] = tokens[curr];
				last++;
			}
		}
		if (curr !== last) tokens.length = last;
	};
}));
var require_state_inline = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Token = require_token();
	var isWhiteSpace = require_utils().isWhiteSpace;
	var isPunctChar = require_utils().isPunctChar;
	var isMdAsciiPunct = require_utils().isMdAsciiPunct;
	function StateInline(src, md, env, outTokens) {
		this.src = src;
		this.env = env;
		this.md = md;
		this.tokens = outTokens;
		this.tokens_meta = Array(outTokens.length);
		this.pos = 0;
		this.posMax = this.src.length;
		this.level = 0;
		this.pending = "";
		this.pendingLevel = 0;
		this.cache = {};
		this.delimiters = [];
		this._prev_delimiters = [];
		this.backticks = {};
		this.backticksScanned = false;
		this.linkLevel = 0;
	}
	StateInline.prototype.pushPending = function() {
		var token = new Token("text", "", 0);
		token.content = this.pending;
		token.level = this.pendingLevel;
		this.tokens.push(token);
		this.pending = "";
		return token;
	};
	StateInline.prototype.push = function(type, tag$2, nesting) {
		if (this.pending) this.pushPending();
		var token = new Token(type, tag$2, nesting);
		var token_meta = null;
		if (nesting < 0) {
			this.level--;
			this.delimiters = this._prev_delimiters.pop();
		}
		token.level = this.level;
		if (nesting > 0) {
			this.level++;
			this._prev_delimiters.push(this.delimiters);
			this.delimiters = [];
			token_meta = { delimiters: this.delimiters };
		}
		this.pendingLevel = this.level;
		this.tokens.push(token);
		this.tokens_meta.push(token_meta);
		return token;
	};
	StateInline.prototype.scanDelims = function(start, canSplitWord) {
		var pos = start, lastChar, nextChar, count$3, can_open, can_close, isLastWhiteSpace, isLastPunctChar, isNextWhiteSpace, isNextPunctChar, left_flanking = true, right_flanking = true, max$2 = this.posMax, marker$1 = this.src.charCodeAt(start);
		lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 32;
		while (pos < max$2 && this.src.charCodeAt(pos) === marker$1) pos++;
		count$3 = pos - start;
		nextChar = pos < max$2 ? this.src.charCodeAt(pos) : 32;
		isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
		isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
		isLastWhiteSpace = isWhiteSpace(lastChar);
		isNextWhiteSpace = isWhiteSpace(nextChar);
		if (isNextWhiteSpace) left_flanking = false;
		else if (isNextPunctChar) {
			if (!(isLastWhiteSpace || isLastPunctChar)) left_flanking = false;
		}
		if (isLastWhiteSpace) right_flanking = false;
		else if (isLastPunctChar) {
			if (!(isNextWhiteSpace || isNextPunctChar)) right_flanking = false;
		}
		if (!canSplitWord) {
			can_open = left_flanking && (!right_flanking || isLastPunctChar);
			can_close = right_flanking && (!left_flanking || isNextPunctChar);
		} else {
			can_open = left_flanking;
			can_close = right_flanking;
		}
		return {
			can_open,
			can_close,
			length: count$3
		};
	};
	StateInline.prototype.Token = Token;
	module.exports = StateInline;
}));
var require_parser_inline = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Ruler = require_ruler();
	var _rules = [
		["text", require_text()],
		["linkify", require_linkify()],
		["newline", require_newline()],
		["escape", require_escape()],
		["backticks", require_backticks()],
		["strikethrough", require_strikethrough().tokenize],
		["emphasis", require_emphasis().tokenize],
		["link", require_link()],
		["image", require_image()],
		["autolink", require_autolink()],
		["html_inline", require_html_inline()],
		["entity", require_entity()]
	];
	var _rules2 = [
		["balance_pairs", require_balance_pairs()],
		["strikethrough", require_strikethrough().postProcess],
		["emphasis", require_emphasis().postProcess],
		["fragments_join", require_fragments_join()]
	];
	function ParserInline$1() {
		var i$1;
		this.ruler = new Ruler();
		for (i$1 = 0; i$1 < _rules.length; i$1++) this.ruler.push(_rules[i$1][0], _rules[i$1][1]);
		this.ruler2 = new Ruler();
		for (i$1 = 0; i$1 < _rules2.length; i$1++) this.ruler2.push(_rules2[i$1][0], _rules2[i$1][1]);
	}
	ParserInline$1.prototype.skipToken = function(state) {
		var ok$1, i$1, pos = state.pos, rules = this.ruler.getRules(""), len = rules.length, maxNesting = state.md.options.maxNesting, cache$1 = state.cache;
		if (typeof cache$1[pos] !== "undefined") {
			state.pos = cache$1[pos];
			return;
		}
		if (state.level < maxNesting) for (i$1 = 0; i$1 < len; i$1++) {
			state.level++;
			ok$1 = rules[i$1](state, true);
			state.level--;
			if (ok$1) {
				if (pos >= state.pos) throw new Error("inline rule didn't increment state.pos");
				break;
			}
		}
		else state.pos = state.posMax;
		if (!ok$1) state.pos++;
		cache$1[pos] = state.pos;
	};
	ParserInline$1.prototype.tokenize = function(state) {
		var ok$1, i$1, prevPos, rules = this.ruler.getRules(""), len = rules.length, end$1 = state.posMax, maxNesting = state.md.options.maxNesting;
		while (state.pos < end$1) {
			prevPos = state.pos;
			if (state.level < maxNesting) for (i$1 = 0; i$1 < len; i$1++) {
				ok$1 = rules[i$1](state, false);
				if (ok$1) {
					if (prevPos >= state.pos) throw new Error("inline rule didn't increment state.pos");
					break;
				}
			}
			if (ok$1) {
				if (state.pos >= end$1) break;
				continue;
			}
			state.pending += state.src[state.pos++];
		}
		if (state.pending) state.pushPending();
	};
	ParserInline$1.prototype.parse = function(str, md, env, outTokens) {
		var i$1, rules, len;
		var state = new this.State(str, md, env, outTokens);
		this.tokenize(state);
		rules = this.ruler2.getRules("");
		len = rules.length;
		for (i$1 = 0; i$1 < len; i$1++) rules[i$1](state);
	};
	ParserInline$1.prototype.State = require_state_inline();
	module.exports = ParserInline$1;
}));
var require_re = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = function(opts) {
		var re$1 = {};
		opts = opts || {};
		re$1.src_Any = require_regex$3().source;
		re$1.src_Cc = require_regex$2().source;
		re$1.src_Z = require_regex().source;
		re$1.src_P = require_regex$4().source;
		re$1.src_ZPCc = [
			re$1.src_Z,
			re$1.src_P,
			re$1.src_Cc
		].join("|");
		re$1.src_ZCc = [re$1.src_Z, re$1.src_Cc].join("|");
		var text_separators = "[><]";
		re$1.src_pseudo_letter = "(?:(?!" + text_separators + "|" + re$1.src_ZPCc + ")" + re$1.src_Any + ")";
		re$1.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)";
		re$1.src_auth = "(?:(?:(?!" + re$1.src_ZCc + "|[@/\\[\\]()]).)+@)?";
		re$1.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?";
		re$1.src_host_terminator = "(?=$|" + text_separators + "|" + re$1.src_ZPCc + ")(?!" + (opts["---"] ? "-(?!--)|" : "-|") + "_|:\\d|\\.-|\\.(?!$|" + re$1.src_ZPCc + "))";
		re$1.src_path = "(?:[/?#](?:(?!" + re$1.src_ZCc + "|" + text_separators + "|[()[\\]{}.,\"'?!\\-;]).|\\[(?:(?!" + re$1.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + re$1.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + re$1.src_ZCc + "|[}]).)*\\}|\\\"(?:(?!" + re$1.src_ZCc + "|[\"]).)+\\\"|\\'(?:(?!" + re$1.src_ZCc + "|[']).)+\\'|\\'(?=" + re$1.src_pseudo_letter + "|[-])|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + re$1.src_ZCc + "|[.]|$)|" + (opts["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + ",(?!" + re$1.src_ZCc + "|$)|;(?!" + re$1.src_ZCc + "|$)|\\!+(?!" + re$1.src_ZCc + "|[!]|$)|\\?(?!" + re$1.src_ZCc + "|[?]|$))+|\\/)?";
		re$1.src_email_name = "[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\\"\\.a-zA-Z0-9_]*";
		re$1.src_xn = "xn--[a-z0-9\\-]{1,59}";
		re$1.src_domain_root = "(?:" + re$1.src_xn + "|" + re$1.src_pseudo_letter + "{1,63})";
		re$1.src_domain = "(?:" + re$1.src_xn + "|(?:" + re$1.src_pseudo_letter + ")|(?:" + re$1.src_pseudo_letter + "(?:-|" + re$1.src_pseudo_letter + "){0,61}" + re$1.src_pseudo_letter + "))";
		re$1.src_host = "(?:(?:(?:(?:" + re$1.src_domain + ")\\.)*" + re$1.src_domain + "))";
		re$1.tpl_host_fuzzy = "(?:" + re$1.src_ip4 + "|(?:(?:(?:" + re$1.src_domain + ")\\.)+(?:%TLDS%)))";
		re$1.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + re$1.src_domain + ")\\.)+(?:%TLDS%))";
		re$1.src_host_strict = re$1.src_host + re$1.src_host_terminator;
		re$1.tpl_host_fuzzy_strict = re$1.tpl_host_fuzzy + re$1.src_host_terminator;
		re$1.src_host_port_strict = re$1.src_host + re$1.src_port + re$1.src_host_terminator;
		re$1.tpl_host_port_fuzzy_strict = re$1.tpl_host_fuzzy + re$1.src_port + re$1.src_host_terminator;
		re$1.tpl_host_port_no_ip_fuzzy_strict = re$1.tpl_host_no_ip_fuzzy + re$1.src_port + re$1.src_host_terminator;
		re$1.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + re$1.src_ZPCc + "|>|$))";
		re$1.tpl_email_fuzzy = "(^|" + text_separators + "|\"|\\(|" + re$1.src_ZCc + ")(" + re$1.src_email_name + "@" + re$1.tpl_host_fuzzy_strict + ")";
		re$1.tpl_link_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|]|" + re$1.src_ZPCc + "))((?![$+<=>^`|])" + re$1.tpl_host_port_fuzzy_strict + re$1.src_path + ")";
		re$1.tpl_link_no_ip_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|]|" + re$1.src_ZPCc + "))((?![$+<=>^`|])" + re$1.tpl_host_port_no_ip_fuzzy_strict + re$1.src_path + ")";
		return re$1;
	};
}));
var require_linkify_it = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function assign(obj) {
		Array.prototype.slice.call(arguments, 1).forEach(function(source) {
			if (!source) return;
			Object.keys(source).forEach(function(key$2) {
				obj[key$2] = source[key$2];
			});
		});
		return obj;
	}
	function _class(obj) {
		return Object.prototype.toString.call(obj);
	}
	function isString(obj) {
		return _class(obj) === "[object String]";
	}
	function isObject$1(obj) {
		return _class(obj) === "[object Object]";
	}
	function isRegExp(obj) {
		return _class(obj) === "[object RegExp]";
	}
	function isFunction$1(obj) {
		return _class(obj) === "[object Function]";
	}
	function escapeRE(str) {
		return str.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
	}
	var defaultOptions = {
		fuzzyLink: true,
		fuzzyEmail: true,
		fuzzyIP: false
	};
	function isOptionsObj(obj) {
		return Object.keys(obj || {}).reduce(function(acc, k) {
			return acc || defaultOptions.hasOwnProperty(k);
		}, false);
	}
	var defaultSchemas = {
		"http:": { validate: function(text$7, pos, self$1) {
			var tail = text$7.slice(pos);
			if (!self$1.re.http) self$1.re.http = new RegExp("^\\/\\/" + self$1.re.src_auth + self$1.re.src_host_port_strict + self$1.re.src_path, "i");
			if (self$1.re.http.test(tail)) return tail.match(self$1.re.http)[0].length;
			return 0;
		} },
		"https:": "http:",
		"ftp:": "http:",
		"//": { validate: function(text$7, pos, self$1) {
			var tail = text$7.slice(pos);
			if (!self$1.re.no_http) self$1.re.no_http = new RegExp("^" + self$1.re.src_auth + "(?:localhost|(?:(?:" + self$1.re.src_domain + ")\\.)+" + self$1.re.src_domain_root + ")" + self$1.re.src_port + self$1.re.src_host_terminator + self$1.re.src_path, "i");
			if (self$1.re.no_http.test(tail)) {
				if (pos >= 3 && text$7[pos - 3] === ":") return 0;
				if (pos >= 3 && text$7[pos - 3] === "/") return 0;
				return tail.match(self$1.re.no_http)[0].length;
			}
			return 0;
		} },
		"mailto:": { validate: function(text$7, pos, self$1) {
			var tail = text$7.slice(pos);
			if (!self$1.re.mailto) self$1.re.mailto = new RegExp("^" + self$1.re.src_email_name + "@" + self$1.re.src_host_strict, "i");
			if (self$1.re.mailto.test(tail)) return tail.match(self$1.re.mailto)[0].length;
			return 0;
		} }
	};
	var tlds_2ch_src_re = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]";
	var tlds_default = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|".split("|");
	function resetScanCache(self$1) {
		self$1.__index__ = -1;
		self$1.__text_cache__ = "";
	}
	function createValidator(re$1) {
		return function(text$7, pos) {
			var tail = text$7.slice(pos);
			if (re$1.test(tail)) return tail.match(re$1)[0].length;
			return 0;
		};
	}
	function createNormalizer() {
		return function(match, self$1) {
			self$1.normalize(match);
		};
	}
	function compile(self$1) {
		var re$1 = self$1.re = require_re()(self$1.__opts__);
		var tlds = self$1.__tlds__.slice();
		self$1.onCompile();
		if (!self$1.__tlds_replaced__) tlds.push(tlds_2ch_src_re);
		tlds.push(re$1.src_xn);
		re$1.src_tlds = tlds.join("|");
		function untpl(tpl) {
			return tpl.replace("%TLDS%", re$1.src_tlds);
		}
		re$1.email_fuzzy = RegExp(untpl(re$1.tpl_email_fuzzy), "i");
		re$1.link_fuzzy = RegExp(untpl(re$1.tpl_link_fuzzy), "i");
		re$1.link_no_ip_fuzzy = RegExp(untpl(re$1.tpl_link_no_ip_fuzzy), "i");
		re$1.host_fuzzy_test = RegExp(untpl(re$1.tpl_host_fuzzy_test), "i");
		var aliases = [];
		self$1.__compiled__ = {};
		function schemaError(name$1, val) {
			throw new Error("(LinkifyIt) Invalid schema \"" + name$1 + "\": " + val);
		}
		Object.keys(self$1.__schemas__).forEach(function(name$1) {
			var val = self$1.__schemas__[name$1];
			if (val === null) return;
			var compiled = {
				validate: null,
				link: null
			};
			self$1.__compiled__[name$1] = compiled;
			if (isObject$1(val)) {
				if (isRegExp(val.validate)) compiled.validate = createValidator(val.validate);
				else if (isFunction$1(val.validate)) compiled.validate = val.validate;
				else schemaError(name$1, val);
				if (isFunction$1(val.normalize)) compiled.normalize = val.normalize;
				else if (!val.normalize) compiled.normalize = createNormalizer();
				else schemaError(name$1, val);
				return;
			}
			if (isString(val)) {
				aliases.push(name$1);
				return;
			}
			schemaError(name$1, val);
		});
		aliases.forEach(function(alias) {
			if (!self$1.__compiled__[self$1.__schemas__[alias]]) return;
			self$1.__compiled__[alias].validate = self$1.__compiled__[self$1.__schemas__[alias]].validate;
			self$1.__compiled__[alias].normalize = self$1.__compiled__[self$1.__schemas__[alias]].normalize;
		});
		self$1.__compiled__[""] = {
			validate: null,
			normalize: createNormalizer()
		};
		var slist = Object.keys(self$1.__compiled__).filter(function(name$1) {
			return name$1.length > 0 && self$1.__compiled__[name$1];
		}).map(escapeRE).join("|");
		self$1.re.schema_test = RegExp("(^|(?!_)(?:[><]|" + re$1.src_ZPCc + "))(" + slist + ")", "i");
		self$1.re.schema_search = RegExp("(^|(?!_)(?:[><]|" + re$1.src_ZPCc + "))(" + slist + ")", "ig");
		self$1.re.schema_at_start = RegExp("^" + self$1.re.schema_search.source, "i");
		self$1.re.pretest = RegExp("(" + self$1.re.schema_test.source + ")|(" + self$1.re.host_fuzzy_test.source + ")|@", "i");
		resetScanCache(self$1);
	}
	function Match(self$1, shift$2) {
		var start = self$1.__index__, end$1 = self$1.__last_index__, text$7 = self$1.__text_cache__.slice(start, end$1);
		this.schema = self$1.__schema__.toLowerCase();
		this.index = start + shift$2;
		this.lastIndex = end$1 + shift$2;
		this.raw = text$7;
		this.text = text$7;
		this.url = text$7;
	}
	function createMatch(self$1, shift$2) {
		var match = new Match(self$1, shift$2);
		self$1.__compiled__[match.schema].normalize(match, self$1);
		return match;
	}
	function LinkifyIt$1(schemas, options$1) {
		if (!(this instanceof LinkifyIt$1)) return new LinkifyIt$1(schemas, options$1);
		if (!options$1) {
			if (isOptionsObj(schemas)) {
				options$1 = schemas;
				schemas = {};
			}
		}
		this.__opts__ = assign({}, defaultOptions, options$1);
		this.__index__ = -1;
		this.__last_index__ = -1;
		this.__schema__ = "";
		this.__text_cache__ = "";
		this.__schemas__ = assign({}, defaultSchemas, schemas);
		this.__compiled__ = {};
		this.__tlds__ = tlds_default;
		this.__tlds_replaced__ = false;
		this.re = {};
		compile(this);
	}
	LinkifyIt$1.prototype.add = function add$1(schema, definition) {
		this.__schemas__[schema] = definition;
		compile(this);
		return this;
	};
	LinkifyIt$1.prototype.set = function set(options$1) {
		this.__opts__ = assign(this.__opts__, options$1);
		return this;
	};
	LinkifyIt$1.prototype.test = function test(text$7) {
		this.__text_cache__ = text$7;
		this.__index__ = -1;
		if (!text$7.length) return false;
		var m$2, ml$1, me$2, len, shift$2, next$1, re$1, tld_pos, at_pos;
		if (this.re.schema_test.test(text$7)) {
			re$1 = this.re.schema_search;
			re$1.lastIndex = 0;
			while ((m$2 = re$1.exec(text$7)) !== null) {
				len = this.testSchemaAt(text$7, m$2[2], re$1.lastIndex);
				if (len) {
					this.__schema__ = m$2[2];
					this.__index__ = m$2.index + m$2[1].length;
					this.__last_index__ = m$2.index + m$2[0].length + len;
					break;
				}
			}
		}
		if (this.__opts__.fuzzyLink && this.__compiled__["http:"]) {
			tld_pos = text$7.search(this.re.host_fuzzy_test);
			if (tld_pos >= 0) {
				if (this.__index__ < 0 || tld_pos < this.__index__) {
					if ((ml$1 = text$7.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {
						shift$2 = ml$1.index + ml$1[1].length;
						if (this.__index__ < 0 || shift$2 < this.__index__) {
							this.__schema__ = "";
							this.__index__ = shift$2;
							this.__last_index__ = ml$1.index + ml$1[0].length;
						}
					}
				}
			}
		}
		if (this.__opts__.fuzzyEmail && this.__compiled__["mailto:"]) {
			at_pos = text$7.indexOf("@");
			if (at_pos >= 0) {
				if ((me$2 = text$7.match(this.re.email_fuzzy)) !== null) {
					shift$2 = me$2.index + me$2[1].length;
					next$1 = me$2.index + me$2[0].length;
					if (this.__index__ < 0 || shift$2 < this.__index__ || shift$2 === this.__index__ && next$1 > this.__last_index__) {
						this.__schema__ = "mailto:";
						this.__index__ = shift$2;
						this.__last_index__ = next$1;
					}
				}
			}
		}
		return this.__index__ >= 0;
	};
	LinkifyIt$1.prototype.pretest = function pretest(text$7) {
		return this.re.pretest.test(text$7);
	};
	LinkifyIt$1.prototype.testSchemaAt = function testSchemaAt(text$7, schema, pos) {
		if (!this.__compiled__[schema.toLowerCase()]) return 0;
		return this.__compiled__[schema.toLowerCase()].validate(text$7, pos, this);
	};
	LinkifyIt$1.prototype.match = function match(text$7) {
		var shift$2 = 0, result = [];
		if (this.__index__ >= 0 && this.__text_cache__ === text$7) {
			result.push(createMatch(this, shift$2));
			shift$2 = this.__last_index__;
		}
		var tail = shift$2 ? text$7.slice(shift$2) : text$7;
		while (this.test(tail)) {
			result.push(createMatch(this, shift$2));
			tail = tail.slice(this.__last_index__);
			shift$2 += this.__last_index__;
		}
		if (result.length) return result;
		return null;
	};
	LinkifyIt$1.prototype.matchAtStart = function matchAtStart(text$7) {
		this.__text_cache__ = text$7;
		this.__index__ = -1;
		if (!text$7.length) return null;
		var m$2 = this.re.schema_at_start.exec(text$7);
		if (!m$2) return null;
		var len = this.testSchemaAt(text$7, m$2[2], m$2[0].length);
		if (!len) return null;
		this.__schema__ = m$2[2];
		this.__index__ = m$2.index + m$2[1].length;
		this.__last_index__ = m$2.index + m$2[0].length + len;
		return createMatch(this, 0);
	};
	LinkifyIt$1.prototype.tlds = function tlds(list$1, keepOld) {
		list$1 = Array.isArray(list$1) ? list$1 : [list$1];
		if (!keepOld) {
			this.__tlds__ = list$1.slice();
			this.__tlds_replaced__ = true;
			compile(this);
			return this;
		}
		this.__tlds__ = this.__tlds__.concat(list$1).sort().filter(function(el$2, idx, arr) {
			return el$2 !== arr[idx - 1];
		}).reverse();
		compile(this);
		return this;
	};
	LinkifyIt$1.prototype.normalize = function normalize(match) {
		if (!match.schema) match.url = "http://" + match.url;
		if (match.schema === "mailto:" && !/^mailto:/i.test(match.url)) match.url = "mailto:" + match.url;
	};
	LinkifyIt$1.prototype.onCompile = function onCompile() {};
	module.exports = LinkifyIt$1;
}));
var require_default = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = {
		options: {
			html: false,
			xhtmlOut: false,
			breaks: false,
			langPrefix: "language-",
			linkify: false,
			typographer: false,
			quotes: "",
			highlight: null,
			maxNesting: 100
		},
		components: {
			core: {},
			block: {},
			inline: {}
		}
	};
}));
var require_zero = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = {
		options: {
			html: false,
			xhtmlOut: false,
			breaks: false,
			langPrefix: "language-",
			linkify: false,
			typographer: false,
			quotes: "",
			highlight: null,
			maxNesting: 20
		},
		components: {
			core: { rules: [
				"normalize",
				"block",
				"inline",
				"text_join"
			] },
			block: { rules: ["paragraph"] },
			inline: {
				rules: ["text"],
				rules2: ["balance_pairs", "fragments_join"]
			}
		}
	};
}));
var require_commonmark = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = {
		options: {
			html: true,
			xhtmlOut: true,
			breaks: false,
			langPrefix: "language-",
			linkify: false,
			typographer: false,
			quotes: "",
			highlight: null,
			maxNesting: 20
		},
		components: {
			core: { rules: [
				"normalize",
				"block",
				"inline",
				"text_join"
			] },
			block: { rules: [
				"blockquote",
				"code",
				"fence",
				"heading",
				"hr",
				"html_block",
				"lheading",
				"list",
				"reference",
				"paragraph"
			] },
			inline: {
				rules: [
					"autolink",
					"backticks",
					"emphasis",
					"entity",
					"escape",
					"html_inline",
					"image",
					"link",
					"newline",
					"text"
				],
				rules2: [
					"balance_pairs",
					"emphasis",
					"fragments_join"
				]
			}
		}
	};
}));
var require_lib = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var utils = require_utils();
	var helpers = require_helpers();
	var Renderer = require_renderer();
	var ParserCore = require_parser_core();
	var ParserBlock = require_parser_block();
	var ParserInline = require_parser_inline();
	var LinkifyIt = require_linkify_it();
	var mdurl = require_mdurl();
	var punycode = require_punycode();
	var config = {
		default: require_default(),
		zero: require_zero(),
		commonmark: require_commonmark()
	};
	var BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;
	var GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/;
	function validateLink(url) {
		var str = url.trim().toLowerCase();
		return BAD_PROTO_RE.test(str) ? GOOD_DATA_RE.test(str) ? true : false : true;
	}
	var RECODE_HOSTNAME_FOR = [
		"http:",
		"https:",
		"mailto:"
	];
	function normalizeLink(url) {
		var parsed = mdurl.parse(url, true);
		if (parsed.hostname) {
			if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) try {
				parsed.hostname = punycode.toASCII(parsed.hostname);
			} catch (er) {}
		}
		return mdurl.encode(mdurl.format(parsed));
	}
	function normalizeLinkText(url) {
		var parsed = mdurl.parse(url, true);
		if (parsed.hostname) {
			if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) try {
				parsed.hostname = punycode.toUnicode(parsed.hostname);
			} catch (er) {}
		}
		return mdurl.decode(mdurl.format(parsed), mdurl.decode.defaultChars + "%");
	}
	function MarkdownIt(presetName, options$1) {
		if (!(this instanceof MarkdownIt)) return new MarkdownIt(presetName, options$1);
		if (!options$1) {
			if (!utils.isString(presetName)) {
				options$1 = presetName || {};
				presetName = "default";
			}
		}
		this.inline = new ParserInline();
		this.block = new ParserBlock();
		this.core = new ParserCore();
		this.renderer = new Renderer();
		this.linkify = new LinkifyIt();
		this.validateLink = validateLink;
		this.normalizeLink = normalizeLink;
		this.normalizeLinkText = normalizeLinkText;
		this.utils = utils;
		this.helpers = utils.assign({}, helpers);
		this.options = {};
		this.configure(presetName);
		if (options$1) this.set(options$1);
	}
	MarkdownIt.prototype.set = function(options$1) {
		utils.assign(this.options, options$1);
		return this;
	};
	MarkdownIt.prototype.configure = function(presets) {
		var self$1 = this, presetName;
		if (utils.isString(presets)) {
			presetName = presets;
			presets = config[presetName];
			if (!presets) throw new Error("Wrong `markdown-it` preset \"" + presetName + "\", check name");
		}
		if (!presets) throw new Error("Wrong `markdown-it` preset, can't be empty");
		if (presets.options) self$1.set(presets.options);
		if (presets.components) Object.keys(presets.components).forEach(function(name$1) {
			if (presets.components[name$1].rules) self$1[name$1].ruler.enableOnly(presets.components[name$1].rules);
			if (presets.components[name$1].rules2) self$1[name$1].ruler2.enableOnly(presets.components[name$1].rules2);
		});
		return this;
	};
	MarkdownIt.prototype.enable = function(list$1, ignoreInvalid) {
		var result = [];
		if (!Array.isArray(list$1)) list$1 = [list$1];
		[
			"core",
			"block",
			"inline"
		].forEach(function(chain) {
			result = result.concat(this[chain].ruler.enable(list$1, true));
		}, this);
		result = result.concat(this.inline.ruler2.enable(list$1, true));
		var missed = list$1.filter(function(name$1) {
			return result.indexOf(name$1) < 0;
		});
		if (missed.length && !ignoreInvalid) throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + missed);
		return this;
	};
	MarkdownIt.prototype.disable = function(list$1, ignoreInvalid) {
		var result = [];
		if (!Array.isArray(list$1)) list$1 = [list$1];
		[
			"core",
			"block",
			"inline"
		].forEach(function(chain) {
			result = result.concat(this[chain].ruler.disable(list$1, true));
		}, this);
		result = result.concat(this.inline.ruler2.disable(list$1, true));
		var missed = list$1.filter(function(name$1) {
			return result.indexOf(name$1) < 0;
		});
		if (missed.length && !ignoreInvalid) throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + missed);
		return this;
	};
	MarkdownIt.prototype.use = function(plugin) {
		var args = [this].concat(Array.prototype.slice.call(arguments, 1));
		plugin.apply(plugin, args);
		return this;
	};
	MarkdownIt.prototype.parse = function(src, env) {
		if (typeof src !== "string") throw new Error("Input data should be a String");
		var state = new this.core.State(src, this, env);
		this.core.process(state);
		return state.tokens;
	};
	MarkdownIt.prototype.render = function(src, env) {
		env = env || {};
		return this.renderer.render(this.parse(src, env), this.options, env);
	};
	MarkdownIt.prototype.parseInline = function(src, env) {
		var state = new this.core.State(src, this, env);
		state.inlineMode = true;
		this.core.process(state);
		return state.tokens;
	};
	MarkdownIt.prototype.renderInline = function(src, env) {
		env = env || {};
		return this.renderer.render(this.parseInline(src, env), this.options, env);
	};
	module.exports = MarkdownIt;
}));
var require_markdown_it = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = require_lib();
}));
var require_markdown_it_link_attributes = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function findFirstMatchingConfig(link$3, configs) {
		var i$1, config$1;
		var href = link$3.attrs[link$3.attrIndex("href")][1];
		for (i$1 = 0; i$1 < configs.length; ++i$1) {
			config$1 = configs[i$1];
			if (typeof config$1.matcher === "function") if (config$1.matcher(href, config$1)) return config$1;
			else continue;
			return config$1;
		}
	}
	function applyAttributes(idx, tokens, attributes) {
		Object.keys(attributes).forEach(function(attr) {
			var attrIndex;
			var value = attributes[attr];
			if (attr === "className") attr = "class";
			attrIndex = tokens[idx].attrIndex(attr);
			if (attrIndex < 0) tokens[idx].attrPush([attr, value]);
			else tokens[idx].attrs[attrIndex][1] = value;
		});
	}
	function markdownitLinkAttributes(md, configs) {
		if (!configs) configs = [];
		else configs = Array.isArray(configs) ? configs : [configs];
		Object.freeze(configs);
		var defaultRender = md.renderer.rules.link_open || this.defaultRender;
		md.renderer.rules.link_open = function(tokens, idx, options$1, env, self$1) {
			var config$1 = findFirstMatchingConfig(tokens[idx], configs);
			var attributes = config$1 && config$1.attrs;
			if (attributes) applyAttributes(idx, tokens, attributes);
			return defaultRender(tokens, idx, options$1, env, self$1);
		};
	}
	markdownitLinkAttributes.defaultRender = function(tokens, idx, options$1, env, self$1) {
		return self$1.renderToken(tokens, idx, options$1);
	};
	module.exports = markdownitLinkAttributes;
}));
var import_markdown_it$1 = /* @__PURE__ */ __toESM(require_markdown_it());
var import_markdown_it_link_attributes$1 = /* @__PURE__ */ __toESM(require_markdown_it_link_attributes());
function useMarkdown() {
	const { t: t$1 } = useI18n();
	const md = new import_markdown_it$1.default({ breaks: true });
	md.use(import_markdown_it_link_attributes$1.default, { attrs: {
		target: "_blank",
		rel: "noopener"
	} });
	function renderMarkdown(content$4) {
		try {
			return md.render(content$4);
		} catch (e) {
			console.error(`Error parsing markdown content ${content$4}`);
			return `<p>${t$1("assistantChat.errorParsingMarkdown")}</p>`;
		}
	}
	return { renderMarkdown };
}
var _sfc_main$1 = {};
var _hoisted_1$42 = { class: "blinking-cursor" };
function _sfc_render$1(_ctx, _cache) {
	return openBlock(), createElementBlock("span", _hoisted_1$42);
}
var BlinkingCursor_default = /* @__PURE__ */ __plugin_vue_export_helper_default(_sfc_main$1, [["render", _sfc_render$1]]);
var BlockMessage_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "BlockMessage",
	props: {
		message: {},
		isFirstOfRole: { type: Boolean },
		user: {},
		streaming: { type: Boolean },
		isLastMessage: { type: Boolean }
	},
	emits: ["feedback"],
	setup(__props, { emit: __emit }) {
		const emit = __emit;
		const { renderMarkdown } = useMarkdown();
		return (_ctx, _cache) => {
			const _directive_n8n_html = resolveDirective("n8n-html");
			return openBlock(), createBlock(BaseMessage_default, {
				message: _ctx.message,
				"is-first-of-role": _ctx.isFirstOfRole,
				user: _ctx.user,
				onFeedback: _cache[0] || (_cache[0] = (feedback) => emit("feedback", feedback))
			}, {
				default: withCtx(() => [createBaseVNode("div", { class: normalizeClass(_ctx.$style.block) }, [createBaseVNode("div", { class: normalizeClass(_ctx.$style.blockTitle) }, [createTextVNode(toDisplayString(_ctx.message.title) + " ", 1), _ctx.streaming && _ctx.isLastMessage && !_ctx.message.content ? (openBlock(), createBlock(BlinkingCursor_default, { key: 0 })) : createCommentVNode("", true)], 2), createBaseVNode("div", { class: normalizeClass(_ctx.$style.blockBody) }, [withDirectives(createBaseVNode("span", { class: normalizeClass(_ctx.$style["rendered-content"]) }, null, 2), [[_directive_n8n_html, unref(renderMarkdown)(_ctx.message.content)]]), _ctx.streaming && _ctx.isLastMessage && _ctx.message.title && _ctx.message.content ? (openBlock(), createBlock(BlinkingCursor_default, { key: 0 })) : createCommentVNode("", true)], 2)], 2)]),
				_: 1
			}, 8, [
				"message",
				"is-first-of-role",
				"user"
			]);
		};
	}
});
var BlockMessage_vue_vue_type_style_index_0_lang_module_default = {
	block: "_block_21ltf_123",
	blockTitle: "_blockTitle_21ltf_134",
	blockBody: "_blockBody_21ltf_140",
	"rendered-content": "_rendered-content_21ltf_144"
};
var BlockMessage_default = /* @__PURE__ */ __plugin_vue_export_helper_default(BlockMessage_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": BlockMessage_vue_vue_type_style_index_0_lang_module_default }]]);
var import_parse_diff = /* @__PURE__ */ __toESM((/* @__PURE__ */ __commonJSMin(((exports, module) => {
	function _typeof(obj) {
		"@babel/helpers - typeof";
		return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj$1) {
			return typeof obj$1;
		} : function(obj$1) {
			return obj$1 && "function" == typeof Symbol && obj$1.constructor === Symbol && obj$1 !== Symbol.prototype ? "symbol" : typeof obj$1;
		}, _typeof(obj);
	}
	function _createForOfIteratorHelper(o$1, allowArrayLike) {
		var it$4 = typeof Symbol !== "undefined" && o$1[Symbol.iterator] || o$1["@@iterator"];
		if (!it$4) {
			if (Array.isArray(o$1) || (it$4 = _unsupportedIterableToArray(o$1)) || allowArrayLike && o$1 && typeof o$1.length === "number") {
				if (it$4) o$1 = it$4;
				var i$1 = 0;
				var F$1 = function F$2() {};
				return {
					s: F$1,
					n: function n() {
						if (i$1 >= o$1.length) return { done: true };
						return {
							done: false,
							value: o$1[i$1++]
						};
					},
					e: function e(_e2) {
						throw _e2;
					},
					f: F$1
				};
			}
			throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
		}
		var normalCompletion = true, didErr = false, err;
		return {
			s: function s() {
				it$4 = it$4.call(o$1);
			},
			n: function n() {
				var step = it$4.next();
				normalCompletion = step.done;
				return step;
			},
			e: function e(_e3) {
				didErr = true;
				err = _e3;
			},
			f: function f() {
				try {
					if (!normalCompletion && it$4["return"] != null) it$4["return"]();
				} finally {
					if (didErr) throw err;
				}
			}
		};
	}
	function _defineProperty(obj, key$2, value) {
		key$2 = _toPropertyKey(key$2);
		if (key$2 in obj) Object.defineProperty(obj, key$2, {
			value,
			enumerable: true,
			configurable: true,
			writable: true
		});
		else obj[key$2] = value;
		return obj;
	}
	function _toPropertyKey(arg) {
		var key$2 = _toPrimitive(arg, "string");
		return _typeof(key$2) === "symbol" ? key$2 : String(key$2);
	}
	function _toPrimitive(input$4, hint) {
		if (_typeof(input$4) !== "object" || input$4 === null) return input$4;
		var prim = input$4[Symbol.toPrimitive];
		if (prim !== void 0) {
			var res = prim.call(input$4, hint || "default");
			if (_typeof(res) !== "object") return res;
			throw new TypeError("@@toPrimitive must return a primitive value.");
		}
		return (hint === "string" ? String : Number)(input$4);
	}
	function _slicedToArray(arr, i$1) {
		return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i$1) || _unsupportedIterableToArray(arr, i$1) || _nonIterableRest();
	}
	function _nonIterableRest() {
		throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	}
	function _unsupportedIterableToArray(o$1, minLen) {
		if (!o$1) return;
		if (typeof o$1 === "string") return _arrayLikeToArray(o$1, minLen);
		var n = Object.prototype.toString.call(o$1).slice(8, -1);
		if (n === "Object" && o$1.constructor) n = o$1.constructor.name;
		if (n === "Map" || n === "Set") return Array.from(o$1);
		if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o$1, minLen);
	}
	function _arrayLikeToArray(arr, len) {
		if (len == null || len > arr.length) len = arr.length;
		for (var i$1 = 0, arr2 = new Array(len); i$1 < len; i$1++) arr2[i$1] = arr[i$1];
		return arr2;
	}
	function _iterableToArrayLimit(arr, i$1) {
		var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
		if (null != _i) {
			var _s, _e$1, _x, _r, _arr = [], _n = !0, _d = !1;
			try {
				if (_x = (_i = _i.call(arr)).next, 0 === i$1) {
					if (Object(_i) !== _i) return;
					_n = !1;
				} else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i$1); _n = !0);
			} catch (err) {
				_d = !0, _e$1 = err;
			} finally {
				try {
					if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return;
				} finally {
					if (_d) throw _e$1;
				}
			}
			return _arr;
		}
	}
	function _arrayWithHoles(arr) {
		if (Array.isArray(arr)) return arr;
	}
	module.exports = function(input$4) {
		if (!input$4) return [];
		if (typeof input$4 !== "string" || input$4.match(/^\s+$/)) return [];
		var lines = input$4.split("\n");
		if (lines.length === 0) return [];
		var files = [];
		var currentFile = null;
		var currentChunk = null;
		var deletedLineCounter = 0;
		var addedLineCounter = 0;
		var currentFileChanges = null;
		var normal$1 = function normal$2(line$1) {
			var _currentChunk;
			(_currentChunk = currentChunk) === null || _currentChunk === void 0 || _currentChunk.changes.push({
				type: "normal",
				normal: true,
				ln1: deletedLineCounter++,
				ln2: addedLineCounter++,
				content: line$1
			});
			currentFileChanges.oldLines--;
			currentFileChanges.newLines--;
		};
		var start = function start$1(line$1) {
			var _parseFiles;
			var _ref2 = _slicedToArray((_parseFiles = parseFiles(line$1)) !== null && _parseFiles !== void 0 ? _parseFiles : [], 2);
			currentFile = {
				chunks: [],
				deletions: 0,
				additions: 0,
				from: _ref2[0],
				to: _ref2[1]
			};
			files.push(currentFile);
		};
		var restart = function restart$1() {
			if (!currentFile || currentFile.chunks.length) start();
		};
		var newFile = function newFile$1(_, match) {
			restart();
			currentFile["new"] = true;
			currentFile.newMode = match[1];
			currentFile.from = "/dev/null";
		};
		var deletedFile = function deletedFile$1(_, match) {
			restart();
			currentFile.deleted = true;
			currentFile.oldMode = match[1];
			currentFile.to = "/dev/null";
		};
		var oldMode = function oldMode$1(_, match) {
			restart();
			currentFile.oldMode = match[1];
		};
		var newMode = function newMode$1(_, match) {
			restart();
			currentFile.newMode = match[1];
		};
		var index = function index$1(line$1, match) {
			restart();
			currentFile.index = line$1.split(" ").slice(1);
			if (match[1]) currentFile.oldMode = currentFile.newMode = match[1].trim();
		};
		var fromFile = function fromFile$1(line$1) {
			restart();
			currentFile.from = parseOldOrNewFile(line$1);
		};
		var toFile = function toFile$1(line$1) {
			restart();
			currentFile.to = parseOldOrNewFile(line$1);
		};
		var toNumOfLines = function toNumOfLines$1(number) {
			return +(number || 1);
		};
		var chunk$1 = function chunk$2(line$1, match) {
			if (!currentFile) start(line$1);
			var _match$slice2 = _slicedToArray(match.slice(1), 4), oldStart = _match$slice2[0], oldNumLines = _match$slice2[1], newStart = _match$slice2[2], newNumLines = _match$slice2[3];
			deletedLineCounter = +oldStart;
			addedLineCounter = +newStart;
			currentChunk = {
				content: line$1,
				changes: [],
				oldStart: +oldStart,
				oldLines: toNumOfLines(oldNumLines),
				newStart: +newStart,
				newLines: toNumOfLines(newNumLines)
			};
			currentFileChanges = {
				oldLines: toNumOfLines(oldNumLines),
				newLines: toNumOfLines(newNumLines)
			};
			currentFile.chunks.push(currentChunk);
		};
		var del$1 = function del$2(line$1) {
			if (!currentChunk) return;
			currentChunk.changes.push({
				type: "del",
				del: true,
				ln: deletedLineCounter++,
				content: line$1
			});
			currentFile.deletions++;
			currentFileChanges.oldLines--;
		};
		var add$1 = function add$2(line$1) {
			if (!currentChunk) return;
			currentChunk.changes.push({
				type: "add",
				add: true,
				ln: addedLineCounter++,
				content: line$1
			});
			currentFile.additions++;
			currentFileChanges.newLines--;
		};
		var eof = function eof$1(line$1) {
			var _currentChunk$changes3;
			if (!currentChunk) return;
			var mostRecentChange = _slicedToArray(currentChunk.changes.slice(-1), 1)[0];
			currentChunk.changes.push((_currentChunk$changes3 = { type: mostRecentChange.type }, _defineProperty(_currentChunk$changes3, mostRecentChange.type, true), _defineProperty(_currentChunk$changes3, "ln1", mostRecentChange.ln1), _defineProperty(_currentChunk$changes3, "ln2", mostRecentChange.ln2), _defineProperty(_currentChunk$changes3, "ln", mostRecentChange.ln), _defineProperty(_currentChunk$changes3, "content", line$1), _currentChunk$changes3));
		};
		var schemaHeaders = [
			[/^diff\s/, start],
			[/^new file mode (\d+)$/, newFile],
			[/^deleted file mode (\d+)$/, deletedFile],
			[/^old mode (\d+)$/, oldMode],
			[/^new mode (\d+)$/, newMode],
			[/^index\s[\da-zA-Z]+\.\.[\da-zA-Z]+(\s(\d+))?$/, index],
			[/^---\s/, fromFile],
			[/^\+\+\+\s/, toFile],
			[/^@@\s+-(\d+),?(\d+)?\s+\+(\d+),?(\d+)?\s@@/, chunk$1],
			[/^\\ No newline at end of file$/, eof]
		];
		var schemaContent = [
			[/^\\ No newline at end of file$/, eof],
			[/^-/, del$1],
			[/^\+/, add$1],
			[/^\s+/, normal$1]
		];
		var parseContentLine = function parseContentLine$1(line$1) {
			for (var _i2 = 0, _schemaContent = schemaContent; _i2 < _schemaContent.length; _i2++) {
				var _schemaContent$_i = _slicedToArray(_schemaContent[_i2], 2), pattern = _schemaContent$_i[0], handler = _schemaContent$_i[1];
				var match = line$1.match(pattern);
				if (match) {
					handler(line$1, match);
					break;
				}
			}
			if (currentFileChanges.oldLines === 0 && currentFileChanges.newLines === 0) currentFileChanges = null;
		};
		var parseHeaderLine = function parseHeaderLine$1(line$1) {
			for (var _i3 = 0, _schemaHeaders = schemaHeaders; _i3 < _schemaHeaders.length; _i3++) {
				var _schemaHeaders$_i = _slicedToArray(_schemaHeaders[_i3], 2), pattern = _schemaHeaders$_i[0], handler = _schemaHeaders$_i[1];
				var match = line$1.match(pattern);
				if (match) {
					handler(line$1, match);
					break;
				}
			}
		};
		var parseLine = function parseLine$1(line$1) {
			if (currentFileChanges) parseContentLine(line$1);
			else parseHeaderLine(line$1);
		};
		var _iterator = _createForOfIteratorHelper(lines), _step;
		try {
			for (_iterator.s(); !(_step = _iterator.n()).done;) {
				var line = _step.value;
				parseLine(line);
			}
		} catch (err) {
			_iterator.e(err);
		} finally {
			_iterator.f();
		}
		return files;
	};
	var fileNameDiffRegex = /(a|i|w|c|o|1|2)\/.*(?=["']? ["']?(b|i|w|c|o|1|2)\/)|(b|i|w|c|o|1|2)\/.*$/g;
	var gitFileHeaderRegex = /^(a|b|i|w|c|o|1|2)\//;
	var parseFiles = function parseFiles$1(line) {
		var fileNames = line === null || line === void 0 ? void 0 : line.match(fileNameDiffRegex);
		return fileNames === null || fileNames === void 0 ? void 0 : fileNames.map(function(fileName) {
			return fileName.replace(gitFileHeaderRegex, "").replace(/("|')$/, "");
		});
	};
	var qoutedFileNameRegex = /^\\?['"]|\\?['"]$/g;
	var parseOldOrNewFile = function parseOldOrNewFile$1(line) {
		var fileName = leftTrimChars(line, "-+").trim();
		fileName = removeTimeStamp(fileName);
		return fileName.replace(qoutedFileNameRegex, "").replace(gitFileHeaderRegex, "");
	};
	var leftTrimChars = function leftTrimChars$1(string, trimmingChars) {
		string = makeString(string);
		if (!trimmingChars && String.prototype.trimLeft) return string.trimLeft();
		var trimmingString = formTrimmingString(trimmingChars);
		return string.replace(new RegExp("^".concat(trimmingString, "+")), "");
	};
	var timeStampRegex = /\t.*|\d{4}-\d\d-\d\d\s\d\d:\d\d:\d\d(.\d+)?\s(\+|-)\d\d\d\d/;
	var removeTimeStamp = function removeTimeStamp$1(string) {
		var timeStamp = timeStampRegex.exec(string);
		if (timeStamp) string = string.substring(0, timeStamp.index).trim();
		return string;
	};
	var formTrimmingString = function formTrimmingString$1(trimmingChars) {
		if (trimmingChars === null || trimmingChars === void 0) return "\\s";
		else if (trimmingChars instanceof RegExp) return trimmingChars.source;
		return "[".concat(makeString(trimmingChars).replace(/([.*+?^=!:${}()|[\]/\\])/g, "\\$1"), "]");
	};
	var makeString = function makeString$1(itemToConvert) {
		return (itemToConvert !== null && itemToConvert !== void 0 ? itemToConvert : "") + "";
	};
})))());
var _hoisted_1$41 = { key: 0 };
var _hoisted_2$24 = { key: 1 };
var _hoisted_3$9 = { key: 2 };
var _hoisted_4$6 = { key: 0 };
var _hoisted_5$3 = { key: 1 };
var MIN_LINES = 4;
var CodeDiff_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "CodeDiff",
	props: {
		title: { default: "" },
		content: { default: "" },
		replacing: {
			type: Boolean,
			default: false
		},
		replaced: {
			type: Boolean,
			default: false
		},
		error: {
			type: Boolean,
			default: false
		},
		streaming: {
			type: Boolean,
			default: false
		}
	},
	emits: ["replace", "undo"],
	setup(__props, { emit: __emit }) {
		const props = __props;
		const emit = __emit;
		const { t: t$1 } = useI18n();
		const diffs = computed(() => {
			const file = (0, import_parse_diff.default)(props.content)[0] ?? { chunks: [] };
			const lines = file.chunks.reduce((accu, chunk$1, i$1) => {
				const changes = chunk$1.changes.map((change) => {
					let content$4 = change.content;
					if (change.type === "add" && content$4.startsWith("+")) content$4 = content$4.replace("+", "");
					else if (change.type === "del" && content$4.startsWith("-")) content$4 = content$4.replace("-", "");
					return {
						...change,
						content: content$4
					};
				});
				if (i$1 !== file.chunks.length - 1) changes.push({
					type: "seperator",
					content: "..."
				});
				return [...accu, ...changes];
			}, []);
			const len = lines.length;
			if (len <= MIN_LINES) for (let i$1 = 0; i$1 < MIN_LINES - len; i$1++) lines.push({
				type: "filler",
				content: ""
			});
			return lines;
		});
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", {
				class: normalizeClass(_ctx.$style.container),
				"data-test-id": "code-diff-suggestion"
			}, [
				createBaseVNode("div", { class: normalizeClass(_ctx.$style.title) }, toDisplayString(_ctx.title), 3),
				createBaseVNode("div", { class: normalizeClass(_ctx.$style.diffSection) }, [(openBlock(true), createElementBlock(Fragment, null, renderList(diffs.value, (diff$1, i$1) => {
					return openBlock(), createElementBlock("div", {
						key: i$1,
						class: normalizeClass(_ctx.$style.diff)
					}, [createBaseVNode("div", { class: normalizeClass(_ctx.$style.lineNumber) }, toDisplayString(diff$1.type === "normal" ? diff$1.ln2 : diff$1.type === "add" ? diff$1.ln : ""), 3), createBaseVNode("div", { class: normalizeClass([_ctx.$style[diff$1.type], _ctx.$style.diffContent]) }, [diff$1.type === "add" ? (openBlock(), createElementBlock("span", _hoisted_1$41, "\xA0+\xA0")) : diff$1.type === "del" ? (openBlock(), createElementBlock("span", _hoisted_2$24, "\xA0-\xA0")) : (openBlock(), createElementBlock("span", _hoisted_3$9, "\xA0\xA0\xA0")), createBaseVNode("span", null, toDisplayString(diff$1.content), 1)], 2)], 2);
				}), 128))], 2),
				createBaseVNode("div", { class: normalizeClass(_ctx.$style.actions) }, [_ctx.error ? (openBlock(), createElementBlock("div", _hoisted_4$6, [createVNode(unref(N8nIcon_default), {
					icon: "triangle-alert",
					color: "danger",
					class: "mr-5xs"
				}), createBaseVNode("span", { class: normalizeClass(_ctx.$style.infoText) }, toDisplayString(unref(t$1)("codeDiff.couldNotReplace")), 3)])) : _ctx.replaced ? (openBlock(), createElementBlock("div", _hoisted_5$3, [
					createVNode(unref(N8nButton_default), {
						type: "secondary",
						size: "mini",
						icon: "undo-2",
						"data-test-id": "undo-replace-button",
						onClick: _cache[0] || (_cache[0] = () => emit("undo"))
					}, {
						default: withCtx(() => [createTextVNode(toDisplayString(unref(t$1)("codeDiff.undo")), 1)]),
						_: 1
					}),
					createVNode(unref(N8nIcon_default), {
						icon: "check",
						color: "success",
						class: "ml-xs"
					}),
					createBaseVNode("span", {
						class: normalizeClass(_ctx.$style.infoText),
						"data-test-id": "code-replaced-message"
					}, toDisplayString(unref(t$1)("codeDiff.codeReplaced")), 3)
				])) : (openBlock(), createBlock(unref(N8nButton_default), {
					key: 2,
					type: _ctx.replacing ? "secondary" : "primary",
					size: "mini",
					icon: "refresh-cw",
					"data-test-id": "replace-code-button",
					disabled: !_ctx.content || _ctx.streaming,
					loading: _ctx.replacing,
					onClick: _cache[1] || (_cache[1] = () => emit("replace"))
				}, {
					default: withCtx(() => [createTextVNode(toDisplayString(_ctx.replacing ? unref(t$1)("codeDiff.replacing") : unref(t$1)("codeDiff.replaceMyCode")), 1)]),
					_: 1
				}, 8, [
					"type",
					"disabled",
					"loading"
				]))], 2)
			], 2);
		};
	}
});
var CodeDiff_vue_vue_type_style_index_0_lang_module_default = {
	container: "_container_6dz7t_123",
	title: "_title_6dz7t_129",
	lineNumber: "_lineNumber_6dz7t_138",
	diffSection: "_diffSection_6dz7t_146",
	diff: "_diff_6dz7t_146",
	diffContent: "_diffContent_6dz7t_163",
	add: "_add_6dz7t_172",
	del: "_del_6dz7t_177",
	normal: "_normal_6dz7t_182",
	actions: "_actions_6dz7t_186",
	infoText: "_infoText_6dz7t_193"
};
var CodeDiff_default = /* @__PURE__ */ __plugin_vue_export_helper_default(CodeDiff_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": CodeDiff_vue_vue_type_style_index_0_lang_module_default }]]);
var CodeDiffMessage_default = /* @__PURE__ */ defineComponent({
	__name: "CodeDiffMessage",
	props: {
		message: {},
		isFirstOfRole: { type: Boolean },
		user: {},
		streaming: { type: Boolean },
		isLastMessage: { type: Boolean }
	},
	emits: [
		"codeReplace",
		"codeUndo",
		"feedback"
	],
	setup(__props, { emit: __emit }) {
		const emit = __emit;
		return (_ctx, _cache) => {
			return openBlock(), createBlock(BaseMessage_default, {
				message: _ctx.message,
				"is-first-of-role": _ctx.isFirstOfRole,
				user: _ctx.user,
				onFeedback: _cache[2] || (_cache[2] = (feedback) => emit("feedback", feedback))
			}, {
				default: withCtx(() => [createVNode(CodeDiff_default, {
					title: _ctx.message.description,
					content: _ctx.message.codeDiff,
					replacing: _ctx.message.replacing,
					replaced: _ctx.message.replaced,
					error: _ctx.message.error,
					streaming: _ctx.streaming && _ctx.isLastMessage,
					onReplace: _cache[0] || (_cache[0] = ($event) => emit("codeReplace")),
					onUndo: _cache[1] || (_cache[1] = ($event) => emit("codeUndo"))
				}, null, 8, [
					"title",
					"content",
					"replacing",
					"replaced",
					"error",
					"streaming"
				])]),
				_: 1
			}, 8, [
				"message",
				"is-first-of-role",
				"user"
			]);
		};
	}
});
var ErrorMessage_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "ErrorMessage",
	props: {
		message: {},
		isFirstOfRole: { type: Boolean },
		user: {}
	},
	setup(__props) {
		const { t: t$1 } = useI18n();
		return (_ctx, _cache) => {
			return openBlock(), createBlock(BaseMessage_default, {
				message: _ctx.message,
				"is-first-of-role": _ctx.isFirstOfRole,
				user: _ctx.user
			}, {
				default: withCtx(() => [createBaseVNode("div", {
					class: normalizeClass(_ctx.$style.error),
					"data-test-id": "chat-message-system"
				}, [createBaseVNode("p", { class: normalizeClass(_ctx.$style.errorText) }, [createVNode(unref(N8nIcon_default), {
					icon: "triangle-alert",
					size: "small",
					class: normalizeClass(_ctx.$style.errorIcon)
				}, null, 8, ["class"]), createTextVNode(" " + toDisplayString(_ctx.message.content), 1)], 2), _ctx.message.retry ? (openBlock(), createBlock(unref(N8nButton_default), {
					key: 0,
					type: "secondary",
					size: "mini",
					class: normalizeClass(_ctx.$style.retryButton),
					"data-test-id": "error-retry-button",
					onClick: _cache[0] || (_cache[0] = () => _ctx.message.retry?.())
				}, {
					default: withCtx(() => [createTextVNode(toDisplayString(unref(t$1)("generic.retry")), 1)]),
					_: 1
				}, 8, ["class"])) : createCommentVNode("", true)], 2)]),
				_: 1
			}, 8, [
				"message",
				"is-first-of-role",
				"user"
			]);
		};
	}
});
var ErrorMessage_vue_vue_type_style_index_0_lang_module_default = {
	error: "_error_1wsms_123",
	errorIcon: "_errorIcon_1wsms_133",
	errorText: "_errorText_1wsms_138",
	retryButton: "_retryButton_1wsms_146"
};
var ErrorMessage_default = /* @__PURE__ */ __plugin_vue_export_helper_default(ErrorMessage_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": ErrorMessage_vue_vue_type_style_index_0_lang_module_default }]]);
var _hoisted_1$40 = ["disabled", "tabindex"];
var _hoisted_2$23 = { key: 0 };
var InlineAskAssistantButton_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "InlineAskAssistantButton",
	props: {
		size: { default: "medium" },
		static: {
			type: Boolean,
			default: false
		},
		asked: {
			type: Boolean,
			default: false
		}
	},
	emits: ["click"],
	setup(__props, { emit: __emit }) {
		const { t: t$1 } = useI18n();
		const props = __props;
		const emit = __emit;
		const sizes = {
			medium: {
				padding: "0px 12px",
				height: "28px"
			},
			small: {
				padding: "0px 6px",
				height: "18px"
			}
		};
		const hoverable$3 = computed(() => !props.static && !props.asked);
		const onClick = () => {
			if (hoverable$3.value) emit("click");
		};
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("button", {
				class: normalizeClass({
					[_ctx.$style.button]: true,
					[_ctx.$style.hoverable]: hoverable$3.value,
					[_ctx.$style.asked]: _ctx.asked
				}),
				style: normalizeStyle({ height: sizes[_ctx.size].height }),
				disabled: _ctx.asked,
				tabindex: _ctx.static ? "-1" : "",
				"data-test-id": "ask-assistant-button",
				onClick
			}, [createBaseVNode("div", { style: normalizeStyle({ padding: sizes[_ctx.size].padding }) }, [createVNode(AssistantIcon_default, {
				size: _ctx.size,
				class: normalizeClass(_ctx.$style.icon),
				theme: _ctx.asked ? "disabled" : "default"
			}, null, 8, [
				"size",
				"class",
				"theme"
			]), _ctx.asked ? (openBlock(), createElementBlock("span", _hoisted_2$23, toDisplayString(unref(t$1)("inlineAskAssistantButton.asked")), 1)) : (openBlock(), createBlock(AssistantText_default, {
				key: 1,
				size: _ctx.size,
				text: unref(t$1)("askAssistantButton.askAssistant")
			}, null, 8, ["size", "text"]))], 4)], 14, _hoisted_1$40);
		};
	}
});
var InlineAskAssistantButton_vue_vue_type_style_index_0_lang_module_default = {
	button: "_button_1jajl_123",
	hoverable: "_hoverable_1jajl_139",
	asked: "_asked_1jajl_153",
	icon: "_icon_1jajl_159"
};
var InlineAskAssistantButton_default$1 = /* @__PURE__ */ __plugin_vue_export_helper_default(InlineAskAssistantButton_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": InlineAskAssistantButton_vue_vue_type_style_index_0_lang_module_default }]]);
var EventMessage_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "EventMessage",
	props: {
		message: {},
		isFirstOfRole: { type: Boolean },
		user: {}
	},
	setup(__props) {
		const { t: t$1 } = useI18n();
		const eventMessages = {
			"end-session": {
				part1: "assistantChat.sessionEndMessage.1",
				part2: "assistantChat.sessionEndMessage.2"
			},
			"session-timeout": {
				part1: "assistantChat.sessionTimeoutMessage.1",
				part2: "assistantChat.sessionTimeoutMessage.2"
			},
			"session-error": {
				part1: "assistantChat.sessionErrorMessage.1",
				part2: "assistantChat.sessionErrorMessage.2"
			}
		};
		return (_ctx, _cache) => {
			return openBlock(), createBlock(BaseMessage_default, {
				message: _ctx.message,
				"is-first-of-role": _ctx.isFirstOfRole,
				user: _ctx.user
			}, {
				default: withCtx(() => [createBaseVNode("div", {
					class: normalizeClass(_ctx.$style.eventText),
					"data-test-id": "chat-message-system"
				}, [
					createBaseVNode("span", null, toDisplayString(unref(t$1)(eventMessages[_ctx.message.eventName]?.part1 || "assistantChat.unknownEvent")), 1),
					createVNode(InlineAskAssistantButton_default$1, {
						size: "small",
						static: true
					}),
					createBaseVNode("span", null, toDisplayString(unref(t$1)(eventMessages[_ctx.message.eventName]?.part2 || "")), 1)
				], 2)]),
				_: 1
			}, 8, [
				"message",
				"is-first-of-role",
				"user"
			]);
		};
	}
});
var EventMessage_vue_vue_type_style_index_0_lang_module_default = { eventText: "_eventText_u4086_123" };
var EventMessage_default = /* @__PURE__ */ __plugin_vue_export_helper_default(EventMessage_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": EventMessage_vue_vue_type_style_index_0_lang_module_default }]]);
var _hoisted_1$39 = { key: 0 };
var MAX_HEIGHT = 200;
var TextMessage_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "TextMessage",
	props: {
		message: {},
		isFirstOfRole: { type: Boolean },
		user: {},
		streaming: { type: Boolean },
		isLastMessage: { type: Boolean },
		color: {}
	},
	emits: ["feedback"],
	setup(__props, { emit: __emit }) {
		const props = __props;
		const emit = __emit;
		const { renderMarkdown } = useMarkdown();
		const { t: t$1 } = useI18n();
		const isClipboardSupported = computed(() => {
			return navigator.clipboard?.writeText;
		});
		const isExpanded = ref(false);
		const userContentRef = ref(null);
		const isOverflowing = ref(false);
		function checkOverflow() {
			if (userContentRef.value) isOverflowing.value = userContentRef.value.scrollHeight > MAX_HEIGHT;
		}
		function toggleExpanded() {
			isExpanded.value = !isExpanded.value;
		}
		onMounted(() => {
			nextTick(() => {
				checkOverflow();
			});
		});
		watch(() => props.message.content, () => {
			nextTick(() => {
				checkOverflow();
			});
		});
		async function onCopyButtonClick(content$4, e) {
			const button$7 = e.target;
			await navigator.clipboard.writeText(content$4);
			button$7.innerText = t$1("assistantChat.copied");
			setTimeout(() => {
				button$7.innerText = t$1("assistantChat.copy");
			}, 2e3);
		}
		return (_ctx, _cache) => {
			const _directive_n8n_html = resolveDirective("n8n-html");
			return openBlock(), createBlock(BaseMessage_default, {
				message: _ctx.message,
				"is-first-of-role": _ctx.isFirstOfRole,
				user: _ctx.user,
				onFeedback: _cache[1] || (_cache[1] = (feedback) => emit("feedback", feedback))
			}, {
				default: withCtx(() => [createBaseVNode("div", { class: normalizeClass([_ctx.$style.textMessage, { [_ctx.$style.userMessage]: _ctx.message.role === "user" }]) }, [
					_ctx.message.role === "user" ? (openBlock(), createElementBlock("div", {
						key: 0,
						class: normalizeClass(_ctx.$style.userMessageContainer)
					}, [createBaseVNode("div", {
						ref_key: "userContentRef",
						ref: userContentRef,
						class: normalizeClass([_ctx.$style.userContent, { [_ctx.$style.collapsed]: !isExpanded.value && isOverflowing.value }])
					}, [withDirectives(createBaseVNode("span", { class: normalizeClass(_ctx.$style.renderedContent) }, null, 2), [[_directive_n8n_html, unref(renderMarkdown)(_ctx.message.content)]])], 2), isOverflowing.value ? (openBlock(), createElementBlock("button", {
						key: 0,
						class: normalizeClass(_ctx.$style.showMoreButton),
						type: "button",
						onClick: toggleExpanded
					}, toDisplayString(isExpanded.value ? unref(t$1)("notice.showLess") : unref(t$1)("notice.showMore")), 3)) : createCommentVNode("", true)], 2)) : withDirectives((openBlock(), createElementBlock("div", {
						key: 1,
						class: normalizeClass([_ctx.$style.assistantText, _ctx.$style.renderedContent]),
						style: normalizeStyle(_ctx.color ? { color: _ctx.color } : void 0)
					}, null, 6)), [[_directive_n8n_html, unref(renderMarkdown)(_ctx.message.content)]]),
					_ctx.message?.codeSnippet ? (openBlock(), createElementBlock("div", {
						key: 2,
						class: normalizeClass(_ctx.$style.codeSnippet),
						"data-test-id": "assistant-code-snippet"
					}, [isClipboardSupported.value ? (openBlock(), createElementBlock("header", _hoisted_1$39, [createVNode(unref(N8nButton_default), {
						type: "tertiary",
						text: true,
						size: "mini",
						"data-test-id": "assistant-copy-snippet-button",
						onClick: _cache[0] || (_cache[0] = ($event) => onCopyButtonClick(_ctx.message.codeSnippet, $event))
					}, {
						default: withCtx(() => [createTextVNode(toDisplayString(unref(t$1)("assistantChat.copy")), 1)]),
						_: 1
					})])) : createCommentVNode("", true), withDirectives(createBaseVNode("div", {
						"data-test-id": "assistant-code-snippet-content",
						class: normalizeClass([_ctx.$style.snippetContent, _ctx.$style.renderedContent])
					}, null, 2), [[_directive_n8n_html, unref(renderMarkdown)(_ctx.message.codeSnippet).trim()]])], 2)) : createCommentVNode("", true),
					_ctx.streaming && _ctx.isLastMessage && _ctx.message.role === "assistant" ? (openBlock(), createBlock(BlinkingCursor_default, { key: 3 })) : createCommentVNode("", true)
				], 2)]),
				_: 1
			}, 8, [
				"message",
				"is-first-of-role",
				"user"
			]);
		};
	}
});
var TextMessage_vue_vue_type_style_index_0_lang_module_default = {
	textMessage: "_textMessage_nsboz_123",
	userMessage: "_userMessage_nsboz_132",
	userMessageContainer: "_userMessageContainer_nsboz_136",
	userContent: "_userContent_nsboz_144",
	collapsed: "_collapsed_nsboz_144",
	showMoreButton: "_showMoreButton_nsboz_149",
	codeSnippet: "_codeSnippet_nsboz_164",
	snippetContent: "_snippetContent_nsboz_185",
	assistantText: "_assistantText_nsboz_196",
	renderedContent: "_renderedContent_nsboz_205"
};
var TextMessage_default = /* @__PURE__ */ __plugin_vue_export_helper_default(TextMessage_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": TextMessage_vue_vue_type_style_index_0_lang_module_default }]]);
var N8nTooltip_default = Tooltip_default;
var ToolMessage_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "ToolMessage",
	props: {
		message: {},
		isFirstOfRole: { type: Boolean },
		showProgressLogs: { type: Boolean },
		user: {}
	},
	setup(__props) {
		const props = __props;
		const { t: t$1 } = useI18n();
		const toolDisplayName = computed(() => {
			return props.message.customDisplayTitle ?? props.message.displayTitle ?? props.message.toolName.split("_").map((word) => word.charAt(0).toUpperCase() + word.slice(1)).join(" ");
		});
		const statusMessage = computed(() => {
			switch (props.message.status) {
				case "running": return t$1("assistantChat.builder.toolRunning");
				case "error": return t$1("assistantChat.builder.toolError");
				default: return "";
			}
		});
		const statusColor = computed(() => {
			switch (props.message.status) {
				case "completed": return "success";
				case "error": return "warning";
				default: return "secondary";
			}
		});
		return (_ctx, _cache) => {
			return openBlock(), createBlock(BaseMessage_default, {
				message: _ctx.message,
				"is-first-of-role": _ctx.isFirstOfRole,
				user: _ctx.user
			}, {
				default: withCtx(() => [createBaseVNode("div", { class: normalizeClass(_ctx.$style.toolMessage) }, [createBaseVNode("div", { class: normalizeClass(_ctx.$style.header) }, [createBaseVNode("div", { class: normalizeClass(_ctx.$style.titleRow) }, [createBaseVNode("div", { class: normalizeClass(_ctx.$style.status) }, [createVNode(unref(N8nTooltip_default), {
					placement: "top",
					disabled: !statusMessage.value
				}, {
					content: withCtx(() => [createBaseVNode("span", { class: normalizeClass(_ctx.$style.statusText) }, toDisplayString(statusMessage.value), 3)]),
					default: withCtx(() => [_ctx.message.status === "running" ? (openBlock(), createBlock(unref(N8nIcon_default), {
						key: 0,
						icon: "spinner",
						spin: "",
						color: statusColor.value,
						size: "large"
					}, null, 8, ["color"])) : _ctx.message.status === "error" ? (openBlock(), createBlock(unref(N8nIcon_default), {
						key: 1,
						icon: "triangle-alert",
						color: statusColor.value,
						size: "large"
					}, null, 8, ["color"])) : (openBlock(), createBlock(unref(N8nIcon_default), {
						key: 2,
						icon: "circle-check",
						color: statusColor.value,
						size: "large"
					}, null, 8, ["color"]))]),
					_: 1
				}, 8, ["disabled"])], 2), createVNode(unref(N8nText_default), {
					size: "small",
					bold: ""
				}, {
					default: withCtx(() => [createTextVNode(toDisplayString(toolDisplayName.value), 1)]),
					_: 1
				})], 2)], 2)], 2)]),
				_: 1
			}, 8, [
				"message",
				"is-first-of-role",
				"user"
			]);
		};
	}
});
const toolMessage = "_toolMessage_1oe1p_131";
const titleRow = "_titleRow_1oe1p_135";
const status = "_status_1oe1p_141";
const statusText$1 = "_statusText_1oe1p_149";
const content$3 = "_content_1oe1p_162";
const sectionTitle = "_sectionTitle_1oe1p_167";
const errorContent = "_errorContent_1oe1p_174";
const shimmer$2 = "_shimmer_1oe1p_1";
var ToolMessage_vue_vue_type_style_index_0_lang_module_default = {
	toolMessage,
	titleRow,
	status,
	statusText: statusText$1,
	"status-running": "_status-running_1oe1p_152",
	"status-completed": "_status-completed_1oe1p_155",
	"status-error": "_status-error_1oe1p_158",
	content: content$3,
	sectionTitle,
	errorContent,
	shimmer: shimmer$2
};
var ToolMessage_default = /* @__PURE__ */ __plugin_vue_export_helper_default(ToolMessage_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": ToolMessage_vue_vue_type_style_index_0_lang_module_default }]]);
function getSupportedMessageComponent(type) {
	switch (type) {
		case "text": return TextMessage_default;
		case "block": return BlockMessage_default;
		case "code-diff": return CodeDiffMessage_default;
		case "error": return ErrorMessage_default;
		case "event": return EventMessage_default;
		case "tool": return ToolMessage_default;
		case "thinking-group":
		case "agent-suggestion":
		case "workflow-updated":
		case "custom": return null;
		default: return null;
	}
}
var MessageWrapper_default = /* @__PURE__ */ defineComponent({
	__name: "MessageWrapper",
	props: {
		message: {},
		isFirstOfRole: { type: Boolean },
		user: {},
		streaming: { type: Boolean },
		isLastMessage: { type: Boolean },
		color: {}
	},
	emits: [
		"codeReplace",
		"codeUndo",
		"feedback"
	],
	setup(__props, { emit: __emit }) {
		const props = __props;
		const emit = __emit;
		const messageComponent = computed(() => {
			return getSupportedMessageComponent(props.message.type);
		});
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", null, [messageComponent.value ? (openBlock(), createBlock(resolveDynamicComponent(messageComponent.value), {
				key: 0,
				message: _ctx.message,
				"is-first-of-role": _ctx.isFirstOfRole,
				user: _ctx.user,
				streaming: _ctx.streaming,
				"is-last-message": _ctx.isLastMessage,
				color: _ctx.color,
				onCodeReplace: _cache[0] || (_cache[0] = ($event) => emit("codeReplace")),
				onCodeUndo: _cache[1] || (_cache[1] = ($event) => emit("codeUndo")),
				onFeedback: _cache[2] || (_cache[2] = (feedback) => emit("feedback", feedback))
			}, null, 40, [
				"message",
				"is-first-of-role",
				"user",
				"streaming",
				"is-last-message",
				"color"
			])) : _ctx.message.type === "custom" ? renderSlot(_ctx.$slots, "custom-message", {
				key: 1,
				message: _ctx.message,
				isFirstOfRole: _ctx.isFirstOfRole,
				user: _ctx.user,
				streaming: _ctx.streaming,
				isLastMessage: _ctx.isLastMessage
			}) : createCommentVNode("", true)]);
		};
	}
});
var ThinkingMessage_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "ThinkingMessage",
	props: {
		items: {},
		latestStatusText: {},
		isStreaming: {
			type: Boolean,
			default: false
		}
	},
	setup(__props) {
		const props = __props;
		const isExpanded = ref(false);
		const hasRunningItem = computed(() => props.items.some((item$4) => item$4.status === "running"));
		const shouldShowShimmer = computed(() => hasRunningItem.value);
		const toggleExpanded = () => {
			isExpanded.value = !isExpanded.value;
		};
		function getIconForStatus(status$1) {
			switch (status$1) {
				case "completed": return {
					icon: "circle-check",
					spin: false
				};
				case "running": return {
					icon: "spinner",
					spin: true
				};
				case "error": return {
					icon: "triangle-alert",
					spin: false
				};
				default: return {
					icon: "circle",
					spin: false
				};
			}
		}
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", { class: normalizeClass(_ctx.$style.thinkingContainer) }, [createBaseVNode("button", {
				class: normalizeClass(_ctx.$style.header),
				type: "button",
				onClick: toggleExpanded
			}, [createBaseVNode("span", { class: normalizeClass([_ctx.$style.statusText, { [_ctx.$style.shimmer]: shouldShowShimmer.value }]) }, toDisplayString(_ctx.latestStatusText), 3), createVNode(unref(N8nIcon_default), {
				icon: isExpanded.value ? "chevron-down" : "chevron-right",
				class: normalizeClass(_ctx.$style.chevron)
			}, null, 8, ["icon", "class"])], 2), createVNode(Transition, { name: "expand" }, {
				default: withCtx(() => [isExpanded.value ? (openBlock(), createElementBlock("div", {
					key: 0,
					class: normalizeClass(_ctx.$style.itemList)
				}, [(openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.items, (item$4) => {
					return openBlock(), createElementBlock("div", {
						key: item$4.id,
						class: normalizeClass(_ctx.$style.item)
					}, [createVNode(unref(N8nIcon_default), {
						icon: getIconForStatus(item$4.status).icon,
						spin: getIconForStatus(item$4.status).spin,
						class: normalizeClass(_ctx.$style.itemIcon)
					}, null, 8, [
						"icon",
						"spin",
						"class"
					]), createBaseVNode("span", { class: normalizeClass(_ctx.$style.itemText) }, toDisplayString(item$4.displayTitle), 3)], 2);
				}), 128))], 2)) : createCommentVNode("", true)]),
				_: 1
			})], 2);
		};
	}
});
var ThinkingMessage_vue_vue_type_style_index_0_lang_module_default = {
	thinkingContainer: "_thinkingContainer_12sg5_131",
	header: "_header_12sg5_135",
	chevron: "_chevron_12sg5_150",
	statusText: "_statusText_12sg5_162",
	shimmer: "_shimmer_12sg5_169",
	itemList: "_itemList_12sg5_177",
	item: "_item_12sg5_177",
	itemIcon: "_itemIcon_12sg5_191",
	itemText: "_itemText_12sg5_202"
};
var ThinkingMessage_default = /* @__PURE__ */ __plugin_vue_export_helper_default(ThinkingMessage_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": ThinkingMessage_vue_vue_type_style_index_0_lang_module_default }], ["__scopeId", "data-v-45dbdf83"]]);
var AssistantLoadingMessage_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "AssistantLoadingMessage",
	props: {
		message: {},
		animationType: { default: "slide-vertical" }
	},
	setup(__props) {
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", { class: normalizeClass(_ctx.$style.container) }, [createBaseVNode("div", { class: normalizeClass(_ctx.$style.loadingSpinner) }, [createVNode(unref(N8nIcon_default), {
				icon: "spinner",
				spin: "",
				color: "secondary",
				size: "large"
			})], 2), createVNode(Transition, {
				name: _ctx.animationType,
				mode: "out-in"
			}, {
				default: withCtx(() => [_ctx.message ? (openBlock(), createBlock(unref(N8nText_default), {
					key: _ctx.message,
					size: "small",
					bold: ""
				}, {
					default: withCtx(() => [createTextVNode(toDisplayString(_ctx.message), 1)]),
					_: 1
				})) : createCommentVNode("", true)]),
				_: 1
			}, 8, ["name"])], 2);
		};
	}
});
var AssistantLoadingMessage_vue_vue_type_style_index_0_lang_module_default = {
	container: "_container_1bn5e_131",
	loadingSpinner: "_loadingSpinner_1bn5e_138",
	shimmer: "_shimmer_1bn5e_1"
};
var AssistantLoadingMessage_default = /* @__PURE__ */ __plugin_vue_export_helper_default(AssistantLoadingMessage_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": AssistantLoadingMessage_vue_vue_type_style_index_0_lang_module_default }], ["__scopeId", "data-v-55cfb2bc"]]);
function useCharacterLimit({ value, maxLength }) {
	const characterCount$1 = computed(() => value.value.length);
	return {
		characterCount: characterCount$1,
		remainingCharacters: computed(() => maxLength.value - characterCount$1.value),
		isOverLimit: computed(() => characterCount$1.value > maxLength.value),
		isAtLimit: computed(() => characterCount$1.value >= maxLength.value)
	};
}
var _hoisted_1$38 = [
	"href",
	"target",
	"title",
	"data-test-id"
];
var N8nRoute_default = /* @__PURE__ */ defineComponent({
	name: "N8nRoute",
	__name: "Route",
	props: {
		to: {},
		newWindow: { type: Boolean },
		title: {},
		dataTestId: {}
	},
	setup(__props) {
		const props = __props;
		const useRouterLink = computed(() => {
			if (props.newWindow) return false;
			if (typeof props.to === "string") return props.to.startsWith("/");
			return props.to !== void 0;
		});
		const openNewWindow = computed(() => !useRouterLink.value);
		return (_ctx, _cache) => {
			return useRouterLink.value && _ctx.to ? (openBlock(), createBlock(unref(RouterLink), mergeProps({
				key: 0,
				to: _ctx.to,
				role: "link"
			}, _ctx.$attrs, { "data-test-id": _ctx.dataTestId }), {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 16, ["to", "data-test-id"])) : (openBlock(), createElementBlock("a", mergeProps({
				key: 1,
				href: _ctx.to ? `${_ctx.to}` : void 0,
				target: openNewWindow.value ? "_blank" : "_self"
			}, _ctx.$attrs, {
				title: _ctx.title,
				"data-test-id": _ctx.dataTestId
			}), [renderSlot(_ctx.$slots, "default")], 16, _hoisted_1$38));
		};
	}
});
var Link_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	name: "N8nLink",
	__name: "Link",
	props: {
		to: { default: void 0 },
		size: { default: void 0 },
		newWindow: { type: Boolean },
		bold: {
			type: Boolean,
			default: false
		},
		underline: {
			type: Boolean,
			default: false
		},
		theme: { default: "primary" },
		title: {}
	},
	setup(__props) {
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(N8nRoute_default), mergeProps({
				to: _ctx.to,
				title: _ctx.title,
				"new-window": _ctx.newWindow
			}, _ctx.$attrs, { class: "n8n-link" }), {
				default: withCtx(() => [createBaseVNode("span", { class: normalizeClass(_ctx.$style[`${_ctx.underline ? `${_ctx.theme}-underline` : _ctx.theme}`]) }, [createVNode(unref(N8nText_default), {
					size: _ctx.size,
					bold: _ctx.bold
				}, {
					default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
					_: 3
				}, 8, ["size", "bold"])], 2)]),
				_: 3
			}, 16, [
				"to",
				"title",
				"new-window"
			]);
		};
	}
});
var Link_vue_vue_type_style_index_0_lang_module_default = {
	primary: "_primary_1rq9e_123",
	text: "_text_1rq9e_130",
	danger: "_danger_1rq9e_140",
	secondary: "_secondary_1rq9e_147",
	"primary-underline": "_primary-underline_1rq9e_154 _primary_1rq9e_123",
	"text-underline": "_text-underline_1rq9e_159 _text_1rq9e_130",
	"danger-underline": "_danger-underline_1rq9e_164 _danger_1rq9e_140",
	"secondary-underline": "_secondary-underline_1rq9e_169 _secondary_1rq9e_147"
};
var N8nLink_default = /* @__PURE__ */ __plugin_vue_export_helper_default(Link_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": Link_vue_vue_type_style_index_0_lang_module_default }]]);
function serialize(o$1) {
	return typeof o$1 == "string" ? `'${o$1}'` : new c$1().serialize(o$1);
}
var c$1 = /* @__PURE__ */ function() {
	class o$1 {
		#t = /* @__PURE__ */ new Map();
		compare(t$1, r) {
			const e = typeof t$1, n = typeof r;
			return e === "string" && n === "string" ? t$1.localeCompare(r) : e === "number" && n === "number" ? t$1 - r : String.prototype.localeCompare.call(this.serialize(t$1, true), this.serialize(r, true));
		}
		serialize(t$1, r) {
			if (t$1 === null) return "null";
			switch (typeof t$1) {
				case "string": return r ? t$1 : `'${t$1}'`;
				case "bigint": return `${t$1}n`;
				case "object": return this.$object(t$1);
				case "function": return this.$function(t$1);
			}
			return String(t$1);
		}
		serializeObject(t$1) {
			const r = Object.prototype.toString.call(t$1);
			if (r !== "[object Object]") return this.serializeBuiltInType(r.length < 10 ? `unknown:${r}` : r.slice(8, -1), t$1);
			const e = t$1.constructor, n = e === Object || e === void 0 ? "" : e.name;
			if (n !== "" && globalThis[n] === e) return this.serializeBuiltInType(n, t$1);
			if (typeof t$1.toJSON == "function") {
				const i$1 = t$1.toJSON();
				return n + (i$1 !== null && typeof i$1 == "object" ? this.$object(i$1) : `(${this.serialize(i$1)})`);
			}
			return this.serializeObjectEntries(n, Object.entries(t$1));
		}
		serializeBuiltInType(t$1, r) {
			const e = this["$" + t$1];
			if (e) return e.call(this, r);
			if (typeof r?.entries == "function") return this.serializeObjectEntries(t$1, r.entries());
			throw new Error(`Cannot serialize ${t$1}`);
		}
		serializeObjectEntries(t$1, r) {
			const e = Array.from(r).sort((i$1, a$1) => this.compare(i$1[0], a$1[0]));
			let n = `${t$1}{`;
			for (let i$1 = 0; i$1 < e.length; i$1++) {
				const [a$1, l] = e[i$1];
				n += `${this.serialize(a$1, true)}:${this.serialize(l)}`, i$1 < e.length - 1 && (n += ",");
			}
			return n + "}";
		}
		$object(t$1) {
			let r = this.#t.get(t$1);
			return r === void 0 && (this.#t.set(t$1, `#${this.#t.size}`), r = this.serializeObject(t$1), this.#t.set(t$1, r)), r;
		}
		$function(t$1) {
			const r = Function.prototype.toString.call(t$1);
			return r.slice(-15) === "[native code] }" ? `${t$1.name || ""}()[native]` : `${t$1.name}(${t$1.length})${r.replace(/\s*\n\s*/g, "")}`;
		}
		$Array(t$1) {
			let r = "[";
			for (let e = 0; e < t$1.length; e++) r += this.serialize(t$1[e]), e < t$1.length - 1 && (r += ",");
			return r + "]";
		}
		$Date(t$1) {
			try {
				return `Date(${t$1.toISOString()})`;
			} catch {
				return "Date(null)";
			}
		}
		$ArrayBuffer(t$1) {
			return `ArrayBuffer[${new Uint8Array(t$1).join(",")}]`;
		}
		$Set(t$1) {
			return `Set${this.$Array(Array.from(t$1).sort((r, e) => this.compare(r, e)))}`;
		}
		$Map(t$1) {
			return this.serializeObjectEntries("Map", t$1.entries());
		}
	}
	for (const s of [
		"Error",
		"RegExp",
		"URL"
	]) o$1.prototype["$" + s] = function(t$1) {
		return `${s}(${t$1})`;
	};
	for (const s of [
		"Int8Array",
		"Uint8Array",
		"Uint8ClampedArray",
		"Int16Array",
		"Uint16Array",
		"Int32Array",
		"Uint32Array",
		"Float32Array",
		"Float64Array"
	]) o$1.prototype["$" + s] = function(t$1) {
		return `${s}[${t$1.join(",")}]`;
	};
	for (const s of ["BigInt64Array", "BigUint64Array"]) o$1.prototype["$" + s] = function(t$1) {
		return `${s}[${t$1.join("n,")}${t$1.length > 0 ? "n" : ""}]`;
	};
	return o$1;
}();
function isEqual(object1, object2) {
	if (object1 === object2) return true;
	if (serialize(object1) === serialize(object2)) return true;
	return false;
}
function clamp$1(value, min$2 = Number.NEGATIVE_INFINITY, max$2 = Number.POSITIVE_INFINITY) {
	return Math.min(max$2, Math.max(min$2, value));
}
function createContext(providerComponentName, contextName) {
	const symbolDescription = typeof providerComponentName === "string" && !contextName ? `${providerComponentName}Context` : contextName;
	const injectionKey = Symbol(symbolDescription);
	const injectContext = (fallback) => {
		const context$1 = inject(injectionKey, fallback);
		if (context$1) return context$1;
		if (context$1 === null) return context$1;
		throw new Error(`Injection \`${injectionKey.toString()}\` not found. Component must be used within ${Array.isArray(providerComponentName) ? `one of the following components: ${providerComponentName.join(", ")}` : `\`${providerComponentName}\``}`);
	};
	const provideContext = (contextValue) => {
		provide(injectionKey, contextValue);
		return contextValue;
	};
	return [injectContext, provideContext];
}
function getActiveElement() {
	let activeElement = document.activeElement;
	if (activeElement == null) return null;
	while (activeElement != null && activeElement.shadowRoot != null && activeElement.shadowRoot.activeElement != null) activeElement = activeElement.shadowRoot.activeElement;
	return activeElement;
}
function handleAndDispatchCustomEvent(name$1, handler, detail) {
	const target$1 = detail.originalEvent.target;
	const event = new CustomEvent(name$1, {
		bubbles: false,
		cancelable: true,
		detail
	});
	if (handler) target$1.addEventListener(name$1, handler, { once: true });
	target$1.dispatchEvent(event);
}
function isNullish(value) {
	return value === null || value === void 0;
}
function renderSlotFragments(children) {
	if (!children) return [];
	return children.flatMap((child$1) => {
		if (child$1.type === Fragment) return renderSlotFragments(child$1.children);
		return [child$1];
	});
}
var [injectConfigProviderContext, provideConfigProviderContext] = createContext("ConfigProvider");
function computedEager(fn$1, options$1) {
	var _a;
	const result = shallowRef();
	watchEffect(() => {
		result.value = fn$1();
	}, {
		...options$1,
		flush: (_a = options$1 == null ? void 0 : options$1.flush) != null ? _a : "sync"
	});
	return readonly(result);
}
function tryOnScopeDispose(fn$1) {
	if (getCurrentScope()) {
		onScopeDispose(fn$1);
		return true;
	}
	return false;
}
function createGlobalState(stateFactory) {
	let initialized = false;
	let state;
	const scope = effectScope(true);
	return (...args) => {
		if (!initialized) {
			state = scope.run(() => stateFactory(...args));
			initialized = true;
		}
		return state;
	};
}
function createSharedComposable(composable) {
	let subscribers = 0;
	let state;
	let scope;
	const dispose = () => {
		subscribers -= 1;
		if (scope && subscribers <= 0) {
			scope.stop();
			state = void 0;
			scope = void 0;
		}
	};
	return (...args) => {
		subscribers += 1;
		if (!scope) {
			scope = effectScope(true);
			state = scope.run(() => composable(...args));
		}
		tryOnScopeDispose(dispose);
		return state;
	};
}
function toReactive(objectRef) {
	if (!isRef(objectRef)) return reactive(objectRef);
	return reactive(new Proxy({}, {
		get(_, p$1, receiver) {
			return unref(Reflect.get(objectRef.value, p$1, receiver));
		},
		set(_, p$1, value) {
			if (isRef(objectRef.value[p$1]) && !isRef(value)) objectRef.value[p$1].value = value;
			else objectRef.value[p$1] = value;
			return true;
		},
		deleteProperty(_, p$1) {
			return Reflect.deleteProperty(objectRef.value, p$1);
		},
		has(_, p$1) {
			return Reflect.has(objectRef.value, p$1);
		},
		ownKeys() {
			return Object.keys(objectRef.value);
		},
		getOwnPropertyDescriptor() {
			return {
				enumerable: true,
				configurable: true
			};
		}
	}));
}
function reactiveComputed(fn$1) {
	return toReactive(computed(fn$1));
}
function reactiveOmit(obj, ...keys$1) {
	const flatKeys = keys$1.flat();
	const predicate = flatKeys[0];
	return reactiveComputed(() => typeof predicate === "function" ? Object.fromEntries(Object.entries(toRefs(obj)).filter(([k, v$1]) => !predicate(toValue$1(v$1), k))) : Object.fromEntries(Object.entries(toRefs(obj)).filter((e) => !flatKeys.includes(e[0]))));
}
var isClient = typeof window !== "undefined" && typeof document !== "undefined";
typeof WorkerGlobalScope !== "undefined" && globalThis instanceof WorkerGlobalScope;
var isDef = (val) => typeof val !== "undefined";
var toString$1 = Object.prototype.toString;
var isObject = (val) => toString$1.call(val) === "[object Object]";
var noop = () => {};
var isIOS = /* @__PURE__ */ getIsIOS();
function getIsIOS() {
	var _a, _b;
	return isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((_b = window == null ? void 0 : window.navigator) == null ? void 0 : _b.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));
}
function createFilterWrapper(filter, fn$1) {
	function wrapper$2(...args) {
		return new Promise((resolve, reject) => {
			Promise.resolve(filter(() => fn$1.apply(this, args), {
				fn: fn$1,
				thisArg: this,
				args
			})).then(resolve).catch(reject);
		});
	}
	return wrapper$2;
}
function debounceFilter(ms, options$1 = {}) {
	let timer;
	let maxTimer;
	let lastRejector = noop;
	const _clearTimeout = (timer2) => {
		clearTimeout(timer2);
		lastRejector();
		lastRejector = noop;
	};
	let lastInvoker;
	const filter = (invoke) => {
		const duration = toValue$1(ms);
		const maxDuration = toValue$1(options$1.maxWait);
		if (timer) _clearTimeout(timer);
		if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {
			if (maxTimer) {
				_clearTimeout(maxTimer);
				maxTimer = null;
			}
			return Promise.resolve(invoke());
		}
		return new Promise((resolve, reject) => {
			lastRejector = options$1.rejectOnCancel ? reject : resolve;
			lastInvoker = invoke;
			if (maxDuration && !maxTimer) maxTimer = setTimeout(() => {
				if (timer) _clearTimeout(timer);
				maxTimer = null;
				resolve(lastInvoker());
			}, maxDuration);
			timer = setTimeout(() => {
				if (maxTimer) _clearTimeout(maxTimer);
				maxTimer = null;
				resolve(invoke());
			}, duration);
		});
	};
	return filter;
}
function cacheStringFunction(fn$1) {
	const cache$1 = /* @__PURE__ */ Object.create(null);
	return (str) => {
		return cache$1[str] || (cache$1[str] = fn$1(str));
	};
}
var hyphenateRE = /\B([A-Z])/g;
cacheStringFunction((str) => str.replace(hyphenateRE, "-$1").toLowerCase());
var camelizeRE = /-(\w)/g;
cacheStringFunction((str) => {
	return str.replace(camelizeRE, (_, c$2) => c$2 ? c$2.toUpperCase() : "");
});
function getLifeCycleTarget(target$1) {
	return target$1 || getCurrentInstance();
}
function toArray(value) {
	return Array.isArray(value) ? value : [value];
}
function refAutoReset(defaultValue, afterMs = 1e4) {
	return customRef((track, trigger) => {
		let value = toValue$1(defaultValue);
		let timer;
		const resetAfter = () => setTimeout(() => {
			value = toValue$1(defaultValue);
			trigger();
		}, toValue$1(afterMs));
		tryOnScopeDispose(() => {
			clearTimeout(timer);
		});
		return {
			get() {
				track();
				return value;
			},
			set(newValue) {
				value = newValue;
				trigger();
				clearTimeout(timer);
				timer = resetAfter();
			}
		};
	});
}
function useDebounceFn(fn$1, ms = 200, options$1 = {}) {
	return createFilterWrapper(debounceFilter(ms, options$1), fn$1);
}
var toValue$2 = toValue$1;
function tryOnBeforeUnmount(fn$1, target$1) {
	if (getLifeCycleTarget(target$1)) onBeforeUnmount(fn$1, target$1);
}
function watchImmediate(source, cb, options$1) {
	return watch(source, cb, {
		...options$1,
		immediate: true
	});
}
function watchOnce(source, cb, options$1) {
	const stop = watch(source, (...args) => {
		nextTick(() => stop());
		return cb(...args);
	}, options$1);
	return stop;
}
var defaultWindow = isClient ? window : void 0;
isClient && window.document;
isClient && window.navigator;
isClient && window.location;
function unrefElement(elRef) {
	var _a;
	const plain = toValue$1(elRef);
	return (_a = plain == null ? void 0 : plain.$el) != null ? _a : plain;
}
function useEventListener(...args) {
	const cleanups = [];
	const cleanup = () => {
		cleanups.forEach((fn$1) => fn$1());
		cleanups.length = 0;
	};
	const register = (el$2, event, listener, options$1) => {
		el$2.addEventListener(event, listener, options$1);
		return () => el$2.removeEventListener(event, listener, options$1);
	};
	const firstParamTargets = computed(() => {
		const test = toArray(toValue$1(args[0])).filter((e) => e != null);
		return test.every((e) => typeof e !== "string") ? test : void 0;
	});
	const stopWatch = watchImmediate(() => {
		var _a, _b;
		return [
			(_b = (_a = firstParamTargets.value) == null ? void 0 : _a.map((e) => unrefElement(e))) != null ? _b : [defaultWindow].filter((e) => e != null),
			toArray(toValue$1(firstParamTargets.value ? args[1] : args[0])),
			toArray(unref(firstParamTargets.value ? args[2] : args[1])),
			toValue$1(firstParamTargets.value ? args[3] : args[2])
		];
	}, ([raw_targets, raw_events, raw_listeners, raw_options]) => {
		cleanup();
		if (!(raw_targets == null ? void 0 : raw_targets.length) || !(raw_events == null ? void 0 : raw_events.length) || !(raw_listeners == null ? void 0 : raw_listeners.length)) return;
		const optionsClone = isObject(raw_options) ? { ...raw_options } : raw_options;
		cleanups.push(...raw_targets.flatMap((el$2) => raw_events.flatMap((event) => raw_listeners.map((listener) => register(el$2, event, listener, optionsClone)))));
	}, { flush: "post" });
	const stop = () => {
		stopWatch();
		cleanup();
	};
	tryOnScopeDispose(cleanup);
	return stop;
}
function useMounted() {
	const isMounted = shallowRef(false);
	const instance = getCurrentInstance();
	if (instance) onMounted(() => {
		isMounted.value = true;
	}, instance);
	return isMounted;
}
function useSupported(callback) {
	const isMounted = useMounted();
	return computed(() => {
		isMounted.value;
		return Boolean(callback());
	});
}
function createKeyPredicate(keyFilter) {
	if (typeof keyFilter === "function") return keyFilter;
	else if (typeof keyFilter === "string") return (event) => event.key === keyFilter;
	else if (Array.isArray(keyFilter)) return (event) => keyFilter.includes(event.key);
	return () => true;
}
function onKeyStroke(...args) {
	let key$2;
	let handler;
	let options$1 = {};
	if (args.length === 3) {
		key$2 = args[0];
		handler = args[1];
		options$1 = args[2];
	} else if (args.length === 2) if (typeof args[1] === "object") {
		key$2 = true;
		handler = args[0];
		options$1 = args[1];
	} else {
		key$2 = args[0];
		handler = args[1];
	}
	else {
		key$2 = true;
		handler = args[0];
	}
	const { target: target$1 = defaultWindow, eventName = "keydown", passive = false, dedupe = false } = options$1;
	const predicate = createKeyPredicate(key$2);
	const listener = (e) => {
		if (e.repeat && toValue$1(dedupe)) return;
		if (predicate(e)) handler(e);
	};
	return useEventListener(target$1, eventName, listener, passive);
}
function cloneFnJSON(source) {
	return JSON.parse(JSON.stringify(source));
}
function useResizeObserver$1(target$1, callback, options$1 = {}) {
	const { window: window$2 = defaultWindow,...observerOptions } = options$1;
	let observer;
	const isSupported$1 = useSupported(() => window$2 && "ResizeObserver" in window$2);
	const cleanup = () => {
		if (observer) {
			observer.disconnect();
			observer = void 0;
		}
	};
	const stopWatch = watch(computed(() => {
		const _targets = toValue$1(target$1);
		return Array.isArray(_targets) ? _targets.map((el$2) => unrefElement(el$2)) : [unrefElement(_targets)];
	}), (els$1) => {
		cleanup();
		if (isSupported$1.value && window$2) {
			observer = new ResizeObserver(callback);
			for (const _el of els$1) if (_el) observer.observe(_el, observerOptions);
		}
	}, {
		immediate: true,
		flush: "post"
	});
	const stop = () => {
		cleanup();
		stopWatch();
	};
	tryOnScopeDispose(stop);
	return {
		isSupported: isSupported$1,
		stop
	};
}
Number.POSITIVE_INFINITY;
function useVModel(props, key$2, emit, options$1 = {}) {
	var _a, _b, _c;
	const { clone = false, passive = false, eventName, deep = false, defaultValue, shouldEmit } = options$1;
	const vm = getCurrentInstance();
	const _emit = emit || (vm == null ? void 0 : vm.emit) || ((_a = vm == null ? void 0 : vm.$emit) == null ? void 0 : _a.bind(vm)) || ((_c = (_b = vm == null ? void 0 : vm.proxy) == null ? void 0 : _b.$emit) == null ? void 0 : _c.bind(vm == null ? void 0 : vm.proxy));
	let event = eventName;
	if (!key$2) key$2 = "modelValue";
	event = event || `update:${key$2.toString()}`;
	const cloneFn = (val) => !clone ? val : typeof clone === "function" ? clone(val) : cloneFnJSON(val);
	const getValue = () => isDef(props[key$2]) ? cloneFn(props[key$2]) : defaultValue;
	const triggerEmit = (value) => {
		if (shouldEmit) {
			if (shouldEmit(value)) _emit(event, value);
		} else _emit(event, value);
	};
	if (passive) {
		const proxy = ref(getValue());
		let isUpdating = false;
		watch(() => props[key$2], (v$1) => {
			if (!isUpdating) {
				isUpdating = true;
				proxy.value = cloneFn(v$1);
				nextTick(() => isUpdating = false);
			}
		});
		watch(proxy, (v$1) => {
			if (!isUpdating && (v$1 !== props[key$2] || deep)) triggerEmit(v$1);
		}, { deep });
		return proxy;
	} else return computed({
		get() {
			return getValue();
		},
		set(value) {
			triggerEmit(value);
		}
	});
}
function isPlainObject(value) {
	if (value === null || typeof value !== "object") return false;
	const prototype = Object.getPrototypeOf(value);
	if (prototype !== null && prototype !== Object.prototype && Object.getPrototypeOf(prototype) !== null) return false;
	if (Symbol.iterator in value) return false;
	if (Symbol.toStringTag in value) return Object.prototype.toString.call(value) === "[object Module]";
	return true;
}
function _defu(baseObject, defaults, namespace = ".", merger) {
	if (!isPlainObject(defaults)) return _defu(baseObject, {}, namespace, merger);
	const object = Object.assign({}, defaults);
	for (const key$2 in baseObject) {
		if (key$2 === "__proto__" || key$2 === "constructor") continue;
		const value = baseObject[key$2];
		if (value === null || value === void 0) continue;
		if (merger && merger(object, key$2, value, namespace)) continue;
		if (Array.isArray(value) && Array.isArray(object[key$2])) object[key$2] = [...value, ...object[key$2]];
		else if (isPlainObject(value) && isPlainObject(object[key$2])) object[key$2] = _defu(value, object[key$2], (namespace ? `${namespace}.` : "") + key$2.toString(), merger);
		else object[key$2] = value;
	}
	return object;
}
function createDefu(merger) {
	return (...arguments_) => arguments_.reduce((p$1, c$2) => _defu(p$1, c$2, "", merger), {});
}
var defu = createDefu();
createDefu((object, key$2, currentValue) => {
	if (object[key$2] !== void 0 && typeof currentValue === "function") {
		object[key$2] = currentValue(object[key$2]);
		return true;
	}
});
createDefu((object, key$2, currentValue) => {
	if (Array.isArray(object[key$2]) && typeof currentValue === "function") {
		object[key$2] = currentValue(object[key$2]);
		return true;
	}
});
var useBodyLockStackCount = createSharedComposable(() => {
	const map$1 = ref(/* @__PURE__ */ new Map());
	const initialOverflow = ref();
	const locked = computed(() => {
		for (const value of map$1.value.values()) if (value) return true;
		return false;
	});
	const context$1 = injectConfigProviderContext({ scrollBody: ref(true) });
	let stopTouchMoveListener = null;
	const resetBodyStyle = () => {
		document.body.style.paddingRight = "";
		document.body.style.marginRight = "";
		document.body.style.pointerEvents = "";
		document.documentElement.style.removeProperty("--scrollbar-width");
		document.body.style.overflow = initialOverflow.value ?? "";
		isIOS && stopTouchMoveListener?.();
		initialOverflow.value = void 0;
	};
	watch(locked, (val, oldVal) => {
		if (!isClient) return;
		if (!val) {
			if (oldVal) resetBodyStyle();
			return;
		}
		if (initialOverflow.value === void 0) initialOverflow.value = document.body.style.overflow;
		const verticalScrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
		const defaultConfig = {
			padding: verticalScrollbarWidth,
			margin: 0
		};
		const config$1 = context$1.scrollBody?.value ? typeof context$1.scrollBody.value === "object" ? defu({
			padding: context$1.scrollBody.value.padding === true ? verticalScrollbarWidth : context$1.scrollBody.value.padding,
			margin: context$1.scrollBody.value.margin === true ? verticalScrollbarWidth : context$1.scrollBody.value.margin
		}, defaultConfig) : defaultConfig : {
			padding: 0,
			margin: 0
		};
		if (verticalScrollbarWidth > 0) {
			document.body.style.paddingRight = typeof config$1.padding === "number" ? `${config$1.padding}px` : String(config$1.padding);
			document.body.style.marginRight = typeof config$1.margin === "number" ? `${config$1.margin}px` : String(config$1.margin);
			document.documentElement.style.setProperty("--scrollbar-width", `${verticalScrollbarWidth}px`);
			document.body.style.overflow = "hidden";
		}
		if (isIOS) stopTouchMoveListener = useEventListener(document, "touchmove", (e) => preventDefault(e), { passive: false });
		nextTick(() => {
			document.body.style.pointerEvents = "none";
			document.body.style.overflow = "hidden";
		});
	}, {
		immediate: true,
		flush: "sync"
	});
	return map$1;
});
function useBodyScrollLock(initialState) {
	const id$1 = Math.random().toString(36).substring(2, 7);
	const map$1 = useBodyLockStackCount();
	map$1.value.set(id$1, initialState ?? false);
	const locked = computed({
		get: () => map$1.value.get(id$1) ?? false,
		set: (value) => map$1.value.set(id$1, value)
	});
	tryOnBeforeUnmount(() => {
		map$1.value.delete(id$1);
	});
	return locked;
}
function checkOverflowScroll(ele) {
	const style = window.getComputedStyle(ele);
	if (style.overflowX === "scroll" || style.overflowY === "scroll" || style.overflowX === "auto" && ele.clientWidth < ele.scrollWidth || style.overflowY === "auto" && ele.clientHeight < ele.scrollHeight) return true;
	else {
		const parent = ele.parentNode;
		if (!(parent instanceof Element) || parent.tagName === "BODY") return false;
		return checkOverflowScroll(parent);
	}
}
function preventDefault(rawEvent) {
	const e = rawEvent || window.event;
	const _target = e.target;
	if (_target instanceof Element && checkOverflowScroll(_target)) return false;
	if (e.touches.length > 1) return true;
	if (e.preventDefault && e.cancelable) e.preventDefault();
	return false;
}
var $62225008020f0a13$var$ERA_START_DATES = [
	[
		1868,
		9,
		8
	],
	[
		1912,
		7,
		30
	],
	[
		1926,
		12,
		25
	],
	[
		1989,
		1,
		8
	],
	[
		2019,
		5,
		1
	]
];
var $62225008020f0a13$var$ERA_END_DATES = [
	[
		1912,
		7,
		29
	],
	[
		1926,
		12,
		24
	],
	[
		1989,
		1,
		7
	],
	[
		2019,
		4,
		30
	]
];
var $62225008020f0a13$var$ERA_ADDENDS = [
	1867,
	1911,
	1925,
	1988,
	2018
];
var $62225008020f0a13$var$ERA_NAMES = [
	"meiji",
	"taisho",
	"showa",
	"heisei",
	"reiwa"
];
function $62225008020f0a13$var$findEraFromGregorianDate(date$1) {
	const idx = $62225008020f0a13$var$ERA_START_DATES.findIndex(([year, month, day]) => {
		if (date$1.year < year) return true;
		if (date$1.year === year && date$1.month < month) return true;
		if (date$1.year === year && date$1.month === month && date$1.day < day) return true;
		return false;
	});
	if (idx === -1) return $62225008020f0a13$var$ERA_START_DATES.length - 1;
	if (idx === 0) return 0;
	return idx - 1;
}
function $62225008020f0a13$var$toGregorian(date$1) {
	let eraAddend = $62225008020f0a13$var$ERA_ADDENDS[$62225008020f0a13$var$ERA_NAMES.indexOf(date$1.era)];
	if (!eraAddend) throw new Error("Unknown era: " + date$1.era);
	return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(date$1.year + eraAddend, date$1.month, date$1.day);
}
var $62225008020f0a13$export$b746ab2b60cdffbf = class extends $3b62074eb05584b2$export$80ee6245ec4f29ec {
	fromJulianDay(jd) {
		let date$1 = super.fromJulianDay(jd);
		let era = $62225008020f0a13$var$findEraFromGregorianDate(date$1);
		return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(this, $62225008020f0a13$var$ERA_NAMES[era], date$1.year - $62225008020f0a13$var$ERA_ADDENDS[era], date$1.month, date$1.day);
	}
	toJulianDay(date$1) {
		return super.toJulianDay($62225008020f0a13$var$toGregorian(date$1));
	}
	balanceDate(date$1) {
		let gregorianDate = $62225008020f0a13$var$toGregorian(date$1);
		let era = $62225008020f0a13$var$findEraFromGregorianDate(gregorianDate);
		if ($62225008020f0a13$var$ERA_NAMES[era] !== date$1.era) {
			date$1.era = $62225008020f0a13$var$ERA_NAMES[era];
			date$1.year = gregorianDate.year - $62225008020f0a13$var$ERA_ADDENDS[era];
		}
		this.constrainDate(date$1);
	}
	constrainDate(date$1) {
		let idx = $62225008020f0a13$var$ERA_NAMES.indexOf(date$1.era);
		let end$1 = $62225008020f0a13$var$ERA_END_DATES[idx];
		if (end$1 != null) {
			let [endYear, endMonth, endDay] = end$1;
			let maxYear = endYear - $62225008020f0a13$var$ERA_ADDENDS[idx];
			date$1.year = Math.max(1, Math.min(maxYear, date$1.year));
			if (date$1.year === maxYear) {
				date$1.month = Math.min(endMonth, date$1.month);
				if (date$1.month === endMonth) date$1.day = Math.min(endDay, date$1.day);
			}
		}
		if (date$1.year === 1 && idx >= 0) {
			let [, startMonth, startDay] = $62225008020f0a13$var$ERA_START_DATES[idx];
			date$1.month = Math.max(startMonth, date$1.month);
			if (date$1.month === startMonth) date$1.day = Math.max(startDay, date$1.day);
		}
	}
	getEras() {
		return $62225008020f0a13$var$ERA_NAMES;
	}
	getYearsInEra(date$1) {
		let era = $62225008020f0a13$var$ERA_NAMES.indexOf(date$1.era);
		let cur = $62225008020f0a13$var$ERA_START_DATES[era];
		let next$1 = $62225008020f0a13$var$ERA_START_DATES[era + 1];
		if (next$1 == null) return 9999 - cur[0] + 1;
		let years = next$1[0] - cur[0];
		if (date$1.month < next$1[1] || date$1.month === next$1[1] && date$1.day < next$1[2]) years++;
		return years;
	}
	getDaysInMonth(date$1) {
		return super.getDaysInMonth($62225008020f0a13$var$toGregorian(date$1));
	}
	getMinimumMonthInYear(date$1) {
		let start = $62225008020f0a13$var$getMinimums(date$1);
		return start ? start[1] : 1;
	}
	getMinimumDayInMonth(date$1) {
		let start = $62225008020f0a13$var$getMinimums(date$1);
		return start && date$1.month === start[1] ? start[2] : 1;
	}
	constructor(...args) {
		super(...args), this.identifier = "japanese";
	}
};
function $62225008020f0a13$var$getMinimums(date$1) {
	if (date$1.year === 1) return $62225008020f0a13$var$ERA_START_DATES[$62225008020f0a13$var$ERA_NAMES.indexOf(date$1.era)];
}
var $8d73d47422ca7302$var$BUDDHIST_ERA_START = -543;
var $8d73d47422ca7302$export$42d20a78301dee44 = class extends $3b62074eb05584b2$export$80ee6245ec4f29ec {
	fromJulianDay(jd) {
		let gregorianDate = super.fromJulianDay(jd);
		let year = $3b62074eb05584b2$export$c36e0ecb2d4fa69d(gregorianDate.era, gregorianDate.year);
		return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(this, year - $8d73d47422ca7302$var$BUDDHIST_ERA_START, gregorianDate.month, gregorianDate.day);
	}
	toJulianDay(date$1) {
		return super.toJulianDay($8d73d47422ca7302$var$toGregorian(date$1));
	}
	getEras() {
		return ["BE"];
	}
	getDaysInMonth(date$1) {
		return super.getDaysInMonth($8d73d47422ca7302$var$toGregorian(date$1));
	}
	balanceDate() {}
	constructor(...args) {
		super(...args), this.identifier = "buddhist";
	}
};
function $8d73d47422ca7302$var$toGregorian(date$1) {
	let [era, year] = $3b62074eb05584b2$export$4475b7e617eb123c(date$1.year + $8d73d47422ca7302$var$BUDDHIST_ERA_START);
	return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(era, year, date$1.month, date$1.day);
}
var $5f31bd6f0c8940b2$var$TAIWAN_ERA_START = 1911;
function $5f31bd6f0c8940b2$var$gregorianYear(date$1) {
	return date$1.era === "minguo" ? date$1.year + $5f31bd6f0c8940b2$var$TAIWAN_ERA_START : 1 - date$1.year + $5f31bd6f0c8940b2$var$TAIWAN_ERA_START;
}
function $5f31bd6f0c8940b2$var$gregorianToTaiwan(year) {
	let y = year - $5f31bd6f0c8940b2$var$TAIWAN_ERA_START;
	if (y > 0) return ["minguo", y];
	else return ["before_minguo", 1 - y];
}
var $5f31bd6f0c8940b2$export$65e01080afcb0799 = class extends $3b62074eb05584b2$export$80ee6245ec4f29ec {
	fromJulianDay(jd) {
		let date$1 = super.fromJulianDay(jd);
		let [era, year] = $5f31bd6f0c8940b2$var$gregorianToTaiwan($3b62074eb05584b2$export$c36e0ecb2d4fa69d(date$1.era, date$1.year));
		return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(this, era, year, date$1.month, date$1.day);
	}
	toJulianDay(date$1) {
		return super.toJulianDay($5f31bd6f0c8940b2$var$toGregorian(date$1));
	}
	getEras() {
		return ["before_minguo", "minguo"];
	}
	balanceDate(date$1) {
		let [era, year] = $5f31bd6f0c8940b2$var$gregorianToTaiwan($5f31bd6f0c8940b2$var$gregorianYear(date$1));
		date$1.era = era;
		date$1.year = year;
	}
	isInverseEra(date$1) {
		return date$1.era === "before_minguo";
	}
	getDaysInMonth(date$1) {
		return super.getDaysInMonth($5f31bd6f0c8940b2$var$toGregorian(date$1));
	}
	getYearsInEra(date$1) {
		return date$1.era === "before_minguo" ? 9999 : 9999 - $5f31bd6f0c8940b2$var$TAIWAN_ERA_START;
	}
	constructor(...args) {
		super(...args), this.identifier = "roc";
	}
};
function $5f31bd6f0c8940b2$var$toGregorian(date$1) {
	let [era, year] = $3b62074eb05584b2$export$4475b7e617eb123c($5f31bd6f0c8940b2$var$gregorianYear(date$1));
	return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(era, year, date$1.month, date$1.day);
}
var $f3ed2e4472ae7e25$var$PERSIAN_EPOCH = 1948320;
var $f3ed2e4472ae7e25$var$MONTH_START = [
	0,
	31,
	62,
	93,
	124,
	155,
	186,
	216,
	246,
	276,
	306,
	336
];
var $f3ed2e4472ae7e25$export$37fccdbfd14c5939 = class {
	fromJulianDay(jd) {
		let daysSinceEpoch = jd - $f3ed2e4472ae7e25$var$PERSIAN_EPOCH;
		let year = 1 + Math.floor((33 * daysSinceEpoch + 3) / 12053);
		let dayOfYear = daysSinceEpoch - (365 * (year - 1) + Math.floor((8 * year + 21) / 33));
		let month = dayOfYear < 216 ? Math.floor(dayOfYear / 31) : Math.floor((dayOfYear - 6) / 30);
		let day = dayOfYear - $f3ed2e4472ae7e25$var$MONTH_START[month] + 1;
		return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(this, year, month + 1, day);
	}
	toJulianDay(date$1) {
		let jd = $f3ed2e4472ae7e25$var$PERSIAN_EPOCH - 1 + 365 * (date$1.year - 1) + Math.floor((8 * date$1.year + 21) / 33);
		jd += $f3ed2e4472ae7e25$var$MONTH_START[date$1.month - 1];
		jd += date$1.day;
		return jd;
	}
	getMonthsInYear() {
		return 12;
	}
	getDaysInMonth(date$1) {
		if (date$1.month <= 6) return 31;
		if (date$1.month <= 11) return 30;
		return $2b4dce13dd5a17fa$export$842a2cf37af977e1(25 * date$1.year + 11, 33) < 8 ? 30 : 29;
	}
	getEras() {
		return ["AP"];
	}
	getYearsInEra() {
		return 9377;
	}
	constructor() {
		this.identifier = "persian";
	}
};
var $82c358003bdda0a8$var$INDIAN_ERA_START = 78;
var $82c358003bdda0a8$var$INDIAN_YEAR_START = 80;
var $82c358003bdda0a8$export$39f31c639fa15726 = class extends $3b62074eb05584b2$export$80ee6245ec4f29ec {
	fromJulianDay(jd) {
		let date$1 = super.fromJulianDay(jd);
		let indianYear = date$1.year - $82c358003bdda0a8$var$INDIAN_ERA_START;
		let yDay = jd - $3b62074eb05584b2$export$f297eb839006d339(date$1.era, date$1.year, 1, 1);
		let leapMonth;
		if (yDay < $82c358003bdda0a8$var$INDIAN_YEAR_START) {
			indianYear--;
			leapMonth = $3b62074eb05584b2$export$553d7fa8e3805fc0(date$1.year - 1) ? 31 : 30;
			yDay += leapMonth + 155 + 90 + 10;
		} else {
			leapMonth = $3b62074eb05584b2$export$553d7fa8e3805fc0(date$1.year) ? 31 : 30;
			yDay -= $82c358003bdda0a8$var$INDIAN_YEAR_START;
		}
		let indianMonth;
		let indianDay;
		if (yDay < leapMonth) {
			indianMonth = 1;
			indianDay = yDay + 1;
		} else {
			let mDay = yDay - leapMonth;
			if (mDay < 155) {
				indianMonth = Math.floor(mDay / 31) + 2;
				indianDay = mDay % 31 + 1;
			} else {
				mDay -= 155;
				indianMonth = Math.floor(mDay / 30) + 7;
				indianDay = mDay % 30 + 1;
			}
		}
		return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(this, indianYear, indianMonth, indianDay);
	}
	toJulianDay(date$1) {
		let [era, year] = $3b62074eb05584b2$export$4475b7e617eb123c(date$1.year + $82c358003bdda0a8$var$INDIAN_ERA_START);
		let leapMonth;
		let jd;
		if ($3b62074eb05584b2$export$553d7fa8e3805fc0(year)) {
			leapMonth = 31;
			jd = $3b62074eb05584b2$export$f297eb839006d339(era, year, 3, 21);
		} else {
			leapMonth = 30;
			jd = $3b62074eb05584b2$export$f297eb839006d339(era, year, 3, 22);
		}
		if (date$1.month === 1) return jd + date$1.day - 1;
		jd += leapMonth + Math.min(date$1.month - 2, 5) * 31;
		if (date$1.month >= 8) jd += (date$1.month - 7) * 30;
		jd += date$1.day - 1;
		return jd;
	}
	getDaysInMonth(date$1) {
		if (date$1.month === 1 && $3b62074eb05584b2$export$553d7fa8e3805fc0(date$1.year + $82c358003bdda0a8$var$INDIAN_ERA_START)) return 31;
		if (date$1.month >= 2 && date$1.month <= 6) return 31;
		return 30;
	}
	getYearsInEra() {
		return 9919;
	}
	getEras() {
		return ["saka"];
	}
	balanceDate() {}
	constructor(...args) {
		super(...args), this.identifier = "indian";
	}
};
var $f2f3e0e3a817edbd$var$CIVIL_EPOC = 1948440;
var $f2f3e0e3a817edbd$var$ASTRONOMICAL_EPOC = 1948439;
var $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START = 1300;
var $f2f3e0e3a817edbd$var$UMALQURA_YEAR_END = 1600;
var $f2f3e0e3a817edbd$var$UMALQURA_START_DAYS = 460322;
function $f2f3e0e3a817edbd$var$islamicToJulianDay(epoch, year, month, day) {
	return day + Math.ceil(29.5 * (month - 1)) + (year - 1) * 354 + Math.floor((3 + 11 * year) / 30) + epoch - 1;
}
function $f2f3e0e3a817edbd$var$julianDayToIslamic(calendar$1, epoch, jd) {
	let year = Math.floor((30 * (jd - epoch) + 10646) / 10631);
	let month = Math.min(12, Math.ceil((jd - (29 + $f2f3e0e3a817edbd$var$islamicToJulianDay(epoch, year, 1, 1))) / 29.5) + 1);
	return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(calendar$1, year, month, jd - $f2f3e0e3a817edbd$var$islamicToJulianDay(epoch, year, month, 1) + 1);
}
function $f2f3e0e3a817edbd$var$isLeapYear(year) {
	return (14 + 11 * year) % 30 < 11;
}
var $f2f3e0e3a817edbd$export$2066795aadd37bfc = class {
	fromJulianDay(jd) {
		return $f2f3e0e3a817edbd$var$julianDayToIslamic(this, $f2f3e0e3a817edbd$var$CIVIL_EPOC, jd);
	}
	toJulianDay(date$1) {
		return $f2f3e0e3a817edbd$var$islamicToJulianDay($f2f3e0e3a817edbd$var$CIVIL_EPOC, date$1.year, date$1.month, date$1.day);
	}
	getDaysInMonth(date$1) {
		let length = 29 + date$1.month % 2;
		if (date$1.month === 12 && $f2f3e0e3a817edbd$var$isLeapYear(date$1.year)) length++;
		return length;
	}
	getMonthsInYear() {
		return 12;
	}
	getDaysInYear(date$1) {
		return $f2f3e0e3a817edbd$var$isLeapYear(date$1.year) ? 355 : 354;
	}
	getYearsInEra() {
		return 9665;
	}
	getEras() {
		return ["AH"];
	}
	constructor() {
		this.identifier = "islamic-civil";
	}
};
var $f2f3e0e3a817edbd$export$37f0887f2f9d22f7 = class extends $f2f3e0e3a817edbd$export$2066795aadd37bfc {
	fromJulianDay(jd) {
		return $f2f3e0e3a817edbd$var$julianDayToIslamic(this, $f2f3e0e3a817edbd$var$ASTRONOMICAL_EPOC, jd);
	}
	toJulianDay(date$1) {
		return $f2f3e0e3a817edbd$var$islamicToJulianDay($f2f3e0e3a817edbd$var$ASTRONOMICAL_EPOC, date$1.year, date$1.month, date$1.day);
	}
	constructor(...args) {
		super(...args), this.identifier = "islamic-tbla";
	}
};
var $f2f3e0e3a817edbd$var$UMALQURA_DATA = "qgpUDckO1AbqBmwDrQpVBakGkgepC9QF2gpcBS0NlQZKB1QLagutBa4ETwoXBYsGpQbVCtYCWwmdBE0KJg2VDawFtgm6AlsKKwWVCsoG6Qr0AnYJtgJWCcoKpAvSC9kF3AJtCU0FpQpSC6ULtAW2CVcFlwJLBaMGUgdlC2oFqworBZUMSg2lDcoF1gpXCasESwmlClILagt1BXYCtwhbBFUFqQW0BdoJ3QRuAjYJqgpUDbIN1QXaAlsJqwRVCkkLZAtxC7QFtQpVCiUNkg7JDtQG6QprCasEkwpJDaQNsg25CroEWworBZUKKgtVC1wFvQQ9Ah0JlQpKC1oLbQW2AjsJmwRVBqkGVAdqC2wFrQpVBSkLkgupC9QF2gpaBasKlQVJB2QHqgu1BbYCVgpNDiULUgtqC60FrgIvCZcESwalBqwG1gpdBZ0ETQoWDZUNqgW1BdoCWwmtBJUFygbkBuoK9QS2AlYJqgpUC9IL2QXqAm0JrQSVCkoLpQuyBbUJ1gSXCkcFkwZJB1ULagVrCisFiwpGDaMNygXWCtsEawJLCaUKUgtpC3UFdgG3CFsCKwVlBbQF2gntBG0BtgimClINqQ3UBdoKWwmrBFMGKQdiB6kLsgW1ClUFJQuSDckO0gbpCmsFqwRVCikNVA2qDbUJugQ7CpsETQqqCtUK2gJdCV4ELgqaDFUNsga5BroEXQotBZUKUguoC7QLuQXaAloJSgukDdEO6AZqC20FNQWVBkoNqA3UDdoGWwWdAisGFQtKC5ULqgWuCi4JjwwnBZUGqgbWCl0FnQI=";
var $f2f3e0e3a817edbd$var$UMALQURA_MONTHLENGTH;
var $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START_TABLE;
function $f2f3e0e3a817edbd$var$umalquraYearStart(year) {
	return $f2f3e0e3a817edbd$var$UMALQURA_START_DAYS + $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START_TABLE[year - $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START];
}
function $f2f3e0e3a817edbd$var$umalquraMonthLength(year, month) {
	let idx = year - $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START;
	let mask$1 = 1 << 11 - (month - 1);
	if (($f2f3e0e3a817edbd$var$UMALQURA_MONTHLENGTH[idx] & mask$1) === 0) return 29;
	else return 30;
}
function $f2f3e0e3a817edbd$var$umalquraMonthStart(year, month) {
	let day = $f2f3e0e3a817edbd$var$umalquraYearStart(year);
	for (let i$1 = 1; i$1 < month; i$1++) day += $f2f3e0e3a817edbd$var$umalquraMonthLength(year, i$1);
	return day;
}
function $f2f3e0e3a817edbd$var$umalquraYearLength(year) {
	return $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START_TABLE[year + 1 - $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START] - $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START_TABLE[year - $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START];
}
var $f2f3e0e3a817edbd$export$5baab4758c231076 = class extends $f2f3e0e3a817edbd$export$2066795aadd37bfc {
	fromJulianDay(jd) {
		let days = jd - $f2f3e0e3a817edbd$var$CIVIL_EPOC;
		let startDays = $f2f3e0e3a817edbd$var$umalquraYearStart($f2f3e0e3a817edbd$var$UMALQURA_YEAR_START);
		let endDays = $f2f3e0e3a817edbd$var$umalquraYearStart($f2f3e0e3a817edbd$var$UMALQURA_YEAR_END);
		if (days < startDays || days > endDays) return super.fromJulianDay(jd);
		else {
			let y = $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START - 1;
			let m$2 = 1;
			let d = 1;
			while (d > 0) {
				y++;
				d = days - $f2f3e0e3a817edbd$var$umalquraYearStart(y) + 1;
				let yearLength = $f2f3e0e3a817edbd$var$umalquraYearLength(y);
				if (d === yearLength) {
					m$2 = 12;
					break;
				} else if (d < yearLength) {
					let monthLength = $f2f3e0e3a817edbd$var$umalquraMonthLength(y, m$2);
					m$2 = 1;
					while (d > monthLength) {
						d -= monthLength;
						m$2++;
						monthLength = $f2f3e0e3a817edbd$var$umalquraMonthLength(y, m$2);
					}
					break;
				}
			}
			return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(this, y, m$2, days - $f2f3e0e3a817edbd$var$umalquraMonthStart(y, m$2) + 1);
		}
	}
	toJulianDay(date$1) {
		if (date$1.year < $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START || date$1.year > $f2f3e0e3a817edbd$var$UMALQURA_YEAR_END) return super.toJulianDay(date$1);
		return $f2f3e0e3a817edbd$var$CIVIL_EPOC + $f2f3e0e3a817edbd$var$umalquraMonthStart(date$1.year, date$1.month) + (date$1.day - 1);
	}
	getDaysInMonth(date$1) {
		if (date$1.year < $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START || date$1.year > $f2f3e0e3a817edbd$var$UMALQURA_YEAR_END) return super.getDaysInMonth(date$1);
		return $f2f3e0e3a817edbd$var$umalquraMonthLength(date$1.year, date$1.month);
	}
	getDaysInYear(date$1) {
		if (date$1.year < $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START || date$1.year > $f2f3e0e3a817edbd$var$UMALQURA_YEAR_END) return super.getDaysInYear(date$1);
		return $f2f3e0e3a817edbd$var$umalquraYearLength(date$1.year);
	}
	constructor() {
		super(), this.identifier = "islamic-umalqura";
		if (!$f2f3e0e3a817edbd$var$UMALQURA_MONTHLENGTH) $f2f3e0e3a817edbd$var$UMALQURA_MONTHLENGTH = new Uint16Array(Uint8Array.from(atob($f2f3e0e3a817edbd$var$UMALQURA_DATA), (c$2) => c$2.charCodeAt(0)).buffer);
		if (!$f2f3e0e3a817edbd$var$UMALQURA_YEAR_START_TABLE) {
			$f2f3e0e3a817edbd$var$UMALQURA_YEAR_START_TABLE = new Uint32Array($f2f3e0e3a817edbd$var$UMALQURA_YEAR_END - $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START + 1);
			let yearStart = 0;
			for (let year = $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START; year <= $f2f3e0e3a817edbd$var$UMALQURA_YEAR_END; year++) {
				$f2f3e0e3a817edbd$var$UMALQURA_YEAR_START_TABLE[year - $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START] = yearStart;
				for (let i$1 = 1; i$1 <= 12; i$1++) yearStart += $f2f3e0e3a817edbd$var$umalquraMonthLength(year, i$1);
			}
		}
	}
};
var $7c5f6fbf42389787$var$HEBREW_EPOCH = 347997;
var $7c5f6fbf42389787$var$HOUR_PARTS = 1080;
var $7c5f6fbf42389787$var$DAY_PARTS = 24 * $7c5f6fbf42389787$var$HOUR_PARTS;
var $7c5f6fbf42389787$var$MONTH_DAYS = 29;
var $7c5f6fbf42389787$var$MONTH_FRACT = 12 * $7c5f6fbf42389787$var$HOUR_PARTS + 793;
var $7c5f6fbf42389787$var$MONTH_PARTS = $7c5f6fbf42389787$var$MONTH_DAYS * $7c5f6fbf42389787$var$DAY_PARTS + $7c5f6fbf42389787$var$MONTH_FRACT;
function $7c5f6fbf42389787$var$isLeapYear(year) {
	return $2b4dce13dd5a17fa$export$842a2cf37af977e1(year * 7 + 1, 19) < 7;
}
function $7c5f6fbf42389787$var$hebrewDelay1(year) {
	let months = Math.floor((235 * year - 234) / 19);
	let parts = 12084 + 13753 * months;
	let day = months * 29 + Math.floor(parts / 25920);
	if ($2b4dce13dd5a17fa$export$842a2cf37af977e1(3 * (day + 1), 7) < 3) day += 1;
	return day;
}
function $7c5f6fbf42389787$var$hebrewDelay2(year) {
	let last = $7c5f6fbf42389787$var$hebrewDelay1(year - 1);
	let present = $7c5f6fbf42389787$var$hebrewDelay1(year);
	if ($7c5f6fbf42389787$var$hebrewDelay1(year + 1) - present === 356) return 2;
	if (present - last === 382) return 1;
	return 0;
}
function $7c5f6fbf42389787$var$startOfYear(year) {
	return $7c5f6fbf42389787$var$hebrewDelay1(year) + $7c5f6fbf42389787$var$hebrewDelay2(year);
}
function $7c5f6fbf42389787$var$getDaysInYear(year) {
	return $7c5f6fbf42389787$var$startOfYear(year + 1) - $7c5f6fbf42389787$var$startOfYear(year);
}
function $7c5f6fbf42389787$var$getYearType(year) {
	let yearLength = $7c5f6fbf42389787$var$getDaysInYear(year);
	if (yearLength > 380) yearLength -= 30;
	switch (yearLength) {
		case 353: return 0;
		case 354: return 1;
		case 355: return 2;
	}
}
function $7c5f6fbf42389787$var$getDaysInMonth(year, month) {
	if (month >= 6 && !$7c5f6fbf42389787$var$isLeapYear(year)) month++;
	if (month === 4 || month === 7 || month === 9 || month === 11 || month === 13) return 29;
	let yearType = $7c5f6fbf42389787$var$getYearType(year);
	if (month === 2) return yearType === 2 ? 30 : 29;
	if (month === 3) return yearType === 0 ? 29 : 30;
	if (month === 6) return $7c5f6fbf42389787$var$isLeapYear(year) ? 30 : 0;
	return 30;
}
var $7c5f6fbf42389787$export$ca405048b8fb5af = class {
	fromJulianDay(jd) {
		let d = jd - $7c5f6fbf42389787$var$HEBREW_EPOCH;
		let m$2 = d * $7c5f6fbf42389787$var$DAY_PARTS / $7c5f6fbf42389787$var$MONTH_PARTS;
		let year = Math.floor((19 * m$2 + 234) / 235) + 1;
		let ys = $7c5f6fbf42389787$var$startOfYear(year);
		let dayOfYear = Math.floor(d - ys);
		while (dayOfYear < 1) {
			year--;
			ys = $7c5f6fbf42389787$var$startOfYear(year);
			dayOfYear = Math.floor(d - ys);
		}
		let month = 1;
		let monthStart = 0;
		while (monthStart < dayOfYear) {
			monthStart += $7c5f6fbf42389787$var$getDaysInMonth(year, month);
			month++;
		}
		month--;
		monthStart -= $7c5f6fbf42389787$var$getDaysInMonth(year, month);
		let day = dayOfYear - monthStart;
		return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(this, year, month, day);
	}
	toJulianDay(date$1) {
		let jd = $7c5f6fbf42389787$var$startOfYear(date$1.year);
		for (let month = 1; month < date$1.month; month++) jd += $7c5f6fbf42389787$var$getDaysInMonth(date$1.year, month);
		return jd + date$1.day + $7c5f6fbf42389787$var$HEBREW_EPOCH;
	}
	getDaysInMonth(date$1) {
		return $7c5f6fbf42389787$var$getDaysInMonth(date$1.year, date$1.month);
	}
	getMonthsInYear(date$1) {
		return $7c5f6fbf42389787$var$isLeapYear(date$1.year) ? 13 : 12;
	}
	getDaysInYear(date$1) {
		return $7c5f6fbf42389787$var$getDaysInYear(date$1.year);
	}
	getYearsInEra() {
		return 9999;
	}
	getEras() {
		return ["AM"];
	}
	balanceYearMonth(date$1, previousDate) {
		if (previousDate.year !== date$1.year) {
			if ($7c5f6fbf42389787$var$isLeapYear(previousDate.year) && !$7c5f6fbf42389787$var$isLeapYear(date$1.year) && previousDate.month > 6) date$1.month--;
			else if (!$7c5f6fbf42389787$var$isLeapYear(previousDate.year) && $7c5f6fbf42389787$var$isLeapYear(date$1.year) && previousDate.month > 6) date$1.month++;
		}
	}
	constructor() {
		this.identifier = "hebrew";
	}
};
var $b956b2d7a6cf451f$var$ETHIOPIC_EPOCH = 1723856;
var $b956b2d7a6cf451f$var$COPTIC_EPOCH = 1824665;
var $b956b2d7a6cf451f$var$AMETE_MIHRET_DELTA = 5500;
function $b956b2d7a6cf451f$var$ceToJulianDay(epoch, year, month, day) {
	return epoch + 365 * year + Math.floor(year / 4) + 30 * (month - 1) + day - 1;
}
function $b956b2d7a6cf451f$var$julianDayToCE(epoch, jd) {
	let year = Math.floor(4 * (jd - epoch) / 1461);
	let month = 1 + Math.floor((jd - $b956b2d7a6cf451f$var$ceToJulianDay(epoch, year, 1, 1)) / 30);
	return [
		year,
		month,
		jd + 1 - $b956b2d7a6cf451f$var$ceToJulianDay(epoch, year, month, 1)
	];
}
function $b956b2d7a6cf451f$var$getLeapDay(year) {
	return Math.floor(year % 4 / 3);
}
function $b956b2d7a6cf451f$var$getDaysInMonth(year, month) {
	if (month % 13 !== 0) return 30;
	else return $b956b2d7a6cf451f$var$getLeapDay(year) + 5;
}
var $b956b2d7a6cf451f$export$26ba6eab5e20cd7d = class {
	fromJulianDay(jd) {
		let [year, month, day] = $b956b2d7a6cf451f$var$julianDayToCE($b956b2d7a6cf451f$var$ETHIOPIC_EPOCH, jd);
		let era = "AM";
		if (year <= 0) {
			era = "AA";
			year += $b956b2d7a6cf451f$var$AMETE_MIHRET_DELTA;
		}
		return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(this, era, year, month, day);
	}
	toJulianDay(date$1) {
		let year = date$1.year;
		if (date$1.era === "AA") year -= $b956b2d7a6cf451f$var$AMETE_MIHRET_DELTA;
		return $b956b2d7a6cf451f$var$ceToJulianDay($b956b2d7a6cf451f$var$ETHIOPIC_EPOCH, year, date$1.month, date$1.day);
	}
	getDaysInMonth(date$1) {
		return $b956b2d7a6cf451f$var$getDaysInMonth(date$1.year, date$1.month);
	}
	getMonthsInYear() {
		return 13;
	}
	getDaysInYear(date$1) {
		return 365 + $b956b2d7a6cf451f$var$getLeapDay(date$1.year);
	}
	getYearsInEra(date$1) {
		return date$1.era === "AA" ? 9999 : 9991;
	}
	getEras() {
		return ["AA", "AM"];
	}
	constructor() {
		this.identifier = "ethiopic";
	}
};
var $b956b2d7a6cf451f$export$d72e0c37005a4914 = class extends $b956b2d7a6cf451f$export$26ba6eab5e20cd7d {
	fromJulianDay(jd) {
		let [year, month, day] = $b956b2d7a6cf451f$var$julianDayToCE($b956b2d7a6cf451f$var$ETHIOPIC_EPOCH, jd);
		year += $b956b2d7a6cf451f$var$AMETE_MIHRET_DELTA;
		return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(this, "AA", year, month, day);
	}
	getEras() {
		return ["AA"];
	}
	getYearsInEra() {
		return 9999;
	}
	constructor(...args) {
		super(...args), this.identifier = "ethioaa";
	}
};
var $b956b2d7a6cf451f$export$fe6243cbe1a4b7c1 = class extends $b956b2d7a6cf451f$export$26ba6eab5e20cd7d {
	fromJulianDay(jd) {
		let [year, month, day] = $b956b2d7a6cf451f$var$julianDayToCE($b956b2d7a6cf451f$var$COPTIC_EPOCH, jd);
		let era = "CE";
		if (year <= 0) {
			era = "BCE";
			year = 1 - year;
		}
		return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(this, era, year, month, day);
	}
	toJulianDay(date$1) {
		let year = date$1.year;
		if (date$1.era === "BCE") year = 1 - year;
		return $b956b2d7a6cf451f$var$ceToJulianDay($b956b2d7a6cf451f$var$COPTIC_EPOCH, year, date$1.month, date$1.day);
	}
	getDaysInMonth(date$1) {
		let year = date$1.year;
		if (date$1.era === "BCE") year = 1 - year;
		return $b956b2d7a6cf451f$var$getDaysInMonth(year, date$1.month);
	}
	isInverseEra(date$1) {
		return date$1.era === "BCE";
	}
	balanceDate(date$1) {
		if (date$1.year <= 0) {
			date$1.era = date$1.era === "BCE" ? "CE" : "BCE";
			date$1.year = 1 - date$1.year;
		}
	}
	getEras() {
		return ["BCE", "CE"];
	}
	getYearsInEra(date$1) {
		return date$1.era === "BCE" ? 9999 : 9715;
	}
	constructor(...args) {
		super(...args), this.identifier = "coptic";
	}
};
function $64244302c3013299$export$dd0bbc9b26defe37(name$1) {
	switch (name$1) {
		case "buddhist": return new $8d73d47422ca7302$export$42d20a78301dee44();
		case "ethiopic": return new $b956b2d7a6cf451f$export$26ba6eab5e20cd7d();
		case "ethioaa": return new $b956b2d7a6cf451f$export$d72e0c37005a4914();
		case "coptic": return new $b956b2d7a6cf451f$export$fe6243cbe1a4b7c1();
		case "hebrew": return new $7c5f6fbf42389787$export$ca405048b8fb5af();
		case "indian": return new $82c358003bdda0a8$export$39f31c639fa15726();
		case "islamic-civil": return new $f2f3e0e3a817edbd$export$2066795aadd37bfc();
		case "islamic-tbla": return new $f2f3e0e3a817edbd$export$37f0887f2f9d22f7();
		case "islamic-umalqura": return new $f2f3e0e3a817edbd$export$5baab4758c231076();
		case "japanese": return new $62225008020f0a13$export$b746ab2b60cdffbf();
		case "persian": return new $f3ed2e4472ae7e25$export$37fccdbfd14c5939();
		case "roc": return new $5f31bd6f0c8940b2$export$65e01080afcb0799();
		case "gregory":
		default: return new $3b62074eb05584b2$export$80ee6245ec4f29ec();
	}
}
var $fb18d541ea1ad717$var$formatterCache = /* @__PURE__ */ new Map();
var $fb18d541ea1ad717$export$ad991b66133851cf = class {
	format(value) {
		return this.formatter.format(value);
	}
	formatToParts(value) {
		return this.formatter.formatToParts(value);
	}
	formatRange(start, end$1) {
		if (typeof this.formatter.formatRange === "function") return this.formatter.formatRange(start, end$1);
		if (end$1 < start) throw new RangeError("End date must be >= start date");
		return `${this.formatter.format(start)} \u{2013} ${this.formatter.format(end$1)}`;
	}
	formatRangeToParts(start, end$1) {
		if (typeof this.formatter.formatRangeToParts === "function") return this.formatter.formatRangeToParts(start, end$1);
		if (end$1 < start) throw new RangeError("End date must be >= start date");
		let startParts = this.formatter.formatToParts(start);
		let endParts = this.formatter.formatToParts(end$1);
		return [
			...startParts.map((p$1) => ({
				...p$1,
				source: "startRange"
			})),
			{
				type: "literal",
				value: "  ",
				source: "shared"
			},
			...endParts.map((p$1) => ({
				...p$1,
				source: "endRange"
			}))
		];
	}
	resolvedOptions() {
		let resolvedOptions = this.formatter.resolvedOptions();
		if ($fb18d541ea1ad717$var$hasBuggyResolvedHourCycle()) {
			if (!this.resolvedHourCycle) this.resolvedHourCycle = $fb18d541ea1ad717$var$getResolvedHourCycle(resolvedOptions.locale, this.options);
			resolvedOptions.hourCycle = this.resolvedHourCycle;
			resolvedOptions.hour12 = this.resolvedHourCycle === "h11" || this.resolvedHourCycle === "h12";
		}
		if (resolvedOptions.calendar === "ethiopic-amete-alem") resolvedOptions.calendar = "ethioaa";
		return resolvedOptions;
	}
	constructor(locale, options$1 = {}) {
		this.formatter = $fb18d541ea1ad717$var$getCachedDateFormatter(locale, options$1);
		this.options = options$1;
	}
};
var $fb18d541ea1ad717$var$hour12Preferences = {
	true: { ja: "h11" },
	false: {}
};
function $fb18d541ea1ad717$var$getCachedDateFormatter(locale, options$1 = {}) {
	if (typeof options$1.hour12 === "boolean" && $fb18d541ea1ad717$var$hasBuggyHour12Behavior()) {
		options$1 = { ...options$1 };
		let pref = $fb18d541ea1ad717$var$hour12Preferences[String(options$1.hour12)][locale.split("-")[0]];
		let defaultHourCycle = options$1.hour12 ? "h12" : "h23";
		options$1.hourCycle = pref !== null && pref !== void 0 ? pref : defaultHourCycle;
		delete options$1.hour12;
	}
	let cacheKey = locale + (options$1 ? Object.entries(options$1).sort((a$1, b$2) => a$1[0] < b$2[0] ? -1 : 1).join() : "");
	if ($fb18d541ea1ad717$var$formatterCache.has(cacheKey)) return $fb18d541ea1ad717$var$formatterCache.get(cacheKey);
	let numberFormatter = new Intl.DateTimeFormat(locale, options$1);
	$fb18d541ea1ad717$var$formatterCache.set(cacheKey, numberFormatter);
	return numberFormatter;
}
var $fb18d541ea1ad717$var$_hasBuggyHour12Behavior = null;
function $fb18d541ea1ad717$var$hasBuggyHour12Behavior() {
	if ($fb18d541ea1ad717$var$_hasBuggyHour12Behavior == null) $fb18d541ea1ad717$var$_hasBuggyHour12Behavior = new Intl.DateTimeFormat("en-US", {
		hour: "numeric",
		hour12: false
	}).format(new Date(2020, 2, 3, 0)) === "24";
	return $fb18d541ea1ad717$var$_hasBuggyHour12Behavior;
}
var $fb18d541ea1ad717$var$_hasBuggyResolvedHourCycle = null;
function $fb18d541ea1ad717$var$hasBuggyResolvedHourCycle() {
	if ($fb18d541ea1ad717$var$_hasBuggyResolvedHourCycle == null) $fb18d541ea1ad717$var$_hasBuggyResolvedHourCycle = new Intl.DateTimeFormat("fr", {
		hour: "numeric",
		hour12: false
	}).resolvedOptions().hourCycle === "h12";
	return $fb18d541ea1ad717$var$_hasBuggyResolvedHourCycle;
}
function $fb18d541ea1ad717$var$getResolvedHourCycle(locale, options$1) {
	if (!options$1.timeStyle && !options$1.hour) return void 0;
	locale = locale.replace(/(-u-)?-nu-[a-zA-Z0-9]+/, "");
	locale += (locale.includes("-u-") ? "" : "-u") + "-nu-latn";
	let formatter = $fb18d541ea1ad717$var$getCachedDateFormatter(locale, {
		...options$1,
		timeZone: void 0
	});
	let min$2 = parseInt(formatter.formatToParts(new Date(2020, 2, 3, 0)).find((p$1) => p$1.type === "hour").value, 10);
	let max$2 = parseInt(formatter.formatToParts(new Date(2020, 2, 3, 23)).find((p$1) => p$1.type === "hour").value, 10);
	if (min$2 === 0 && max$2 === 23) return "h23";
	if (min$2 === 24 && max$2 === 23) return "h24";
	if (min$2 === 0 && max$2 === 11) return "h11";
	if (min$2 === 12 && max$2 === 11) return "h12";
	throw new Error("Unexpected hour cycle result");
}
function toDate(dateValue, tz = $14e0f24ef4ac5c92$export$aa8b41735afcabd2()) {
	if (isZonedDateTime(dateValue)) return dateValue.toDate();
	else return dateValue.toDate(tz);
}
function isCalendarDateTime(dateValue) {
	return dateValue instanceof $35ea8db9cb2ccb90$export$ca871e8dbb80966f;
}
function isZonedDateTime(dateValue) {
	return dateValue instanceof $35ea8db9cb2ccb90$export$d3b7288e7994edea;
}
function hasTime(dateValue) {
	return isCalendarDateTime(dateValue) || isZonedDateTime(dateValue);
}
function getDaysInMonth(date$1) {
	if (date$1 instanceof Date) {
		const year = date$1.getFullYear();
		const month = date$1.getMonth() + 1;
		return new Date(year, month, 0).getDate();
	} else return date$1.set({ day: 100 }).day;
}
function isBefore(dateToCompare, referenceDate) {
	return dateToCompare.compare(referenceDate) < 0;
}
function isAfter(dateToCompare, referenceDate) {
	return dateToCompare.compare(referenceDate) > 0;
}
function isBeforeOrSame(dateToCompare, referenceDate) {
	return dateToCompare.compare(referenceDate) <= 0;
}
function isAfterOrSame(dateToCompare, referenceDate) {
	return dateToCompare.compare(referenceDate) >= 0;
}
function isBetweenInclusive(date$1, start, end$1) {
	return isAfterOrSame(date$1, start) && isBeforeOrSame(date$1, end$1);
}
function isBetween(date$1, start, end$1) {
	return isAfter(date$1, start) && isBefore(date$1, end$1);
}
function getLastFirstDayOfWeek(date$1, firstDayOfWeek, locale) {
	const day = $14e0f24ef4ac5c92$export$2061056d06d7cdf7(date$1, locale);
	if (firstDayOfWeek > day) return date$1.subtract({ days: day + 7 - firstDayOfWeek });
	if (firstDayOfWeek === day) return date$1;
	return date$1.subtract({ days: day - firstDayOfWeek });
}
function getNextLastDayOfWeek(date$1, firstDayOfWeek, locale) {
	const day = $14e0f24ef4ac5c92$export$2061056d06d7cdf7(date$1, locale);
	const lastDayOfWeek = firstDayOfWeek === 0 ? 6 : firstDayOfWeek - 1;
	if (day === lastDayOfWeek) return date$1;
	if (day > lastDayOfWeek) return date$1.add({ days: 7 - day + lastDayOfWeek });
	return date$1.add({ days: lastDayOfWeek - day });
}
function areAllDaysBetweenValid(start, end$1, isUnavailable, isDisabled, isHighlightable) {
	if (isUnavailable === void 0 && isDisabled === void 0 && isHighlightable === void 0) return true;
	let dCurrent = start.add({ days: 1 });
	if ((isDisabled?.(dCurrent) || isUnavailable?.(dCurrent)) && !isHighlightable?.(dCurrent)) return false;
	const dEnd = end$1;
	while (dCurrent.compare(dEnd) < 0) {
		dCurrent = dCurrent.add({ days: 1 });
		if ((isDisabled?.(dCurrent) || isUnavailable?.(dCurrent)) && !isHighlightable?.(dCurrent)) return false;
	}
	return true;
}
function getDefaultDate(props) {
	const { defaultValue, defaultPlaceholder, granularity = "day", locale = "en" } = props;
	if (Array.isArray(defaultValue) && defaultValue.length) return defaultValue.at(-1).copy();
	if (defaultValue && !Array.isArray(defaultValue)) return defaultValue.copy();
	if (defaultPlaceholder) return defaultPlaceholder.copy();
	const date$1 = /* @__PURE__ */ new Date();
	const year = date$1.getFullYear();
	const month = date$1.getMonth() + 1;
	const day = date$1.getDate();
	const calendarDateTimeGranularities$1 = [
		"hour",
		"minute",
		"second"
	];
	const calendar$1 = $64244302c3013299$export$dd0bbc9b26defe37(new $fb18d541ea1ad717$export$ad991b66133851cf(locale).resolvedOptions().calendar);
	if (calendarDateTimeGranularities$1.includes(granularity ?? "day")) return $11d87f3f76e88657$export$b4a036af3fc0b032(new $35ea8db9cb2ccb90$export$ca871e8dbb80966f(year, month, day, 0, 0, 0), calendar$1);
	return $11d87f3f76e88657$export$b4a036af3fc0b032(new $35ea8db9cb2ccb90$export$99faa760c7908e4f(year, month, day), calendar$1);
}
function chunk(arr, size$2) {
	const result = [];
	for (let i$1 = 0; i$1 < arr.length; i$1 += size$2) result.push(arr.slice(i$1, i$1 + size$2));
	return result;
}
function getOptsByGranularity(granularity, hourCycle, isTimeValue = false) {
	const opts = {
		year: "numeric",
		month: "2-digit",
		day: "2-digit",
		hour: "2-digit",
		minute: "2-digit",
		second: "2-digit",
		timeZoneName: "short",
		hourCycle: normalizeHourCycle(hourCycle),
		hour12: normalizeHour12(hourCycle)
	};
	if (isTimeValue) {
		delete opts.year;
		delete opts.month;
		delete opts.day;
	}
	if (granularity === "day") {
		delete opts.second;
		delete opts.hour;
		delete opts.minute;
		delete opts.timeZoneName;
	}
	if (granularity === "hour") {
		delete opts.minute;
		delete opts.second;
	}
	if (granularity === "minute") delete opts.second;
	return opts;
}
function normalizeDateStep(props) {
	return defu(props?.step, {
		year: 1,
		month: 1,
		day: 1,
		hour: 1,
		minute: 1,
		second: 1,
		millisecond: 1
	});
}
function handleCalendarInitialFocus(calendar$1) {
	const selectedDay = calendar$1.querySelector("[data-selected]");
	if (selectedDay) return selectedDay.focus();
	const today = calendar$1.querySelector("[data-today]");
	if (today) return today.focus();
	const firstDay = calendar$1.querySelector("[data-reka-calendar-day]");
	if (firstDay) return firstDay.focus();
}
function normalizeHourCycle(hourCycle) {
	if (hourCycle === 24) return "h23";
	if (hourCycle === 12) return "h11";
}
function normalizeHour12(hourCycle) {
	if (hourCycle === 24) return false;
	if (hourCycle === 12) return true;
}
function getDaysBetween(start, end$1) {
	const days = [];
	let dCurrent = start.add({ days: 1 });
	const dEnd = end$1;
	while (dCurrent.compare(dEnd) < 0) {
		days.push(dCurrent);
		dCurrent = dCurrent.add({ days: 1 });
	}
	return days;
}
function createMonth(props) {
	const { dateObj, weekStartsOn, fixedWeeks, locale } = props;
	const daysInMonth = getDaysInMonth(dateObj);
	const datesArray = Array.from({ length: daysInMonth }, (_, i$1) => dateObj.set({ day: i$1 + 1 }));
	const firstDayOfMonth = $14e0f24ef4ac5c92$export$a5a3b454ada2268e(dateObj);
	const lastDayOfMonth = $14e0f24ef4ac5c92$export$a2258d9c4118825c(dateObj);
	const lastSunday = getLastFirstDayOfWeek(firstDayOfMonth, weekStartsOn, locale);
	const nextSaturday = getNextLastDayOfWeek(lastDayOfMonth, weekStartsOn, locale);
	const lastMonthDays = getDaysBetween(lastSunday.subtract({ days: 1 }), firstDayOfMonth);
	const nextMonthDays = getDaysBetween(lastDayOfMonth, nextSaturday.add({ days: 1 }));
	const totalDays = lastMonthDays.length + datesArray.length + nextMonthDays.length;
	if (fixedWeeks && totalDays < 42) {
		const extraDays = 42 - totalDays;
		let startFrom = nextMonthDays[nextMonthDays.length - 1];
		if (!startFrom) startFrom = $14e0f24ef4ac5c92$export$a2258d9c4118825c(dateObj);
		const extraDaysArray = Array.from({ length: extraDays }, (_, i$1) => {
			const incr = i$1 + 1;
			return startFrom.add({ days: incr });
		});
		nextMonthDays.push(...extraDaysArray);
	}
	const allDays = lastMonthDays.concat(datesArray, nextMonthDays);
	return {
		value: dateObj,
		cells: allDays,
		rows: chunk(allDays, 7)
	};
}
function createMonths(props) {
	const { numberOfMonths, dateObj,...monthProps } = props;
	const months = [];
	if (!numberOfMonths || numberOfMonths === 1) {
		months.push(createMonth({
			...monthProps,
			dateObj
		}));
		return months;
	}
	months.push(createMonth({
		...monthProps,
		dateObj
	}));
	for (let i$1 = 1; i$1 < numberOfMonths; i$1++) {
		const nextMonth = dateObj.add({ months: i$1 });
		months.push(createMonth({
			...monthProps,
			dateObj: nextMonth
		}));
	}
	return months;
}
function useDateFormatter(initialLocale, opts = {}) {
	const locale = ref(initialLocale);
	function getLocale() {
		return locale.value;
	}
	function setLocale(newLocale) {
		locale.value = newLocale;
	}
	function custom$3(date$1, options$1) {
		return new $fb18d541ea1ad717$export$ad991b66133851cf(locale.value, {
			...opts,
			...options$1
		}).format(date$1);
	}
	function selectedDate(date$1, includeTime = true) {
		if (hasTime(date$1) && includeTime) return custom$3(toDate(date$1), {
			dateStyle: "long",
			timeStyle: "long"
		});
		else return custom$3(toDate(date$1), { dateStyle: "long" });
	}
	function fullMonthAndYear(date$1, options$1 = {}) {
		return new $fb18d541ea1ad717$export$ad991b66133851cf(locale.value, {
			...opts,
			month: "long",
			year: "numeric",
			...options$1
		}).format(date$1);
	}
	function fullMonth(date$1, options$1 = {}) {
		return new $fb18d541ea1ad717$export$ad991b66133851cf(locale.value, {
			...opts,
			month: "long",
			...options$1
		}).format(date$1);
	}
	function getMonths() {
		const defaultDate = $14e0f24ef4ac5c92$export$d0bdf45af03a6ea3($14e0f24ef4ac5c92$export$aa8b41735afcabd2());
		return [
			1,
			2,
			3,
			4,
			5,
			6,
			7,
			8,
			9,
			10,
			11,
			12
		].map((item$4) => ({
			label: fullMonth(toDate(defaultDate.set({ month: item$4 }))),
			value: item$4
		}));
	}
	function fullYear(date$1, options$1 = {}) {
		return new $fb18d541ea1ad717$export$ad991b66133851cf(locale.value, {
			...opts,
			year: "numeric",
			...options$1
		}).format(date$1);
	}
	function toParts(date$1, options$1) {
		if (isZonedDateTime(date$1)) return new $fb18d541ea1ad717$export$ad991b66133851cf(locale.value, {
			...opts,
			...options$1,
			timeZone: date$1.timeZone
		}).formatToParts(toDate(date$1));
		else return new $fb18d541ea1ad717$export$ad991b66133851cf(locale.value, {
			...opts,
			...options$1
		}).formatToParts(toDate(date$1));
	}
	function dayOfWeek(date$1, length = "narrow") {
		return new $fb18d541ea1ad717$export$ad991b66133851cf(locale.value, {
			...opts,
			weekday: length
		}).format(date$1);
	}
	function dayPeriod(date$1) {
		const value = new $fb18d541ea1ad717$export$ad991b66133851cf(locale.value, {
			...opts,
			hour: "numeric",
			minute: "numeric"
		}).formatToParts(date$1).find((p$1) => p$1.type === "dayPeriod")?.value;
		if (value === "PM" || value === "p.m.") return "PM";
		return "AM";
	}
	const defaultPartOptions = {
		year: "numeric",
		month: "numeric",
		day: "numeric",
		hour: "numeric",
		minute: "numeric",
		second: "numeric"
	};
	function part$1(dateObj, type, options$1 = {}) {
		const part$1$1 = toParts(dateObj, {
			...defaultPartOptions,
			...options$1
		}).find((p$1) => p$1.type === type);
		return part$1$1 ? part$1$1.value : "";
	}
	return {
		setLocale,
		getLocale,
		fullMonth,
		fullYear,
		fullMonthAndYear,
		toParts,
		custom: custom$3,
		part: part$1,
		dayPeriod,
		selectedDate,
		dayOfWeek,
		getMonths
	};
}
function useDirection(dir) {
	const context$1 = injectConfigProviderContext({ dir: ref("ltr") });
	return computed(() => dir?.value || context$1.dir?.value || "ltr");
}
function useEmitAsProps(emit) {
	const vm = getCurrentInstance();
	const events = vm?.type.emits;
	const result = {};
	if (!events?.length) console.warn(`No emitted event found. Please check component: ${vm?.type.__name}`);
	events?.forEach((ev) => {
		result[toHandlerKey(camelize(ev))] = (...arg) => emit(ev, ...arg);
	});
	return result;
}
var count$2 = 0;
function useFocusGuards() {
	watchEffect((cleanupFn) => {
		if (!isClient) return;
		const edgeGuards = document.querySelectorAll("[data-reka-focus-guard]");
		document.body.insertAdjacentElement("afterbegin", edgeGuards[0] ?? createFocusGuard());
		document.body.insertAdjacentElement("beforeend", edgeGuards[1] ?? createFocusGuard());
		count$2++;
		cleanupFn(() => {
			if (count$2 === 1) document.querySelectorAll("[data-reka-focus-guard]").forEach((node) => node.remove());
			count$2--;
		});
	});
}
function createFocusGuard() {
	const element = document.createElement("span");
	element.setAttribute("data-reka-focus-guard", "");
	element.tabIndex = 0;
	element.style.outline = "none";
	element.style.opacity = "0";
	element.style.position = "fixed";
	element.style.pointerEvents = "none";
	return element;
}
function useFormControl(el$2) {
	return computed(() => toValue$2(el$2) ? Boolean(unrefElement(el$2)?.closest("form")) : true);
}
function useForwardExpose() {
	const instance = getCurrentInstance();
	const currentRef = ref();
	const currentElement = computed(() => {
		return ["#text", "#comment"].includes(currentRef.value?.$el.nodeName) ? currentRef.value?.$el.nextElementSibling : unrefElement(currentRef);
	});
	const localExpose = Object.assign({}, instance.exposed);
	const ret = {};
	for (const key$2 in instance.props) Object.defineProperty(ret, key$2, {
		enumerable: true,
		configurable: true,
		get: () => instance.props[key$2]
	});
	if (Object.keys(localExpose).length > 0) for (const key$2 in localExpose) Object.defineProperty(ret, key$2, {
		enumerable: true,
		configurable: true,
		get: () => localExpose[key$2]
	});
	Object.defineProperty(ret, "$el", {
		enumerable: true,
		configurable: true,
		get: () => instance.vnode.el
	});
	instance.exposed = ret;
	function forwardRef(ref$1) {
		currentRef.value = ref$1;
		if (!ref$1) return;
		Object.defineProperty(ret, "$el", {
			enumerable: true,
			configurable: true,
			get: () => ref$1 instanceof Element ? ref$1 : ref$1.$el
		});
		instance.exposed = ret;
	}
	return {
		forwardRef,
		currentRef,
		currentElement
	};
}
function useForwardProps(props) {
	const vm = getCurrentInstance();
	const defaultProps = Object.keys(vm?.type.props ?? {}).reduce((prev, curr) => {
		const defaultValue = (vm?.type.props[curr]).default;
		if (defaultValue !== void 0) prev[curr] = defaultValue;
		return prev;
	}, {});
	const refProps = toRef(props);
	return computed(() => {
		const preservedProps = {};
		const assignedProps = vm?.vnode.props ?? {};
		Object.keys(assignedProps).forEach((key$2) => {
			preservedProps[camelize(key$2)] = assignedProps[key$2];
		});
		return Object.keys({
			...defaultProps,
			...preservedProps
		}).reduce((prev, curr) => {
			if (refProps.value[curr] !== void 0) prev[curr] = refProps.value[curr];
			return prev;
		}, {});
	});
}
function useForwardPropsEmits(props, emit) {
	const parsedProps = useForwardProps(props);
	const emitsAsProps = emit ? useEmitAsProps(emit) : {};
	return computed(() => ({
		...parsedProps.value,
		...emitsAsProps
	}));
}
var getDefaultParent = function(originalTarget) {
	if (typeof document === "undefined") return null;
	return (Array.isArray(originalTarget) ? originalTarget[0] : originalTarget).ownerDocument.body;
};
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
var markerMap = {};
var lockCount = 0;
var unwrapHost = function(node) {
	return node && (node.host || unwrapHost(node.parentNode));
};
var correctTargets = function(parent, targets) {
	return targets.map(function(target$1) {
		if (parent.contains(target$1)) return target$1;
		var correctedTarget = unwrapHost(target$1);
		if (correctedTarget && parent.contains(correctedTarget)) return correctedTarget;
		console.error("aria-hidden", target$1, "in not contained inside", parent, ". Doing nothing");
		return null;
	}).filter(function(x$2) {
		return Boolean(x$2);
	});
};
var applyAttributeToOthers = function(originalTarget, parentNode, markerName, controlAttribute) {
	var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
	if (!markerMap[markerName]) markerMap[markerName] = /* @__PURE__ */ new WeakMap();
	var markerCounter = markerMap[markerName];
	var hiddenNodes = [];
	var elementsToKeep = /* @__PURE__ */ new Set();
	var elementsToStop = new Set(targets);
	var keep = function(el$2) {
		if (!el$2 || elementsToKeep.has(el$2)) return;
		elementsToKeep.add(el$2);
		keep(el$2.parentNode);
	};
	targets.forEach(keep);
	var deep = function(parent) {
		if (!parent || elementsToStop.has(parent)) return;
		Array.prototype.forEach.call(parent.children, function(node) {
			if (elementsToKeep.has(node)) deep(node);
			else try {
				var attr = node.getAttribute(controlAttribute);
				var alreadyHidden = attr !== null && attr !== "false";
				var counterValue = (counterMap.get(node) || 0) + 1;
				var markerValue = (markerCounter.get(node) || 0) + 1;
				counterMap.set(node, counterValue);
				markerCounter.set(node, markerValue);
				hiddenNodes.push(node);
				if (counterValue === 1 && alreadyHidden) uncontrolledNodes.set(node, true);
				if (markerValue === 1) node.setAttribute(markerName, "true");
				if (!alreadyHidden) node.setAttribute(controlAttribute, "true");
			} catch (e) {
				console.error("aria-hidden: cannot operate on ", node, e);
			}
		});
	};
	deep(parentNode);
	elementsToKeep.clear();
	lockCount++;
	return function() {
		hiddenNodes.forEach(function(node) {
			var counterValue = counterMap.get(node) - 1;
			var markerValue = markerCounter.get(node) - 1;
			counterMap.set(node, counterValue);
			markerCounter.set(node, markerValue);
			if (!counterValue) {
				if (!uncontrolledNodes.has(node)) node.removeAttribute(controlAttribute);
				uncontrolledNodes.delete(node);
			}
			if (!markerValue) node.removeAttribute(markerName);
		});
		lockCount--;
		if (!lockCount) {
			counterMap = /* @__PURE__ */ new WeakMap();
			counterMap = /* @__PURE__ */ new WeakMap();
			uncontrolledNodes = /* @__PURE__ */ new WeakMap();
			markerMap = {};
		}
	};
};
var hideOthers = function(originalTarget, parentNode, markerName) {
	if (markerName === void 0) markerName = "data-aria-hidden";
	var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
	var activeParentNode = parentNode || getDefaultParent(originalTarget);
	if (!activeParentNode) return function() {
		return null;
	};
	targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live], script")));
	return applyAttributeToOthers(targets, activeParentNode, markerName, "aria-hidden");
};
function useHideOthers(target$1) {
	let undo;
	watch(() => unrefElement(target$1), (el$2) => {
		if (el$2) undo = hideOthers(el$2);
		else if (undo) undo();
	});
	onUnmounted(() => {
		if (undo) undo();
	});
}
var count$1 = 0;
function useId(deterministicId, prefix$1 = "reka") {
	if (deterministicId) return deterministicId;
	if ("useId" in vue_runtime_esm_bundler_exports) return `${prefix$1}-${useId$2?.()}`;
	const configProviderContext = injectConfigProviderContext({ useId: void 0 });
	if (configProviderContext.useId) return `${prefix$1}-${configProviderContext.useId()}`;
	return `${prefix$1}-${++count$1}`;
}
function useKbd() {
	return {
		ALT: "Alt",
		ARROW_DOWN: "ArrowDown",
		ARROW_LEFT: "ArrowLeft",
		ARROW_RIGHT: "ArrowRight",
		ARROW_UP: "ArrowUp",
		BACKSPACE: "Backspace",
		CAPS_LOCK: "CapsLock",
		CONTROL: "Control",
		DELETE: "Delete",
		END: "End",
		ENTER: "Enter",
		ESCAPE: "Escape",
		F1: "F1",
		F10: "F10",
		F11: "F11",
		F12: "F12",
		F2: "F2",
		F3: "F3",
		F4: "F4",
		F5: "F5",
		F6: "F6",
		F7: "F7",
		F8: "F8",
		F9: "F9",
		HOME: "Home",
		META: "Meta",
		PAGE_DOWN: "PageDown",
		PAGE_UP: "PageUp",
		SHIFT: "Shift",
		SPACE: " ",
		TAB: "Tab",
		CTRL: "Control",
		ASTERISK: "*",
		SPACE_CODE: "Space"
	};
}
function useLocale(locale) {
	const context$1 = injectConfigProviderContext({ locale: ref("en") });
	return computed(() => locale?.value || context$1.locale?.value || "en");
}
function useSize(element) {
	const size$2 = ref();
	const width = computed(() => size$2.value?.width ?? 0);
	const height = computed(() => size$2.value?.height ?? 0);
	onMounted(() => {
		const el$2 = unrefElement(element);
		if (el$2) {
			size$2.value = {
				width: el$2.offsetWidth,
				height: el$2.offsetHeight
			};
			const resizeObserver = new ResizeObserver((entries) => {
				if (!Array.isArray(entries)) return;
				if (!entries.length) return;
				const entry = entries[0];
				let width$1;
				let height$1;
				if ("borderBoxSize" in entry) {
					const borderSizeEntry = entry.borderBoxSize;
					const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
					width$1 = borderSize.inlineSize;
					height$1 = borderSize.blockSize;
				} else {
					width$1 = el$2.offsetWidth;
					height$1 = el$2.offsetHeight;
				}
				size$2.value = {
					width: width$1,
					height: height$1
				};
			});
			resizeObserver.observe(el$2, { box: "border-box" });
			return () => resizeObserver.unobserve(el$2);
		} else size$2.value = void 0;
	});
	return {
		width,
		height
	};
}
function useStateMachine(initialState, machine) {
	const state = ref(initialState);
	function reducer(event) {
		return machine[state.value][event] ?? state.value;
	}
	const dispatch = (event) => {
		state.value = reducer(event);
	};
	return {
		state,
		dispatch
	};
}
function useTypeahead(callback) {
	const search = refAutoReset("", 1e3);
	const handleTypeaheadSearch = (key$2, items) => {
		search.value = search.value + key$2;
		if (callback) callback(key$2);
		else {
			const currentItem = getActiveElement();
			const itemsWithTextValue = items.map((item$4) => ({
				...item$4,
				textValue: item$4.value?.textValue ?? item$4.ref.textContent?.trim() ?? ""
			}));
			const currentMatch = itemsWithTextValue.find((item$4) => item$4.ref === currentItem);
			const nextMatch = getNextMatch(itemsWithTextValue.map((item$4) => item$4.textValue), search.value, currentMatch?.textValue);
			const newItem = itemsWithTextValue.find((item$4) => item$4.textValue === nextMatch);
			if (newItem) newItem.ref.focus();
			return newItem?.ref;
		}
	};
	const resetTypeahead = () => {
		search.value = "";
	};
	return {
		search,
		handleTypeaheadSearch,
		resetTypeahead
	};
}
function wrapArray(array, startIndex) {
	return array.map((_, index) => array[(startIndex + index) % array.length]);
}
function getNextMatch(values, search, currentMatch) {
	const normalizedSearch = search.length > 1 && Array.from(search).every((char) => char === search[0]) ? search[0] : search;
	const currentMatchIndex = currentMatch ? values.indexOf(currentMatch) : -1;
	let wrappedValues = wrapArray(values, Math.max(currentMatchIndex, 0));
	if (normalizedSearch.length === 1) wrappedValues = wrappedValues.filter((v$1) => v$1 !== currentMatch);
	const nextMatch = wrappedValues.find((value) => value.toLowerCase().startsWith(normalizedSearch.toLowerCase()));
	return nextMatch !== currentMatch ? nextMatch : void 0;
}
function usePresence(present, node) {
	const stylesRef = ref({});
	const prevAnimationNameRef = ref("none");
	const prevPresentRef = ref(present);
	const initialState = present.value ? "mounted" : "unmounted";
	let timeoutId;
	const ownerWindow = node.value?.ownerDocument.defaultView ?? defaultWindow;
	const { state, dispatch } = useStateMachine(initialState, {
		mounted: {
			UNMOUNT: "unmounted",
			ANIMATION_OUT: "unmountSuspended"
		},
		unmountSuspended: {
			MOUNT: "mounted",
			ANIMATION_END: "unmounted"
		},
		unmounted: { MOUNT: "mounted" }
	});
	const dispatchCustomEvent = (name$1) => {
		if (isClient) {
			const customEvent = new CustomEvent(name$1, {
				bubbles: false,
				cancelable: false
			});
			node.value?.dispatchEvent(customEvent);
		}
	};
	watch(present, async (currentPresent, prevPresent) => {
		const hasPresentChanged = prevPresent !== currentPresent;
		await nextTick();
		if (hasPresentChanged) {
			const prevAnimationName = prevAnimationNameRef.value;
			const currentAnimationName = getAnimationName(node.value);
			if (currentPresent) {
				dispatch("MOUNT");
				dispatchCustomEvent("enter");
				if (currentAnimationName === "none") dispatchCustomEvent("after-enter");
			} else if (currentAnimationName === "none" || currentAnimationName === "undefined" || stylesRef.value?.display === "none") {
				dispatch("UNMOUNT");
				dispatchCustomEvent("leave");
				dispatchCustomEvent("after-leave");
			} else if (prevPresent && prevAnimationName !== currentAnimationName) {
				dispatch("ANIMATION_OUT");
				dispatchCustomEvent("leave");
			} else {
				dispatch("UNMOUNT");
				dispatchCustomEvent("after-leave");
			}
		}
	}, { immediate: true });
	const handleAnimationEnd = (event) => {
		const currentAnimationName = getAnimationName(node.value);
		const isCurrentAnimation = currentAnimationName.includes(event.animationName);
		const directionName = state.value === "mounted" ? "enter" : "leave";
		if (event.target === node.value && isCurrentAnimation) {
			dispatchCustomEvent(`after-${directionName}`);
			dispatch("ANIMATION_END");
			if (!prevPresentRef.value) {
				const currentFillMode = node.value.style.animationFillMode;
				node.value.style.animationFillMode = "forwards";
				timeoutId = ownerWindow?.setTimeout(() => {
					if (node.value?.style.animationFillMode === "forwards") node.value.style.animationFillMode = currentFillMode;
				});
			}
		}
		if (event.target === node.value && currentAnimationName === "none") dispatch("ANIMATION_END");
	};
	const handleAnimationStart = (event) => {
		if (event.target === node.value) prevAnimationNameRef.value = getAnimationName(node.value);
	};
	const watcher = watch(node, (newNode, oldNode) => {
		if (newNode) {
			stylesRef.value = getComputedStyle(newNode);
			newNode.addEventListener("animationstart", handleAnimationStart);
			newNode.addEventListener("animationcancel", handleAnimationEnd);
			newNode.addEventListener("animationend", handleAnimationEnd);
		} else {
			dispatch("ANIMATION_END");
			if (timeoutId !== void 0) ownerWindow?.clearTimeout(timeoutId);
			oldNode?.removeEventListener("animationstart", handleAnimationStart);
			oldNode?.removeEventListener("animationcancel", handleAnimationEnd);
			oldNode?.removeEventListener("animationend", handleAnimationEnd);
		}
	}, { immediate: true });
	const stateWatcher = watch(state, () => {
		const currentAnimationName = getAnimationName(node.value);
		prevAnimationNameRef.value = state.value === "mounted" ? currentAnimationName : "none";
	});
	onUnmounted(() => {
		watcher();
		stateWatcher();
	});
	return { isPresent: computed(() => ["mounted", "unmountSuspended"].includes(state.value)) };
}
function getAnimationName(node) {
	return node ? getComputedStyle(node).animationName || "none" : "none";
}
var Presence_default = defineComponent({
	name: "Presence",
	props: {
		present: {
			type: Boolean,
			required: true
		},
		forceMount: { type: Boolean }
	},
	slots: {},
	setup(props, { slots, expose }) {
		const { present, forceMount } = toRefs(props);
		const node = ref();
		const { isPresent } = usePresence(present, node);
		expose({ present: isPresent });
		let children = slots.default({ present: isPresent.value });
		children = renderSlotFragments(children || []);
		const instance = getCurrentInstance();
		if (children && children?.length > 1) {
			const componentName$1 = instance?.parent?.type.name ? `<${instance.parent.type.name} />` : "component";
			throw new Error([
				`Detected an invalid children for \`${componentName$1}\` for  \`Presence\` component.`,
				"",
				"Note: Presence works similarly to `v-if` directly, but it waits for animation/transition to finished before unmounting. So it expect only one direct child of valid VNode type.",
				"You can apply a few solutions:",
				["Provide a single child element so that `presence` directive attach correctly.", "Ensure the first child is an actual element instead of a raw text node or comment node."].map((line) => `  - ${line}`).join("\n")
			].join("\n"));
		}
		return () => {
			if (forceMount.value || present.value || isPresent.value) return h(slots.default({ present: isPresent.value })[0], { ref: (v$1) => {
				const el$2 = unrefElement(v$1);
				if (typeof el$2?.hasAttribute === "undefined") return el$2;
				if (el$2?.hasAttribute("data-reka-popper-content-wrapper")) node.value = el$2.firstElementChild;
				else node.value = el$2;
				return el$2;
			} });
			else return null;
		};
	}
});
var Slot = defineComponent({
	name: "PrimitiveSlot",
	inheritAttrs: false,
	setup(_, { attrs, slots }) {
		return () => {
			if (!slots.default) return null;
			const children = renderSlotFragments(slots.default());
			const firstNonCommentChildrenIndex = children.findIndex((child$1) => child$1.type !== Comment);
			if (firstNonCommentChildrenIndex === -1) return children;
			const firstNonCommentChildren = children[firstNonCommentChildrenIndex];
			delete firstNonCommentChildren.props?.ref;
			const mergedProps = firstNonCommentChildren.props ? mergeProps(attrs, firstNonCommentChildren.props) : attrs;
			const cloned = cloneVNode({
				...firstNonCommentChildren,
				props: {}
			}, mergedProps);
			if (children.length === 1) return cloned;
			children[firstNonCommentChildrenIndex] = cloned;
			return children;
		};
	}
});
var SELF_CLOSING_TAGS = [
	"area",
	"img",
	"input"
];
var Primitive = defineComponent({
	name: "Primitive",
	inheritAttrs: false,
	props: {
		asChild: {
			type: Boolean,
			default: false
		},
		as: {
			type: [String, Object],
			default: "div"
		}
	},
	setup(props, { attrs, slots }) {
		const asTag = props.asChild ? "template" : props.as;
		if (typeof asTag === "string" && SELF_CLOSING_TAGS.includes(asTag)) return () => h(asTag, attrs);
		if (asTag !== "template") return () => h(props.as, attrs, { default: slots.default });
		return () => h(Slot, attrs, { default: slots.default });
	}
});
function usePrimitiveElement() {
	const primitiveElement = ref();
	return {
		primitiveElement,
		currentElement: computed(() => ["#text", "#comment"].includes(primitiveElement.value?.$el.nodeName) ? primitiveElement.value?.$el.nextElementSibling : unrefElement(primitiveElement))
	};
}
var POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside";
var FOCUS_OUTSIDE = "dismissableLayer.focusOutside";
function isLayerExist(layerElement, targetElement) {
	const targetLayer = targetElement.closest("[data-dismissable-layer]");
	const mainLayer = layerElement.dataset.dismissableLayer === "" ? layerElement : layerElement.querySelector("[data-dismissable-layer]");
	const nodeList$1 = Array.from(layerElement.ownerDocument.querySelectorAll("[data-dismissable-layer]"));
	if (targetLayer && (mainLayer === targetLayer || nodeList$1.indexOf(mainLayer) < nodeList$1.indexOf(targetLayer))) return true;
	else return false;
}
function usePointerDownOutside(onPointerDownOutside, element, enabled = true) {
	const ownerDocument = element?.value?.ownerDocument ?? globalThis?.document;
	const isPointerInsideDOMTree = ref(false);
	const handleClickRef = ref(() => {});
	watchEffect((cleanupFn) => {
		if (!isClient || !toValue$1(enabled)) return;
		const handlePointerDown = async (event) => {
			const target$1 = event.target;
			if (!element?.value || !target$1) return;
			if (isLayerExist(element.value, target$1)) {
				isPointerInsideDOMTree.value = false;
				return;
			}
			if (event.target && !isPointerInsideDOMTree.value) {
				const eventDetail = { originalEvent: event };
				function handleAndDispatchPointerDownOutsideEvent() {
					handleAndDispatchCustomEvent(POINTER_DOWN_OUTSIDE, onPointerDownOutside, eventDetail);
				}
				if (event.pointerType === "touch") {
					ownerDocument.removeEventListener("click", handleClickRef.value);
					handleClickRef.value = handleAndDispatchPointerDownOutsideEvent;
					ownerDocument.addEventListener("click", handleClickRef.value, { once: true });
				} else handleAndDispatchPointerDownOutsideEvent();
			} else ownerDocument.removeEventListener("click", handleClickRef.value);
			isPointerInsideDOMTree.value = false;
		};
		const timerId = window.setTimeout(() => {
			ownerDocument.addEventListener("pointerdown", handlePointerDown);
		}, 0);
		cleanupFn(() => {
			window.clearTimeout(timerId);
			ownerDocument.removeEventListener("pointerdown", handlePointerDown);
			ownerDocument.removeEventListener("click", handleClickRef.value);
		});
	});
	return { onPointerDownCapture: () => {
		if (!toValue$1(enabled)) return;
		isPointerInsideDOMTree.value = true;
	} };
}
function useFocusOutside(onFocusOutside, element, enabled = true) {
	const ownerDocument = element?.value?.ownerDocument ?? globalThis?.document;
	const isFocusInsideDOMTree = ref(false);
	watchEffect((cleanupFn) => {
		if (!isClient || !toValue$1(enabled)) return;
		const handleFocus = async (event) => {
			if (!element?.value) return;
			await nextTick();
			await nextTick();
			const target$1 = event.target;
			if (!element.value || !target$1 || isLayerExist(element.value, target$1)) return;
			if (event.target && !isFocusInsideDOMTree.value) handleAndDispatchCustomEvent(FOCUS_OUTSIDE, onFocusOutside, { originalEvent: event });
		};
		ownerDocument.addEventListener("focusin", handleFocus);
		cleanupFn(() => ownerDocument.removeEventListener("focusin", handleFocus));
	});
	return {
		onFocusCapture: () => {
			if (!toValue$1(enabled)) return;
			isFocusInsideDOMTree.value = true;
		},
		onBlurCapture: () => {
			if (!toValue$1(enabled)) return;
			isFocusInsideDOMTree.value = false;
		}
	};
}
var context = reactive({
	layersRoot: /* @__PURE__ */ new Set(),
	layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
	branches: /* @__PURE__ */ new Set()
});
var DismissableLayer_default = /* @__PURE__ */ defineComponent({
	__name: "DismissableLayer",
	props: {
		disableOutsidePointerEvents: {
			type: Boolean,
			required: false,
			default: false
		},
		asChild: {
			type: Boolean,
			required: false
		},
		as: {
			type: null,
			required: false
		}
	},
	emits: [
		"escapeKeyDown",
		"pointerDownOutside",
		"focusOutside",
		"interactOutside",
		"dismiss"
	],
	setup(__props, { emit: __emit }) {
		const props = __props;
		const emits = __emit;
		const { forwardRef, currentElement: layerElement } = useForwardExpose();
		const ownerDocument = computed(() => layerElement.value?.ownerDocument ?? globalThis.document);
		const layers = computed(() => context.layersRoot);
		const index = computed(() => {
			return layerElement.value ? Array.from(layers.value).indexOf(layerElement.value) : -1;
		});
		const isBodyPointerEventsDisabled = computed(() => {
			return context.layersWithOutsidePointerEventsDisabled.size > 0;
		});
		const isPointerEventsEnabled = computed(() => {
			const localLayers = Array.from(layers.value);
			const [highestLayerWithOutsidePointerEventsDisabled] = [...context.layersWithOutsidePointerEventsDisabled].slice(-1);
			const highestLayerWithOutsidePointerEventsDisabledIndex = localLayers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
			return index.value >= highestLayerWithOutsidePointerEventsDisabledIndex;
		});
		const pointerDownOutside = usePointerDownOutside(async (event) => {
			const isPointerDownOnBranch = [...context.branches].some((branch) => branch?.contains(event.target));
			if (!isPointerEventsEnabled.value || isPointerDownOnBranch) return;
			emits("pointerDownOutside", event);
			emits("interactOutside", event);
			await nextTick();
			if (!event.defaultPrevented) emits("dismiss");
		}, layerElement);
		const focusOutside = useFocusOutside((event) => {
			if ([...context.branches].some((branch) => branch?.contains(event.target))) return;
			emits("focusOutside", event);
			emits("interactOutside", event);
			if (!event.defaultPrevented) emits("dismiss");
		}, layerElement);
		onKeyStroke("Escape", (event) => {
			if (!(index.value === layers.value.size - 1)) return;
			emits("escapeKeyDown", event);
			if (!event.defaultPrevented) emits("dismiss");
		});
		let originalBodyPointerEvents;
		watchEffect((cleanupFn) => {
			if (!layerElement.value) return;
			if (props.disableOutsidePointerEvents) {
				if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
					originalBodyPointerEvents = ownerDocument.value.body.style.pointerEvents;
					ownerDocument.value.body.style.pointerEvents = "none";
				}
				context.layersWithOutsidePointerEventsDisabled.add(layerElement.value);
			}
			layers.value.add(layerElement.value);
			cleanupFn(() => {
				if (props.disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1) ownerDocument.value.body.style.pointerEvents = originalBodyPointerEvents;
			});
		});
		watchEffect((cleanupFn) => {
			cleanupFn(() => {
				if (!layerElement.value) return;
				layers.value.delete(layerElement.value);
				context.layersWithOutsidePointerEventsDisabled.delete(layerElement.value);
			});
		});
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(Primitive), {
				ref: unref(forwardRef),
				"as-child": _ctx.asChild,
				as: _ctx.as,
				"data-dismissable-layer": "",
				style: normalizeStyle({ pointerEvents: isBodyPointerEventsDisabled.value ? isPointerEventsEnabled.value ? "auto" : "none" : void 0 }),
				onFocusCapture: unref(focusOutside).onFocusCapture,
				onBlurCapture: unref(focusOutside).onBlurCapture,
				onPointerdownCapture: unref(pointerDownOutside).onPointerDownCapture
			}, {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 8, [
				"as-child",
				"as",
				"style",
				"onFocusCapture",
				"onBlurCapture",
				"onPointerdownCapture"
			]);
		};
	}
});
var useFocusStackState = createGlobalState(() => {
	return ref([]);
});
function createFocusScopesStack() {
	const stack = useFocusStackState();
	return {
		add(focusScope) {
			const activeFocusScope = stack.value[0];
			if (focusScope !== activeFocusScope) activeFocusScope?.pause();
			stack.value = arrayRemove(stack.value, focusScope);
			stack.value.unshift(focusScope);
		},
		remove(focusScope) {
			stack.value = arrayRemove(stack.value, focusScope);
			stack.value[0]?.resume();
		}
	};
}
function arrayRemove(array, item$4) {
	const updatedArray = [...array];
	const index = updatedArray.indexOf(item$4);
	if (index !== -1) updatedArray.splice(index, 1);
	return updatedArray;
}
function removeLinks(items) {
	return items.filter((item$4) => item$4.tagName !== "A");
}
var AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount";
var AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount";
var EVENT_OPTIONS = {
	bubbles: false,
	cancelable: true
};
function focusFirst$1(candidates, { select = false } = {}) {
	const previouslyFocusedElement = getActiveElement();
	for (const candidate of candidates) {
		focus(candidate, { select });
		if (getActiveElement() !== previouslyFocusedElement) return true;
	}
}
function getTabbableEdges(container$18) {
	const candidates = getTabbableCandidates(container$18);
	return [findVisible(candidates, container$18), findVisible(candidates.reverse(), container$18)];
}
function getTabbableCandidates(container$18) {
	const nodes = [];
	const walker = document.createTreeWalker(container$18, NodeFilter.SHOW_ELEMENT, { acceptNode: (node) => {
		const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
		if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;
		return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
	} });
	while (walker.nextNode()) nodes.push(walker.currentNode);
	return nodes;
}
function findVisible(elements, container$18) {
	for (const element of elements) if (!isHidden(element, { upTo: container$18 })) return element;
}
function isHidden(node, { upTo }) {
	if (getComputedStyle(node).visibility === "hidden") return true;
	while (node) {
		if (upTo !== void 0 && node === upTo) return false;
		if (getComputedStyle(node).display === "none") return true;
		node = node.parentElement;
	}
	return false;
}
function isSelectableInput(element) {
	return element instanceof HTMLInputElement && "select" in element;
}
function focus(element, { select = false } = {}) {
	if (element && element.focus) {
		const previouslyFocusedElement = getActiveElement();
		element.focus({ preventScroll: true });
		if (element !== previouslyFocusedElement && isSelectableInput(element) && select) element.select();
	}
}
var FocusScope_default = /* @__PURE__ */ defineComponent({
	__name: "FocusScope",
	props: {
		loop: {
			type: Boolean,
			required: false,
			default: false
		},
		trapped: {
			type: Boolean,
			required: false,
			default: false
		},
		asChild: {
			type: Boolean,
			required: false
		},
		as: {
			type: null,
			required: false
		}
	},
	emits: ["mountAutoFocus", "unmountAutoFocus"],
	setup(__props, { emit: __emit }) {
		const props = __props;
		const emits = __emit;
		const { currentRef, currentElement } = useForwardExpose();
		const lastFocusedElementRef = ref(null);
		const focusScopesStack = createFocusScopesStack();
		const focusScope = reactive({
			paused: false,
			pause() {
				this.paused = true;
			},
			resume() {
				this.paused = false;
			}
		});
		watchEffect((cleanupFn) => {
			if (!isClient) return;
			const container$18 = currentElement.value;
			if (!props.trapped) return;
			function handleFocusIn(event) {
				if (focusScope.paused || !container$18) return;
				const target$1 = event.target;
				if (container$18.contains(target$1)) lastFocusedElementRef.value = target$1;
				else focus(lastFocusedElementRef.value, { select: true });
			}
			function handleFocusOut(event) {
				if (focusScope.paused || !container$18) return;
				const relatedTarget = event.relatedTarget;
				if (relatedTarget === null) return;
				if (!container$18.contains(relatedTarget)) focus(lastFocusedElementRef.value, { select: true });
			}
			function handleMutations(mutations) {
				if (!container$18.contains(lastFocusedElementRef.value)) focus(container$18);
			}
			document.addEventListener("focusin", handleFocusIn);
			document.addEventListener("focusout", handleFocusOut);
			const mutationObserver = new MutationObserver(handleMutations);
			if (container$18) mutationObserver.observe(container$18, {
				childList: true,
				subtree: true
			});
			cleanupFn(() => {
				document.removeEventListener("focusin", handleFocusIn);
				document.removeEventListener("focusout", handleFocusOut);
				mutationObserver.disconnect();
			});
		});
		watchEffect(async (cleanupFn) => {
			const container$18 = currentElement.value;
			await nextTick();
			if (!container$18) return;
			focusScopesStack.add(focusScope);
			const previouslyFocusedElement = getActiveElement();
			if (!container$18.contains(previouslyFocusedElement)) {
				const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);
				container$18.addEventListener(AUTOFOCUS_ON_MOUNT, (ev) => emits("mountAutoFocus", ev));
				container$18.dispatchEvent(mountEvent);
				if (!mountEvent.defaultPrevented) {
					focusFirst$1(removeLinks(getTabbableCandidates(container$18)), { select: true });
					if (getActiveElement() === previouslyFocusedElement) focus(container$18);
				}
			}
			cleanupFn(() => {
				container$18.removeEventListener(AUTOFOCUS_ON_MOUNT, (ev) => emits("mountAutoFocus", ev));
				const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS);
				const unmountEventHandler = (ev) => {
					emits("unmountAutoFocus", ev);
				};
				container$18.addEventListener(AUTOFOCUS_ON_UNMOUNT, unmountEventHandler);
				container$18.dispatchEvent(unmountEvent);
				setTimeout(() => {
					if (!unmountEvent.defaultPrevented) focus(previouslyFocusedElement ?? document.body, { select: true });
					container$18.removeEventListener(AUTOFOCUS_ON_UNMOUNT, unmountEventHandler);
					focusScopesStack.remove(focusScope);
				}, 0);
			});
		});
		function handleKeyDown(event) {
			if (!props.loop && !props.trapped) return;
			if (focusScope.paused) return;
			const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
			const focusedElement = getActiveElement();
			if (isTabKey && focusedElement) {
				const container$18 = event.currentTarget;
				const [first, last] = getTabbableEdges(container$18);
				if (!(first && last)) {
					if (focusedElement === container$18) event.preventDefault();
				} else if (!event.shiftKey && focusedElement === last) {
					event.preventDefault();
					if (props.loop) focus(first, { select: true });
				} else if (event.shiftKey && focusedElement === first) {
					event.preventDefault();
					if (props.loop) focus(last, { select: true });
				}
			}
		}
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(Primitive), {
				ref_key: "currentRef",
				ref: currentRef,
				tabindex: "-1",
				"as-child": _ctx.asChild,
				as: _ctx.as,
				onKeydown: handleKeyDown
			}, {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 8, ["as-child", "as"]);
		};
	}
});
var SELECTION_KEYS$1 = ["Enter", " "];
var FIRST_KEYS = [
	"ArrowDown",
	"PageUp",
	"Home"
];
var LAST_KEYS = [
	"ArrowUp",
	"PageDown",
	"End"
];
[...FIRST_KEYS, ...LAST_KEYS];
[...SELECTION_KEYS$1], [...SELECTION_KEYS$1];
function focusFirst(candidates) {
	const PREVIOUSLY_FOCUSED_ELEMENT = getActiveElement();
	for (const candidate of candidates) {
		if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;
		candidate.focus();
		if (getActiveElement() !== PREVIOUSLY_FOCUSED_ELEMENT) return;
	}
}
var Teleport_default = /* @__PURE__ */ defineComponent({
	__name: "Teleport",
	props: {
		to: {
			type: null,
			required: false,
			default: "body"
		},
		disabled: {
			type: Boolean,
			required: false
		},
		defer: {
			type: Boolean,
			required: false
		},
		forceMount: {
			type: Boolean,
			required: false
		}
	},
	setup(__props) {
		const isMounted = useMounted();
		return (_ctx, _cache) => {
			return unref(isMounted) || _ctx.forceMount ? (openBlock(), createBlock(Teleport, {
				key: 0,
				to: _ctx.to,
				disabled: _ctx.disabled,
				defer: _ctx.defer
			}, [renderSlot(_ctx.$slots, "default")], 8, [
				"to",
				"disabled",
				"defer"
			])) : createCommentVNode("v-if", true);
		};
	}
});
var DATE_SEGMENT_PARTS = [
	"day",
	"month",
	"year"
];
var TIME_SEGMENT_PARTS = [
	"hour",
	"minute",
	"second",
	"dayPeriod"
];
var NON_EDITABLE_SEGMENT_PARTS = ["literal", "timeZoneName"];
var EDITABLE_SEGMENT_PARTS = [...DATE_SEGMENT_PARTS, ...TIME_SEGMENT_PARTS];
[...TIME_SEGMENT_PARTS];
[...EDITABLE_SEGMENT_PARTS, ...NON_EDITABLE_SEGMENT_PARTS].filter((part$1) => part$1 !== "literal");
function isDateSegmentPart(part$1) {
	return DATE_SEGMENT_PARTS.includes(part$1);
}
function isSegmentPart(part$1) {
	return EDITABLE_SEGMENT_PARTS.includes(part$1);
}
var supportedLocales = [
	"ach",
	"af",
	"am",
	"an",
	"ar",
	"ast",
	"az",
	"be",
	"bg",
	"bn",
	"br",
	"bs",
	"ca",
	"cak",
	"ckb",
	"cs",
	"cy",
	"da",
	"de",
	"dsb",
	"el",
	"en",
	"eo",
	"es",
	"et",
	"eu",
	"fa",
	"ff",
	"fi",
	"fr",
	"fy",
	"ga",
	"gd",
	"gl",
	"he",
	"hr",
	"hsb",
	"hu",
	"ia",
	"id",
	"it",
	"ja",
	"ka",
	"kk",
	"kn",
	"ko",
	"lb",
	"lo",
	"lt",
	"lv",
	"meh",
	"ml",
	"ms",
	"nl",
	"nn",
	"no",
	"oc",
	"pl",
	"pt",
	"rm",
	"ro",
	"ru",
	"sc",
	"scn",
	"sk",
	"sl",
	"sr",
	"sv",
	"szl",
	"tg",
	"th",
	"tr",
	"uk",
	"zh-CN",
	"zh-TW"
];
var placeholderFields = [
	"year",
	"month",
	"day"
];
var placeholders = {
	"ach": {
		year: "mwaka",
		month: "dwe",
		day: "nino"
	},
	"af": {
		year: "jjjj",
		month: "mm",
		day: "dd"
	},
	"am": {
		year: "",
		month: "",
		day: ""
	},
	"an": {
		year: "aaaa",
		month: "mm",
		day: "dd"
	},
	"ar": {
		year: "",
		month: "",
		day: ""
	},
	"ast": {
		year: "aaaa",
		month: "mm",
		day: "dd"
	},
	"az": {
		year: "iiii",
		month: "aa",
		day: "gg"
	},
	"be": {
		year: "",
		month: "",
		day: ""
	},
	"bg": {
		year: "",
		month: "",
		day: ""
	},
	"bn": {
		year: "yyyy",
		month: "",
		day: "dd"
	},
	"br": {
		year: "bbbb",
		month: "mm",
		day: "dd"
	},
	"bs": {
		year: "gggg",
		month: "mm",
		day: "dd"
	},
	"ca": {
		year: "aaaa",
		month: "mm",
		day: "dd"
	},
	"cak": {
		year: "jjjj",
		month: "ii",
		day: "q'q'"
	},
	"ckb": {
		year: "",
		month: "",
		day: ""
	},
	"cs": {
		year: "rrrr",
		month: "mm",
		day: "dd"
	},
	"cy": {
		year: "bbbb",
		month: "mm",
		day: "dd"
	},
	"da": {
		year: "",
		month: "mm",
		day: "dd"
	},
	"de": {
		year: "jjjj",
		month: "mm",
		day: "tt"
	},
	"dsb": {
		year: "llll",
		month: "mm",
		day: ""
	},
	"el": {
		year: "",
		month: "",
		day: ""
	},
	"en": {
		year: "yyyy",
		month: "mm",
		day: "dd"
	},
	"eo": {
		year: "jjjj",
		month: "mm",
		day: "tt"
	},
	"es": {
		year: "aaaa",
		month: "mm",
		day: "dd"
	},
	"et": {
		year: "aaaa",
		month: "kk",
		day: "pp"
	},
	"eu": {
		year: "uuuu",
		month: "hh",
		day: "ee"
	},
	"fa": {
		year: "",
		month: "",
		day: ""
	},
	"ff": {
		year: "hhhh",
		month: "ll",
		day: ""
	},
	"fi": {
		year: "vvvv",
		month: "kk",
		day: "pp"
	},
	"fr": {
		year: "aaaa",
		month: "mm",
		day: "jj"
	},
	"fy": {
		year: "jjjj",
		month: "mm",
		day: "dd"
	},
	"ga": {
		year: "bbbb",
		month: "mm",
		day: "ll"
	},
	"gd": {
		year: "bbbb",
		month: "mm",
		day: "ll"
	},
	"gl": {
		year: "aaaa",
		month: "mm",
		day: "dd"
	},
	"he": {
		year: "",
		month: "",
		day: ""
	},
	"hr": {
		year: "gggg",
		month: "mm",
		day: "dd"
	},
	"hsb": {
		year: "llll",
		month: "mm",
		day: "dd"
	},
	"hu": {
		year: "",
		month: "hh",
		day: "nn"
	},
	"ia": {
		year: "aaaa",
		month: "mm",
		day: "dd"
	},
	"id": {
		year: "tttt",
		month: "bb",
		day: "hh"
	},
	"it": {
		year: "aaaa",
		month: "mm",
		day: "gg"
	},
	"ja": {
		year: "  ",
		month: "",
		day: ""
	},
	"ka": {
		year: "",
		month: "",
		day: ""
	},
	"kk": {
		year: "",
		month: "",
		day: ""
	},
	"kn": {
		year: "",
		month: "",
		day: ""
	},
	"ko": {
		year: "",
		month: "",
		day: ""
	},
	"lb": {
		year: "jjjj",
		month: "mm",
		day: "dd"
	},
	"lo": {
		year: "",
		month: "",
		day: ""
	},
	"lt": {
		year: "mmmm",
		month: "mm",
		day: "dd"
	},
	"lv": {
		year: "gggg",
		month: "mm",
		day: "dd"
	},
	"meh": {
		year: "aaaa",
		month: "mm",
		day: "dd"
	},
	"ml": {
		year: "",
		month: "",
		day: ""
	},
	"ms": {
		year: "tttt",
		month: "mm",
		day: "hh"
	},
	"nl": {
		year: "jjjj",
		month: "mm",
		day: "dd"
	},
	"nn": {
		year: "",
		month: "mm",
		day: "dd"
	},
	"no": {
		year: "",
		month: "mm",
		day: "dd"
	},
	"oc": {
		year: "aaaa",
		month: "mm",
		day: "jj"
	},
	"pl": {
		year: "rrrr",
		month: "mm",
		day: "dd"
	},
	"pt": {
		year: "aaaa",
		month: "mm",
		day: "dd"
	},
	"rm": {
		year: "oooo",
		month: "mm",
		day: "dd"
	},
	"ro": {
		year: "aaaa",
		month: "ll",
		day: "zz"
	},
	"ru": {
		year: "",
		month: "",
		day: ""
	},
	"sc": {
		year: "aaaa",
		month: "mm",
		day: "dd"
	},
	"scn": {
		year: "aaaa",
		month: "mm",
		day: "jj"
	},
	"sk": {
		year: "rrrr",
		month: "mm",
		day: "dd"
	},
	"sl": {
		year: "llll",
		month: "mm",
		day: "dd"
	},
	"sr": {
		year: "",
		month: "",
		day: ""
	},
	"sv": {
		year: "",
		month: "mm",
		day: "dd"
	},
	"szl": {
		year: "rrrr",
		month: "mm",
		day: "dd"
	},
	"tg": {
		year: "",
		month: "",
		day: ""
	},
	"th": {
		year: "",
		month: "",
		day: ""
	},
	"tr": {
		year: "yyyy",
		month: "aa",
		day: "gg"
	},
	"uk": {
		year: "",
		month: "",
		day: ""
	},
	"zh-CN": {
		year: "",
		month: "",
		day: ""
	},
	"zh-TW": {
		year: "",
		month: "",
		day: ""
	}
};
function getPlaceholderObj(locale) {
	if (!isSupportedLocale(locale)) {
		const localeLanguage = getLocaleLanguage(locale);
		if (!isSupportedLocale(localeLanguage)) return placeholders.en;
		else return placeholders[localeLanguage];
	} else return placeholders[locale];
}
function getPlaceholder(field, value, locale) {
	if (isPlaceholderField(field)) return getPlaceholderObj(locale)[field];
	if (isDefaultField(field)) return value;
	if (isTimeField(field)) return "";
	return "";
}
function isSupportedLocale(locale) {
	return supportedLocales.includes(locale);
}
function isPlaceholderField(field) {
	return placeholderFields.includes(field);
}
function isTimeField(field) {
	return field === "hour" || field === "minute" || field === "second";
}
function isDefaultField(field) {
	return field === "era" || field === "dayPeriod";
}
function getLocaleLanguage(locale) {
	if (Intl.Locale) return new Intl.Locale(locale).language;
	return locale.split("-")[0];
}
var calendarDateTimeGranularities = [
	"hour",
	"minute",
	"second"
];
function syncTimeSegmentValues(props) {
	return Object.fromEntries(TIME_SEGMENT_PARTS.map((part$1) => {
		if (part$1 === "dayPeriod") return [part$1, props.formatter.dayPeriod(toDate(props.value))];
		return [part$1, props.value[part$1]];
	}));
}
function syncSegmentValues(props) {
	const { formatter } = props;
	const dateValues = DATE_SEGMENT_PARTS.map((part$1) => {
		return [part$1, props.value[part$1]];
	});
	if ("hour" in props.value) {
		const timeValues = syncTimeSegmentValues({
			value: props.value,
			formatter
		});
		return {
			...Object.fromEntries(dateValues),
			...timeValues
		};
	}
	return Object.fromEntries(dateValues);
}
function initializeSegmentValues(granularity) {
	const initialParts = EDITABLE_SEGMENT_PARTS.map((part$1) => {
		if (part$1 === "dayPeriod") return [part$1, "AM"];
		return [part$1, null];
	}).filter(([key$2]) => {
		if (key$2 === "literal" || key$2 === null) return false;
		if (granularity === "minute" && key$2 === "second") return false;
		if (granularity === "hour" && (key$2 === "second" || key$2 === "minute")) return false;
		if (granularity === "day") return !calendarDateTimeGranularities.includes(key$2) && key$2 !== "dayPeriod";
		else return true;
	});
	return Object.fromEntries(initialParts);
}
function createContentObj(props) {
	const { segmentValues, formatter, locale } = props;
	function getPartContent(part$1) {
		if ("hour" in segmentValues) {
			const value = segmentValues[part$1];
			if (value !== null) {
				if (part$1 === "day") return formatter.part(props.dateRef.set({
					[part$1]: value,
					month: segmentValues.month ?? 1
				}), part$1, { hourCycle: normalizeHourCycle(props.hourCycle) });
				return formatter.part(props.dateRef.set({ [part$1]: value }), part$1, { hourCycle: normalizeHourCycle(props.hourCycle) });
			} else return getPlaceholder(part$1, "", locale.value);
		} else {
			if (isDateSegmentPart(part$1)) {
				const value = segmentValues[part$1];
				if (value !== null) {
					if (part$1 === "day") return formatter.part(props.dateRef.set({
						[part$1]: value,
						month: segmentValues.month ?? 1
					}), part$1);
					return formatter.part(props.dateRef.set({ [part$1]: value }), part$1);
				} else return getPlaceholder(part$1, "", locale.value);
			}
			return "";
		}
	}
	return Object.keys(segmentValues).reduce((obj, part$1) => {
		if (!isSegmentPart(part$1)) return obj;
		if ("hour" in segmentValues && part$1 === "dayPeriod") {
			const value = segmentValues[part$1];
			if (value !== null) obj[part$1] = value;
			else obj[part$1] = getPlaceholder(part$1, "AM", locale.value);
		} else obj[part$1] = getPartContent(part$1);
		return obj;
	}, {});
}
function createContentArr(props) {
	const { granularity, formatter, contentObj, hideTimeZone, hourCycle, isTimeValue } = props;
	return formatter.toParts(props.dateRef, getOptsByGranularity(granularity, hourCycle, isTimeValue)).map((part$1) => {
		if ([
			"literal",
			"timeZoneName",
			null
		].includes(part$1.type) || !isSegmentPart(part$1.type)) return {
			part: part$1.type,
			value: part$1.value
		};
		return {
			part: part$1.type,
			value: contentObj[part$1.type]
		};
	}).filter((segment) => {
		if (segment.part === null || segment.value === null) return false;
		if (segment.part === "timeZoneName" && (!isZonedDateTime(props.dateRef) || hideTimeZone)) return false;
		return true;
	});
}
function createContent(props) {
	const contentObj = createContentObj(props);
	return {
		obj: contentObj,
		arr: createContentArr({
			contentObj,
			...props
		})
	};
}
function isSegmentNavigationKey(key$2) {
	const kbd = useKbd();
	if (key$2 === kbd.ARROW_RIGHT || key$2 === kbd.ARROW_LEFT) return true;
	return false;
}
function isNumberString(value) {
	if (Number.isNaN(Number.parseInt(value))) return false;
	return true;
}
function isAcceptableSegmentKey(key$2) {
	const kbd = useKbd();
	if ([
		kbd.ENTER,
		kbd.ARROW_UP,
		kbd.ARROW_DOWN,
		kbd.ARROW_LEFT,
		kbd.ARROW_RIGHT,
		kbd.BACKSPACE,
		kbd.SPACE,
		"a",
		"A",
		"p",
		"P"
	].includes(key$2)) return true;
	if (isNumberString(key$2)) return true;
	return false;
}
function getSegmentElements(parentElement) {
	return Array.from(parentElement.querySelectorAll("[data-reka-date-field-segment]")).filter((item$4) => item$4.getAttribute("data-reka-date-field-segment") !== "literal");
}
function commonSegmentAttrs(props) {
	return {
		role: "spinbutton",
		contenteditable: true,
		tabindex: props.disabled ? void 0 : 0,
		spellcheck: false,
		inputmode: "numeric",
		autocorrect: "off",
		enterkeyhint: "next",
		style: "caret-color: transparent;"
	};
}
function daySegmentAttrs(props) {
	const { segmentValues, placeholder: placeholder$1 } = props;
	const isEmpty = segmentValues.day === null;
	const date$1 = segmentValues.day ? placeholder$1.set({ day: segmentValues.day }) : placeholder$1;
	const valueNow = date$1.day;
	const valueMin = 1;
	const valueMax = getDaysInMonth(date$1);
	const valueText = isEmpty ? "Empty" : `${valueNow}`;
	return {
		...commonSegmentAttrs(props),
		"aria-label": "day,",
		"aria-valuemin": valueMin,
		"aria-valuemax": valueMax,
		"aria-valuenow": valueNow,
		"aria-valuetext": valueText,
		"data-placeholder": isEmpty ? "" : void 0
	};
}
function monthSegmentAttrs(props) {
	const { segmentValues, placeholder: placeholder$1, formatter } = props;
	const isEmpty = segmentValues.month === null;
	const date$1 = segmentValues.month ? placeholder$1.set({ month: segmentValues.month }) : placeholder$1;
	const valueNow = date$1.month;
	const valueMin = 1;
	const valueMax = 12;
	const valueText = isEmpty ? "Empty" : `${valueNow} - ${formatter.fullMonth(toDate(date$1))}`;
	return {
		...commonSegmentAttrs(props),
		"aria-label": "month, ",
		"contenteditable": true,
		"aria-valuemin": valueMin,
		"aria-valuemax": valueMax,
		"aria-valuenow": valueNow,
		"aria-valuetext": valueText,
		"data-placeholder": isEmpty ? "" : void 0
	};
}
function yearSegmentAttrs(props) {
	const { segmentValues, placeholder: placeholder$1 } = props;
	const isEmpty = segmentValues.year === null;
	const date$1 = segmentValues.year ? placeholder$1.set({ year: segmentValues.year }) : placeholder$1;
	const valueMin = 1;
	const valueMax = 9999;
	const valueNow = date$1.year;
	const valueText = isEmpty ? "Empty" : `${valueNow}`;
	return {
		...commonSegmentAttrs(props),
		"aria-label": "year, ",
		"aria-valuemin": valueMin,
		"aria-valuemax": valueMax,
		"aria-valuenow": valueNow,
		"aria-valuetext": valueText,
		"data-placeholder": isEmpty ? "" : void 0
	};
}
function hourSegmentAttrs(props) {
	const { segmentValues, hourCycle, placeholder: placeholder$1 } = props;
	if (!("hour" in segmentValues) || !("hour" in placeholder$1)) return {};
	const isEmpty = segmentValues.hour === null;
	const date$1 = segmentValues.hour ? placeholder$1.set({ hour: segmentValues.hour }) : placeholder$1;
	const valueMin = hourCycle === 12 ? 1 : 0;
	const valueMax = hourCycle === 12 ? 12 : 23;
	const valueNow = date$1.hour;
	const valueText = isEmpty ? "Empty" : `${valueNow} ${segmentValues.dayPeriod ?? ""}`;
	return {
		...commonSegmentAttrs(props),
		"aria-label": "hour, ",
		"aria-valuemin": valueMin,
		"aria-valuemax": valueMax,
		"aria-valuenow": valueNow,
		"aria-valuetext": valueText,
		"data-placeholder": isEmpty ? "" : void 0
	};
}
function minuteSegmentAttrs(props) {
	const { segmentValues, placeholder: placeholder$1 } = props;
	if (!("minute" in segmentValues) || !("minute" in placeholder$1)) return {};
	const isEmpty = segmentValues.minute === null;
	const valueNow = (segmentValues.minute ? placeholder$1.set({ minute: segmentValues.minute }) : placeholder$1).minute;
	const valueMin = 0;
	const valueMax = 59;
	const valueText = isEmpty ? "Empty" : `${valueNow}`;
	return {
		...commonSegmentAttrs(props),
		"aria-label": "minute, ",
		"aria-valuemin": valueMin,
		"aria-valuemax": valueMax,
		"aria-valuenow": valueNow,
		"aria-valuetext": valueText,
		"data-placeholder": isEmpty ? "" : void 0
	};
}
function secondSegmentAttrs(props) {
	const { segmentValues, placeholder: placeholder$1 } = props;
	if (!("second" in segmentValues) || !("second" in placeholder$1)) return {};
	const isEmpty = segmentValues.second === null;
	const valueNow = (segmentValues.second ? placeholder$1.set({ second: segmentValues.second }) : placeholder$1).second;
	const valueMin = 0;
	const valueMax = 59;
	const valueText = isEmpty ? "Empty" : `${valueNow}`;
	return {
		...commonSegmentAttrs(props),
		"aria-label": "second, ",
		"aria-valuemin": valueMin,
		"aria-valuemax": valueMax,
		"aria-valuenow": valueNow,
		"aria-valuetext": valueText,
		"data-placeholder": isEmpty ? "" : void 0
	};
}
function dayPeriodSegmentAttrs(props) {
	const { segmentValues } = props;
	if (!("dayPeriod" in segmentValues)) return {};
	const valueMin = 0;
	const valueMax = 12;
	const valueNow = segmentValues.hour ? segmentValues.hour > 12 ? segmentValues.hour - 12 : segmentValues.hour : 0;
	const valueText = segmentValues.dayPeriod ?? "AM";
	return {
		...commonSegmentAttrs(props),
		"inputmode": "text",
		"aria-label": "AM/PM",
		"aria-valuemin": valueMin,
		"aria-valuemax": valueMax,
		"aria-valuenow": valueNow,
		"aria-valuetext": valueText
	};
}
function literalSegmentAttrs(_props) {
	return {
		"aria-hidden": true,
		"data-segment": "literal"
	};
}
function timeZoneSegmentAttrs(props) {
	return {
		"role": "textbox",
		"aria-label": "timezone, ",
		"data-readonly": true,
		"data-segment": "timeZoneName",
		"tabindex": props.disabled ? void 0 : 0,
		"style": "caret-color: transparent;"
	};
}
function eraSegmentAttrs(props) {
	const { segmentValues, placeholder: placeholder$1 } = props;
	const valueMin = 0;
	const valueMax = 0;
	const valueNow = 0;
	const valueText = "era" in segmentValues ? segmentValues.era : placeholder$1.era;
	return {
		...commonSegmentAttrs(props),
		"aria-label": "era",
		"aria-valuemin": valueMin,
		"aria-valuemax": valueMax,
		"aria-valuenow": valueNow,
		"aria-valuetext": valueText
	};
}
var segmentBuilders = {
	day: { attrs: daySegmentAttrs },
	month: { attrs: monthSegmentAttrs },
	year: { attrs: yearSegmentAttrs },
	hour: { attrs: hourSegmentAttrs },
	minute: { attrs: minuteSegmentAttrs },
	second: { attrs: secondSegmentAttrs },
	dayPeriod: { attrs: dayPeriodSegmentAttrs },
	literal: { attrs: literalSegmentAttrs },
	timeZoneName: { attrs: timeZoneSegmentAttrs },
	era: { attrs: eraSegmentAttrs }
};
function useDateField(props) {
	const kbd = useKbd();
	function minuteSecondIncrementation({ e, part: part$1, dateRef, prevValue }) {
		const step = props.step.value[part$1] ?? 1;
		const sign = e.key === kbd.ARROW_UP ? step : -step;
		const min$2 = 0;
		const max$2 = 59;
		if (prevValue === null) return sign > 0 ? min$2 : max$2;
		const cycleArgs = [part$1, sign];
		return dateRef.set({ [part$1]: prevValue }).cycle(...cycleArgs)[part$1];
	}
	function deleteValue(prevValue) {
		props.hasLeftFocus.value = false;
		if (prevValue === null) return prevValue;
		const str = prevValue.toString();
		if (str.length === 1) {
			props.modelValue.value = void 0;
			return null;
		}
		return Number.parseInt(str.slice(0, -1));
	}
	function dateTimeValueIncrementation({ e, part: part$1, dateRef, prevValue, hourCycle }) {
		const step = props.step.value[part$1] ?? 1;
		const sign = e.key === kbd.ARROW_UP ? step : -step;
		if (prevValue === null) return dateRef[part$1];
		if (part$1 === "hour" && "hour" in dateRef) {
			const cycleArgs$1 = [
				part$1,
				sign,
				{ hourCycle }
			];
			return dateRef.set({ [part$1]: prevValue }).cycle(...cycleArgs$1)[part$1];
		}
		const cycleArgs = [part$1, sign];
		if (part$1 === "day") return dateRef.set({
			[part$1]: prevValue,
			month: props.segmentValues.value.month ?? 1
		}).cycle(...cycleArgs)[part$1];
		return dateRef.set({ [part$1]: prevValue }).cycle(...cycleArgs)[part$1];
	}
	function updateDayOrMonth(max$2, num$2, prev) {
		let moveToNext = false;
		const maxStart = Math.floor(max$2 / 10);
		if (props.hasLeftFocus.value) {
			props.hasLeftFocus.value = false;
			prev = null;
		}
		if (prev === null) {
			if (num$2 === 0) {
				props.lastKeyZero.value = true;
				return {
					value: null,
					moveToNext
				};
			}
			if (props.lastKeyZero.value || num$2 > maxStart) moveToNext = true;
			props.lastKeyZero.value = false;
			return {
				value: num$2,
				moveToNext
			};
		}
		const digits = prev.toString().length;
		const total = Number.parseInt(prev.toString() + num$2.toString());
		if (digits === 2 || total > max$2) {
			if (num$2 > maxStart || total > max$2) moveToNext = true;
			return {
				value: num$2,
				moveToNext
			};
		}
		moveToNext = true;
		return {
			value: total,
			moveToNext
		};
	}
	function updateMinuteOrSecond(num$2, prev) {
		const max$2 = 59;
		let moveToNext = false;
		const maxStart = Math.floor(max$2 / 10);
		if (props.hasLeftFocus.value) {
			props.hasLeftFocus.value = false;
			prev = null;
		}
		if (prev === null) {
			if (num$2 === 0) {
				props.lastKeyZero.value = true;
				return {
					value: 0,
					moveToNext
				};
			}
			if (props.lastKeyZero.value || num$2 > maxStart) moveToNext = true;
			props.lastKeyZero.value = false;
			return {
				value: num$2,
				moveToNext
			};
		}
		const digits = prev.toString().length;
		const total = Number.parseInt(prev.toString() + num$2.toString());
		if (digits === 2 || total > max$2) {
			if (num$2 > maxStart) moveToNext = true;
			return {
				value: num$2,
				moveToNext
			};
		}
		moveToNext = true;
		return {
			value: total,
			moveToNext
		};
	}
	function updateHour(num$2, prev) {
		const max$2 = 24;
		let moveToNext = false;
		const maxStart = Math.floor(max$2 / 10);
		if (props.hasLeftFocus.value) {
			props.hasLeftFocus.value = false;
			prev = null;
		}
		if (prev === null) {
			if (num$2 === 0) {
				props.lastKeyZero.value = true;
				return {
					value: 0,
					moveToNext
				};
			}
			if (props.lastKeyZero.value || num$2 > maxStart) moveToNext = true;
			props.lastKeyZero.value = false;
			return {
				value: num$2,
				moveToNext
			};
		}
		const digits = prev.toString().length;
		const total = Number.parseInt(prev.toString() + num$2.toString());
		if (digits === 2 || total > max$2) {
			if (num$2 > maxStart) moveToNext = true;
			return {
				value: num$2,
				moveToNext
			};
		}
		moveToNext = true;
		return {
			value: total,
			moveToNext
		};
	}
	function updateYear(num$2, prev) {
		let moveToNext = false;
		if (props.hasLeftFocus.value) {
			props.hasLeftFocus.value = false;
			prev = null;
		}
		if (prev === null) return {
			value: num$2 === 0 ? 1 : num$2,
			moveToNext
		};
		const str = prev.toString() + num$2.toString();
		if (str.length > 4) return {
			value: num$2 === 0 ? 1 : num$2,
			moveToNext
		};
		if (str.length === 4) moveToNext = true;
		return {
			value: Number.parseInt(str),
			moveToNext
		};
	}
	const attributes = computed(() => segmentBuilders[props.part]?.attrs({
		disabled: props.disabled.value,
		placeholder: props.placeholder.value,
		hourCycle: props.hourCycle,
		segmentValues: props.segmentValues.value,
		formatter: props.formatter
	}) ?? {});
	function handleDaySegmentKeydown(e) {
		if (!isAcceptableSegmentKey(e.key) || isSegmentNavigationKey(e.key)) return;
		const prevValue = props.segmentValues.value.day;
		if (e.key === kbd.ARROW_DOWN || e.key === kbd.ARROW_UP) {
			props.segmentValues.value.day = dateTimeValueIncrementation({
				e,
				part: "day",
				dateRef: props.placeholder.value,
				prevValue
			});
			return;
		}
		if (isNumberString(e.key)) {
			const num$2 = Number.parseInt(e.key);
			const segmentMonthValue = props.segmentValues.value.month;
			const { value, moveToNext } = updateDayOrMonth(segmentMonthValue ? getDaysInMonth(props.placeholder.value.set({ month: segmentMonthValue })) : 31, num$2, prevValue);
			props.segmentValues.value.day = value;
			if (moveToNext) props.focusNext();
		}
		if (e.key === kbd.BACKSPACE) {
			props.hasLeftFocus.value = false;
			props.segmentValues.value.day = deleteValue(prevValue);
		}
	}
	function handleMonthSegmentKeydown(e) {
		if (!isAcceptableSegmentKey(e.key) || isSegmentNavigationKey(e.key)) return;
		const prevValue = props.segmentValues.value.month;
		if (e.key === kbd.ARROW_DOWN || e.key === kbd.ARROW_UP) {
			props.segmentValues.value.month = dateTimeValueIncrementation({
				e,
				part: "month",
				dateRef: props.placeholder.value,
				prevValue
			});
			return;
		}
		if (isNumberString(e.key)) {
			const { value, moveToNext } = updateDayOrMonth(12, Number.parseInt(e.key), prevValue);
			props.segmentValues.value.month = value;
			if (moveToNext) props.focusNext();
		}
		if (e.key === kbd.BACKSPACE) {
			props.hasLeftFocus.value = false;
			props.segmentValues.value.month = deleteValue(prevValue);
		}
	}
	function handleYearSegmentKeydown(e) {
		if (!isAcceptableSegmentKey(e.key) || isSegmentNavigationKey(e.key)) return;
		const prevValue = props.segmentValues.value.year;
		if (e.key === kbd.ARROW_DOWN || e.key === kbd.ARROW_UP) {
			props.segmentValues.value.year = dateTimeValueIncrementation({
				e,
				part: "year",
				dateRef: props.placeholder.value,
				prevValue
			});
			return;
		}
		if (isNumberString(e.key)) {
			const { value, moveToNext } = updateYear(Number.parseInt(e.key), prevValue);
			props.segmentValues.value.year = value;
			if (moveToNext) props.focusNext();
		}
		if (e.key === kbd.BACKSPACE) {
			props.hasLeftFocus.value = false;
			props.segmentValues.value.year = deleteValue(prevValue);
		}
	}
	function handleHourSegmentKeydown(e) {
		const dateRef = props.placeholder.value;
		if (!isAcceptableSegmentKey(e.key) || isSegmentNavigationKey(e.key) || !("hour" in dateRef) || !("hour" in props.segmentValues.value)) return;
		const prevValue = props.segmentValues.value.hour;
		const hourCycle = props.hourCycle;
		if (e.key === kbd.ARROW_UP || e.key === kbd.ARROW_DOWN) {
			props.segmentValues.value.hour = dateTimeValueIncrementation({
				e,
				part: "hour",
				dateRef: props.placeholder.value,
				prevValue,
				hourCycle
			});
			if ("dayPeriod" in props.segmentValues.value) {
				if (props.segmentValues.value.hour < 12) props.segmentValues.value.dayPeriod = "AM";
				else if (props.segmentValues.value.hour) props.segmentValues.value.dayPeriod = "PM";
			}
			return;
		}
		if (isNumberString(e.key)) {
			const { value, moveToNext } = updateHour(Number.parseInt(e.key), prevValue);
			if ("dayPeriod" in props.segmentValues.value && value && value > 12) props.segmentValues.value.dayPeriod = "PM";
			else if ("dayPeriod" in props.segmentValues.value && value) props.segmentValues.value.dayPeriod = "AM";
			props.segmentValues.value.hour = value;
			if (moveToNext) props.focusNext();
		}
		if (e.key === kbd.BACKSPACE) {
			props.hasLeftFocus.value = false;
			props.segmentValues.value.hour = deleteValue(prevValue);
		}
	}
	function handleMinuteSegmentKeydown(e) {
		const dateRef = props.placeholder.value;
		if (!isAcceptableSegmentKey(e.key) || isSegmentNavigationKey(e.key) || !("minute" in dateRef) || !("minute" in props.segmentValues.value)) return;
		const prevValue = props.segmentValues.value.minute;
		if (e.key === kbd.ARROW_UP || e.key === kbd.ARROW_DOWN) props.segmentValues.value.minute = minuteSecondIncrementation({
			e,
			part: "minute",
			dateRef: props.placeholder.value,
			prevValue
		});
		if (isNumberString(e.key)) {
			const { value, moveToNext } = updateMinuteOrSecond(Number.parseInt(e.key), prevValue);
			props.segmentValues.value.minute = value;
			if (moveToNext) props.focusNext();
		}
		if (e.key === kbd.BACKSPACE) {
			props.hasLeftFocus.value = false;
			props.segmentValues.value.minute = deleteValue(prevValue);
		}
	}
	function handleSecondSegmentKeydown(e) {
		const dateRef = props.placeholder.value;
		if (!isAcceptableSegmentKey(e.key) || isSegmentNavigationKey(e.key) || !("second" in dateRef) || !("second" in props.segmentValues.value)) return;
		const prevValue = props.segmentValues.value.second;
		if (e.key === kbd.ARROW_UP || e.key === kbd.ARROW_DOWN) props.segmentValues.value.second = minuteSecondIncrementation({
			e,
			part: "second",
			dateRef: props.placeholder.value,
			prevValue
		});
		if (isNumberString(e.key)) {
			const { value, moveToNext } = updateMinuteOrSecond(Number.parseInt(e.key), prevValue);
			props.segmentValues.value.second = value;
			if (moveToNext) props.focusNext();
		}
		if (e.key === kbd.BACKSPACE) {
			props.hasLeftFocus.value = false;
			props.segmentValues.value.second = deleteValue(prevValue);
		}
	}
	function handleDayPeriodSegmentKeydown(e) {
		if ((!isAcceptableSegmentKey(e.key) || isSegmentNavigationKey(e.key)) && e.key !== "a" && e.key !== "p" || !("hour" in props.placeholder.value) || !("dayPeriod" in props.segmentValues.value)) return;
		if (e.key === kbd.ARROW_UP || e.key === kbd.ARROW_DOWN) {
			if (props.segmentValues.value.dayPeriod === "AM") {
				props.segmentValues.value.dayPeriod = "PM";
				props.segmentValues.value.hour = props.segmentValues.value.hour + 12;
				return;
			}
			props.segmentValues.value.dayPeriod = "AM";
			props.segmentValues.value.hour = props.segmentValues.value.hour - 12;
			return;
		}
		if (["a", "A"].includes(e.key) && props.segmentValues.value.dayPeriod !== "AM") {
			props.segmentValues.value.dayPeriod = "AM";
			props.segmentValues.value.hour = props.segmentValues.value.hour - 12;
			return;
		}
		if (["p", "P"].includes(e.key) && props.segmentValues.value.dayPeriod !== "PM") {
			props.segmentValues.value.dayPeriod = "PM";
			props.segmentValues.value.hour = props.segmentValues.value.hour + 12;
		}
	}
	function handleSegmentClick(e) {
		if (props.disabled.value) e.preventDefault();
	}
	function handleSegmentKeydown(e) {
		const disabled$9 = props.disabled.value;
		const readonly$1 = props.readonly.value;
		if (e.key !== kbd.TAB) e.preventDefault();
		if (disabled$9 || readonly$1) return;
		({
			day: handleDaySegmentKeydown,
			month: handleMonthSegmentKeydown,
			year: handleYearSegmentKeydown,
			hour: handleHourSegmentKeydown,
			minute: handleMinuteSegmentKeydown,
			second: handleSecondSegmentKeydown,
			dayPeriod: handleDayPeriodSegmentKeydown,
			timeZoneName: () => {}
		})[props.part](e);
		if (![kbd.ARROW_LEFT, kbd.ARROW_RIGHT].includes(e.key) && e.key !== kbd.TAB && e.key !== kbd.SHIFT && isAcceptableSegmentKey(e.key)) {
			if (Object.values(props.segmentValues.value).every((item$4) => item$4 !== null)) {
				const updateObject = { ...props.segmentValues.value };
				let dateRef = props.placeholder.value.copy();
				Object.keys(updateObject).forEach((part$1) => {
					const value = updateObject[part$1];
					dateRef = dateRef.set({ [part$1]: value });
				});
				props.modelValue.value = dateRef.copy();
			}
		}
	}
	return {
		handleSegmentClick,
		handleSegmentKeydown,
		attributes
	};
}
function handleNextDisabled(lastPeriodInView, nextPageFunc) {
	const firstPeriodOfNextPage = nextPageFunc(lastPeriodInView);
	const diff$1 = firstPeriodOfNextPage.compare(lastPeriodInView);
	const duration = {};
	if (diff$1 >= 7) duration.day = 1;
	if (diff$1 >= getDaysInMonth(lastPeriodInView)) duration.month = 1;
	return firstPeriodOfNextPage.set({ ...duration });
}
function handlePrevDisabled(firstPeriodInView, prevPageFunc) {
	const lastPeriodOfPrevPage = prevPageFunc(firstPeriodInView);
	const diff$1 = firstPeriodInView.compare(lastPeriodOfPrevPage);
	const duration = {};
	if (diff$1 >= 7) duration.day = 35;
	if (diff$1 >= getDaysInMonth(firstPeriodInView)) duration.month = 13;
	return lastPeriodOfPrevPage.set({ ...duration });
}
function handleNextPage(date$1, nextPageFunc) {
	return nextPageFunc(date$1);
}
function handlePrevPage(date$1, prevPageFunc) {
	return prevPageFunc(date$1);
}
function useCalendar(props) {
	const formatter = useDateFormatter(props.locale.value);
	const headingFormatOptions = computed(() => {
		const options$1 = { calendar: props.placeholder.value.calendar.identifier };
		if (props.placeholder.value.calendar.identifier === "gregory" && props.placeholder.value.era === "BC") options$1.era = "short";
		return options$1;
	});
	const grid$1 = ref(createMonths({
		dateObj: props.placeholder.value,
		weekStartsOn: props.weekStartsOn.value,
		locale: props.locale.value,
		fixedWeeks: props.fixedWeeks.value,
		numberOfMonths: props.numberOfMonths.value
	}));
	const visibleView = computed(() => {
		return grid$1.value.map((month) => month.value);
	});
	function isOutsideVisibleView(date$1) {
		return !visibleView.value.some((month) => $14e0f24ef4ac5c92$export$5a8da0c44a3afdf2(date$1, month));
	}
	const isNextButtonDisabled = (nextPageFunc) => {
		if (!props.maxValue.value || !grid$1.value.length) return false;
		if (props.disabled.value) return true;
		const lastPeriodInView = grid$1.value[grid$1.value.length - 1].value;
		if (!nextPageFunc && !props.nextPage.value) return isAfter(lastPeriodInView.add({ months: 1 }).set({ day: 1 }), props.maxValue.value);
		return isAfter(handleNextDisabled(lastPeriodInView, nextPageFunc || props.nextPage.value), props.maxValue.value);
	};
	const isPrevButtonDisabled = (prevPageFunc) => {
		if (!props.minValue.value || !grid$1.value.length) return false;
		if (props.disabled.value) return true;
		const firstPeriodInView = grid$1.value[0].value;
		if (!prevPageFunc && !props.prevPage.value) return isBefore(firstPeriodInView.subtract({ months: 1 }).set({ day: 35 }), props.minValue.value);
		return isBefore(handlePrevDisabled(firstPeriodInView, prevPageFunc || props.prevPage.value), props.minValue.value);
	};
	function isDateDisabled(dateObj) {
		if (props.isDateDisabled?.(dateObj) || props.disabled.value) return true;
		if (props.maxValue.value && isAfter(dateObj, props.maxValue.value)) return true;
		if (props.minValue.value && isBefore(dateObj, props.minValue.value)) return true;
		return false;
	}
	const isDateUnavailable = (date$1) => {
		if (props.isDateUnavailable?.(date$1)) return true;
		return false;
	};
	const weekdays = computed(() => {
		if (!grid$1.value.length) return [];
		return grid$1.value[0].rows[0].map((date$1) => {
			return formatter.dayOfWeek(toDate(date$1), props.weekdayFormat.value);
		});
	});
	const nextPage = (nextPageFunc) => {
		const firstDate = grid$1.value[0].value;
		if (!nextPageFunc && !props.nextPage.value) {
			const newGrid$1 = createMonths({
				dateObj: firstDate.add({ months: props.pagedNavigation.value ? props.numberOfMonths.value : 1 }),
				weekStartsOn: props.weekStartsOn.value,
				locale: props.locale.value,
				fixedWeeks: props.fixedWeeks.value,
				numberOfMonths: props.numberOfMonths.value
			});
			grid$1.value = newGrid$1;
			props.placeholder.value = newGrid$1[0].value.set({ day: 1 });
			return;
		}
		const newGrid = createMonths({
			dateObj: handleNextPage(firstDate, nextPageFunc || props.nextPage.value),
			weekStartsOn: props.weekStartsOn.value,
			locale: props.locale.value,
			fixedWeeks: props.fixedWeeks.value,
			numberOfMonths: props.numberOfMonths.value
		});
		grid$1.value = newGrid;
		const duration = {};
		if (!nextPageFunc) {
			const diff$1 = newGrid[0].value.compare(firstDate);
			if (diff$1 >= getDaysInMonth(firstDate)) duration.day = 1;
			if (diff$1 >= 365) duration.month = 1;
		}
		props.placeholder.value = newGrid[0].value.set({ ...duration });
	};
	const prevPage = (prevPageFunc) => {
		const firstDate = grid$1.value[0].value;
		if (!prevPageFunc && !props.prevPage.value) {
			const newGrid$1 = createMonths({
				dateObj: firstDate.subtract({ months: props.pagedNavigation.value ? props.numberOfMonths.value : 1 }),
				weekStartsOn: props.weekStartsOn.value,
				locale: props.locale.value,
				fixedWeeks: props.fixedWeeks.value,
				numberOfMonths: props.numberOfMonths.value
			});
			grid$1.value = newGrid$1;
			props.placeholder.value = newGrid$1[0].value.set({ day: 1 });
			return;
		}
		const newGrid = createMonths({
			dateObj: handlePrevPage(firstDate, prevPageFunc || props.prevPage.value),
			weekStartsOn: props.weekStartsOn.value,
			locale: props.locale.value,
			fixedWeeks: props.fixedWeeks.value,
			numberOfMonths: props.numberOfMonths.value
		});
		grid$1.value = newGrid;
		const duration = {};
		if (!prevPageFunc) {
			const diff$1 = firstDate.compare(newGrid[0].value);
			if (diff$1 >= getDaysInMonth(firstDate)) duration.day = 1;
			if (diff$1 >= 365) duration.month = 1;
		}
		props.placeholder.value = newGrid[0].value.set({ ...duration });
	};
	watch(props.placeholder, (value) => {
		if (visibleView.value.some((month) => $14e0f24ef4ac5c92$export$5a8da0c44a3afdf2(month, value))) return;
		grid$1.value = createMonths({
			dateObj: value,
			weekStartsOn: props.weekStartsOn.value,
			locale: props.locale.value,
			fixedWeeks: props.fixedWeeks.value,
			numberOfMonths: props.numberOfMonths.value
		});
	});
	watch([
		props.locale,
		props.weekStartsOn,
		props.fixedWeeks,
		props.numberOfMonths
	], () => {
		grid$1.value = createMonths({
			dateObj: props.placeholder.value,
			weekStartsOn: props.weekStartsOn.value,
			locale: props.locale.value,
			fixedWeeks: props.fixedWeeks.value,
			numberOfMonths: props.numberOfMonths.value
		});
	});
	const headingValue = computed(() => {
		if (!grid$1.value.length) return "";
		if (props.locale.value !== formatter.getLocale()) formatter.setLocale(props.locale.value);
		if (grid$1.value.length === 1) {
			const month = grid$1.value[0].value;
			return `${formatter.fullMonthAndYear(toDate(month), headingFormatOptions.value)}`;
		}
		const startMonth = toDate(grid$1.value[0].value);
		const endMonth = toDate(grid$1.value[grid$1.value.length - 1].value);
		const startMonthName = formatter.fullMonth(startMonth, headingFormatOptions.value);
		const endMonthName = formatter.fullMonth(endMonth, headingFormatOptions.value);
		const startMonthYear = formatter.fullYear(startMonth, headingFormatOptions.value);
		const endMonthYear = formatter.fullYear(endMonth, headingFormatOptions.value);
		return startMonthYear === endMonthYear ? `${startMonthName} - ${endMonthName} ${endMonthYear}` : `${startMonthName} ${startMonthYear} - ${endMonthName} ${endMonthYear}`;
	});
	return {
		isDateDisabled,
		isDateUnavailable,
		isNextButtonDisabled,
		isPrevButtonDisabled,
		grid: grid$1,
		weekdays,
		visibleView,
		isOutsideVisibleView,
		formatter,
		nextPage,
		prevPage,
		headingValue,
		fullCalendarLabel: computed(() => `${props.calendarLabel.value ?? "Event Date"}, ${headingValue.value}`)
	};
}
var SELECTOR = "[data-reka-calendar-cell-trigger]:not([data-outside-view]):not([data-outside-visible-view])";
function getSelectableCells(calendar$1) {
	return Array.from(calendar$1.querySelectorAll(SELECTOR)) ?? [];
}
var ITEM_DATA_ATTR = "data-reka-collection-item";
function useCollection(options$1 = {}) {
	const { key: key$2 = "", isProvider = false } = options$1;
	const injectionKey = `${key$2}CollectionProvider`;
	let context$1;
	if (isProvider) {
		const itemMap = ref(/* @__PURE__ */ new Map());
		context$1 = {
			collectionRef: ref(),
			itemMap
		};
		provide(injectionKey, context$1);
	} else context$1 = inject(injectionKey);
	const getItems = (includeDisabledItem = false) => {
		const collectionNode = context$1.collectionRef.value;
		if (!collectionNode) return [];
		const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));
		const orderedItems = Array.from(context$1.itemMap.value.values()).sort((a$1, b$2) => orderedNodes.indexOf(a$1.ref) - orderedNodes.indexOf(b$2.ref));
		if (includeDisabledItem) return orderedItems;
		else return orderedItems.filter((i$1) => i$1.ref.dataset.disabled !== "");
	};
	const CollectionSlot = defineComponent({
		name: "CollectionSlot",
		setup(_, { slots }) {
			const { primitiveElement, currentElement } = usePrimitiveElement();
			watch(currentElement, () => {
				context$1.collectionRef.value = currentElement.value;
			});
			return () => h(Slot, { ref: primitiveElement }, slots);
		}
	});
	const CollectionItem$1 = defineComponent({
		name: "CollectionItem",
		inheritAttrs: false,
		props: { value: { validator: () => true } },
		setup(props, { slots, attrs }) {
			const { primitiveElement, currentElement } = usePrimitiveElement();
			watchEffect((cleanupFn) => {
				if (currentElement.value) {
					const key$1$1 = markRaw(currentElement.value);
					context$1.itemMap.value.set(key$1$1, {
						ref: currentElement.value,
						value: props.value
					});
					cleanupFn(() => context$1.itemMap.value.delete(key$1$1));
				}
			});
			return () => h(Slot, {
				...attrs,
				[ITEM_DATA_ATTR]: "",
				ref: primitiveElement
			}, slots);
		}
	});
	return {
		getItems,
		reactiveItems: computed(() => Array.from(context$1.itemMap.value.values())),
		itemMapSize: computed(() => context$1.itemMap.value.size),
		CollectionSlot,
		CollectionItem: CollectionItem$1
	};
}
var VisuallyHidden_default = /* @__PURE__ */ defineComponent({
	__name: "VisuallyHidden",
	props: {
		feature: {
			type: String,
			required: false,
			default: "focusable"
		},
		asChild: {
			type: Boolean,
			required: false
		},
		as: {
			type: null,
			required: false,
			default: "span"
		}
	},
	setup(__props) {
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(Primitive), {
				as: _ctx.as,
				"as-child": _ctx.asChild,
				"aria-hidden": _ctx.feature === "focusable" ? "true" : void 0,
				"data-hidden": _ctx.feature === "fully-hidden" ? "" : void 0,
				tabindex: _ctx.feature === "fully-hidden" ? "-1" : void 0,
				style: {
					position: "absolute",
					border: 0,
					width: "1px",
					height: "1px",
					padding: 0,
					margin: "-1px",
					overflow: "hidden",
					clip: "rect(0, 0, 0, 0)",
					clipPath: "inset(50%)",
					whiteSpace: "nowrap",
					wordWrap: "normal"
				}
			}, {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 8, [
				"as",
				"as-child",
				"aria-hidden",
				"data-hidden",
				"tabindex"
			]);
		};
	}
});
var VisuallyHiddenInputBubble_default = /* @__PURE__ */ defineComponent({
	inheritAttrs: false,
	__name: "VisuallyHiddenInputBubble",
	props: {
		name: {
			type: String,
			required: true
		},
		value: {
			type: null,
			required: true
		},
		checked: {
			type: Boolean,
			required: false,
			default: void 0
		},
		required: {
			type: Boolean,
			required: false
		},
		disabled: {
			type: Boolean,
			required: false
		},
		feature: {
			type: String,
			required: false,
			default: "fully-hidden"
		}
	},
	setup(__props) {
		const props = __props;
		const { primitiveElement, currentElement } = usePrimitiveElement();
		watch(computed(() => props.checked ?? props.value), (cur, prev) => {
			if (!currentElement.value) return;
			const input$4 = currentElement.value;
			const inputProto = window.HTMLInputElement.prototype;
			const setValue = Object.getOwnPropertyDescriptor(inputProto, "value").set;
			if (setValue && cur !== prev) {
				const inputEvent = new Event("input", { bubbles: true });
				const changeEvent = new Event("change", { bubbles: true });
				setValue.call(input$4, cur);
				input$4.dispatchEvent(inputEvent);
				input$4.dispatchEvent(changeEvent);
			}
		});
		return (_ctx, _cache) => {
			return openBlock(), createBlock(VisuallyHidden_default, mergeProps({
				ref_key: "primitiveElement",
				ref: primitiveElement
			}, {
				...props,
				..._ctx.$attrs
			}, { as: "input" }), null, 16);
		};
	}
});
var VisuallyHiddenInput_default = /* @__PURE__ */ defineComponent({
	inheritAttrs: false,
	__name: "VisuallyHiddenInput",
	props: {
		name: {
			type: String,
			required: true
		},
		value: {
			type: null,
			required: true
		},
		checked: {
			type: Boolean,
			required: false,
			default: void 0
		},
		required: {
			type: Boolean,
			required: false
		},
		disabled: {
			type: Boolean,
			required: false
		},
		feature: {
			type: String,
			required: false,
			default: "fully-hidden"
		}
	},
	setup(__props) {
		const props = __props;
		const isFormArrayEmptyAndRequired = computed(() => typeof props.value === "object" && Array.isArray(props.value) && props.value.length === 0 && props.required);
		const parsedValue = computed(() => {
			if (typeof props.value === "string" || typeof props.value === "number" || typeof props.value === "boolean" || props.value === null || props.value === void 0) return [{
				name: props.name,
				value: props.value
			}];
			else if (typeof props.value === "object" && Array.isArray(props.value)) return props.value.flatMap((obj, index) => {
				if (typeof obj === "object") return Object.entries(obj).map(([key$2, value]) => ({
					name: `${props.name}[${index}][${key$2}]`,
					value
				}));
				else return {
					name: `${props.name}[${index}]`,
					value: obj
				};
			});
			else if (props.value !== null && typeof props.value === "object" && !Array.isArray(props.value)) return Object.entries(props.value).map(([key$2, value]) => ({
				name: `${props.name}[${key$2}]`,
				value
			}));
			return [];
		});
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock(Fragment, null, [createCommentVNode(" We render single input if it's required "), isFormArrayEmptyAndRequired.value ? (openBlock(), createBlock(VisuallyHiddenInputBubble_default, mergeProps({ key: _ctx.name }, {
				...props,
				..._ctx.$attrs
			}, {
				name: _ctx.name,
				value: _ctx.value
			}), null, 16, ["name", "value"])) : (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(parsedValue.value, (parsed) => {
				return openBlock(), createBlock(VisuallyHiddenInputBubble_default, mergeProps({ key: parsed.name }, { ref_for: true }, {
					...props,
					..._ctx.$attrs
				}, {
					name: parsed.name,
					value: parsed.value
				}), null, 16, ["name", "value"]);
			}), 128))], 2112);
		};
	}
});
var [injectPopperRootContext, providePopperRootContext] = createContext("PopperRoot");
var PopperRoot_default = /* @__PURE__ */ defineComponent({
	inheritAttrs: false,
	__name: "PopperRoot",
	setup(__props) {
		const anchor$1 = ref();
		providePopperRootContext({
			anchor: anchor$1,
			onAnchorChange: (element) => anchor$1.value = element
		});
		return (_ctx, _cache) => {
			return renderSlot(_ctx.$slots, "default");
		};
	}
});
var PopperAnchor_default = /* @__PURE__ */ defineComponent({
	__name: "PopperAnchor",
	props: {
		reference: {
			type: null,
			required: false
		},
		asChild: {
			type: Boolean,
			required: false
		},
		as: {
			type: null,
			required: false
		}
	},
	setup(__props) {
		const props = __props;
		const { forwardRef, currentElement } = useForwardExpose();
		const rootContext = injectPopperRootContext();
		watchPostEffect(() => {
			rootContext.onAnchorChange(props.reference ?? currentElement.value);
		});
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(Primitive), {
				ref: unref(forwardRef),
				as: _ctx.as,
				"as-child": _ctx.asChild
			}, {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 8, ["as", "as-child"]);
		};
	}
});
function isNotNull(value) {
	return value !== null;
}
function transformOrigin(options$1) {
	return {
		name: "transformOrigin",
		options: options$1,
		fn(data) {
			const { placement, rects, middlewareData } = data;
			const isArrowHidden = middlewareData.arrow?.centerOffset !== 0;
			const arrowWidth = isArrowHidden ? 0 : options$1.arrowWidth;
			const arrowHeight = isArrowHidden ? 0 : options$1.arrowHeight;
			const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
			const noArrowAlign = {
				start: "0%",
				center: "50%",
				end: "100%"
			}[placedAlign];
			const arrowXCenter = (middlewareData.arrow?.x ?? 0) + arrowWidth / 2;
			const arrowYCenter = (middlewareData.arrow?.y ?? 0) + arrowHeight / 2;
			let x$2 = "";
			let y = "";
			if (placedSide === "bottom") {
				x$2 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
				y = `${-arrowHeight}px`;
			} else if (placedSide === "top") {
				x$2 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
				y = `${rects.floating.height + arrowHeight}px`;
			} else if (placedSide === "right") {
				x$2 = `${-arrowHeight}px`;
				y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
			} else if (placedSide === "left") {
				x$2 = `${rects.floating.width + arrowHeight}px`;
				y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
			}
			return { data: {
				x: x$2,
				y
			} };
		}
	};
}
function getSideAndAlignFromPlacement(placement) {
	const [side, align = "center"] = placement.split("-");
	return [side, align];
}
function isComponentPublicInstance(target$1) {
	return target$1 != null && typeof target$1 === "object" && "$el" in target$1;
}
function unwrapElement(target$1) {
	if (isComponentPublicInstance(target$1)) {
		const element = target$1.$el;
		return isNode(element) && getNodeName(element) === "#comment" ? null : element;
	}
	return target$1;
}
function toValue(source) {
	return typeof source === "function" ? source() : unref(source);
}
function arrow(options$1) {
	return {
		name: "arrow",
		options: options$1,
		fn(args) {
			const element = unwrapElement(toValue(options$1.element));
			if (element == null) return {};
			return arrow$1({
				element,
				padding: options$1.padding
			}).fn(args);
		}
	};
}
function getDPR(element) {
	if (typeof window === "undefined") return 1;
	return (element.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function roundByDPR(element, value) {
	const dpr = getDPR(element);
	return Math.round(value * dpr) / dpr;
}
function useFloating(reference, floating, options$1) {
	if (options$1 === void 0) options$1 = {};
	const whileElementsMountedOption = options$1.whileElementsMounted;
	const openOption = computed(() => {
		var _toValue;
		return (_toValue = toValue(options$1.open)) != null ? _toValue : true;
	});
	const middlewareOption = computed(() => toValue(options$1.middleware));
	const placementOption = computed(() => {
		var _toValue2;
		return (_toValue2 = toValue(options$1.placement)) != null ? _toValue2 : "bottom";
	});
	const strategyOption = computed(() => {
		var _toValue3;
		return (_toValue3 = toValue(options$1.strategy)) != null ? _toValue3 : "absolute";
	});
	const transformOption = computed(() => {
		var _toValue4;
		return (_toValue4 = toValue(options$1.transform)) != null ? _toValue4 : true;
	});
	const referenceElement = computed(() => unwrapElement(reference.value));
	const floatingElement = computed(() => unwrapElement(floating.value));
	const x$2 = ref(0);
	const y = ref(0);
	const strategy = ref(strategyOption.value);
	const placement = ref(placementOption.value);
	const middlewareData = shallowRef({});
	const isPositioned = ref(false);
	const floatingStyles = computed(() => {
		const initialStyles = {
			position: strategy.value,
			left: "0",
			top: "0"
		};
		if (!floatingElement.value) return initialStyles;
		const xVal = roundByDPR(floatingElement.value, x$2.value);
		const yVal = roundByDPR(floatingElement.value, y.value);
		if (transformOption.value) return {
			...initialStyles,
			transform: "translate(" + xVal + "px, " + yVal + "px)",
			...getDPR(floatingElement.value) >= 1.5 && { willChange: "transform" }
		};
		return {
			position: strategy.value,
			left: xVal + "px",
			top: yVal + "px"
		};
	});
	let whileElementsMountedCleanup;
	function update() {
		if (referenceElement.value == null || floatingElement.value == null) return;
		const open = openOption.value;
		computePosition(referenceElement.value, floatingElement.value, {
			middleware: middlewareOption.value,
			placement: placementOption.value,
			strategy: strategyOption.value
		}).then((position) => {
			x$2.value = position.x;
			y.value = position.y;
			strategy.value = position.strategy;
			placement.value = position.placement;
			middlewareData.value = position.middlewareData;
			isPositioned.value = open !== false;
		});
	}
	function cleanup() {
		if (typeof whileElementsMountedCleanup === "function") {
			whileElementsMountedCleanup();
			whileElementsMountedCleanup = void 0;
		}
	}
	function attach() {
		cleanup();
		if (whileElementsMountedOption === void 0) {
			update();
			return;
		}
		if (referenceElement.value != null && floatingElement.value != null) {
			whileElementsMountedCleanup = whileElementsMountedOption(referenceElement.value, floatingElement.value, update);
			return;
		}
	}
	function reset() {
		if (!openOption.value) isPositioned.value = false;
	}
	watch([
		middlewareOption,
		placementOption,
		strategyOption,
		openOption
	], update, { flush: "sync" });
	watch([referenceElement, floatingElement], attach, { flush: "sync" });
	watch(openOption, reset, { flush: "sync" });
	if (getCurrentScope()) onScopeDispose(cleanup);
	return {
		x: shallowReadonly(x$2),
		y: shallowReadonly(y),
		strategy: shallowReadonly(strategy),
		placement: shallowReadonly(placement),
		middlewareData: shallowReadonly(middlewareData),
		isPositioned: shallowReadonly(isPositioned),
		floatingStyles,
		update
	};
}
var PopperContentPropsDefaultValue = {
	side: "bottom",
	sideOffset: 0,
	sideFlip: true,
	align: "center",
	alignOffset: 0,
	alignFlip: true,
	arrowPadding: 0,
	avoidCollisions: true,
	collisionBoundary: () => [],
	collisionPadding: 0,
	sticky: "partial",
	hideWhenDetached: false,
	positionStrategy: "fixed",
	updatePositionStrategy: "optimized",
	prioritizePosition: false
};
var [injectPopperContentContext, providePopperContentContext] = createContext("PopperContent");
var PopperContent_default = /* @__PURE__ */ defineComponent({
	inheritAttrs: false,
	__name: "PopperContent",
	props: /* @__PURE__ */ mergeDefaults({
		side: {
			type: null,
			required: false
		},
		sideOffset: {
			type: Number,
			required: false
		},
		sideFlip: {
			type: Boolean,
			required: false
		},
		align: {
			type: null,
			required: false
		},
		alignOffset: {
			type: Number,
			required: false
		},
		alignFlip: {
			type: Boolean,
			required: false
		},
		avoidCollisions: {
			type: Boolean,
			required: false
		},
		collisionBoundary: {
			type: null,
			required: false
		},
		collisionPadding: {
			type: [Number, Object],
			required: false
		},
		arrowPadding: {
			type: Number,
			required: false
		},
		sticky: {
			type: String,
			required: false
		},
		hideWhenDetached: {
			type: Boolean,
			required: false
		},
		positionStrategy: {
			type: String,
			required: false
		},
		updatePositionStrategy: {
			type: String,
			required: false
		},
		disableUpdateOnLayoutShift: {
			type: Boolean,
			required: false
		},
		prioritizePosition: {
			type: Boolean,
			required: false
		},
		reference: {
			type: null,
			required: false
		},
		asChild: {
			type: Boolean,
			required: false
		},
		as: {
			type: null,
			required: false
		}
	}, { ...PopperContentPropsDefaultValue }),
	emits: ["placed"],
	setup(__props, { emit: __emit }) {
		const props = __props;
		const emits = __emit;
		const rootContext = injectPopperRootContext();
		const { forwardRef, currentElement: contentElement } = useForwardExpose();
		const floatingRef = ref();
		const arrow$1$1 = ref();
		const { width: arrowWidth, height: arrowHeight } = useSize(arrow$1$1);
		const desiredPlacement = computed(() => props.side + (props.align !== "center" ? `-${props.align}` : ""));
		const collisionPadding = computed(() => {
			return typeof props.collisionPadding === "number" ? props.collisionPadding : {
				top: 0,
				right: 0,
				bottom: 0,
				left: 0,
				...props.collisionPadding
			};
		});
		const boundary = computed(() => {
			return Array.isArray(props.collisionBoundary) ? props.collisionBoundary : [props.collisionBoundary];
		});
		const detectOverflowOptions = computed(() => {
			return {
				padding: collisionPadding.value,
				boundary: boundary.value.filter(isNotNull),
				altBoundary: boundary.value.length > 0
			};
		});
		const flipOptions = computed(() => {
			return {
				mainAxis: props.sideFlip,
				crossAxis: props.alignFlip
			};
		});
		const computedMiddleware = computedEager(() => {
			return [
				offset({
					mainAxis: props.sideOffset + arrowHeight.value,
					alignmentAxis: props.alignOffset
				}),
				props.prioritizePosition && props.avoidCollisions && flip({
					...detectOverflowOptions.value,
					...flipOptions.value
				}),
				props.avoidCollisions && shift({
					mainAxis: true,
					crossAxis: !!props.prioritizePosition,
					limiter: props.sticky === "partial" ? limitShift() : void 0,
					...detectOverflowOptions.value
				}),
				!props.prioritizePosition && props.avoidCollisions && flip({
					...detectOverflowOptions.value,
					...flipOptions.value
				}),
				size({
					...detectOverflowOptions.value,
					apply: ({ elements, rects, availableWidth, availableHeight }) => {
						const { width: anchorWidth, height: anchorHeight } = rects.reference;
						const contentStyle = elements.floating.style;
						contentStyle.setProperty("--reka-popper-available-width", `${availableWidth}px`);
						contentStyle.setProperty("--reka-popper-available-height", `${availableHeight}px`);
						contentStyle.setProperty("--reka-popper-anchor-width", `${anchorWidth}px`);
						contentStyle.setProperty("--reka-popper-anchor-height", `${anchorHeight}px`);
					}
				}),
				arrow$1$1.value && arrow({
					element: arrow$1$1.value,
					padding: props.arrowPadding
				}),
				transformOrigin({
					arrowWidth: arrowWidth.value,
					arrowHeight: arrowHeight.value
				}),
				props.hideWhenDetached && hide({
					strategy: "referenceHidden",
					...detectOverflowOptions.value
				})
			];
		});
		const { floatingStyles, placement, isPositioned, middlewareData, update } = useFloating(computed(() => props.reference ?? rootContext.anchor.value), floatingRef, {
			strategy: props.positionStrategy,
			placement: desiredPlacement,
			whileElementsMounted: (...args) => {
				return autoUpdate(...args, {
					layoutShift: !props.disableUpdateOnLayoutShift,
					animationFrame: props.updatePositionStrategy === "always"
				});
			},
			middleware: computedMiddleware
		});
		const placedSide = computed(() => getSideAndAlignFromPlacement(placement.value)[0]);
		const placedAlign = computed(() => getSideAndAlignFromPlacement(placement.value)[1]);
		watchPostEffect(() => {
			if (isPositioned.value) emits("placed");
		});
		const cannotCenterArrow = computed(() => middlewareData.value.arrow?.centerOffset !== 0);
		const contentZIndex = ref("");
		watchEffect(() => {
			if (contentElement.value) contentZIndex.value = window.getComputedStyle(contentElement.value).zIndex;
		});
		providePopperContentContext({
			placedSide,
			onArrowChange: (element) => arrow$1$1.value = element,
			arrowX: computed(() => middlewareData.value.arrow?.x ?? 0),
			arrowY: computed(() => middlewareData.value.arrow?.y ?? 0),
			shouldHideArrow: cannotCenterArrow
		});
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", {
				ref_key: "floatingRef",
				ref: floatingRef,
				"data-reka-popper-content-wrapper": "",
				style: normalizeStyle({
					...unref(floatingStyles),
					transform: unref(isPositioned) ? unref(floatingStyles).transform : "translate(0, -200%)",
					minWidth: "max-content",
					zIndex: contentZIndex.value,
					["--reka-popper-transform-origin"]: [unref(middlewareData).transformOrigin?.x, unref(middlewareData).transformOrigin?.y].join(" "),
					...unref(middlewareData).hide?.referenceHidden && {
						visibility: "hidden",
						pointerEvents: "none"
					}
				})
			}, [createVNode(unref(Primitive), mergeProps({ ref: unref(forwardRef) }, _ctx.$attrs, {
				"as-child": props.asChild,
				as: _ctx.as,
				"data-side": placedSide.value,
				"data-align": placedAlign.value,
				style: { animation: !unref(isPositioned) ? "none" : void 0 }
			}), {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 16, [
				"as-child",
				"as",
				"data-side",
				"data-align",
				"style"
			])], 4);
		};
	}
});
function useNonce(nonce) {
	const context$1 = injectConfigProviderContext({ nonce: ref() });
	return computed(() => nonce?.value || context$1.nonce?.value);
}
var [injectPopoverRootContext, providePopoverRootContext] = createContext("PopoverRoot");
var PopoverRoot_default = /* @__PURE__ */ defineComponent({
	__name: "PopoverRoot",
	props: {
		defaultOpen: {
			type: Boolean,
			required: false,
			default: false
		},
		open: {
			type: Boolean,
			required: false,
			default: void 0
		},
		modal: {
			type: Boolean,
			required: false,
			default: false
		}
	},
	emits: ["update:open"],
	setup(__props, { emit: __emit }) {
		const props = __props;
		const emit = __emit;
		const { modal } = toRefs(props);
		const open = useVModel(props, "open", emit, {
			defaultValue: props.defaultOpen,
			passive: props.open === void 0
		});
		providePopoverRootContext({
			contentId: "",
			triggerId: "",
			modal,
			open,
			onOpenChange: (value) => {
				open.value = value;
			},
			onOpenToggle: () => {
				open.value = !open.value;
			},
			triggerElement: ref(),
			hasCustomAnchor: ref(false)
		});
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(PopperRoot_default), null, {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default", {
					open: unref(open),
					close: () => open.value = false
				})]),
				_: 3
			});
		};
	}
});
var PopoverContentImpl_default = /* @__PURE__ */ defineComponent({
	__name: "PopoverContentImpl",
	props: {
		trapFocus: {
			type: Boolean,
			required: false
		},
		side: {
			type: null,
			required: false
		},
		sideOffset: {
			type: Number,
			required: false
		},
		sideFlip: {
			type: Boolean,
			required: false
		},
		align: {
			type: null,
			required: false
		},
		alignOffset: {
			type: Number,
			required: false
		},
		alignFlip: {
			type: Boolean,
			required: false
		},
		avoidCollisions: {
			type: Boolean,
			required: false
		},
		collisionBoundary: {
			type: null,
			required: false
		},
		collisionPadding: {
			type: [Number, Object],
			required: false
		},
		arrowPadding: {
			type: Number,
			required: false
		},
		sticky: {
			type: String,
			required: false
		},
		hideWhenDetached: {
			type: Boolean,
			required: false
		},
		positionStrategy: {
			type: String,
			required: false
		},
		updatePositionStrategy: {
			type: String,
			required: false
		},
		disableUpdateOnLayoutShift: {
			type: Boolean,
			required: false
		},
		prioritizePosition: {
			type: Boolean,
			required: false
		},
		reference: {
			type: null,
			required: false
		},
		asChild: {
			type: Boolean,
			required: false
		},
		as: {
			type: null,
			required: false
		},
		disableOutsidePointerEvents: {
			type: Boolean,
			required: false
		}
	},
	emits: [
		"escapeKeyDown",
		"pointerDownOutside",
		"focusOutside",
		"interactOutside",
		"openAutoFocus",
		"closeAutoFocus"
	],
	setup(__props, { emit: __emit }) {
		const props = __props;
		const emits = __emit;
		const forwarded = useForwardProps(reactiveOmit(props, "trapFocus", "disableOutsidePointerEvents"));
		const { forwardRef } = useForwardExpose();
		const rootContext = injectPopoverRootContext();
		useFocusGuards();
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(FocusScope_default), {
				"as-child": "",
				loop: "",
				trapped: _ctx.trapFocus,
				onMountAutoFocus: _cache[5] || (_cache[5] = ($event) => emits("openAutoFocus", $event)),
				onUnmountAutoFocus: _cache[6] || (_cache[6] = ($event) => emits("closeAutoFocus", $event))
			}, {
				default: withCtx(() => [createVNode(unref(DismissableLayer_default), {
					"as-child": "",
					"disable-outside-pointer-events": _ctx.disableOutsidePointerEvents,
					onPointerDownOutside: _cache[0] || (_cache[0] = ($event) => emits("pointerDownOutside", $event)),
					onInteractOutside: _cache[1] || (_cache[1] = ($event) => emits("interactOutside", $event)),
					onEscapeKeyDown: _cache[2] || (_cache[2] = ($event) => emits("escapeKeyDown", $event)),
					onFocusOutside: _cache[3] || (_cache[3] = ($event) => emits("focusOutside", $event)),
					onDismiss: _cache[4] || (_cache[4] = ($event) => unref(rootContext).onOpenChange(false))
				}, {
					default: withCtx(() => [createVNode(unref(PopperContent_default), mergeProps(unref(forwarded), {
						id: unref(rootContext).contentId,
						ref: unref(forwardRef),
						"data-state": unref(rootContext).open.value ? "open" : "closed",
						"aria-labelledby": unref(rootContext).triggerId,
						style: {
							"--reka-popover-content-transform-origin": "var(--reka-popper-transform-origin)",
							"--reka-popover-content-available-width": "var(--reka-popper-available-width)",
							"--reka-popover-content-available-height": "var(--reka-popper-available-height)",
							"--reka-popover-trigger-width": "var(--reka-popper-anchor-width)",
							"--reka-popover-trigger-height": "var(--reka-popper-anchor-height)"
						},
						role: "dialog"
					}), {
						default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
						_: 3
					}, 16, [
						"id",
						"data-state",
						"aria-labelledby"
					])]),
					_: 3
				}, 8, ["disable-outside-pointer-events"])]),
				_: 3
			}, 8, ["trapped"]);
		};
	}
});
var PopoverContentModal_default = /* @__PURE__ */ defineComponent({
	__name: "PopoverContentModal",
	props: {
		side: {
			type: null,
			required: false
		},
		sideOffset: {
			type: Number,
			required: false
		},
		sideFlip: {
			type: Boolean,
			required: false
		},
		align: {
			type: null,
			required: false
		},
		alignOffset: {
			type: Number,
			required: false
		},
		alignFlip: {
			type: Boolean,
			required: false
		},
		avoidCollisions: {
			type: Boolean,
			required: false
		},
		collisionBoundary: {
			type: null,
			required: false
		},
		collisionPadding: {
			type: [Number, Object],
			required: false
		},
		arrowPadding: {
			type: Number,
			required: false
		},
		sticky: {
			type: String,
			required: false
		},
		hideWhenDetached: {
			type: Boolean,
			required: false
		},
		positionStrategy: {
			type: String,
			required: false
		},
		updatePositionStrategy: {
			type: String,
			required: false
		},
		disableUpdateOnLayoutShift: {
			type: Boolean,
			required: false
		},
		prioritizePosition: {
			type: Boolean,
			required: false
		},
		reference: {
			type: null,
			required: false
		},
		asChild: {
			type: Boolean,
			required: false
		},
		as: {
			type: null,
			required: false
		},
		disableOutsidePointerEvents: {
			type: Boolean,
			required: false
		}
	},
	emits: [
		"escapeKeyDown",
		"pointerDownOutside",
		"focusOutside",
		"interactOutside",
		"openAutoFocus",
		"closeAutoFocus"
	],
	setup(__props, { emit: __emit }) {
		const props = __props;
		const emits = __emit;
		const rootContext = injectPopoverRootContext();
		const isRightClickOutsideRef = ref(false);
		useBodyScrollLock(true);
		const forwarded = useForwardPropsEmits(props, emits);
		const { forwardRef, currentElement } = useForwardExpose();
		useHideOthers(currentElement);
		return (_ctx, _cache) => {
			return openBlock(), createBlock(PopoverContentImpl_default, mergeProps(unref(forwarded), {
				ref: unref(forwardRef),
				"trap-focus": unref(rootContext).open.value,
				"disable-outside-pointer-events": "",
				onCloseAutoFocus: _cache[0] || (_cache[0] = withModifiers((event) => {
					emits("closeAutoFocus", event);
					if (!isRightClickOutsideRef.value) unref(rootContext).triggerElement.value?.focus();
				}, ["prevent"])),
				onPointerDownOutside: _cache[1] || (_cache[1] = (event) => {
					emits("pointerDownOutside", event);
					const originalEvent = event.detail.originalEvent;
					const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
					isRightClickOutsideRef.value = originalEvent.button === 2 || ctrlLeftClick;
				}),
				onFocusOutside: _cache[2] || (_cache[2] = withModifiers(() => {}, ["prevent"]))
			}), {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 16, ["trap-focus"]);
		};
	}
});
var PopoverContentNonModal_default = /* @__PURE__ */ defineComponent({
	__name: "PopoverContentNonModal",
	props: {
		side: {
			type: null,
			required: false
		},
		sideOffset: {
			type: Number,
			required: false
		},
		sideFlip: {
			type: Boolean,
			required: false
		},
		align: {
			type: null,
			required: false
		},
		alignOffset: {
			type: Number,
			required: false
		},
		alignFlip: {
			type: Boolean,
			required: false
		},
		avoidCollisions: {
			type: Boolean,
			required: false
		},
		collisionBoundary: {
			type: null,
			required: false
		},
		collisionPadding: {
			type: [Number, Object],
			required: false
		},
		arrowPadding: {
			type: Number,
			required: false
		},
		sticky: {
			type: String,
			required: false
		},
		hideWhenDetached: {
			type: Boolean,
			required: false
		},
		positionStrategy: {
			type: String,
			required: false
		},
		updatePositionStrategy: {
			type: String,
			required: false
		},
		disableUpdateOnLayoutShift: {
			type: Boolean,
			required: false
		},
		prioritizePosition: {
			type: Boolean,
			required: false
		},
		reference: {
			type: null,
			required: false
		},
		asChild: {
			type: Boolean,
			required: false
		},
		as: {
			type: null,
			required: false
		},
		disableOutsidePointerEvents: {
			type: Boolean,
			required: false
		}
	},
	emits: [
		"escapeKeyDown",
		"pointerDownOutside",
		"focusOutside",
		"interactOutside",
		"openAutoFocus",
		"closeAutoFocus"
	],
	setup(__props, { emit: __emit }) {
		const props = __props;
		const emits = __emit;
		const rootContext = injectPopoverRootContext();
		const hasInteractedOutsideRef = ref(false);
		const hasPointerDownOutsideRef = ref(false);
		const forwarded = useForwardPropsEmits(props, emits);
		return (_ctx, _cache) => {
			return openBlock(), createBlock(PopoverContentImpl_default, mergeProps(unref(forwarded), {
				"trap-focus": false,
				"disable-outside-pointer-events": false,
				onCloseAutoFocus: _cache[0] || (_cache[0] = (event) => {
					emits("closeAutoFocus", event);
					if (!event.defaultPrevented) {
						if (!hasInteractedOutsideRef.value) unref(rootContext).triggerElement.value?.focus();
						event.preventDefault();
					}
					hasInteractedOutsideRef.value = false;
					hasPointerDownOutsideRef.value = false;
				}),
				onInteractOutside: _cache[1] || (_cache[1] = async (event) => {
					emits("interactOutside", event);
					if (!event.defaultPrevented) {
						hasInteractedOutsideRef.value = true;
						if (event.detail.originalEvent.type === "pointerdown") hasPointerDownOutsideRef.value = true;
					}
					const target$1 = event.target;
					if (unref(rootContext).triggerElement.value?.contains(target$1)) event.preventDefault();
					if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.value) event.preventDefault();
				})
			}), {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 16);
		};
	}
});
var PopoverContent_default = /* @__PURE__ */ defineComponent({
	__name: "PopoverContent",
	props: {
		forceMount: {
			type: Boolean,
			required: false
		},
		side: {
			type: null,
			required: false
		},
		sideOffset: {
			type: Number,
			required: false
		},
		sideFlip: {
			type: Boolean,
			required: false
		},
		align: {
			type: null,
			required: false
		},
		alignOffset: {
			type: Number,
			required: false
		},
		alignFlip: {
			type: Boolean,
			required: false
		},
		avoidCollisions: {
			type: Boolean,
			required: false
		},
		collisionBoundary: {
			type: null,
			required: false
		},
		collisionPadding: {
			type: [Number, Object],
			required: false
		},
		arrowPadding: {
			type: Number,
			required: false
		},
		sticky: {
			type: String,
			required: false
		},
		hideWhenDetached: {
			type: Boolean,
			required: false
		},
		positionStrategy: {
			type: String,
			required: false
		},
		updatePositionStrategy: {
			type: String,
			required: false
		},
		disableUpdateOnLayoutShift: {
			type: Boolean,
			required: false
		},
		prioritizePosition: {
			type: Boolean,
			required: false
		},
		reference: {
			type: null,
			required: false
		},
		asChild: {
			type: Boolean,
			required: false
		},
		as: {
			type: null,
			required: false
		},
		disableOutsidePointerEvents: {
			type: Boolean,
			required: false
		}
	},
	emits: [
		"escapeKeyDown",
		"pointerDownOutside",
		"focusOutside",
		"interactOutside",
		"openAutoFocus",
		"closeAutoFocus"
	],
	setup(__props, { emit: __emit }) {
		const props = __props;
		const emits = __emit;
		const rootContext = injectPopoverRootContext();
		const forwarded = useForwardPropsEmits(props, emits);
		const { forwardRef } = useForwardExpose();
		rootContext.contentId ||= useId(void 0, "reka-popover-content");
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(Presence_default), { present: _ctx.forceMount || unref(rootContext).open.value }, {
				default: withCtx(() => [unref(rootContext).modal.value ? (openBlock(), createBlock(PopoverContentModal_default, mergeProps({ key: 0 }, unref(forwarded), { ref: unref(forwardRef) }), {
					default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
					_: 3
				}, 16)) : (openBlock(), createBlock(PopoverContentNonModal_default, mergeProps({ key: 1 }, unref(forwarded), { ref: unref(forwardRef) }), {
					default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
					_: 3
				}, 16))]),
				_: 3
			}, 8, ["present"]);
		};
	}
});
var PopoverPortal_default = /* @__PURE__ */ defineComponent({
	__name: "PopoverPortal",
	props: {
		to: {
			type: null,
			required: false
		},
		disabled: {
			type: Boolean,
			required: false
		},
		defer: {
			type: Boolean,
			required: false
		},
		forceMount: {
			type: Boolean,
			required: false
		}
	},
	setup(__props) {
		const props = __props;
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(Teleport_default), normalizeProps(guardReactiveProps(props)), {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 16);
		};
	}
});
var PopoverTrigger_default = /* @__PURE__ */ defineComponent({
	__name: "PopoverTrigger",
	props: {
		asChild: {
			type: Boolean,
			required: false
		},
		as: {
			type: null,
			required: false,
			default: "button"
		}
	},
	setup(__props) {
		const props = __props;
		const rootContext = injectPopoverRootContext();
		const { forwardRef, currentElement: triggerElement } = useForwardExpose();
		rootContext.triggerId ||= useId(void 0, "reka-popover-trigger");
		onMounted(() => {
			rootContext.triggerElement.value = triggerElement.value;
		});
		return (_ctx, _cache) => {
			return openBlock(), createBlock(resolveDynamicComponent(unref(rootContext).hasCustomAnchor.value ? unref(Primitive) : unref(PopperAnchor_default)), { "as-child": "" }, {
				default: withCtx(() => [createVNode(unref(Primitive), {
					id: unref(rootContext).triggerId,
					ref: unref(forwardRef),
					type: _ctx.as === "button" ? "button" : void 0,
					"aria-haspopup": "dialog",
					"aria-expanded": unref(rootContext).open.value,
					"aria-controls": unref(rootContext).contentId,
					"data-state": unref(rootContext).open.value ? "open" : "closed",
					as: _ctx.as,
					"as-child": props.asChild,
					onClick: unref(rootContext).onOpenToggle
				}, {
					default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
					_: 3
				}, 8, [
					"id",
					"type",
					"aria-expanded",
					"aria-controls",
					"data-state",
					"as",
					"as-child",
					"onClick"
				])]),
				_: 3
			});
		};
	}
});
var [injectDateRangeFieldRootContext, provideDateRangeFieldRootContext] = createContext("DateRangeFieldRoot");
var DateRangeFieldRoot_default = /* @__PURE__ */ defineComponent({
	inheritAttrs: false,
	__name: "DateRangeFieldRoot",
	props: {
		defaultValue: {
			type: Object,
			required: false,
			default: void 0
		},
		defaultPlaceholder: {
			type: null,
			required: false
		},
		placeholder: {
			type: null,
			required: false,
			default: void 0
		},
		modelValue: {
			type: [Object, null],
			required: false
		},
		hourCycle: {
			type: null,
			required: false
		},
		step: {
			type: Object,
			required: false
		},
		granularity: {
			type: String,
			required: false
		},
		hideTimeZone: {
			type: Boolean,
			required: false
		},
		maxValue: {
			type: null,
			required: false
		},
		minValue: {
			type: null,
			required: false
		},
		locale: {
			type: String,
			required: false
		},
		disabled: {
			type: Boolean,
			required: false,
			default: false
		},
		readonly: {
			type: Boolean,
			required: false,
			default: false
		},
		isDateUnavailable: {
			type: Function,
			required: false,
			default: void 0
		},
		id: {
			type: String,
			required: false
		},
		dir: {
			type: String,
			required: false
		},
		asChild: {
			type: Boolean,
			required: false
		},
		as: {
			type: null,
			required: false
		},
		name: {
			type: String,
			required: false
		},
		required: {
			type: Boolean,
			required: false
		}
	},
	emits: ["update:modelValue", "update:placeholder"],
	setup(__props, { expose: __expose, emit: __emit }) {
		const props = __props;
		const emits = __emit;
		const { disabled: disabled$9, readonly: readonly$1, isDateUnavailable: propsIsDateUnavailable, dir: propDir, locale: propLocale } = toRefs(props);
		const locale = useLocale(propLocale);
		const dir = useDirection(propDir);
		const formatter = useDateFormatter(locale.value, { hourCycle: normalizeHourCycle(props.hourCycle) });
		const { primitiveElement, currentElement: parentElement } = usePrimitiveElement();
		const segmentElements = ref(/* @__PURE__ */ new Set());
		onMounted(() => {
			getSegmentElements(parentElement.value).forEach((item$4) => segmentElements.value.add(item$4));
		});
		const modelValue = useVModel(props, "modelValue", emits, {
			defaultValue: props.defaultValue ?? {
				start: void 0,
				end: void 0
			},
			passive: props.modelValue === void 0
		});
		const defaultDate = getDefaultDate({
			defaultPlaceholder: props.placeholder,
			granularity: props.granularity,
			defaultValue: modelValue.value?.start,
			locale: props.locale
		});
		const placeholder$1 = useVModel(props, "placeholder", emits, {
			defaultValue: props.defaultPlaceholder ?? defaultDate.copy(),
			passive: props.placeholder === void 0
		});
		const step = computed(() => normalizeDateStep(props));
		const inferredGranularity = computed(() => {
			if (props.granularity) return !hasTime(placeholder$1.value) ? "day" : props.granularity;
			return hasTime(placeholder$1.value) ? "minute" : "day";
		});
		const isStartInvalid = computed(() => {
			if (!modelValue.value?.start) return false;
			if (propsIsDateUnavailable.value?.(modelValue.value.start)) return true;
			if (props.minValue && isBefore(modelValue.value.start, props.minValue)) return true;
			if (props.maxValue && isBefore(props.maxValue, modelValue.value.start)) return true;
			return false;
		});
		const isEndInvalid = computed(() => {
			if (!modelValue.value?.end) return false;
			if (propsIsDateUnavailable.value?.(modelValue.value.end)) return true;
			if (props.minValue && isBefore(modelValue.value.end, props.minValue)) return true;
			if (props.maxValue && isBefore(props.maxValue, modelValue.value.end)) return true;
			return false;
		});
		const isInvalid = computed(() => {
			if (isStartInvalid.value || isEndInvalid.value) return true;
			if (!modelValue.value?.start || !modelValue.value?.end) return false;
			if (!isBeforeOrSame(modelValue.value.start, modelValue.value.end)) return true;
			if (propsIsDateUnavailable.value !== void 0) {
				if (!areAllDaysBetweenValid(modelValue.value.start, modelValue.value.end, propsIsDateUnavailable.value, void 0)) return true;
			}
			return false;
		});
		const initialSegments = initializeSegmentValues(inferredGranularity.value);
		const startSegmentValues = ref(modelValue.value?.start ? { ...syncSegmentValues({
			value: modelValue.value.start,
			formatter
		}) } : { ...initialSegments });
		const endSegmentValues = ref(modelValue.value?.end ? { ...syncSegmentValues({
			value: modelValue.value.end,
			formatter
		}) } : { ...initialSegments });
		const startSegmentContent = computed(() => createContent({
			granularity: inferredGranularity.value,
			dateRef: placeholder$1.value,
			formatter,
			hideTimeZone: props.hideTimeZone,
			hourCycle: props.hourCycle,
			segmentValues: startSegmentValues.value,
			locale
		}));
		const endSegmentContent = computed(() => createContent({
			granularity: inferredGranularity.value,
			dateRef: placeholder$1.value,
			formatter,
			hideTimeZone: props.hideTimeZone,
			hourCycle: props.hourCycle,
			segmentValues: endSegmentValues.value,
			locale
		}));
		const segmentContents = computed(() => ({
			start: startSegmentContent.value.arr,
			end: endSegmentContent.value.arr
		}));
		const editableSegmentContents = computed(() => ({
			start: segmentContents.value.start.filter(({ part: part$1 }) => part$1 !== "literal"),
			end: segmentContents.value.end.filter(({ part: part$1 }) => part$1 !== "literal")
		}));
		const startValue = ref(modelValue.value?.start?.copy());
		const endValue = ref(modelValue.value?.end?.copy());
		watch([startValue, endValue], ([_startValue, _endValue]) => {
			modelValue.value = {
				start: _startValue?.copy(),
				end: _endValue?.copy()
			};
		});
		watch(modelValue, (_modelValue) => {
			if (_modelValue?.start && startValue.value ? _modelValue.start.compare(startValue.value) !== 0 : _modelValue?.start !== startValue.value) startValue.value = _modelValue?.start?.copy();
			if (_modelValue?.end && endValue.value ? _modelValue.end.compare(endValue.value) !== 0 : _modelValue?.end !== endValue.value) endValue.value = _modelValue?.end?.copy();
		});
		watch([startValue, locale], ([_startValue]) => {
			if (_startValue !== void 0) startSegmentValues.value = { ...syncSegmentValues({
				value: _startValue,
				formatter
			}) };
			else if (Object.values(startSegmentValues.value).every((value) => value !== null) && _startValue === void 0) startSegmentValues.value = { ...initialSegments };
		});
		watch(locale, (value) => {
			if (formatter.getLocale() !== value) {
				formatter.setLocale(value);
				nextTick(() => {
					segmentElements.value.clear();
					getSegmentElements(parentElement.value).forEach((item$4) => segmentElements.value.add(item$4));
				});
			}
		});
		watch(modelValue, (_modelValue) => {
			if (_modelValue && _modelValue.start !== void 0 && placeholder$1.value.compare(_modelValue.start) !== 0) placeholder$1.value = _modelValue.start.copy();
		});
		watch([endValue, locale], ([_endValue]) => {
			if (_endValue !== void 0) endSegmentValues.value = { ...syncSegmentValues({
				value: _endValue,
				formatter
			}) };
			else if (Object.values(endSegmentValues.value).every((value) => value !== null) && _endValue === void 0) endSegmentValues.value = { ...initialSegments };
		});
		const currentFocusedElement = ref(null);
		const currentSegmentIndex = computed(() => Array.from(segmentElements.value).findIndex((el$2) => el$2.getAttribute("data-reka-date-field-segment") === currentFocusedElement.value?.getAttribute("data-reka-date-field-segment") && el$2.getAttribute("data-reka-date-range-field-segment-type") === currentFocusedElement.value?.getAttribute("data-reka-date-range-field-segment-type")));
		const nextFocusableSegment = computed(() => {
			const sign = dir.value === "rtl" ? -1 : 1;
			if (sign < 0 ? currentSegmentIndex.value < 0 : currentSegmentIndex.value > segmentElements.value.size - 1) return null;
			return Array.from(segmentElements.value)[currentSegmentIndex.value + sign];
		});
		const prevFocusableSegment = computed(() => {
			const sign = dir.value === "rtl" ? -1 : 1;
			if (sign > 0 ? currentSegmentIndex.value < 0 : currentSegmentIndex.value > segmentElements.value.size - 1) return null;
			return Array.from(segmentElements.value)[currentSegmentIndex.value - sign];
		});
		const kbd = useKbd();
		function handleKeydown(e) {
			if (!isSegmentNavigationKey(e.key)) return;
			if (e.key === kbd.ARROW_LEFT) prevFocusableSegment.value?.focus();
			if (e.key === kbd.ARROW_RIGHT) nextFocusableSegment.value?.focus();
		}
		function setFocusedElement(el$2) {
			currentFocusedElement.value = el$2;
		}
		provideDateRangeFieldRootContext({
			isDateUnavailable: propsIsDateUnavailable.value,
			locale,
			startValue,
			endValue,
			placeholder: placeholder$1,
			disabled: disabled$9,
			formatter,
			hourCycle: props.hourCycle,
			step,
			readonly: readonly$1,
			segmentValues: {
				start: startSegmentValues,
				end: endSegmentValues
			},
			isInvalid,
			segmentContents: editableSegmentContents,
			elements: segmentElements,
			setFocusedElement,
			focusNext() {
				nextFocusableSegment.value?.focus();
			}
		});
		__expose({ setFocusedElement });
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(Primitive), mergeProps(_ctx.$attrs, {
				ref_key: "primitiveElement",
				ref: primitiveElement,
				role: "group",
				"aria-disabled": unref(disabled$9) ? true : void 0,
				"data-disabled": unref(disabled$9) ? "" : void 0,
				"data-readonly": unref(readonly$1) ? "" : void 0,
				"data-invalid": isInvalid.value ? "" : void 0,
				dir: unref(dir),
				onKeydown: withKeys(handleKeydown, ["left", "right"])
			}), {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default", {
					modelValue: unref(modelValue),
					segments: segmentContents.value
				}), createVNode(unref(VisuallyHidden_default), {
					id: _ctx.id,
					as: "input",
					feature: "focusable",
					tabindex: "-1",
					value: `${unref(modelValue)?.start?.toString()} - ${unref(modelValue)?.end?.toString()}`,
					name: _ctx.name,
					disabled: unref(disabled$9),
					required: _ctx.required,
					onFocus: _cache[0] || (_cache[0] = ($event) => Array.from(segmentElements.value)?.[0]?.focus())
				}, null, 8, [
					"id",
					"value",
					"name",
					"disabled",
					"required"
				])]),
				_: 3
			}, 16, [
				"aria-disabled",
				"data-disabled",
				"data-readonly",
				"data-invalid",
				"dir"
			]);
		};
	}
});
var DateRangeFieldInput_default = /* @__PURE__ */ defineComponent({
	__name: "DateRangeFieldInput",
	props: {
		part: {
			type: null,
			required: true
		},
		type: {
			type: String,
			required: true
		},
		asChild: {
			type: Boolean,
			required: false
		},
		as: {
			type: null,
			required: false
		}
	},
	setup(__props) {
		const props = __props;
		const rootContext = injectDateRangeFieldRootContext();
		const hasLeftFocus = ref(true);
		const { handleSegmentClick, handleSegmentKeydown, attributes } = useDateField({
			hasLeftFocus,
			lastKeyZero: ref(false),
			placeholder: rootContext.placeholder,
			hourCycle: rootContext.hourCycle,
			step: rootContext.step,
			segmentValues: rootContext.segmentValues[props.type],
			formatter: rootContext.formatter,
			part: props.part,
			disabled: rootContext.disabled,
			readonly: rootContext.readonly,
			focusNext: rootContext.focusNext,
			modelValue: props.type === "start" ? rootContext.startValue : rootContext.endValue
		});
		const disabled$9 = computed(() => rootContext.disabled.value);
		const readonly$1 = computed(() => rootContext.readonly.value);
		const isInvalid = computed(() => rootContext.isInvalid.value);
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(Primitive), mergeProps({
				as: _ctx.as,
				"as-child": _ctx.asChild
			}, unref(attributes), {
				contenteditable: disabled$9.value || readonly$1.value ? false : _ctx.part !== "literal",
				"data-reka-date-field-segment": _ctx.part,
				"aria-disabled": disabled$9.value ? true : void 0,
				"aria-readonly": readonly$1.value ? true : void 0,
				"data-disabled": disabled$9.value ? "" : void 0,
				"data-reka-date-range-field-segment-type": _ctx.type,
				"data-invalid": isInvalid.value ? "" : void 0,
				"aria-invalid": isInvalid.value ? true : void 0
			}, toHandlers(_ctx.part !== "literal" ? {
				mousedown: unref(handleSegmentClick),
				keydown: unref(handleSegmentKeydown),
				focusout: () => {
					hasLeftFocus.value = true;
				},
				focusin: (e) => {
					unref(rootContext).setFocusedElement(e.target);
				}
			} : {})), {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 16, [
				"as",
				"as-child",
				"contenteditable",
				"data-reka-date-field-segment",
				"aria-disabled",
				"aria-readonly",
				"data-disabled",
				"data-reka-date-range-field-segment-type",
				"data-invalid",
				"aria-invalid"
			]);
		};
	}
});
var [injectDateRangePickerRootContext, provideDateRangePickerRootContext] = createContext("DateRangePickerRoot");
var DateRangePickerRoot_default = /* @__PURE__ */ defineComponent({
	inheritAttrs: false,
	__name: "DateRangePickerRoot",
	props: {
		defaultValue: {
			type: Object,
			required: false,
			default: () => ({
				start: void 0,
				end: void 0
			})
		},
		defaultPlaceholder: {
			type: null,
			required: false
		},
		placeholder: {
			type: null,
			required: false,
			default: void 0
		},
		modelValue: {
			type: [Object, null],
			required: false
		},
		hourCycle: {
			type: null,
			required: false
		},
		step: {
			type: Object,
			required: false
		},
		granularity: {
			type: String,
			required: false
		},
		hideTimeZone: {
			type: Boolean,
			required: false
		},
		maxValue: {
			type: null,
			required: false
		},
		minValue: {
			type: null,
			required: false
		},
		locale: {
			type: String,
			required: false,
			default: "en"
		},
		disabled: {
			type: Boolean,
			required: false,
			default: false
		},
		readonly: {
			type: Boolean,
			required: false,
			default: false
		},
		isDateUnavailable: {
			type: Function,
			required: false,
			default: void 0
		},
		id: {
			type: String,
			required: false
		},
		dir: {
			type: String,
			required: false
		},
		asChild: {
			type: Boolean,
			required: false
		},
		as: {
			type: null,
			required: false
		},
		name: {
			type: String,
			required: false
		},
		required: {
			type: Boolean,
			required: false
		},
		defaultOpen: {
			type: Boolean,
			required: false,
			default: false
		},
		open: {
			type: Boolean,
			required: false,
			default: void 0
		},
		modal: {
			type: Boolean,
			required: false,
			default: false
		},
		isDateDisabled: {
			type: Function,
			required: false,
			default: void 0
		},
		pagedNavigation: {
			type: Boolean,
			required: false,
			default: false
		},
		weekStartsOn: {
			type: Number,
			required: false,
			default: 0
		},
		weekdayFormat: {
			type: String,
			required: false,
			default: "narrow"
		},
		fixedWeeks: {
			type: Boolean,
			required: false,
			default: false
		},
		numberOfMonths: {
			type: Number,
			required: false,
			default: 1
		},
		preventDeselect: {
			type: Boolean,
			required: false,
			default: false
		},
		isDateHighlightable: {
			type: Function,
			required: false,
			default: void 0
		},
		allowNonContiguousRanges: {
			type: Boolean,
			required: false,
			default: false
		},
		fixedDate: {
			type: String,
			required: false
		},
		maximumDays: {
			type: Number,
			required: false,
			default: void 0
		},
		closeOnSelect: {
			type: Boolean,
			required: false,
			default: false
		}
	},
	emits: [
		"update:modelValue",
		"update:placeholder",
		"update:startValue",
		"update:open"
	],
	setup(__props, { emit: __emit }) {
		const props = __props;
		const emits = __emit;
		const { locale, disabled: disabled$9, readonly: readonly$1, pagedNavigation, weekStartsOn, weekdayFormat, fixedWeeks, numberOfMonths, preventDeselect, isDateDisabled: propsIsDateDisabled, isDateUnavailable: propsIsDateUnavailable, isDateHighlightable: propsIsDateHighlightable, defaultOpen, modal, id: id$1, name: name$1, required, minValue, maxValue, granularity, hideTimeZone, hourCycle, dir: propsDir, allowNonContiguousRanges, fixedDate, maximumDays, step, closeOnSelect } = toRefs(props);
		const dir = useDirection(propsDir);
		const modelValue = useVModel(props, "modelValue", emits, {
			defaultValue: props.defaultValue ?? {
				start: void 0,
				end: void 0
			},
			passive: props.modelValue === void 0
		});
		const defaultDate = getDefaultDate({
			defaultPlaceholder: props.placeholder,
			granularity: props.granularity,
			defaultValue: modelValue.value?.start,
			locale: props.locale
		});
		const placeholder$1 = useVModel(props, "placeholder", emits, {
			defaultValue: props.defaultPlaceholder ?? defaultDate.copy(),
			passive: props.placeholder === void 0
		});
		const open = useVModel(props, "open", emits, {
			defaultValue: defaultOpen.value,
			passive: props.open === void 0
		});
		const dateFieldRef = ref();
		watch(modelValue, (value) => {
			if (value && value.start && value.start.compare(placeholder$1.value) !== 0) placeholder$1.value = value.start.copy();
			if (value.start && value.end) {
				if (closeOnSelect.value) open.value = false;
			}
		});
		provideDateRangePickerRootContext({
			allowNonContiguousRanges,
			isDateUnavailable: propsIsDateUnavailable.value,
			isDateDisabled: propsIsDateDisabled.value,
			isDateHighlightable: propsIsDateHighlightable.value,
			locale,
			disabled: disabled$9,
			pagedNavigation,
			weekStartsOn,
			weekdayFormat,
			fixedWeeks,
			numberOfMonths,
			readonly: readonly$1,
			preventDeselect,
			modelValue,
			placeholder: placeholder$1,
			defaultOpen,
			modal,
			open,
			id: id$1,
			name: name$1,
			required,
			minValue,
			maxValue,
			granularity,
			hideTimeZone,
			hourCycle,
			dateFieldRef,
			dir,
			fixedDate,
			maximumDays,
			step,
			onStartValueChange(date$1) {
				emits("update:startValue", date$1);
			},
			onDateChange(date$1) {
				modelValue.value = {
					start: date$1.start?.copy(),
					end: date$1.end?.copy()
				};
			},
			onPlaceholderChange(date$1) {
				placeholder$1.value = date$1.copy();
			},
			closeOnSelect
		});
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(PopoverRoot_default), {
				open: unref(open),
				"onUpdate:open": _cache[0] || (_cache[0] = ($event) => isRef(open) ? open.value = $event : null),
				"default-open": unref(defaultOpen),
				modal: unref(modal)
			}, {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default", {
					modelValue: unref(modelValue),
					open: unref(open)
				})]),
				_: 3
			}, 8, [
				"open",
				"default-open",
				"modal"
			]);
		};
	}
});
function useRangeCalendarState(props) {
	const isStartInvalid = computed(() => {
		if (!props.start.value) return false;
		if (props.isDateDisabled(props.start.value)) return true;
		return false;
	});
	const isEndInvalid = computed(() => {
		if (!props.end.value) return false;
		if (props.isDateDisabled(props.end.value)) return true;
		return false;
	});
	const isInvalid = computed(() => {
		if (isStartInvalid.value || isEndInvalid.value) return false;
		if (props.start.value && props.end.value && isBefore(props.end.value, props.start.value)) return true;
		return false;
	});
	const isSelectionStart = (date$1) => {
		if (!props.start.value) return false;
		return $14e0f24ef4ac5c92$export$ea39ec197993aef0(props.start.value, date$1);
	};
	const isSelectionEnd = (date$1) => {
		if (!props.end.value) return false;
		return $14e0f24ef4ac5c92$export$ea39ec197993aef0(props.end.value, date$1);
	};
	const isSelected = (date$1) => {
		if (props.start.value && $14e0f24ef4ac5c92$export$ea39ec197993aef0(props.start.value, date$1)) return true;
		if (props.end.value && $14e0f24ef4ac5c92$export$ea39ec197993aef0(props.end.value, date$1)) return true;
		if (props.end.value && props.start.value) return isBetween(date$1, props.start.value, props.end.value);
		return false;
	};
	const rangeIsDateDisabled = (date$1) => {
		if (props.isDateDisabled(date$1)) return true;
		if (props.maximumDays?.value) {
			if (props.start.value && props.end.value) {
				if (props.fixedDate.value) {
					const diff$1 = getDaysBetween(props.start.value, props.end.value).length;
					if (diff$1 <= props.maximumDays.value) {
						const daysLeft = props.maximumDays.value - diff$1 - 1;
						return !isBetween(date$1, props.start.value.subtract({ days: daysLeft }), props.end.value.add({ days: daysLeft }));
					}
				}
				return false;
			}
			if (props.start.value) {
				const maxDate = props.start.value.add({ days: props.maximumDays.value });
				return !isBetween(date$1, props.start.value.subtract({ days: props.maximumDays.value }), maxDate);
			}
		}
		if (!props.start.value || props.end.value || $14e0f24ef4ac5c92$export$ea39ec197993aef0(props.start.value, date$1)) return false;
		return false;
	};
	const isDateHighlightable = (date$1) => {
		if (props.isDateHighlightable?.(date$1)) return true;
		return false;
	};
	const highlightedRange = computed(() => {
		if (props.start.value && props.end.value && !props.fixedDate.value) return null;
		if (!props.start.value || !props.focusedValue.value) return null;
		const isStartBeforeFocused = isBefore(props.start.value, props.focusedValue.value);
		const start = isStartBeforeFocused ? props.start.value : props.focusedValue.value;
		const end$1 = isStartBeforeFocused ? props.focusedValue.value : props.start.value;
		if ($14e0f24ef4ac5c92$export$ea39ec197993aef0(start, end$1)) return {
			start,
			end: end$1
		};
		if (props.maximumDays?.value && !props.end.value) return {
			start,
			end: isStartBeforeFocused ? start.add({ days: props.maximumDays.value }) : start.subtract({ days: props.maximumDays.value })
		};
		if (areAllDaysBetweenValid(start, end$1, props.allowNonContiguousRanges.value ? () => false : props.isDateUnavailable, rangeIsDateDisabled, props.isDateHighlightable)) return {
			start,
			end: end$1
		};
		return null;
	});
	const isHighlightedStart = (date$1) => {
		if (!highlightedRange.value || !highlightedRange.value.start) return false;
		return $14e0f24ef4ac5c92$export$ea39ec197993aef0(highlightedRange.value.start, date$1);
	};
	const isHighlightedEnd = (date$1) => {
		if (!highlightedRange.value || !highlightedRange.value.end) return false;
		return $14e0f24ef4ac5c92$export$ea39ec197993aef0(highlightedRange.value.end, date$1);
	};
	return {
		isInvalid,
		isSelected,
		isDateHighlightable,
		highlightedRange,
		isSelectionStart,
		isSelectionEnd,
		isHighlightedStart,
		isHighlightedEnd,
		isDateDisabled: rangeIsDateDisabled
	};
}
var _hoisted_1$37 = { style: {
	"border": "0px",
	"clip": "rect(0px, 0px, 0px, 0px)",
	"clip-path": "inset(50%)",
	"height": "1px",
	"margin": "-1px",
	"overflow": "hidden",
	"padding": "0px",
	"position": "absolute",
	"white-space": "nowrap",
	"width": "1px"
} };
var _hoisted_2$22 = {
	role: "heading",
	"aria-level": "2"
};
var [injectRangeCalendarRootContext, provideRangeCalendarRootContext] = createContext("RangeCalendarRoot");
var RangeCalendarRoot_default = /* @__PURE__ */ defineComponent({
	__name: "RangeCalendarRoot",
	props: {
		defaultPlaceholder: {
			type: null,
			required: false
		},
		defaultValue: {
			type: Object,
			required: false,
			default: () => ({
				start: void 0,
				end: void 0
			})
		},
		modelValue: {
			type: [Object, null],
			required: false
		},
		placeholder: {
			type: null,
			required: false,
			default: void 0
		},
		allowNonContiguousRanges: {
			type: Boolean,
			required: false,
			default: false
		},
		pagedNavigation: {
			type: Boolean,
			required: false,
			default: false
		},
		preventDeselect: {
			type: Boolean,
			required: false,
			default: false
		},
		maximumDays: {
			type: Number,
			required: false,
			default: void 0
		},
		weekStartsOn: {
			type: Number,
			required: false,
			default: 0
		},
		weekdayFormat: {
			type: String,
			required: false,
			default: "narrow"
		},
		calendarLabel: {
			type: String,
			required: false
		},
		fixedWeeks: {
			type: Boolean,
			required: false,
			default: false
		},
		maxValue: {
			type: null,
			required: false
		},
		minValue: {
			type: null,
			required: false
		},
		locale: {
			type: String,
			required: false
		},
		numberOfMonths: {
			type: Number,
			required: false,
			default: 1
		},
		disabled: {
			type: Boolean,
			required: false,
			default: false
		},
		readonly: {
			type: Boolean,
			required: false,
			default: false
		},
		initialFocus: {
			type: Boolean,
			required: false,
			default: false
		},
		isDateDisabled: {
			type: Function,
			required: false,
			default: void 0
		},
		isDateUnavailable: {
			type: Function,
			required: false,
			default: void 0
		},
		isDateHighlightable: {
			type: Function,
			required: false,
			default: void 0
		},
		dir: {
			type: String,
			required: false
		},
		nextPage: {
			type: Function,
			required: false
		},
		prevPage: {
			type: Function,
			required: false
		},
		disableDaysOutsideCurrentView: {
			type: Boolean,
			required: false,
			default: false
		},
		fixedDate: {
			type: String,
			required: false
		},
		asChild: {
			type: Boolean,
			required: false
		},
		as: {
			type: null,
			required: false,
			default: "div"
		}
	},
	emits: [
		"update:modelValue",
		"update:validModelValue",
		"update:placeholder",
		"update:startValue"
	],
	setup(__props, { emit: __emit }) {
		const props = __props;
		const emits = __emit;
		const { disabled: disabled$9, readonly: readonly$1, initialFocus, pagedNavigation, weekStartsOn, weekdayFormat, fixedWeeks, numberOfMonths, preventDeselect, isDateUnavailable: propsIsDateUnavailable, isDateHighlightable: propsIsDateHighlightable, isDateDisabled: propsIsDateDisabled, calendarLabel, maxValue, minValue, dir: propDir, locale: propLocale, nextPage: propsNextPage, prevPage: propsPrevPage, allowNonContiguousRanges, disableDaysOutsideCurrentView, fixedDate, maximumDays } = toRefs(props);
		const { primitiveElement, currentElement: parentElement } = usePrimitiveElement();
		const dir = useDirection(propDir);
		const locale = useLocale(propLocale);
		const lastPressedDateValue = ref();
		const focusedValue = ref();
		const isEditing = ref(false);
		const modelValue = useVModel(props, "modelValue", emits, {
			defaultValue: props.defaultValue ?? {
				start: void 0,
				end: void 0
			},
			passive: props.modelValue === void 0
		});
		const validModelValue = ref(modelValue.value);
		watch(validModelValue, (value) => {
			emits("update:validModelValue", value);
		});
		const defaultDate = getDefaultDate({
			defaultPlaceholder: props.placeholder,
			defaultValue: modelValue.value.start,
			locale: props.locale
		});
		const startValue = ref(modelValue.value.start);
		const endValue = ref(modelValue.value.end);
		const placeholder$1 = useVModel(props, "placeholder", emits, {
			defaultValue: props.defaultPlaceholder ?? defaultDate.copy(),
			passive: props.placeholder === void 0
		});
		function onPlaceholderChange(value) {
			placeholder$1.value = value.copy();
		}
		const { fullCalendarLabel, headingValue, isDateDisabled, isDateUnavailable, isNextButtonDisabled, isPrevButtonDisabled, grid: grid$1, weekdays, isOutsideVisibleView, nextPage, prevPage, formatter } = useCalendar({
			locale,
			placeholder: placeholder$1,
			weekStartsOn,
			fixedWeeks,
			numberOfMonths,
			minValue,
			maxValue,
			disabled: disabled$9,
			weekdayFormat,
			pagedNavigation,
			isDateDisabled: propsIsDateDisabled.value,
			isDateUnavailable: propsIsDateUnavailable.value,
			calendarLabel,
			nextPage: propsNextPage,
			prevPage: propsPrevPage
		});
		const { isInvalid, isSelected, isDateHighlightable, highlightedRange, isSelectionStart, isSelectionEnd, isHighlightedStart, isHighlightedEnd, isDateDisabled: rangeIsDateDisabled } = useRangeCalendarState({
			start: startValue,
			end: endValue,
			isDateDisabled,
			isDateUnavailable,
			isDateHighlightable: propsIsDateHighlightable.value,
			focusedValue,
			allowNonContiguousRanges,
			fixedDate,
			maximumDays
		});
		watch(modelValue, (_modelValue, _prevValue) => {
			if (!_prevValue?.start && _modelValue?.start || !_modelValue || !_modelValue.start || startValue.value && !$14e0f24ef4ac5c92$export$91b62ebf2ba703ee(_modelValue.start, startValue.value)) startValue.value = _modelValue?.start?.copy?.();
			if (!_prevValue?.end && _modelValue.end || !_modelValue || !_modelValue.end || endValue.value && !$14e0f24ef4ac5c92$export$91b62ebf2ba703ee(_modelValue.end, endValue.value)) endValue.value = _modelValue?.end?.copy?.();
		});
		watch(startValue, (_startValue) => {
			if (_startValue && !$14e0f24ef4ac5c92$export$91b62ebf2ba703ee(_startValue, placeholder$1.value)) onPlaceholderChange(_startValue);
			emits("update:startValue", _startValue);
		});
		watch([startValue, endValue], ([_startValue, _endValue]) => {
			const value = modelValue.value;
			if (value && value.start && value.end && _startValue && _endValue && $14e0f24ef4ac5c92$export$91b62ebf2ba703ee(value.start, _startValue) && $14e0f24ef4ac5c92$export$91b62ebf2ba703ee(value.end, _endValue)) return;
			isEditing.value = true;
			if (_endValue && _startValue) {
				if (isBefore(_endValue, _startValue)) modelValue.value = {
					start: _endValue.copy(),
					end: _startValue.copy()
				};
				else modelValue.value = {
					start: _startValue.copy(),
					end: _endValue.copy()
				};
				isEditing.value = false;
				validModelValue.value = {
					start: modelValue.value.start?.copy(),
					end: modelValue.value.end?.copy()
				};
			} else if (_startValue) modelValue.value = {
				start: _startValue.copy(),
				end: void 0
			};
			else modelValue.value = {
				start: _endValue?.copy(),
				end: void 0
			};
		});
		const kbd = useKbd();
		useEventListener("keydown", (ev) => {
			if (ev.key === kbd.ESCAPE && isEditing.value) {
				startValue.value = validModelValue.value.start?.copy();
				endValue.value = validModelValue.value.end?.copy();
			}
		});
		provideRangeCalendarRootContext({
			isDateUnavailable,
			isDateHighlightable,
			startValue,
			endValue,
			formatter,
			modelValue,
			placeholder: placeholder$1,
			disabled: disabled$9,
			initialFocus,
			pagedNavigation,
			grid: grid$1,
			weekDays: weekdays,
			weekStartsOn,
			weekdayFormat,
			fixedWeeks,
			numberOfMonths,
			readonly: readonly$1,
			preventDeselect,
			fullCalendarLabel,
			headingValue,
			isInvalid,
			isDateDisabled: rangeIsDateDisabled,
			allowNonContiguousRanges,
			highlightedRange,
			focusedValue,
			lastPressedDateValue,
			isSelected,
			isSelectionEnd,
			isSelectionStart,
			isNextButtonDisabled,
			isPrevButtonDisabled,
			isOutsideVisibleView,
			nextPage,
			prevPage,
			parentElement,
			onPlaceholderChange,
			locale,
			dir,
			isHighlightedStart,
			isHighlightedEnd,
			disableDaysOutsideCurrentView,
			fixedDate,
			maximumDays
		});
		onMounted(() => {
			if (initialFocus.value) handleCalendarInitialFocus(parentElement.value);
		});
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(Primitive), {
				ref_key: "primitiveElement",
				ref: primitiveElement,
				as: _ctx.as,
				"as-child": _ctx.asChild,
				role: "application",
				"aria-label": unref(fullCalendarLabel),
				"data-readonly": unref(readonly$1) ? "" : void 0,
				"data-disabled": unref(disabled$9) ? "" : void 0,
				"data-invalid": unref(isInvalid) ? "" : void 0,
				dir: unref(dir)
			}, {
				default: withCtx(() => [createBaseVNode("div", _hoisted_1$37, [createBaseVNode("div", _hoisted_2$22, toDisplayString(unref(fullCalendarLabel)), 1)]), renderSlot(_ctx.$slots, "default", {
					date: unref(placeholder$1),
					grid: unref(grid$1),
					weekDays: unref(weekdays),
					weekStartsOn: unref(weekStartsOn),
					locale: unref(locale),
					fixedWeeks: unref(fixedWeeks),
					modelValue: unref(modelValue)
				})]),
				_: 3
			}, 8, [
				"as",
				"as-child",
				"aria-label",
				"data-readonly",
				"data-disabled",
				"data-invalid",
				"dir"
			]);
		};
	}
});
var DateRangePickerCalendar_default = /* @__PURE__ */ defineComponent({
	__name: "DateRangePickerCalendar",
	setup(__props) {
		const rootContext = injectDateRangePickerRootContext();
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(RangeCalendarRoot_default), mergeProps({
				allowNonContiguousRanges: unref(rootContext).allowNonContiguousRanges.value,
				isDateDisabled: unref(rootContext).isDateDisabled,
				isDateUnavailable: unref(rootContext).isDateUnavailable,
				isDateHighlightable: unref(rootContext).isDateHighlightable,
				locale: unref(rootContext).locale.value,
				disabled: unref(rootContext).disabled.value,
				pagedNavigation: unref(rootContext).pagedNavigation.value,
				weekStartsOn: unref(rootContext).weekStartsOn.value,
				weekdayFormat: unref(rootContext).weekdayFormat.value,
				fixedWeeks: unref(rootContext).fixedWeeks.value,
				numberOfMonths: unref(rootContext).numberOfMonths.value,
				readonly: unref(rootContext).readonly.value,
				preventDeselect: unref(rootContext).preventDeselect.value,
				minValue: unref(rootContext).minValue.value,
				maxValue: unref(rootContext).maxValue.value,
				dir: unref(rootContext).dir.value,
				fixedDate: unref(rootContext).fixedDate.value,
				maximumDays: unref(rootContext).maximumDays?.value
			}, {
				"model-value": unref(rootContext).modelValue.value,
				placeholder: unref(rootContext).placeholder.value,
				"onUpdate:startValue": _cache[0] || (_cache[0] = (date$1) => {
					unref(rootContext).onStartValueChange(date$1);
				}),
				"onUpdate:modelValue": _cache[1] || (_cache[1] = (date$1) => {
					if (date$1.start && unref(rootContext).modelValue.value?.start && date$1.end && unref(rootContext).modelValue.value?.end && unref($14e0f24ef4ac5c92$export$91b62ebf2ba703ee)(date$1.start, unref(rootContext).modelValue.value?.start) && unref($14e0f24ef4ac5c92$export$91b62ebf2ba703ee)(date$1.end, unref(rootContext).modelValue.value?.end)) return;
					unref(rootContext).onDateChange(date$1);
				}),
				"onUpdate:placeholder": _cache[2] || (_cache[2] = (date$1) => {
					if (unref($14e0f24ef4ac5c92$export$91b62ebf2ba703ee)(date$1, unref(rootContext).placeholder.value)) return;
					unref(rootContext).onPlaceholderChange(date$1);
				})
			}), {
				default: withCtx(({ weekDays, grid: grid$1, date: date$1, weekStartsOn, locale, fixedWeeks }) => [renderSlot(_ctx.$slots, "default", {
					date: date$1,
					grid: grid$1,
					weekDays,
					weekStartsOn,
					locale,
					fixedWeeks
				})]),
				_: 3
			}, 16, ["model-value", "placeholder"]);
		};
	}
});
var RangeCalendarCell_default = /* @__PURE__ */ defineComponent({
	__name: "RangeCalendarCell",
	props: {
		date: {
			type: null,
			required: true
		},
		asChild: {
			type: Boolean,
			required: false
		},
		as: {
			type: null,
			required: false,
			default: "td"
		}
	},
	setup(__props) {
		const rootContext = injectRangeCalendarRootContext();
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(Primitive), {
				as: _ctx.as,
				"as-child": _ctx.asChild,
				role: "gridcell",
				"aria-selected": unref(rootContext).isSelected(_ctx.date) ? true : void 0,
				"aria-disabled": unref(rootContext).isDateDisabled(_ctx.date) || unref(rootContext).isDateUnavailable?.(_ctx.date) || unref(rootContext).disableDaysOutsideCurrentView.value,
				"data-disabled": unref(rootContext).isDateDisabled(_ctx.date) || unref(rootContext).disableDaysOutsideCurrentView.value ? "" : void 0
			}, {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 8, [
				"as",
				"as-child",
				"aria-selected",
				"aria-disabled",
				"data-disabled"
			]);
		};
	}
});
var DateRangePickerCell_default = /* @__PURE__ */ defineComponent({
	__name: "DateRangePickerCell",
	props: {
		date: {
			type: null,
			required: true
		},
		asChild: {
			type: Boolean,
			required: false
		},
		as: {
			type: null,
			required: false
		}
	},
	setup(__props) {
		const props = __props;
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(RangeCalendarCell_default), normalizeProps(guardReactiveProps(props)), {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 16);
		};
	}
});
var RangeCalendarCellTrigger_default = /* @__PURE__ */ defineComponent({
	__name: "RangeCalendarCellTrigger",
	props: {
		day: {
			type: null,
			required: true
		},
		month: {
			type: null,
			required: true
		},
		asChild: {
			type: Boolean,
			required: false
		},
		as: {
			type: null,
			required: false,
			default: "div"
		}
	},
	setup(__props) {
		const props = __props;
		const rootContext = injectRangeCalendarRootContext();
		const kbd = useKbd();
		const { primitiveElement, currentElement } = usePrimitiveElement();
		const labelText = computed(() => rootContext.formatter.custom(toDate(props.day), {
			weekday: "long",
			month: "long",
			day: "numeric",
			year: "numeric"
		}));
		const isUnavailable = computed(() => rootContext.isDateUnavailable?.(props.day) ?? false);
		const isSelectedDate = computed(() => rootContext.isSelected(props.day));
		const isSelectionStart = computed(() => rootContext.isSelectionStart(props.day));
		const isSelectionEnd = computed(() => rootContext.isSelectionEnd(props.day));
		const isHighlightStart = computed(() => rootContext.isHighlightedStart(props.day));
		const isHighlightEnd = computed(() => rootContext.isHighlightedEnd(props.day));
		const isHighlighted = computed(() => rootContext.highlightedRange.value ? isBetweenInclusive(props.day, rootContext.highlightedRange.value.start, rootContext.highlightedRange.value.end) : false);
		const allowNonContiguousRanges = computed(() => rootContext.allowNonContiguousRanges.value);
		const isDateToday = computed(() => {
			return $14e0f24ef4ac5c92$export$629b0a497aa65267(props.day, $14e0f24ef4ac5c92$export$aa8b41735afcabd2());
		});
		const isOutsideView = computed(() => {
			return !$14e0f24ef4ac5c92$export$a18c89cbd24170ff(props.day, props.month);
		});
		const isOutsideVisibleView = computed(() => rootContext.isOutsideVisibleView(props.day));
		const isDisabled = computed(() => rootContext.isDateDisabled(props.day) || rootContext.disableDaysOutsideCurrentView.value && isOutsideView.value);
		const dayValue = computed(() => props.day.day.toLocaleString(rootContext.locale.value));
		const isFocusedDate = computed(() => {
			return !rootContext.disabled.value && $14e0f24ef4ac5c92$export$ea39ec197993aef0(props.day, rootContext.placeholder.value);
		});
		function changeDate(e, date$1) {
			if (rootContext.readonly.value) return;
			if (rootContext.isDateDisabled(date$1) || rootContext.isDateUnavailable?.(date$1)) return;
			rootContext.lastPressedDateValue.value = date$1.copy();
			if (rootContext.startValue.value && rootContext.highlightedRange.value === null) {
				if ($14e0f24ef4ac5c92$export$ea39ec197993aef0(date$1, rootContext.startValue.value) && !rootContext.preventDeselect.value && !rootContext.endValue.value) {
					rootContext.startValue.value = void 0;
					rootContext.onPlaceholderChange(date$1);
					return;
				} else if (!rootContext.endValue.value) {
					e.preventDefault();
					if (rootContext.lastPressedDateValue.value && $14e0f24ef4ac5c92$export$ea39ec197993aef0(rootContext.lastPressedDateValue.value, date$1)) rootContext.startValue.value = date$1.copy();
					return;
				}
			}
			if (rootContext.startValue.value && rootContext.endValue.value && $14e0f24ef4ac5c92$export$ea39ec197993aef0(rootContext.endValue.value, date$1) && !rootContext.preventDeselect.value) {
				rootContext.startValue.value = void 0;
				rootContext.endValue.value = void 0;
				rootContext.onPlaceholderChange(date$1);
				return;
			}
			if (!rootContext.startValue.value) rootContext.startValue.value = date$1.copy();
			else if (!rootContext.endValue.value) rootContext.endValue.value = date$1.copy();
			else if (rootContext.endValue.value && rootContext.startValue.value) {
				if (!rootContext.fixedDate.value) {
					rootContext.endValue.value = void 0;
					rootContext.startValue.value = date$1.copy();
				} else if (rootContext.fixedDate.value === "start") if (date$1.compare(rootContext.startValue.value) < 0) rootContext.startValue.value = date$1.copy();
				else rootContext.endValue.value = date$1.copy();
				else if (rootContext.fixedDate.value === "end") if (date$1.compare(rootContext.endValue.value) > 0) rootContext.endValue.value = date$1.copy();
				else rootContext.startValue.value = date$1.copy();
			}
		}
		function handleClick(e) {
			if (isDisabled.value) return;
			changeDate(e, props.day);
		}
		function handleFocus() {
			if (isDisabled.value || rootContext.isDateUnavailable?.(props.day)) return;
			rootContext.focusedValue.value = props.day.copy();
		}
		function handleArrowKey(e) {
			if (isDisabled.value) return;
			e.preventDefault();
			e.stopPropagation();
			const parentElement = rootContext.parentElement.value;
			const indexIncrementation = 7;
			const sign = rootContext.dir.value === "rtl" ? -1 : 1;
			switch (e.code) {
				case kbd.ARROW_RIGHT:
					shiftFocus(currentElement.value, sign);
					break;
				case kbd.ARROW_LEFT:
					shiftFocus(currentElement.value, -sign);
					break;
				case kbd.ARROW_UP:
					shiftFocus(currentElement.value, -indexIncrementation);
					break;
				case kbd.ARROW_DOWN:
					shiftFocus(currentElement.value, indexIncrementation);
					break;
				case kbd.ENTER:
				case kbd.SPACE_CODE: changeDate(e, props.day);
			}
			function shiftFocus(node, add$1) {
				const allCollectionItems = getSelectableCells(parentElement);
				if (!allCollectionItems.length) return;
				const newIndex = allCollectionItems.indexOf(node) + add$1;
				if (newIndex >= 0 && newIndex < allCollectionItems.length) {
					if (allCollectionItems[newIndex].hasAttribute("data-disabled")) shiftFocus(allCollectionItems[newIndex], add$1);
					allCollectionItems[newIndex].focus();
					return;
				}
				if (newIndex < 0) {
					if (rootContext.isPrevButtonDisabled()) return;
					rootContext.prevPage();
					nextTick(() => {
						const newCollectionItems = getSelectableCells(parentElement);
						if (!newCollectionItems.length) return;
						if (!rootContext.pagedNavigation.value && rootContext.numberOfMonths.value > 1) {
							const computedIndex$1 = getDaysInMonth(rootContext.placeholder.value) - Math.abs(newIndex);
							if (newCollectionItems[computedIndex$1].hasAttribute("data-disabled")) shiftFocus(newCollectionItems[computedIndex$1], add$1);
							newCollectionItems[computedIndex$1].focus();
							return;
						}
						const computedIndex = newCollectionItems.length - Math.abs(newIndex);
						if (newCollectionItems[computedIndex].hasAttribute("data-disabled")) shiftFocus(newCollectionItems[computedIndex], add$1);
						newCollectionItems[computedIndex].focus();
					});
					return;
				}
				if (newIndex >= allCollectionItems.length) {
					if (rootContext.isNextButtonDisabled()) return;
					rootContext.nextPage();
					nextTick(() => {
						const newCollectionItems = getSelectableCells(parentElement);
						if (!newCollectionItems.length) return;
						if (!rootContext.pagedNavigation.value && rootContext.numberOfMonths.value > 1) {
							const numberOfDays = getDaysInMonth(rootContext.placeholder.value.add({ months: rootContext.numberOfMonths.value - 1 }));
							const computedIndex$1 = newIndex - allCollectionItems.length + (newCollectionItems.length - numberOfDays);
							if (newCollectionItems[computedIndex$1].hasAttribute("data-disabled")) shiftFocus(newCollectionItems[computedIndex$1], add$1);
							newCollectionItems[computedIndex$1].focus();
							return;
						}
						const computedIndex = newIndex - allCollectionItems.length;
						if (newCollectionItems[computedIndex].hasAttribute("data-disabled")) shiftFocus(newCollectionItems[computedIndex], add$1);
						newCollectionItems[computedIndex].focus();
					});
				}
			}
		}
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(Primitive), mergeProps({
				ref_key: "primitiveElement",
				ref: primitiveElement
			}, props, {
				role: "button",
				"aria-label": labelText.value,
				"data-reka-calendar-cell-trigger": "",
				"aria-selected": isSelectedDate.value && (allowNonContiguousRanges.value || !isUnavailable.value) ? true : void 0,
				"aria-disabled": isDisabled.value || isUnavailable.value ? true : void 0,
				"data-highlighted": isHighlighted.value && (allowNonContiguousRanges.value || !isUnavailable.value) ? "" : void 0,
				"data-selection-start": isSelectionStart.value ? true : void 0,
				"data-selection-end": isSelectionEnd.value ? true : void 0,
				"data-highlighted-start": isHighlightStart.value ? true : void 0,
				"data-highlighted-end": isHighlightEnd.value ? true : void 0,
				"data-selected": isSelectedDate.value && (allowNonContiguousRanges.value || !isUnavailable.value) ? true : void 0,
				"data-outside-visible-view": isOutsideVisibleView.value ? "" : void 0,
				"data-value": _ctx.day.toString(),
				"data-disabled": isDisabled.value ? "" : void 0,
				"data-unavailable": isUnavailable.value ? "" : void 0,
				"data-today": isDateToday.value ? "" : void 0,
				"data-outside-view": isOutsideView.value ? "" : void 0,
				"data-focused": isFocusedDate.value ? "" : void 0,
				tabindex: isFocusedDate.value ? 0 : isOutsideView.value || isDisabled.value ? void 0 : -1,
				onClick: handleClick,
				onFocusin: handleFocus,
				onMouseenter: handleFocus,
				onKeydown: withKeys(handleArrowKey, [
					"up",
					"down",
					"left",
					"right",
					"enter",
					"space"
				])
			}), {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default", {
					dayValue: dayValue.value,
					disabled: isDisabled.value,
					today: isDateToday.value,
					selected: isSelectedDate.value,
					outsideView: isOutsideView.value,
					outsideVisibleView: isOutsideVisibleView.value,
					unavailable: isUnavailable.value,
					highlighted: isHighlighted.value && (allowNonContiguousRanges.value || !isUnavailable.value),
					highlightedStart: isHighlightStart.value,
					highlightedEnd: isHighlightEnd.value,
					selectionStart: isSelectionStart.value,
					selectionEnd: isSelectionEnd.value
				}, () => [createTextVNode(toDisplayString(dayValue.value), 1)])]),
				_: 3
			}, 16, [
				"aria-label",
				"aria-selected",
				"aria-disabled",
				"data-highlighted",
				"data-selection-start",
				"data-selection-end",
				"data-highlighted-start",
				"data-highlighted-end",
				"data-selected",
				"data-outside-visible-view",
				"data-value",
				"data-disabled",
				"data-unavailable",
				"data-today",
				"data-outside-view",
				"data-focused",
				"tabindex"
			]);
		};
	}
});
var DateRangePickerCellTrigger_default = /* @__PURE__ */ defineComponent({
	__name: "DateRangePickerCellTrigger",
	props: {
		day: {
			type: null,
			required: true
		},
		month: {
			type: null,
			required: true
		},
		asChild: {
			type: Boolean,
			required: false
		},
		as: {
			type: null,
			required: false
		}
	},
	setup(__props) {
		const props = __props;
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(RangeCalendarCellTrigger_default), normalizeProps(guardReactiveProps(props)), {
				default: withCtx((slotProps) => [renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps(slotProps)))]),
				_: 3
			}, 16);
		};
	}
});
var DateRangePickerContent_default = /* @__PURE__ */ defineComponent({
	__name: "DateRangePickerContent",
	props: {
		portal: {
			type: Object,
			required: false
		},
		forceMount: {
			type: Boolean,
			required: false
		},
		side: {
			type: null,
			required: false
		},
		sideOffset: {
			type: Number,
			required: false
		},
		sideFlip: {
			type: Boolean,
			required: false
		},
		align: {
			type: null,
			required: false
		},
		alignOffset: {
			type: Number,
			required: false
		},
		alignFlip: {
			type: Boolean,
			required: false
		},
		avoidCollisions: {
			type: Boolean,
			required: false
		},
		collisionBoundary: {
			type: null,
			required: false
		},
		collisionPadding: {
			type: [Number, Object],
			required: false
		},
		arrowPadding: {
			type: Number,
			required: false
		},
		sticky: {
			type: String,
			required: false
		},
		hideWhenDetached: {
			type: Boolean,
			required: false
		},
		positionStrategy: {
			type: String,
			required: false
		},
		updatePositionStrategy: {
			type: String,
			required: false
		},
		disableUpdateOnLayoutShift: {
			type: Boolean,
			required: false
		},
		prioritizePosition: {
			type: Boolean,
			required: false
		},
		reference: {
			type: null,
			required: false
		},
		asChild: {
			type: Boolean,
			required: false
		},
		as: {
			type: null,
			required: false
		},
		disableOutsidePointerEvents: {
			type: Boolean,
			required: false
		}
	},
	emits: [
		"escapeKeyDown",
		"pointerDownOutside",
		"focusOutside",
		"interactOutside",
		"openAutoFocus",
		"closeAutoFocus"
	],
	setup(__props, { emit: __emit }) {
		const props = __props;
		const emits = __emit;
		const forwarded = useForwardPropsEmits(computed(() => ({
			...props,
			portal: void 0
		})), emits);
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(PopoverPortal_default), normalizeProps(guardReactiveProps(_ctx.portal)), {
				default: withCtx(() => [createVNode(unref(PopoverContent_default), mergeProps({
					...unref(forwarded),
					..._ctx.$attrs
				}, { onOpenAutoFocus: _cache[0] || (_cache[0] = (event) => {
					emits("openAutoFocus", event);
					if (!event.defaultPrevented && event.target) {
						unref(handleCalendarInitialFocus)(event.target);
						event.preventDefault();
					}
				}) }), {
					default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
					_: 3
				}, 16)]),
				_: 3
			}, 16);
		};
	}
});
var DateRangePickerField_default$1 = /* @__PURE__ */ defineComponent({
	__name: "DateRangePickerField",
	setup(__props) {
		const rootContext = injectDateRangePickerRootContext();
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(DateRangeFieldRoot_default), mergeProps({
				ref: unref(rootContext).dateFieldRef,
				"model-value": unref(rootContext).modelValue.value,
				placeholder: unref(rootContext).placeholder.value
			}, {
				id: unref(rootContext).id.value,
				name: unref(rootContext).name.value,
				disabled: unref(rootContext).disabled.value,
				minValue: unref(rootContext).minValue.value,
				maxValue: unref(rootContext).maxValue.value,
				readonly: unref(rootContext).readonly.value,
				hourCycle: unref(rootContext).hourCycle.value,
				granularity: unref(rootContext).granularity.value,
				hideTimeZone: unref(rootContext).hideTimeZone.value,
				locale: unref(rootContext).locale.value,
				isDateUnavailable: unref(rootContext).isDateUnavailable,
				required: unref(rootContext).required.value,
				dir: unref(rootContext).dir.value,
				step: unref(rootContext).step.value
			}, {
				"onUpdate:modelValue": _cache[0] || (_cache[0] = (date$1) => {
					if (date$1.start && unref(rootContext).modelValue.value.start && date$1.end && unref(rootContext).modelValue.value.end && date$1.start.compare(unref(rootContext).modelValue.value.start) === 0 && date$1.end.compare(unref(rootContext).modelValue.value.end) === 0) return;
					unref(rootContext).onDateChange(date$1);
				}),
				"onUpdate:placeholder": _cache[1] || (_cache[1] = (date$1) => {
					if (unref($14e0f24ef4ac5c92$export$91b62ebf2ba703ee)(date$1, unref(rootContext).placeholder.value) && date$1.compare(unref(rootContext).placeholder.value) === 0) return;
					unref(rootContext).onPlaceholderChange(date$1);
				})
			}), {
				default: withCtx(({ segments, modelValue }) => [renderSlot(_ctx.$slots, "default", {
					segments,
					modelValue
				})]),
				_: 3
			}, 16, ["model-value", "placeholder"]);
		};
	}
});
var RangeCalendarGrid_default = /* @__PURE__ */ defineComponent({
	__name: "RangeCalendarGrid",
	props: {
		asChild: {
			type: Boolean,
			required: false
		},
		as: {
			type: null,
			required: false,
			default: "table"
		}
	},
	setup(__props) {
		const props = __props;
		const rootContext = injectRangeCalendarRootContext();
		const disabled$9 = computed(() => rootContext.disabled.value ? true : void 0);
		const readonly$1 = computed(() => rootContext.readonly.value ? true : void 0);
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(Primitive), mergeProps(props, {
				tabindex: "-1",
				role: "grid",
				"aria-readonly": readonly$1.value,
				"aria-disabled": disabled$9.value,
				"data-readonly": readonly$1.value && "",
				"data-disabled": disabled$9.value && ""
			}), {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 16, [
				"aria-readonly",
				"aria-disabled",
				"data-readonly",
				"data-disabled"
			]);
		};
	}
});
var DateRangePickerGrid_default = /* @__PURE__ */ defineComponent({
	__name: "DateRangePickerGrid",
	props: {
		asChild: {
			type: Boolean,
			required: false
		},
		as: {
			type: null,
			required: false
		}
	},
	setup(__props) {
		const props = __props;
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(RangeCalendarGrid_default), normalizeProps(guardReactiveProps(props)), {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 16);
		};
	}
});
var RangeCalendarGridBody_default = /* @__PURE__ */ defineComponent({
	__name: "RangeCalendarGridBody",
	props: {
		asChild: {
			type: Boolean,
			required: false
		},
		as: {
			type: null,
			required: false,
			default: "tbody"
		}
	},
	setup(__props) {
		const props = __props;
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(Primitive), normalizeProps(guardReactiveProps(props)), {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 16);
		};
	}
});
var DateRangePickerGridBody_default = /* @__PURE__ */ defineComponent({
	__name: "DateRangePickerGridBody",
	props: {
		asChild: {
			type: Boolean,
			required: false
		},
		as: {
			type: null,
			required: false
		}
	},
	setup(__props) {
		const props = __props;
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(RangeCalendarGridBody_default), normalizeProps(guardReactiveProps(props)), {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 16);
		};
	}
});
var RangeCalendarGridHead_default = /* @__PURE__ */ defineComponent({
	__name: "RangeCalendarGridHead",
	props: {
		asChild: {
			type: Boolean,
			required: false
		},
		as: {
			type: null,
			required: false,
			default: "thead"
		}
	},
	setup(__props) {
		const props = __props;
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(Primitive), mergeProps(props, { "aria-hidden": "true" }), {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 16);
		};
	}
});
var DateRangePickerGridHead_default = /* @__PURE__ */ defineComponent({
	__name: "DateRangePickerGridHead",
	props: {
		asChild: {
			type: Boolean,
			required: false
		},
		as: {
			type: null,
			required: false
		}
	},
	setup(__props) {
		const props = __props;
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(RangeCalendarGridHead_default), normalizeProps(guardReactiveProps(props)), {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 16);
		};
	}
});
var RangeCalendarGridRow_default = /* @__PURE__ */ defineComponent({
	__name: "RangeCalendarGridRow",
	props: {
		asChild: {
			type: Boolean,
			required: false
		},
		as: {
			type: null,
			required: false,
			default: "tr"
		}
	},
	setup(__props) {
		const props = __props;
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(Primitive), normalizeProps(guardReactiveProps(props)), {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 16);
		};
	}
});
var DateRangePickerGridRow_default = /* @__PURE__ */ defineComponent({
	__name: "DateRangePickerGridRow",
	props: {
		asChild: {
			type: Boolean,
			required: false
		},
		as: {
			type: null,
			required: false
		}
	},
	setup(__props) {
		const props = __props;
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(RangeCalendarGridRow_default), normalizeProps(guardReactiveProps(props)), {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 16);
		};
	}
});
var RangeCalendarHeadCell_default = /* @__PURE__ */ defineComponent({
	__name: "RangeCalendarHeadCell",
	props: {
		asChild: {
			type: Boolean,
			required: false
		},
		as: {
			type: null,
			required: false,
			default: "th"
		}
	},
	setup(__props) {
		const props = __props;
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(Primitive), normalizeProps(guardReactiveProps(props)), {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 16);
		};
	}
});
var DateRangePickerHeadCell_default = /* @__PURE__ */ defineComponent({
	__name: "DateRangePickerHeadCell",
	props: {
		asChild: {
			type: Boolean,
			required: false
		},
		as: {
			type: null,
			required: false
		}
	},
	setup(__props) {
		const props = __props;
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(RangeCalendarHeadCell_default), normalizeProps(guardReactiveProps(props)), {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 16);
		};
	}
});
var RangeCalendarHeader_default = /* @__PURE__ */ defineComponent({
	__name: "RangeCalendarHeader",
	props: {
		asChild: {
			type: Boolean,
			required: false
		},
		as: {
			type: null,
			required: false,
			default: "div"
		}
	},
	setup(__props) {
		const props = __props;
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(Primitive), normalizeProps(guardReactiveProps(props)), {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 16);
		};
	}
});
var DateRangePickerHeader_default = /* @__PURE__ */ defineComponent({
	__name: "DateRangePickerHeader",
	props: {
		asChild: {
			type: Boolean,
			required: false
		},
		as: {
			type: null,
			required: false
		}
	},
	setup(__props) {
		const props = __props;
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(RangeCalendarHeader_default), normalizeProps(guardReactiveProps(props)), {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 16);
		};
	}
});
var RangeCalendarHeading_default = /* @__PURE__ */ defineComponent({
	__name: "RangeCalendarHeading",
	props: {
		asChild: {
			type: Boolean,
			required: false
		},
		as: {
			type: null,
			required: false,
			default: "div"
		}
	},
	setup(__props) {
		const props = __props;
		const rootContext = injectRangeCalendarRootContext();
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(Primitive), mergeProps(props, { "data-disabled": unref(rootContext).disabled.value ? "" : void 0 }), {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default", { headingValue: unref(rootContext).headingValue.value }, () => [createTextVNode(toDisplayString(unref(rootContext).headingValue.value), 1)])]),
				_: 3
			}, 16, ["data-disabled"]);
		};
	}
});
var DateRangePickerHeading_default = /* @__PURE__ */ defineComponent({
	__name: "DateRangePickerHeading",
	props: {
		asChild: {
			type: Boolean,
			required: false
		},
		as: {
			type: null,
			required: false
		}
	},
	setup(__props) {
		const props = __props;
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(RangeCalendarHeading_default), normalizeProps(guardReactiveProps(props)), {
				default: withCtx(({ headingValue }) => [renderSlot(_ctx.$slots, "default", { headingValue }, () => [createTextVNode(toDisplayString(headingValue), 1)])]),
				_: 3
			}, 16);
		};
	}
});
var DateRangePickerInput_default = /* @__PURE__ */ defineComponent({
	__name: "DateRangePickerInput",
	props: {
		part: {
			type: null,
			required: true
		},
		type: {
			type: String,
			required: true
		},
		asChild: {
			type: Boolean,
			required: false
		},
		as: {
			type: null,
			required: false
		}
	},
	setup(__props) {
		const props = __props;
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(DateRangeFieldInput_default), normalizeProps(guardReactiveProps(props)), {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 16);
		};
	}
});
var RangeCalendarNext_default = /* @__PURE__ */ defineComponent({
	__name: "RangeCalendarNext",
	props: {
		nextPage: {
			type: Function,
			required: false
		},
		asChild: {
			type: Boolean,
			required: false
		},
		as: {
			type: null,
			required: false,
			default: "button"
		}
	},
	setup(__props) {
		const props = __props;
		const disabled$9 = computed(() => rootContext.disabled.value || rootContext.isNextButtonDisabled(props.nextPage));
		const rootContext = injectRangeCalendarRootContext();
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(Primitive), mergeProps(props, {
				"aria-label": "Next page",
				type: _ctx.as === "button" ? "button" : void 0,
				"aria-disabled": disabled$9.value || void 0,
				"data-disabled": disabled$9.value || void 0,
				disabled: disabled$9.value,
				onClick: _cache[0] || (_cache[0] = ($event) => unref(rootContext).nextPage(props.nextPage))
			}), {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default", { disabled: disabled$9.value }, () => [_cache[1] || (_cache[1] = createTextVNode(" Next page "))])]),
				_: 3
			}, 16, [
				"type",
				"aria-disabled",
				"data-disabled",
				"disabled"
			]);
		};
	}
});
var DateRangePickerNext_default = /* @__PURE__ */ defineComponent({
	__name: "DateRangePickerNext",
	props: {
		nextPage: {
			type: Function,
			required: false
		},
		asChild: {
			type: Boolean,
			required: false
		},
		as: {
			type: null,
			required: false
		}
	},
	setup(__props) {
		const props = __props;
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(RangeCalendarNext_default), normalizeProps(guardReactiveProps(props)), {
				default: withCtx((slotProps) => [renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps(slotProps)))]),
				_: 3
			}, 16);
		};
	}
});
var RangeCalendarPrev_default = /* @__PURE__ */ defineComponent({
	__name: "RangeCalendarPrev",
	props: {
		prevPage: {
			type: Function,
			required: false
		},
		asChild: {
			type: Boolean,
			required: false
		},
		as: {
			type: null,
			required: false,
			default: "button"
		}
	},
	setup(__props) {
		const props = __props;
		const disabled$9 = computed(() => rootContext.disabled.value || rootContext.isPrevButtonDisabled(props.prevPage));
		const rootContext = injectRangeCalendarRootContext();
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(Primitive), mergeProps(props, {
				"aria-label": "Previous page",
				type: _ctx.as === "button" ? "button" : void 0,
				"aria-disabled": disabled$9.value || void 0,
				"data-disabled": disabled$9.value || void 0,
				disabled: disabled$9.value,
				onClick: _cache[0] || (_cache[0] = ($event) => unref(rootContext).prevPage(props.prevPage))
			}), {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default", { disabled: disabled$9.value }, () => [_cache[1] || (_cache[1] = createTextVNode(" Prev page "))])]),
				_: 3
			}, 16, [
				"type",
				"aria-disabled",
				"data-disabled",
				"disabled"
			]);
		};
	}
});
var DateRangePickerPrev_default = /* @__PURE__ */ defineComponent({
	__name: "DateRangePickerPrev",
	props: {
		prevPage: {
			type: Function,
			required: false
		},
		asChild: {
			type: Boolean,
			required: false
		},
		as: {
			type: null,
			required: false
		}
	},
	setup(__props) {
		const props = __props;
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(RangeCalendarPrev_default), normalizeProps(guardReactiveProps(props)), {
				default: withCtx((slotProps) => [renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps(slotProps)))]),
				_: 3
			}, 16);
		};
	}
});
var DateRangePickerTrigger_default = /* @__PURE__ */ defineComponent({
	__name: "DateRangePickerTrigger",
	props: {
		asChild: {
			type: Boolean,
			required: false
		},
		as: {
			type: null,
			required: false
		}
	},
	setup(__props) {
		const props = __props;
		const rootContext = injectDateRangePickerRootContext();
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(PopoverTrigger_default), mergeProps({ "data-reka-date-field-segment": "trigger" }, props, {
				disabled: unref(rootContext).disabled.value,
				onFocusin: _cache[0] || (_cache[0] = (e) => {
					unref(rootContext).dateFieldRef.value?.setFocusedElement(e.target);
				})
			}), {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 16, ["disabled"]);
		};
	}
});
var [injectEditableRootContext, provideEditableRootContext] = createContext("EditableRoot");
var EditableRoot_default = /* @__PURE__ */ defineComponent({
	inheritAttrs: false,
	__name: "EditableRoot",
	props: {
		defaultValue: {
			type: String,
			required: false
		},
		modelValue: {
			type: [String, null],
			required: false
		},
		placeholder: {
			type: [String, Object],
			required: false,
			default: "Enter text..."
		},
		dir: {
			type: String,
			required: false
		},
		disabled: {
			type: Boolean,
			required: false,
			default: false
		},
		readonly: {
			type: Boolean,
			required: false
		},
		activationMode: {
			type: String,
			required: false,
			default: "focus"
		},
		selectOnFocus: {
			type: Boolean,
			required: false,
			default: false
		},
		submitMode: {
			type: String,
			required: false,
			default: "blur"
		},
		startWithEditMode: {
			type: Boolean,
			required: false
		},
		maxLength: {
			type: Number,
			required: false
		},
		autoResize: {
			type: Boolean,
			required: false,
			default: false
		},
		id: {
			type: String,
			required: false
		},
		asChild: {
			type: Boolean,
			required: false
		},
		as: {
			type: null,
			required: false,
			default: "div"
		},
		name: {
			type: String,
			required: false
		},
		required: {
			type: Boolean,
			required: false,
			default: false
		}
	},
	emits: [
		"update:modelValue",
		"submit",
		"update:state"
	],
	setup(__props, { expose: __expose, emit: __emit }) {
		const props = __props;
		const emits = __emit;
		const { id: id$1, name: name$1, defaultValue, startWithEditMode, placeholder: propPlaceholder, maxLength, disabled: disabled$9, dir: propDir, submitMode, activationMode, selectOnFocus, readonly: readonly$1, autoResize, required } = toRefs(props);
		const inputRef = ref();
		const dir = useDirection(propDir);
		const isEditing = ref(startWithEditMode.value ?? false);
		const modelValue = useVModel(props, "modelValue", emits, {
			defaultValue: defaultValue.value ?? "",
			passive: props.modelValue === void 0
		});
		const { primitiveElement, currentElement } = usePrimitiveElement();
		const isFormControl = useFormControl(currentElement);
		const placeholder$1 = computed(() => {
			return typeof propPlaceholder.value === "string" ? {
				edit: propPlaceholder.value,
				preview: propPlaceholder.value
			} : propPlaceholder.value;
		});
		const inputValue = ref(modelValue.value);
		watch(() => modelValue.value, () => {
			inputValue.value = modelValue.value;
		}, {
			immediate: true,
			deep: true
		});
		function cancel() {
			isEditing.value = false;
			emits("update:state", "cancel");
		}
		function edit() {
			isEditing.value = true;
			inputValue.value = modelValue.value;
			emits("update:state", "edit");
		}
		function submit() {
			modelValue.value = inputValue.value;
			isEditing.value = false;
			emits("update:state", "submit");
			emits("submit", modelValue.value);
		}
		function handleDismiss() {
			if (isEditing.value) if (submitMode.value === "blur" || submitMode.value === "both") submit();
			else cancel();
		}
		const pointerDownOutside = usePointerDownOutside(() => handleDismiss(), currentElement, isEditing);
		const focusOutside = useFocusOutside(() => handleDismiss(), currentElement, isEditing);
		const isEmpty = computed(() => modelValue.value === "");
		__expose({
			submit,
			cancel,
			edit
		});
		provideEditableRootContext({
			id: id$1,
			name: name$1,
			disabled: disabled$9,
			isEditing,
			maxLength,
			modelValue,
			inputValue,
			placeholder: placeholder$1,
			edit,
			cancel,
			submit,
			activationMode,
			submitMode,
			selectOnFocus,
			inputRef,
			startWithEditMode,
			isEmpty,
			readonly: readonly$1,
			autoResize
		});
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(Primitive), mergeProps(_ctx.$attrs, {
				ref_key: "primitiveElement",
				ref: primitiveElement,
				as: _ctx.as,
				"as-child": _ctx.asChild,
				dir: unref(dir),
				"data-dismissable-layer": "",
				onFocusCapture: unref(focusOutside).onFocusCapture,
				onBlurCapture: unref(focusOutside).onBlurCapture,
				onPointerdownCapture: unref(pointerDownOutside).onPointerDownCapture
			}), {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default", {
					modelValue: unref(modelValue),
					isEditing: isEditing.value,
					isEmpty: isEmpty.value,
					submit,
					cancel,
					edit
				}), unref(isFormControl) && unref(name$1) ? (openBlock(), createBlock(unref(VisuallyHiddenInput_default), {
					key: 0,
					type: "text",
					value: unref(modelValue),
					name: unref(name$1),
					disabled: unref(disabled$9),
					required: unref(required)
				}, null, 8, [
					"value",
					"name",
					"disabled",
					"required"
				])) : createCommentVNode("v-if", true)]),
				_: 3
			}, 16, [
				"as",
				"as-child",
				"dir",
				"onFocusCapture",
				"onBlurCapture",
				"onPointerdownCapture"
			]);
		};
	}
});
var EditableArea_default = /* @__PURE__ */ defineComponent({
	__name: "EditableArea",
	props: {
		asChild: {
			type: Boolean,
			required: false
		},
		as: {
			type: null,
			required: false,
			default: "div"
		}
	},
	setup(__props) {
		const props = __props;
		const context$1 = injectEditableRootContext();
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(Primitive), mergeProps(props, {
				"data-placeholder-shown": unref(context$1).isEditing.value ? void 0 : "",
				"data-focus": unref(context$1).isEditing.value ? "" : void 0,
				"data-focused": unref(context$1).isEditing.value ? "" : void 0,
				"data-empty": unref(context$1).isEmpty.value ? "" : void 0,
				"data-readonly": unref(context$1).readonly.value ? "" : void 0,
				"data-disabled": unref(context$1).disabled.value ? "" : void 0,
				style: unref(context$1).autoResize.value ? { display: "inline-grid" } : void 0
			}), {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 16, [
				"data-placeholder-shown",
				"data-focus",
				"data-focused",
				"data-empty",
				"data-readonly",
				"data-disabled",
				"style"
			]);
		};
	}
});
var EditableInput_default = /* @__PURE__ */ defineComponent({
	__name: "EditableInput",
	props: {
		asChild: {
			type: Boolean,
			required: false
		},
		as: {
			type: null,
			required: false,
			default: "input"
		}
	},
	setup(__props) {
		const props = __props;
		const kbd = useKbd();
		const context$1 = injectEditableRootContext();
		const disabled$9 = computed(() => context$1.disabled.value);
		const placeholder$1 = computed(() => context$1.placeholder.value?.edit);
		const { primitiveElement, currentElement: inputRef } = usePrimitiveElement();
		onMounted(() => {
			context$1.inputRef.value = inputRef.value;
			if (context$1.startWithEditMode.value) {
				context$1.inputRef.value?.focus({ preventScroll: true });
				if (context$1.selectOnFocus.value) context$1.inputRef.value?.select();
			}
		});
		watch(context$1.isEditing, (value) => {
			if (value) nextTick(() => {
				context$1.inputRef.value?.focus({ preventScroll: true });
				if (context$1.selectOnFocus.value) context$1.inputRef.value?.select();
			});
		});
		function handleSubmitKeyDown(event) {
			if ((context$1.submitMode.value === "enter" || context$1.submitMode.value === "both") && event.key === kbd.ENTER && !event.shiftKey && !event.metaKey) context$1.submit();
		}
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(Primitive), mergeProps({
				ref_key: "primitiveElement",
				ref: primitiveElement
			}, props, {
				value: unref(context$1).inputValue.value,
				placeholder: placeholder$1.value,
				disabled: disabled$9.value,
				maxlength: unref(context$1).maxLength.value,
				"data-disabled": disabled$9.value ? "" : void 0,
				"data-readonly": unref(context$1).readonly.value ? "" : void 0,
				readonly: unref(context$1).readonly.value,
				"aria-label": "editable input",
				hidden: unref(context$1).autoResize.value ? void 0 : !unref(context$1).isEditing.value,
				style: unref(context$1).autoResize.value ? {
					all: "unset",
					gridArea: "1 / 1 / auto / auto",
					visibility: !unref(context$1).isEditing.value ? "hidden" : void 0
				} : void 0,
				onInput: _cache[0] || (_cache[0] = ($event) => unref(context$1).inputValue.value = $event.target.value),
				onKeydown: [withKeys(handleSubmitKeyDown, ["enter", "space"]), withKeys(unref(context$1).cancel, ["esc"])]
			}), {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 16, [
				"value",
				"placeholder",
				"disabled",
				"maxlength",
				"data-disabled",
				"data-readonly",
				"readonly",
				"hidden",
				"style",
				"onKeydown"
			]);
		};
	}
});
var EditablePreview_default = /* @__PURE__ */ defineComponent({
	__name: "EditablePreview",
	props: {
		asChild: {
			type: Boolean,
			required: false
		},
		as: {
			type: null,
			required: false,
			default: "span"
		}
	},
	setup(__props) {
		const props = __props;
		const context$1 = injectEditableRootContext();
		const placeholder$1 = computed(() => context$1.placeholder.value?.preview);
		function handleFocus() {
			if (context$1.activationMode.value === "focus") context$1.edit();
		}
		function handleDoubleClick() {
			if (context$1.activationMode.value === "dblclick") context$1.edit();
		}
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(Primitive), mergeProps(props, {
				tabindex: "0",
				"data-placeholder-shown": unref(context$1).isEditing.value ? void 0 : "",
				hidden: unref(context$1).autoResize.value ? void 0 : unref(context$1).isEditing.value,
				style: unref(context$1).autoResize.value ? {
					whiteSpace: "pre",
					userSelect: "none",
					gridArea: "1 / 1 / auto / auto",
					visibility: unref(context$1).isEditing.value ? "hidden" : void 0,
					overflow: "hidden",
					textOverflow: "ellipsis"
				} : void 0,
				onFocusin: handleFocus,
				onDblclick: handleDoubleClick
			}), {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default", {}, () => [createTextVNode(toDisplayString(unref(context$1).modelValue.value || placeholder$1.value), 1)])]),
				_: 3
			}, 16, [
				"data-placeholder-shown",
				"hidden",
				"style"
			]);
		};
	}
});
var [injectScrollAreaRootContext, provideScrollAreaRootContext] = createContext("ScrollAreaRoot");
var ScrollAreaRoot_default = /* @__PURE__ */ defineComponent({
	__name: "ScrollAreaRoot",
	props: {
		type: {
			type: String,
			required: false,
			default: "hover"
		},
		dir: {
			type: String,
			required: false
		},
		scrollHideDelay: {
			type: Number,
			required: false,
			default: 600
		},
		asChild: {
			type: Boolean,
			required: false
		},
		as: {
			type: null,
			required: false
		}
	},
	setup(__props, { expose: __expose }) {
		const props = __props;
		const cornerWidth = ref(0);
		const cornerHeight = ref(0);
		const viewport$1 = ref();
		const content$4 = ref();
		const scrollbarX = ref();
		const scrollbarY = ref();
		const scrollbarXEnabled = ref(false);
		const scrollbarYEnabled = ref(false);
		const { type, dir: propDir, scrollHideDelay } = toRefs(props);
		const dir = useDirection(propDir);
		function scrollTop() {
			viewport$1.value?.scrollTo({ top: 0 });
		}
		function scrollTopLeft() {
			viewport$1.value?.scrollTo({
				top: 0,
				left: 0
			});
		}
		__expose({
			viewport: viewport$1,
			scrollTop,
			scrollTopLeft
		});
		const { forwardRef, currentElement: scrollArea$1 } = useForwardExpose();
		provideScrollAreaRootContext({
			type,
			dir,
			scrollHideDelay,
			scrollArea: scrollArea$1,
			viewport: viewport$1,
			onViewportChange: (el$2) => {
				viewport$1.value = el$2 || void 0;
			},
			content: content$4,
			onContentChange: (el$2) => {
				content$4.value = el$2;
			},
			scrollbarX,
			scrollbarXEnabled,
			scrollbarY,
			scrollbarYEnabled,
			onScrollbarXChange: (scrollbar$1) => {
				scrollbarX.value = scrollbar$1 || void 0;
			},
			onScrollbarYChange: (scrollbar$1) => {
				scrollbarY.value = scrollbar$1 || void 0;
			},
			onScrollbarXEnabledChange: (rendered) => {
				scrollbarXEnabled.value = rendered;
			},
			onScrollbarYEnabledChange: (rendered) => {
				scrollbarYEnabled.value = rendered;
			},
			onCornerWidthChange: (width) => {
				cornerWidth.value = width;
			},
			onCornerHeightChange: (height) => {
				cornerHeight.value = height;
			}
		});
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(Primitive), {
				ref: unref(forwardRef),
				"as-child": props.asChild,
				as: _ctx.as,
				dir: unref(dir),
				style: normalizeStyle({
					position: "relative",
					["--reka-scroll-area-corner-width"]: `${cornerWidth.value}px`,
					["--reka-scroll-area-corner-height"]: `${cornerHeight.value}px`
				})
			}, {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 8, [
				"as-child",
				"as",
				"dir",
				"style"
			]);
		};
	}
});
var ScrollAreaCornerImpl_default = /* @__PURE__ */ defineComponent({
	__name: "ScrollAreaCornerImpl",
	setup(__props) {
		const rootContext = injectScrollAreaRootContext();
		const width = ref(0);
		const height = ref(0);
		const hasSize = computed(() => !!width.value && !!height.value);
		function setCornerHeight() {
			const offsetHeight = rootContext.scrollbarX.value?.offsetHeight || 0;
			rootContext.onCornerHeightChange(offsetHeight);
			height.value = offsetHeight;
		}
		function setCornerWidth() {
			const offsetWidth = rootContext.scrollbarY.value?.offsetWidth || 0;
			rootContext.onCornerWidthChange(offsetWidth);
			width.value = offsetWidth;
		}
		useResizeObserver$1(rootContext.scrollbarX.value, setCornerHeight);
		useResizeObserver$1(rootContext.scrollbarY.value, setCornerWidth);
		watch(() => rootContext.scrollbarX.value, setCornerHeight);
		watch(() => rootContext.scrollbarY.value, setCornerWidth);
		return (_ctx, _cache) => {
			return hasSize.value ? (openBlock(), createBlock(unref(Primitive), mergeProps({
				key: 0,
				style: {
					width: `${width.value}px`,
					height: `${height.value}px`,
					position: "absolute",
					right: unref(rootContext).dir.value === "ltr" ? 0 : void 0,
					left: unref(rootContext).dir.value === "rtl" ? 0 : void 0,
					bottom: 0
				}
			}, _ctx.$parent?.$props), {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 16, ["style"])) : createCommentVNode("v-if", true);
		};
	}
});
var ScrollAreaCorner_default = /* @__PURE__ */ defineComponent({
	__name: "ScrollAreaCorner",
	props: {
		asChild: {
			type: Boolean,
			required: false
		},
		as: {
			type: null,
			required: false
		}
	},
	setup(__props) {
		const props = __props;
		const { forwardRef } = useForwardExpose();
		const rootContext = injectScrollAreaRootContext();
		const hasBothScrollbarsVisible = computed(() => !!rootContext.scrollbarX.value && !!rootContext.scrollbarY.value);
		const hasCorner = computed(() => rootContext.type.value !== "scroll" && hasBothScrollbarsVisible.value);
		return (_ctx, _cache) => {
			return hasCorner.value ? (openBlock(), createBlock(ScrollAreaCornerImpl_default, mergeProps({ key: 0 }, props, { ref: unref(forwardRef) }), {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 16)) : createCommentVNode("v-if", true);
		};
	}
});
function linearScale(input$4, output) {
	return (value) => {
		if (input$4[0] === input$4[1] || output[0] === output[1]) return output[0];
		const ratio$1 = (output[1] - output[0]) / (input$4[1] - input$4[0]);
		return output[0] + ratio$1 * (value - input$4[0]);
	};
}
function getThumbSize(sizes) {
	const ratio$1 = getThumbRatio(sizes.viewport, sizes.content);
	const scrollbarPadding = sizes.scrollbar.paddingStart + sizes.scrollbar.paddingEnd;
	const thumbSize = (sizes.scrollbar.size - scrollbarPadding) * ratio$1;
	return Math.max(thumbSize, 18);
}
function getThumbRatio(viewportSize, contentSize) {
	const ratio$1 = viewportSize / contentSize;
	return Number.isNaN(ratio$1) ? 0 : ratio$1;
}
function addUnlinkedScrollListener(node, handler = () => {}) {
	let prevPosition = {
		left: node.scrollLeft,
		top: node.scrollTop
	};
	let rAF = 0;
	(function loop$1() {
		const position = {
			left: node.scrollLeft,
			top: node.scrollTop
		};
		const isHorizontalScroll = prevPosition.left !== position.left;
		const isVerticalScroll = prevPosition.top !== position.top;
		if (isHorizontalScroll || isVerticalScroll) handler();
		prevPosition = position;
		rAF = window.requestAnimationFrame(loop$1);
	})();
	return () => window.cancelAnimationFrame(rAF);
}
function getThumbOffsetFromScroll(scrollPos, sizes, dir = "ltr") {
	const thumbSizePx = getThumbSize(sizes);
	const scrollbarPadding = sizes.scrollbar.paddingStart + sizes.scrollbar.paddingEnd;
	const scrollbar$1 = sizes.scrollbar.size - scrollbarPadding;
	const maxScrollPos = sizes.content - sizes.viewport;
	const maxThumbPos = scrollbar$1 - thumbSizePx;
	const scrollClampRange = dir === "ltr" ? [0, maxScrollPos] : [maxScrollPos * -1, 0];
	const scrollWithoutMomentum = clamp$1(scrollPos, scrollClampRange[0], scrollClampRange[1]);
	return linearScale([0, maxScrollPos], [0, maxThumbPos])(scrollWithoutMomentum);
}
function toInt(value) {
	return value ? Number.parseInt(value, 10) : 0;
}
function getScrollPositionFromPointer(pointerPos, pointerOffset, sizes, dir = "ltr") {
	const thumbSizePx = getThumbSize(sizes);
	const thumbCenter = thumbSizePx / 2;
	const offset$2 = pointerOffset || thumbCenter;
	const thumbOffsetFromEnd = thumbSizePx - offset$2;
	const minPointerPos = sizes.scrollbar.paddingStart + offset$2;
	const maxPointerPos = sizes.scrollbar.size - sizes.scrollbar.paddingEnd - thumbOffsetFromEnd;
	const maxScrollPos = sizes.content - sizes.viewport;
	const scrollRange = dir === "ltr" ? [0, maxScrollPos] : [maxScrollPos * -1, 0];
	return linearScale([minPointerPos, maxPointerPos], scrollRange)(pointerPos);
}
function isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos) {
	return scrollPos > 0 && scrollPos < maxScrollPos;
}
var ScrollAreaScrollbarX_default = /* @__PURE__ */ defineComponent({
	__name: "ScrollAreaScrollbarX",
	setup(__props) {
		const rootContext = injectScrollAreaRootContext();
		const scrollbarVisibleContext = injectScrollAreaScrollbarVisibleContext();
		const { forwardRef, currentElement: scrollbarElement } = useForwardExpose();
		onMounted(() => {
			if (scrollbarElement.value) rootContext.onScrollbarXChange(scrollbarElement.value);
		});
		const sizes = computed(() => scrollbarVisibleContext.sizes.value);
		return (_ctx, _cache) => {
			return openBlock(), createBlock(ScrollAreaScrollbarImpl_default, {
				ref: unref(forwardRef),
				"is-horizontal": true,
				"data-orientation": "horizontal",
				style: normalizeStyle({
					bottom: 0,
					left: unref(rootContext).dir.value === "rtl" ? "var(--reka-scroll-area-corner-width)" : 0,
					right: unref(rootContext).dir.value === "ltr" ? "var(--reka-scroll-area-corner-width)" : 0,
					["--reka-scroll-area-thumb-width"]: sizes.value ? `${unref(getThumbSize)(sizes.value)}px` : void 0
				}),
				onOnDragScroll: _cache[0] || (_cache[0] = ($event) => unref(scrollbarVisibleContext).onDragScroll($event.x))
			}, {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 8, ["style"]);
		};
	}
});
var ScrollAreaScrollbarY_default = /* @__PURE__ */ defineComponent({
	__name: "ScrollAreaScrollbarY",
	setup(__props) {
		const rootContext = injectScrollAreaRootContext();
		const scrollbarVisibleContext = injectScrollAreaScrollbarVisibleContext();
		const { forwardRef, currentElement: scrollbarElement } = useForwardExpose();
		onMounted(() => {
			if (scrollbarElement.value) rootContext.onScrollbarYChange(scrollbarElement.value);
		});
		const sizes = computed(() => scrollbarVisibleContext.sizes.value);
		return (_ctx, _cache) => {
			return openBlock(), createBlock(ScrollAreaScrollbarImpl_default, {
				ref: unref(forwardRef),
				"is-horizontal": false,
				"data-orientation": "vertical",
				style: normalizeStyle({
					top: 0,
					right: unref(rootContext).dir.value === "ltr" ? 0 : void 0,
					left: unref(rootContext).dir.value === "rtl" ? 0 : void 0,
					bottom: "var(--reka-scroll-area-corner-height)",
					["--reka-scroll-area-thumb-height"]: sizes.value ? `${unref(getThumbSize)(sizes.value)}px` : void 0
				}),
				onOnDragScroll: _cache[0] || (_cache[0] = ($event) => unref(scrollbarVisibleContext).onDragScroll($event.y))
			}, {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 8, ["style"]);
		};
	}
});
var ScrollAreaScrollbarAuto_default = /* @__PURE__ */ defineComponent({
	__name: "ScrollAreaScrollbarAuto",
	props: { forceMount: {
		type: Boolean,
		required: false
	} },
	setup(__props) {
		const rootContext = injectScrollAreaRootContext();
		const scrollbarContext = injectScrollAreaScrollbarContext();
		const { forwardRef } = useForwardExpose();
		const visible$1 = ref(false);
		const handleResize = useDebounceFn(() => {
			if (rootContext.viewport.value) {
				const isOverflowX = rootContext.viewport.value.offsetWidth < rootContext.viewport.value.scrollWidth;
				const isOverflowY = rootContext.viewport.value.offsetHeight < rootContext.viewport.value.scrollHeight;
				visible$1.value = scrollbarContext.isHorizontal.value ? isOverflowX : isOverflowY;
			}
		}, 10);
		onMounted(() => handleResize());
		useResizeObserver$1(rootContext.viewport, handleResize);
		useResizeObserver$1(rootContext.content, handleResize);
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(Presence_default), { present: _ctx.forceMount || visible$1.value }, {
				default: withCtx(() => [createVNode(ScrollAreaScrollbarVisible_default, mergeProps(_ctx.$attrs, {
					ref: unref(forwardRef),
					"data-state": visible$1.value ? "visible" : "hidden"
				}), {
					default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
					_: 3
				}, 16, ["data-state"])]),
				_: 3
			}, 8, ["present"]);
		};
	}
});
var ScrollAreaScrollbarHover_default = /* @__PURE__ */ defineComponent({
	inheritAttrs: false,
	__name: "ScrollAreaScrollbarHover",
	props: { forceMount: {
		type: Boolean,
		required: false
	} },
	setup(__props) {
		const rootContext = injectScrollAreaRootContext();
		const { forwardRef } = useForwardExpose();
		let timeout;
		const visible$1 = ref(false);
		function handlePointerEnter() {
			window.clearTimeout(timeout);
			visible$1.value = true;
		}
		function handlePointerLeave() {
			timeout = window.setTimeout(() => {
				visible$1.value = false;
			}, rootContext.scrollHideDelay.value);
		}
		onMounted(() => {
			const scrollArea$1 = rootContext.scrollArea.value;
			if (scrollArea$1) {
				scrollArea$1.addEventListener("pointerenter", handlePointerEnter);
				scrollArea$1.addEventListener("pointerleave", handlePointerLeave);
			}
		});
		onUnmounted(() => {
			const scrollArea$1 = rootContext.scrollArea.value;
			if (scrollArea$1) {
				window.clearTimeout(timeout);
				scrollArea$1.removeEventListener("pointerenter", handlePointerEnter);
				scrollArea$1.removeEventListener("pointerleave", handlePointerLeave);
			}
		});
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(Presence_default), { present: _ctx.forceMount || visible$1.value }, {
				default: withCtx(() => [createVNode(ScrollAreaScrollbarAuto_default, mergeProps(_ctx.$attrs, {
					ref: unref(forwardRef),
					"data-state": visible$1.value ? "visible" : "hidden"
				}), {
					default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
					_: 3
				}, 16, ["data-state"])]),
				_: 3
			}, 8, ["present"]);
		};
	}
});
var ScrollAreaScrollbarScroll_default = /* @__PURE__ */ defineComponent({
	__name: "ScrollAreaScrollbarScroll",
	props: { forceMount: {
		type: Boolean,
		required: false
	} },
	setup(__props) {
		const rootContext = injectScrollAreaRootContext();
		const scrollbarContext = injectScrollAreaScrollbarContext();
		const { forwardRef } = useForwardExpose();
		const { state, dispatch } = useStateMachine("hidden", {
			hidden: { SCROLL: "scrolling" },
			scrolling: {
				SCROLL_END: "idle",
				POINTER_ENTER: "interacting"
			},
			interacting: {
				SCROLL: "interacting",
				POINTER_LEAVE: "idle"
			},
			idle: {
				HIDE: "hidden",
				SCROLL: "scrolling",
				POINTER_ENTER: "interacting"
			}
		});
		const visible$1 = computed(() => state.value !== "hidden");
		watchEffect((onCleanup) => {
			if (state.value === "idle") {
				const timeId = window.setTimeout(() => dispatch("HIDE"), rootContext.scrollHideDelay.value);
				onCleanup(() => {
					window.clearTimeout(timeId);
				});
			}
		});
		const debounceScrollEnd = useDebounceFn(() => dispatch("SCROLL_END"), 100);
		watchEffect((onCleanup) => {
			const viewport$1 = rootContext.viewport.value;
			const scrollDirection = scrollbarContext.isHorizontal.value ? "scrollLeft" : "scrollTop";
			if (viewport$1) {
				let prevScrollPos = viewport$1[scrollDirection];
				const handleScroll = () => {
					const scrollPos = viewport$1[scrollDirection];
					if (prevScrollPos !== scrollPos) {
						dispatch("SCROLL");
						debounceScrollEnd();
					}
					prevScrollPos = scrollPos;
				};
				viewport$1.addEventListener("scroll", handleScroll);
				onCleanup(() => {
					viewport$1.removeEventListener("scroll", handleScroll);
				});
			}
		});
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(Presence_default), { present: _ctx.forceMount || visible$1.value }, {
				default: withCtx(() => [createVNode(ScrollAreaScrollbarVisible_default, mergeProps(_ctx.$attrs, {
					ref: unref(forwardRef),
					"data-state": visible$1.value ? "visible" : "hidden"
				}), {
					default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
					_: 3
				}, 16, ["data-state"])]),
				_: 3
			}, 8, ["present"]);
		};
	}
});
var [injectScrollAreaScrollbarContext, provideScrollAreaScrollbarContext] = createContext("ScrollAreaScrollbar");
var ScrollAreaScrollbar_default = /* @__PURE__ */ defineComponent({
	inheritAttrs: false,
	__name: "ScrollAreaScrollbar",
	props: {
		orientation: {
			type: String,
			required: false,
			default: "vertical"
		},
		forceMount: {
			type: Boolean,
			required: false
		},
		asChild: {
			type: Boolean,
			required: false
		},
		as: {
			type: null,
			required: false,
			default: "div"
		}
	},
	setup(__props) {
		const props = __props;
		const { forwardRef } = useForwardExpose();
		const rootContext = injectScrollAreaRootContext();
		const isHorizontal = computed(() => props.orientation === "horizontal");
		watch(isHorizontal, () => {
			if (isHorizontal.value) rootContext.onScrollbarXEnabledChange(true);
			else rootContext.onScrollbarYEnabledChange(true);
		}, { immediate: true });
		onUnmounted(() => {
			rootContext.onScrollbarXEnabledChange(false);
			rootContext.onScrollbarYEnabledChange(false);
		});
		const { orientation, forceMount, asChild, as } = toRefs(props);
		provideScrollAreaScrollbarContext({
			orientation,
			forceMount,
			isHorizontal,
			as,
			asChild
		});
		return (_ctx, _cache) => {
			return unref(rootContext).type.value === "hover" ? (openBlock(), createBlock(ScrollAreaScrollbarHover_default, mergeProps({ key: 0 }, _ctx.$attrs, {
				ref: unref(forwardRef),
				"force-mount": unref(forceMount)
			}), {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 16, ["force-mount"])) : unref(rootContext).type.value === "scroll" ? (openBlock(), createBlock(ScrollAreaScrollbarScroll_default, mergeProps({ key: 1 }, _ctx.$attrs, {
				ref: unref(forwardRef),
				"force-mount": unref(forceMount)
			}), {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 16, ["force-mount"])) : unref(rootContext).type.value === "auto" ? (openBlock(), createBlock(ScrollAreaScrollbarAuto_default, mergeProps({ key: 2 }, _ctx.$attrs, {
				ref: unref(forwardRef),
				"force-mount": unref(forceMount)
			}), {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 16, ["force-mount"])) : unref(rootContext).type.value === "always" ? (openBlock(), createBlock(ScrollAreaScrollbarVisible_default, mergeProps({ key: 3 }, _ctx.$attrs, {
				ref: unref(forwardRef),
				"data-state": "visible"
			}), {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 16)) : createCommentVNode("v-if", true);
		};
	}
});
var [injectScrollAreaScrollbarVisibleContext, provideScrollAreaScrollbarVisibleContext] = createContext("ScrollAreaScrollbarVisible");
var ScrollAreaScrollbarVisible_default = /* @__PURE__ */ defineComponent({
	__name: "ScrollAreaScrollbarVisible",
	setup(__props) {
		const rootContext = injectScrollAreaRootContext();
		const scrollbarContext = injectScrollAreaScrollbarContext();
		const { forwardRef } = useForwardExpose();
		const sizes = ref({
			content: 0,
			viewport: 0,
			scrollbar: {
				size: 0,
				paddingStart: 0,
				paddingEnd: 0
			}
		});
		const hasThumb = computed(() => {
			const thumbRatio = getThumbRatio(sizes.value.viewport, sizes.value.content);
			return Boolean(thumbRatio > 0 && thumbRatio < 1);
		});
		const thumbRef = ref();
		const pointerOffset = ref(0);
		function handleWheelScroll(event, payload) {
			if (isShowingScrollbarX.value) {
				const scrollPos = rootContext.viewport.value.scrollLeft + event.deltaY;
				rootContext.viewport.value.scrollLeft = scrollPos;
				if (isScrollingWithinScrollbarBounds(scrollPos, payload)) event.preventDefault();
			} else {
				const scrollPos = rootContext.viewport.value.scrollTop + event.deltaY;
				rootContext.viewport.value.scrollTop = scrollPos;
				if (isScrollingWithinScrollbarBounds(scrollPos, payload)) event.preventDefault();
			}
		}
		function handleThumbDown(event, payload) {
			if (isShowingScrollbarX.value) pointerOffset.value = payload.x;
			else pointerOffset.value = payload.y;
		}
		function handleThumbUp(event) {
			pointerOffset.value = 0;
		}
		function handleSizeChange(payload) {
			sizes.value = payload;
		}
		function getScrollPosition(pointerPos, dir) {
			return getScrollPositionFromPointer(pointerPos, pointerOffset.value, sizes.value, dir);
		}
		const isShowingScrollbarX = computed(() => scrollbarContext.isHorizontal.value);
		function onDragScroll(payload) {
			if (isShowingScrollbarX.value) rootContext.viewport.value.scrollLeft = getScrollPosition(payload, rootContext.dir.value);
			else rootContext.viewport.value.scrollTop = getScrollPosition(payload);
		}
		function onThumbPositionChange() {
			if (isShowingScrollbarX.value) {
				if (rootContext.viewport.value && thumbRef.value) {
					const scrollPos = rootContext.viewport.value.scrollLeft;
					const offset$2 = getThumbOffsetFromScroll(scrollPos, sizes.value, rootContext.dir.value);
					thumbRef.value.style.transform = `translate3d(${offset$2}px, 0, 0)`;
				}
			} else if (rootContext.viewport.value && thumbRef.value) {
				const scrollPos = rootContext.viewport.value.scrollTop;
				const offset$2 = getThumbOffsetFromScroll(scrollPos, sizes.value);
				thumbRef.value.style.transform = `translate3d(0, ${offset$2}px, 0)`;
			}
		}
		function onThumbChange(element) {
			thumbRef.value = element;
		}
		provideScrollAreaScrollbarVisibleContext({
			sizes,
			hasThumb,
			handleWheelScroll,
			handleThumbDown,
			handleThumbUp,
			handleSizeChange,
			onThumbPositionChange,
			onThumbChange,
			onDragScroll
		});
		return (_ctx, _cache) => {
			return isShowingScrollbarX.value ? (openBlock(), createBlock(ScrollAreaScrollbarX_default, mergeProps({ key: 0 }, _ctx.$attrs, { ref: unref(forwardRef) }), {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 16)) : (openBlock(), createBlock(ScrollAreaScrollbarY_default, mergeProps({ key: 1 }, _ctx.$attrs, { ref: unref(forwardRef) }), {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 16));
		};
	}
});
var ScrollAreaScrollbarImpl_default = /* @__PURE__ */ defineComponent({
	__name: "ScrollAreaScrollbarImpl",
	props: { isHorizontal: {
		type: Boolean,
		required: true
	} },
	emits: [
		"onDragScroll",
		"onWheelScroll",
		"onThumbPointerDown"
	],
	setup(__props, { emit: __emit }) {
		const props = __props;
		const emit = __emit;
		const rootContext = injectScrollAreaRootContext();
		const scrollbarVisibleContext = injectScrollAreaScrollbarVisibleContext();
		const scrollbarContext = injectScrollAreaScrollbarContext();
		const { forwardRef, currentElement: scrollbar$1 } = useForwardExpose();
		const prevWebkitUserSelectRef = ref("");
		const rectRef = ref();
		function handleDragScroll(event) {
			if (rectRef.value) emit("onDragScroll", {
				x: event.clientX - rectRef.value?.left,
				y: event.clientY - rectRef.value?.top
			});
		}
		function handlePointerDown(event) {
			if (event.button === 0) {
				event.target.setPointerCapture(event.pointerId);
				rectRef.value = scrollbar$1.value.getBoundingClientRect();
				prevWebkitUserSelectRef.value = document.body.style.webkitUserSelect;
				document.body.style.webkitUserSelect = "none";
				if (rootContext.viewport) rootContext.viewport.value.style.scrollBehavior = "auto";
				handleDragScroll(event);
			}
		}
		function handlePointerMove(event) {
			handleDragScroll(event);
		}
		function handlePointerUp(event) {
			const element = event.target;
			if (element.hasPointerCapture(event.pointerId)) element.releasePointerCapture(event.pointerId);
			document.body.style.webkitUserSelect = prevWebkitUserSelectRef.value;
			if (rootContext.viewport) rootContext.viewport.value.style.scrollBehavior = "";
			rectRef.value = void 0;
		}
		function handleWheel(event) {
			const element = event.target;
			const isScrollbarWheel = scrollbar$1.value?.contains(element);
			const maxScrollPos = scrollbarVisibleContext.sizes.value.content - scrollbarVisibleContext.sizes.value.viewport;
			if (isScrollbarWheel) scrollbarVisibleContext.handleWheelScroll(event, maxScrollPos);
		}
		onMounted(() => {
			document.addEventListener("wheel", handleWheel, { passive: false });
		});
		onUnmounted(() => {
			document.removeEventListener("wheel", handleWheel);
		});
		function handleSizeChange() {
			if (!scrollbar$1.value) return;
			if (props.isHorizontal) scrollbarVisibleContext.handleSizeChange({
				content: rootContext.viewport.value?.scrollWidth ?? 0,
				viewport: rootContext.viewport.value?.offsetWidth ?? 0,
				scrollbar: {
					size: scrollbar$1.value.clientWidth ?? 0,
					paddingStart: toInt(getComputedStyle(scrollbar$1.value).paddingLeft),
					paddingEnd: toInt(getComputedStyle(scrollbar$1.value).paddingRight)
				}
			});
			else scrollbarVisibleContext.handleSizeChange({
				content: rootContext.viewport.value?.scrollHeight ?? 0,
				viewport: rootContext.viewport.value?.offsetHeight ?? 0,
				scrollbar: {
					size: scrollbar$1.value?.clientHeight ?? 0,
					paddingStart: toInt(getComputedStyle(scrollbar$1.value).paddingLeft),
					paddingEnd: toInt(getComputedStyle(scrollbar$1.value).paddingRight)
				}
			});
		}
		useResizeObserver$1(scrollbar$1, handleSizeChange);
		useResizeObserver$1(rootContext.content, handleSizeChange);
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(Primitive), {
				ref: unref(forwardRef),
				style: { "position": "absolute" },
				"data-scrollbarimpl": "",
				as: unref(scrollbarContext).as.value,
				"as-child": unref(scrollbarContext).asChild.value,
				onPointerdown: handlePointerDown,
				onPointermove: handlePointerMove,
				onPointerup: handlePointerUp
			}, {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 8, ["as", "as-child"]);
		};
	}
});
var ScrollAreaThumb_default = /* @__PURE__ */ defineComponent({
	__name: "ScrollAreaThumb",
	props: {
		asChild: {
			type: Boolean,
			required: false
		},
		as: {
			type: null,
			required: false
		}
	},
	setup(__props) {
		const props = __props;
		const rootContext = injectScrollAreaRootContext();
		const scrollbarContextVisible = injectScrollAreaScrollbarVisibleContext();
		function handlePointerDown(event) {
			const thumbRect = event.target.getBoundingClientRect();
			const x$2 = event.clientX - thumbRect.left;
			const y = event.clientY - thumbRect.top;
			scrollbarContextVisible.handleThumbDown(event, {
				x: x$2,
				y
			});
		}
		function handlePointerUp(event) {
			scrollbarContextVisible.handleThumbUp(event);
		}
		const { forwardRef, currentElement: thumbElement } = useForwardExpose();
		const removeUnlinkedScrollListenerRef = ref();
		const viewport$1 = computed(() => rootContext.viewport.value);
		function handleScroll() {
			if (!removeUnlinkedScrollListenerRef.value) {
				removeUnlinkedScrollListenerRef.value = addUnlinkedScrollListener(viewport$1.value, scrollbarContextVisible.onThumbPositionChange);
				scrollbarContextVisible.onThumbPositionChange();
			}
		}
		watchOnce(computed(() => scrollbarContextVisible.sizes.value), () => {
			scrollbarContextVisible.onThumbChange(thumbElement.value);
			if (viewport$1.value) {
				scrollbarContextVisible.onThumbPositionChange();
				viewport$1.value.addEventListener("scroll", handleScroll);
			}
		});
		onUnmounted(() => {
			viewport$1.value.removeEventListener("scroll", handleScroll);
			rootContext.viewport.value?.removeEventListener("scroll", handleScroll);
		});
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(Primitive), {
				ref: unref(forwardRef),
				"data-state": unref(scrollbarContextVisible).hasThumb ? "visible" : "hidden",
				style: {
					width: "var(--reka-scroll-area-thumb-width)",
					height: "var(--reka-scroll-area-thumb-height)"
				},
				"as-child": props.asChild,
				as: _ctx.as,
				onPointerdown: handlePointerDown,
				onPointerup: handlePointerUp
			}, {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 8, [
				"data-state",
				"as-child",
				"as"
			]);
		};
	}
});
var ScrollAreaViewport_default = /* @__PURE__ */ defineComponent({
	inheritAttrs: false,
	__name: "ScrollAreaViewport",
	props: {
		nonce: {
			type: String,
			required: false
		},
		asChild: {
			type: Boolean,
			required: false
		},
		as: {
			type: null,
			required: false
		}
	},
	setup(__props, { expose: __expose }) {
		const props = __props;
		const { nonce: propNonce } = toRefs(props);
		const nonce = useNonce(propNonce);
		const rootContext = injectScrollAreaRootContext();
		const viewportElement = ref();
		onMounted(() => {
			rootContext.onViewportChange(viewportElement.value);
			rootContext.onContentChange(contentElement.value);
		});
		__expose({ viewportElement });
		const { forwardRef, currentElement: contentElement } = useForwardExpose();
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock(Fragment, null, [createBaseVNode("div", mergeProps({
				ref_key: "viewportElement",
				ref: viewportElement,
				"data-reka-scroll-area-viewport": "",
				style: {
					overflowX: unref(rootContext).scrollbarXEnabled.value ? "scroll" : "hidden",
					overflowY: unref(rootContext).scrollbarYEnabled.value ? "scroll" : "hidden"
				}
			}, _ctx.$attrs, { tabindex: 0 }), [createVNode(unref(Primitive), {
				ref: unref(forwardRef),
				style: normalizeStyle({ minWidth: unref(rootContext).scrollbarXEnabled.value ? "fit-content" : void 0 }),
				"as-child": props.asChild,
				as: _ctx.as
			}, {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 8, [
				"style",
				"as-child",
				"as"
			])], 16), createVNode(unref(Primitive), {
				as: "style",
				nonce: unref(nonce)
			}, {
				default: withCtx(() => _cache[0] || (_cache[0] = [createTextVNode(" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-reka-scroll-area-viewport] { scrollbar-width:none; -ms-overflow-style:none; -webkit-overflow-scrolling:touch; } [data-reka-scroll-area-viewport]::-webkit-scrollbar { display:none; } ")])),
				_: 1,
				__: [0]
			}, 8, ["nonce"])], 64);
		};
	}
});
var BubbleSelect_default = /* @__PURE__ */ defineComponent({
	__name: "BubbleSelect",
	props: {
		autocomplete: {
			type: String,
			required: false
		},
		autofocus: {
			type: Boolean,
			required: false
		},
		disabled: {
			type: Boolean,
			required: false
		},
		form: {
			type: String,
			required: false
		},
		multiple: {
			type: Boolean,
			required: false
		},
		name: {
			type: String,
			required: false
		},
		required: {
			type: Boolean,
			required: false
		},
		size: {
			type: Number,
			required: false
		},
		value: {
			type: null,
			required: false
		}
	},
	setup(__props) {
		const props = __props;
		const selectElement = ref();
		watch(() => props.value, (cur, prev) => {
			const selectProto = window.HTMLSelectElement.prototype;
			const setValue = Object.getOwnPropertyDescriptor(selectProto, "value").set;
			if (cur !== prev && setValue && selectElement.value) {
				const event = new Event("change", { bubbles: true });
				setValue.call(selectElement.value, cur);
				selectElement.value.dispatchEvent(event);
			}
		});
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(VisuallyHidden_default), { "as-child": "" }, {
				default: withCtx(() => [createBaseVNode("select", mergeProps({
					ref_key: "selectElement",
					ref: selectElement
				}, props), [renderSlot(_ctx.$slots, "default")], 16)]),
				_: 3
			});
		};
	}
});
var OPEN_KEYS = [
	" ",
	"Enter",
	"ArrowUp",
	"ArrowDown"
];
var SELECTION_KEYS = [" ", "Enter"];
function valueComparator(value, currentValue, comparator) {
	if (value === void 0) return false;
	else if (Array.isArray(value)) return value.some((val) => compare(val, currentValue, comparator));
	else return compare(value, currentValue, comparator);
}
function compare(value, currentValue, comparator) {
	if (value === void 0 || currentValue === void 0) return false;
	if (typeof value === "string") return value === currentValue;
	if (typeof comparator === "function") return comparator(value, currentValue);
	if (typeof comparator === "string") return value?.[comparator] === currentValue?.[comparator];
	return isEqual(value, currentValue);
}
function shouldShowPlaceholder(value) {
	return value === void 0 || value === null || value === "" || Array.isArray(value) && value.length === 0;
}
var _hoisted_1$36 = {
	key: 0,
	value: ""
};
var [injectSelectRootContext, provideSelectRootContext] = createContext("SelectRoot");
var SelectRoot_default = /* @__PURE__ */ defineComponent({
	inheritAttrs: false,
	__name: "SelectRoot",
	props: {
		open: {
			type: Boolean,
			required: false,
			default: void 0
		},
		defaultOpen: {
			type: Boolean,
			required: false
		},
		defaultValue: {
			type: null,
			required: false
		},
		modelValue: {
			type: null,
			required: false,
			default: void 0
		},
		by: {
			type: [String, Function],
			required: false
		},
		dir: {
			type: String,
			required: false
		},
		multiple: {
			type: Boolean,
			required: false
		},
		autocomplete: {
			type: String,
			required: false
		},
		disabled: {
			type: Boolean,
			required: false
		},
		name: {
			type: String,
			required: false
		},
		required: {
			type: Boolean,
			required: false
		}
	},
	emits: ["update:modelValue", "update:open"],
	setup(__props, { emit: __emit }) {
		const props = __props;
		const emits = __emit;
		const { required, disabled: disabled$9, multiple, dir: propDir } = toRefs(props);
		const modelValue = useVModel(props, "modelValue", emits, {
			defaultValue: props.defaultValue ?? (multiple.value ? [] : void 0),
			passive: props.modelValue === void 0,
			deep: true
		});
		const open = useVModel(props, "open", emits, {
			defaultValue: props.defaultOpen,
			passive: props.open === void 0
		});
		const triggerElement = ref();
		const valueElement = ref();
		const triggerPointerDownPosRef = ref({
			x: 0,
			y: 0
		});
		const isEmptyModelValue = computed(() => {
			if (multiple.value && Array.isArray(modelValue.value)) return modelValue.value?.length === 0;
			else return isNullish(modelValue.value);
		});
		useCollection({ isProvider: true });
		const dir = useDirection(propDir);
		const isFormControl = useFormControl(triggerElement);
		const optionsSet = ref(/* @__PURE__ */ new Set());
		const nativeSelectKey = computed(() => {
			return Array.from(optionsSet.value).map((option) => option.value).join(";");
		});
		function handleValueChange(value) {
			if (multiple.value) {
				const array = Array.isArray(modelValue.value) ? [...modelValue.value] : [];
				const index = array.findIndex((i$1) => compare(i$1, value, props.by));
				index === -1 ? array.push(value) : array.splice(index, 1);
				modelValue.value = [...array];
			} else modelValue.value = value;
		}
		function getOption(value) {
			return Array.from(optionsSet.value).find((option) => valueComparator(value, option.value, props.by));
		}
		provideSelectRootContext({
			triggerElement,
			onTriggerChange: (node) => {
				triggerElement.value = node;
			},
			valueElement,
			onValueElementChange: (node) => {
				valueElement.value = node;
			},
			contentId: "",
			modelValue,
			onValueChange: handleValueChange,
			by: props.by,
			open,
			multiple,
			required,
			onOpenChange: (value) => {
				open.value = value;
			},
			dir,
			triggerPointerDownPosRef,
			disabled: disabled$9,
			isEmptyModelValue,
			optionsSet,
			onOptionAdd: (option) => {
				const existingOption = getOption(option.value);
				if (existingOption) optionsSet.value.delete(existingOption);
				optionsSet.value.add(option);
			},
			onOptionRemove: (option) => {
				const existingOption = getOption(option.value);
				if (existingOption) optionsSet.value.delete(existingOption);
			}
		});
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(PopperRoot_default), null, {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default", {
					modelValue: unref(modelValue),
					open: unref(open)
				}), unref(isFormControl) ? (openBlock(), createBlock(BubbleSelect_default, {
					key: nativeSelectKey.value,
					"aria-hidden": "true",
					tabindex: "-1",
					multiple: unref(multiple),
					required: unref(required),
					name: _ctx.name,
					autocomplete: _ctx.autocomplete,
					disabled: unref(disabled$9),
					value: unref(modelValue)
				}, {
					default: withCtx(() => [unref(isNullish)(unref(modelValue)) ? (openBlock(), createElementBlock("option", _hoisted_1$36)) : createCommentVNode("v-if", true), (openBlock(true), createElementBlock(Fragment, null, renderList(Array.from(optionsSet.value), (option) => {
						return openBlock(), createElementBlock("option", mergeProps({ key: option.value ?? "" }, { ref_for: true }, option), null, 16);
					}), 128))]),
					_: 1
				}, 8, [
					"multiple",
					"required",
					"name",
					"autocomplete",
					"disabled",
					"value"
				])) : createCommentVNode("v-if", true)]),
				_: 3
			});
		};
	}
});
var SelectPopperPosition_default = /* @__PURE__ */ defineComponent({
	__name: "SelectPopperPosition",
	props: {
		side: {
			type: null,
			required: false
		},
		sideOffset: {
			type: Number,
			required: false
		},
		sideFlip: {
			type: Boolean,
			required: false
		},
		align: {
			type: null,
			required: false,
			default: "start"
		},
		alignOffset: {
			type: Number,
			required: false
		},
		alignFlip: {
			type: Boolean,
			required: false
		},
		avoidCollisions: {
			type: Boolean,
			required: false
		},
		collisionBoundary: {
			type: null,
			required: false
		},
		collisionPadding: {
			type: [Number, Object],
			required: false,
			default: 10
		},
		arrowPadding: {
			type: Number,
			required: false
		},
		sticky: {
			type: String,
			required: false
		},
		hideWhenDetached: {
			type: Boolean,
			required: false
		},
		positionStrategy: {
			type: String,
			required: false
		},
		updatePositionStrategy: {
			type: String,
			required: false
		},
		disableUpdateOnLayoutShift: {
			type: Boolean,
			required: false
		},
		prioritizePosition: {
			type: Boolean,
			required: false
		},
		reference: {
			type: null,
			required: false
		},
		asChild: {
			type: Boolean,
			required: false
		},
		as: {
			type: null,
			required: false
		}
	},
	setup(__props) {
		const forwarded = useForwardProps(__props);
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(PopperContent_default), mergeProps(unref(forwarded), { style: {
				"boxSizing": "border-box",
				"--reka-select-content-transform-origin": "var(--reka-popper-transform-origin)",
				"--reka-select-content-available-width": "var(--reka-popper-available-width)",
				"--reka-select-content-available-height": "var(--reka-popper-available-height)",
				"--reka-select-trigger-width": "var(--reka-popper-anchor-width)",
				"--reka-select-trigger-height": "var(--reka-popper-anchor-height)"
			} }), {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 16);
		};
	}
});
var SelectContentDefaultContextValue = {
	onViewportChange: () => {},
	itemTextRefCallback: () => {},
	itemRefCallback: () => {}
};
var [injectSelectContentContext, provideSelectContentContext] = createContext("SelectContent");
var SelectContentImpl_default = /* @__PURE__ */ defineComponent({
	__name: "SelectContentImpl",
	props: {
		position: {
			type: String,
			required: false,
			default: "item-aligned"
		},
		bodyLock: {
			type: Boolean,
			required: false,
			default: true
		},
		side: {
			type: null,
			required: false
		},
		sideOffset: {
			type: Number,
			required: false
		},
		sideFlip: {
			type: Boolean,
			required: false
		},
		align: {
			type: null,
			required: false,
			default: "start"
		},
		alignOffset: {
			type: Number,
			required: false
		},
		alignFlip: {
			type: Boolean,
			required: false
		},
		avoidCollisions: {
			type: Boolean,
			required: false
		},
		collisionBoundary: {
			type: null,
			required: false
		},
		collisionPadding: {
			type: [Number, Object],
			required: false
		},
		arrowPadding: {
			type: Number,
			required: false
		},
		sticky: {
			type: String,
			required: false
		},
		hideWhenDetached: {
			type: Boolean,
			required: false
		},
		positionStrategy: {
			type: String,
			required: false
		},
		updatePositionStrategy: {
			type: String,
			required: false
		},
		disableUpdateOnLayoutShift: {
			type: Boolean,
			required: false
		},
		prioritizePosition: {
			type: Boolean,
			required: false
		},
		reference: {
			type: null,
			required: false
		},
		asChild: {
			type: Boolean,
			required: false
		},
		as: {
			type: null,
			required: false
		}
	},
	emits: [
		"closeAutoFocus",
		"escapeKeyDown",
		"pointerDownOutside"
	],
	setup(__props, { emit: __emit }) {
		const props = __props;
		const emits = __emit;
		const rootContext = injectSelectRootContext();
		useFocusGuards();
		useBodyScrollLock(props.bodyLock);
		const { CollectionSlot, getItems } = useCollection();
		const content$4 = ref();
		useHideOthers(content$4);
		const { search, handleTypeaheadSearch } = useTypeahead();
		const viewport$1 = ref();
		const selectedItem = ref();
		const selectedItemText = ref();
		const isPositioned = ref(false);
		const firstValidItemFoundRef = ref(false);
		const firstSelectedItemInArrayFoundRef = ref(false);
		function focusSelectedItem() {
			if (selectedItem.value && content$4.value) focusFirst([selectedItem.value, content$4.value]);
		}
		watch(isPositioned, () => {
			focusSelectedItem();
		});
		const { onOpenChange, triggerPointerDownPosRef } = rootContext;
		watchEffect((cleanupFn) => {
			if (!content$4.value) return;
			let pointerMoveDelta = {
				x: 0,
				y: 0
			};
			const handlePointerMove = (event) => {
				pointerMoveDelta = {
					x: Math.abs(Math.round(event.pageX) - (triggerPointerDownPosRef.value?.x ?? 0)),
					y: Math.abs(Math.round(event.pageY) - (triggerPointerDownPosRef.value?.y ?? 0))
				};
			};
			const handlePointerUp = (event) => {
				if (event.pointerType === "touch") return;
				if (pointerMoveDelta.x <= 10 && pointerMoveDelta.y <= 10) event.preventDefault();
				else if (!content$4.value?.contains(event.target)) onOpenChange(false);
				document.removeEventListener("pointermove", handlePointerMove);
				triggerPointerDownPosRef.value = null;
			};
			if (triggerPointerDownPosRef.value !== null) {
				document.addEventListener("pointermove", handlePointerMove);
				document.addEventListener("pointerup", handlePointerUp, {
					capture: true,
					once: true
				});
			}
			cleanupFn(() => {
				document.removeEventListener("pointermove", handlePointerMove);
				document.removeEventListener("pointerup", handlePointerUp, { capture: true });
			});
		});
		function handleKeyDown(event) {
			const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
			if (event.key === "Tab") event.preventDefault();
			if (!isModifierKey && event.key.length === 1) handleTypeaheadSearch(event.key, getItems());
			if ([
				"ArrowUp",
				"ArrowDown",
				"Home",
				"End"
			].includes(event.key)) {
				let candidateNodes = [...getItems().map((i$1) => i$1.ref)];
				if (["ArrowUp", "End"].includes(event.key)) candidateNodes = candidateNodes.slice().reverse();
				if (["ArrowUp", "ArrowDown"].includes(event.key)) {
					const currentElement = event.target;
					const currentIndex = candidateNodes.indexOf(currentElement);
					candidateNodes = candidateNodes.slice(currentIndex + 1);
				}
				setTimeout(() => focusFirst(candidateNodes));
				event.preventDefault();
			}
		}
		const forwardedProps = useForwardProps(computed(() => {
			if (props.position === "popper") return props;
			else return {};
		}).value);
		provideSelectContentContext({
			content: content$4,
			viewport: viewport$1,
			onViewportChange: (node) => {
				viewport$1.value = node;
			},
			itemRefCallback: (node, value, disabled$9) => {
				const isFirstValidItem = !firstValidItemFoundRef.value && !disabled$9;
				const isSelectedItem = valueComparator(rootContext.modelValue.value, value, rootContext.by);
				if (rootContext.multiple.value) {
					if (firstSelectedItemInArrayFoundRef.value) return;
					if (isSelectedItem || isFirstValidItem) {
						selectedItem.value = node;
						if (isSelectedItem) firstSelectedItemInArrayFoundRef.value = true;
					}
				} else if (isSelectedItem || isFirstValidItem) selectedItem.value = node;
				if (isFirstValidItem) firstValidItemFoundRef.value = true;
			},
			selectedItem,
			selectedItemText,
			onItemLeave: () => {
				content$4.value?.focus();
			},
			itemTextRefCallback: (node, value, disabled$9) => {
				const isFirstValidItem = !firstValidItemFoundRef.value && !disabled$9;
				if (valueComparator(rootContext.modelValue.value, value, rootContext.by) || isFirstValidItem) selectedItemText.value = node;
			},
			focusSelectedItem,
			position: props.position,
			isPositioned,
			searchRef: search
		});
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(CollectionSlot), null, {
				default: withCtx(() => [createVNode(unref(FocusScope_default), {
					"as-child": "",
					onMountAutoFocus: _cache[6] || (_cache[6] = withModifiers(() => {}, ["prevent"])),
					onUnmountAutoFocus: _cache[7] || (_cache[7] = (event) => {
						emits("closeAutoFocus", event);
						if (event.defaultPrevented) return;
						unref(rootContext).triggerElement.value?.focus({ preventScroll: true });
						event.preventDefault();
					})
				}, {
					default: withCtx(() => [createVNode(unref(DismissableLayer_default), {
						"as-child": "",
						"disable-outside-pointer-events": "",
						onFocusOutside: _cache[2] || (_cache[2] = withModifiers(() => {}, ["prevent"])),
						onDismiss: _cache[3] || (_cache[3] = ($event) => unref(rootContext).onOpenChange(false)),
						onEscapeKeyDown: _cache[4] || (_cache[4] = ($event) => emits("escapeKeyDown", $event)),
						onPointerDownOutside: _cache[5] || (_cache[5] = ($event) => emits("pointerDownOutside", $event))
					}, {
						default: withCtx(() => [(openBlock(), createBlock(resolveDynamicComponent(_ctx.position === "popper" ? SelectPopperPosition_default : SelectItemAlignedPosition_default), mergeProps({
							..._ctx.$attrs,
							...unref(forwardedProps)
						}, {
							id: unref(rootContext).contentId,
							ref: (vnode) => {
								const el$2 = unref(unrefElement)(vnode);
								if (el$2?.hasAttribute("data-reka-popper-content-wrapper")) content$4.value = el$2.firstElementChild;
								else content$4.value = el$2;
							},
							role: "listbox",
							"data-state": unref(rootContext).open.value ? "open" : "closed",
							dir: unref(rootContext).dir.value,
							style: {
								display: "flex",
								flexDirection: "column",
								outline: "none"
							},
							onContextmenu: _cache[0] || (_cache[0] = withModifiers(() => {}, ["prevent"])),
							onPlaced: _cache[1] || (_cache[1] = ($event) => isPositioned.value = true),
							onKeydown: handleKeyDown
						}), {
							default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
							_: 3
						}, 16, [
							"id",
							"data-state",
							"dir",
							"onKeydown"
						]))]),
						_: 3
					})]),
					_: 3
				})]),
				_: 3
			});
		};
	}
});
var [injectSelectItemAlignedPositionContext, provideSelectItemAlignedPositionContext] = createContext("SelectItemAlignedPosition");
var SelectItemAlignedPosition_default = /* @__PURE__ */ defineComponent({
	inheritAttrs: false,
	__name: "SelectItemAlignedPosition",
	props: {
		asChild: {
			type: Boolean,
			required: false
		},
		as: {
			type: null,
			required: false
		}
	},
	emits: ["placed"],
	setup(__props, { emit: __emit }) {
		const props = __props;
		const emits = __emit;
		const { getItems } = useCollection();
		const rootContext = injectSelectRootContext();
		const contentContext = injectSelectContentContext();
		const shouldExpandOnScrollRef = ref(false);
		const shouldRepositionRef = ref(true);
		const contentWrapperElement = ref();
		const { forwardRef, currentElement: contentElement } = useForwardExpose();
		const { viewport: viewport$1, selectedItem, selectedItemText, focusSelectedItem } = contentContext;
		function position() {
			if (rootContext.triggerElement.value && rootContext.valueElement.value && contentWrapperElement.value && contentElement.value && viewport$1?.value && selectedItem?.value && selectedItemText?.value) {
				const triggerRect = rootContext.triggerElement.value.getBoundingClientRect();
				const contentRect = contentElement.value.getBoundingClientRect();
				const valueNodeRect = rootContext.valueElement.value.getBoundingClientRect();
				const itemTextRect = selectedItemText.value.getBoundingClientRect();
				if (rootContext.dir.value !== "rtl") {
					const itemTextOffset = itemTextRect.left - contentRect.left;
					const left$1 = valueNodeRect.left - itemTextOffset;
					const leftDelta = triggerRect.left - left$1;
					const minContentWidth = triggerRect.width + leftDelta;
					const contentWidth = Math.max(minContentWidth, contentRect.width);
					const rightEdge = window.innerWidth - 10;
					const clampedLeft = clamp$1(left$1, 10, Math.max(10, rightEdge - contentWidth));
					contentWrapperElement.value.style.minWidth = `${minContentWidth}px`;
					contentWrapperElement.value.style.left = `${clampedLeft}px`;
				} else {
					const itemTextOffset = contentRect.right - itemTextRect.right;
					const right$1 = window.innerWidth - valueNodeRect.right - itemTextOffset;
					const rightDelta = window.innerWidth - triggerRect.right - right$1;
					const minContentWidth = triggerRect.width + rightDelta;
					const contentWidth = Math.max(minContentWidth, contentRect.width);
					const leftEdge = window.innerWidth - 10;
					const clampedRight = clamp$1(right$1, 10, Math.max(10, leftEdge - contentWidth));
					contentWrapperElement.value.style.minWidth = `${minContentWidth}px`;
					contentWrapperElement.value.style.right = `${clampedRight}px`;
				}
				const items = getItems().map((i$1) => i$1.ref);
				const availableHeight = window.innerHeight - 20;
				const itemsHeight = viewport$1.value.scrollHeight;
				const contentStyles = window.getComputedStyle(contentElement.value);
				const contentBorderTopWidth = Number.parseInt(contentStyles.borderTopWidth, 10);
				const contentPaddingTop = Number.parseInt(contentStyles.paddingTop, 10);
				const contentBorderBottomWidth = Number.parseInt(contentStyles.borderBottomWidth, 10);
				const contentPaddingBottom = Number.parseInt(contentStyles.paddingBottom, 10);
				const fullContentHeight = contentBorderTopWidth + contentPaddingTop + itemsHeight + contentPaddingBottom + contentBorderBottomWidth;
				const minContentHeight = Math.min(selectedItem.value.offsetHeight * 5, fullContentHeight);
				const viewportStyles = window.getComputedStyle(viewport$1.value);
				const viewportPaddingTop = Number.parseInt(viewportStyles.paddingTop, 10);
				const viewportPaddingBottom = Number.parseInt(viewportStyles.paddingBottom, 10);
				const topEdgeToTriggerMiddle = triggerRect.top + triggerRect.height / 2 - 10;
				const triggerMiddleToBottomEdge = availableHeight - topEdgeToTriggerMiddle;
				const selectedItemHalfHeight = selectedItem.value.offsetHeight / 2;
				const itemOffsetMiddle = selectedItem.value.offsetTop + selectedItemHalfHeight;
				const contentTopToItemMiddle = contentBorderTopWidth + contentPaddingTop + itemOffsetMiddle;
				const itemMiddleToContentBottom = fullContentHeight - contentTopToItemMiddle;
				if (contentTopToItemMiddle <= topEdgeToTriggerMiddle) {
					const isLastItem = selectedItem.value === items[items.length - 1];
					contentWrapperElement.value.style.bottom = `0px`;
					const viewportOffsetBottom = contentElement.value.clientHeight - viewport$1.value.offsetTop - viewport$1.value.offsetHeight;
					const height = contentTopToItemMiddle + Math.max(triggerMiddleToBottomEdge, selectedItemHalfHeight + (isLastItem ? viewportPaddingBottom : 0) + viewportOffsetBottom + contentBorderBottomWidth);
					contentWrapperElement.value.style.height = `${height}px`;
				} else {
					const isFirstItem = selectedItem.value === items[0];
					contentWrapperElement.value.style.top = `0px`;
					const height = Math.max(topEdgeToTriggerMiddle, contentBorderTopWidth + viewport$1.value.offsetTop + (isFirstItem ? viewportPaddingTop : 0) + selectedItemHalfHeight) + itemMiddleToContentBottom;
					contentWrapperElement.value.style.height = `${height}px`;
					viewport$1.value.scrollTop = contentTopToItemMiddle - topEdgeToTriggerMiddle + viewport$1.value.offsetTop;
				}
				contentWrapperElement.value.style.margin = `10px 0`;
				contentWrapperElement.value.style.minHeight = `${minContentHeight}px`;
				contentWrapperElement.value.style.maxHeight = `${availableHeight}px`;
				emits("placed");
				requestAnimationFrame(() => shouldExpandOnScrollRef.value = true);
			}
		}
		const contentZIndex = ref("");
		onMounted(async () => {
			await nextTick();
			position();
			if (contentElement.value) contentZIndex.value = window.getComputedStyle(contentElement.value).zIndex;
		});
		function handleScrollButtonChange(node) {
			if (node && shouldRepositionRef.value === true) {
				position();
				focusSelectedItem?.();
				shouldRepositionRef.value = false;
			}
		}
		useResizeObserver$1(rootContext.triggerElement, () => {
			position();
		});
		provideSelectItemAlignedPositionContext({
			contentWrapper: contentWrapperElement,
			shouldExpandOnScrollRef,
			onScrollButtonChange: handleScrollButtonChange
		});
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", {
				ref_key: "contentWrapperElement",
				ref: contentWrapperElement,
				style: normalizeStyle({
					display: "flex",
					flexDirection: "column",
					position: "fixed",
					zIndex: contentZIndex.value
				})
			}, [createVNode(unref(Primitive), mergeProps({
				ref: unref(forwardRef),
				style: {
					boxSizing: "border-box",
					maxHeight: "100%"
				}
			}, {
				..._ctx.$attrs,
				...props
			}), {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 16)], 4);
		};
	}
});
var SelectProvider_default = /* @__PURE__ */ defineComponent({
	inheritAttrs: false,
	__name: "SelectProvider",
	props: { context: {
		type: Object,
		required: true
	} },
	setup(__props) {
		provideSelectRootContext(__props.context);
		provideSelectContentContext(SelectContentDefaultContextValue);
		return (_ctx, _cache) => {
			return renderSlot(_ctx.$slots, "default");
		};
	}
});
var _hoisted_1$35 = { key: 1 };
var SelectContent_default = /* @__PURE__ */ defineComponent({
	inheritAttrs: false,
	__name: "SelectContent",
	props: {
		forceMount: {
			type: Boolean,
			required: false
		},
		position: {
			type: String,
			required: false
		},
		bodyLock: {
			type: Boolean,
			required: false
		},
		side: {
			type: null,
			required: false
		},
		sideOffset: {
			type: Number,
			required: false
		},
		sideFlip: {
			type: Boolean,
			required: false
		},
		align: {
			type: null,
			required: false
		},
		alignOffset: {
			type: Number,
			required: false
		},
		alignFlip: {
			type: Boolean,
			required: false
		},
		avoidCollisions: {
			type: Boolean,
			required: false
		},
		collisionBoundary: {
			type: null,
			required: false
		},
		collisionPadding: {
			type: [Number, Object],
			required: false
		},
		arrowPadding: {
			type: Number,
			required: false
		},
		sticky: {
			type: String,
			required: false
		},
		hideWhenDetached: {
			type: Boolean,
			required: false
		},
		positionStrategy: {
			type: String,
			required: false
		},
		updatePositionStrategy: {
			type: String,
			required: false
		},
		disableUpdateOnLayoutShift: {
			type: Boolean,
			required: false
		},
		prioritizePosition: {
			type: Boolean,
			required: false
		},
		reference: {
			type: null,
			required: false
		},
		asChild: {
			type: Boolean,
			required: false
		},
		as: {
			type: null,
			required: false
		}
	},
	emits: [
		"closeAutoFocus",
		"escapeKeyDown",
		"pointerDownOutside"
	],
	setup(__props, { emit: __emit }) {
		const props = __props;
		const forwarded = useForwardPropsEmits(props, __emit);
		const rootContext = injectSelectRootContext();
		const fragment = ref();
		onMounted(() => {
			fragment.value = new DocumentFragment();
		});
		const presenceRef = ref();
		const present = computed(() => props.forceMount || rootContext.open.value);
		const renderPresence = ref(present.value);
		watch(present, () => {
			setTimeout(() => renderPresence.value = present.value);
		});
		return (_ctx, _cache) => {
			return present.value || renderPresence.value || presenceRef.value?.present ? (openBlock(), createBlock(unref(Presence_default), {
				key: 0,
				ref_key: "presenceRef",
				ref: presenceRef,
				present: present.value
			}, {
				default: withCtx(() => [createVNode(SelectContentImpl_default, normalizeProps(guardReactiveProps({
					...unref(forwarded),
					..._ctx.$attrs
				})), {
					default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
					_: 3
				}, 16)]),
				_: 3
			}, 8, ["present"])) : fragment.value ? (openBlock(), createElementBlock("div", _hoisted_1$35, [(openBlock(), createBlock(Teleport, { to: fragment.value }, [createVNode(SelectProvider_default, { context: unref(rootContext) }, {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 8, ["context"])], 8, ["to"]))])) : createCommentVNode("v-if", true);
		};
	}
});
var [injectSelectGroupContext, provideSelectGroupContext] = createContext("SelectGroup");
var SelectGroup_default = /* @__PURE__ */ defineComponent({
	__name: "SelectGroup",
	props: {
		asChild: {
			type: Boolean,
			required: false
		},
		as: {
			type: null,
			required: false
		}
	},
	setup(__props) {
		const props = __props;
		const id$1 = useId(void 0, "reka-select-group");
		provideSelectGroupContext({ id: id$1 });
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(Primitive), mergeProps({ role: "group" }, props, { "aria-labelledby": unref(id$1) }), {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 16, ["aria-labelledby"]);
		};
	}
});
var [injectSelectItemContext, provideSelectItemContext] = createContext("SelectItem");
var SelectItem_default$1 = /* @__PURE__ */ defineComponent({
	__name: "SelectItem",
	props: {
		value: {
			type: null,
			required: true
		},
		disabled: {
			type: Boolean,
			required: false
		},
		textValue: {
			type: String,
			required: false
		},
		asChild: {
			type: Boolean,
			required: false
		},
		as: {
			type: null,
			required: false
		}
	},
	emits: ["select"],
	setup(__props, { emit: __emit }) {
		const props = __props;
		const emits = __emit;
		const { disabled: disabled$9 } = toRefs(props);
		const rootContext = injectSelectRootContext();
		const contentContext = injectSelectContentContext();
		const { forwardRef, currentElement } = useForwardExpose();
		const { CollectionItem: CollectionItem$1 } = useCollection();
		const isSelected = computed(() => valueComparator(rootContext.modelValue?.value, props.value, rootContext.by));
		const isFocused = ref(false);
		const textValue = ref(props.textValue ?? "");
		const textId = useId(void 0, "reka-select-item-text");
		const SELECT_SELECT = "select.select";
		async function handleSelectCustomEvent(ev) {
			if (ev.defaultPrevented) return;
			handleAndDispatchCustomEvent(SELECT_SELECT, handleSelect, {
				originalEvent: ev,
				value: props.value
			});
		}
		async function handleSelect(ev) {
			await nextTick();
			emits("select", ev);
			if (ev.defaultPrevented) return;
			if (!disabled$9.value) {
				rootContext.onValueChange(props.value);
				if (!rootContext.multiple.value) rootContext.onOpenChange(false);
			}
		}
		async function handlePointerMove(event) {
			await nextTick();
			if (event.defaultPrevented) return;
			if (disabled$9.value) contentContext.onItemLeave?.();
			else event.currentTarget?.focus({ preventScroll: true });
		}
		async function handlePointerLeave(event) {
			await nextTick();
			if (event.defaultPrevented) return;
			if (event.currentTarget === getActiveElement()) contentContext.onItemLeave?.();
		}
		async function handleKeyDown(event) {
			await nextTick();
			if (event.defaultPrevented) return;
			if (contentContext.searchRef?.value !== "" && event.key === " ") return;
			if (SELECTION_KEYS.includes(event.key)) handleSelectCustomEvent(event);
			if (event.key === " ") event.preventDefault();
		}
		if (props.value === "") throw new Error("A <SelectItem /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder.");
		onMounted(() => {
			if (!currentElement.value) return;
			contentContext.itemRefCallback(currentElement.value, props.value, props.disabled);
		});
		provideSelectItemContext({
			value: props.value,
			disabled: disabled$9,
			textId,
			isSelected,
			onItemTextChange: (node) => {
				textValue.value = ((textValue.value || node?.textContent) ?? "").trim();
			}
		});
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(CollectionItem$1), { value: { textValue: textValue.value } }, {
				default: withCtx(() => [createVNode(unref(Primitive), {
					ref: unref(forwardRef),
					role: "option",
					"aria-labelledby": unref(textId),
					"data-highlighted": isFocused.value ? "" : void 0,
					"aria-selected": isSelected.value,
					"data-state": isSelected.value ? "checked" : "unchecked",
					"aria-disabled": unref(disabled$9) || void 0,
					"data-disabled": unref(disabled$9) ? "" : void 0,
					tabindex: unref(disabled$9) ? void 0 : -1,
					as: _ctx.as,
					"as-child": _ctx.asChild,
					onFocus: _cache[0] || (_cache[0] = ($event) => isFocused.value = true),
					onBlur: _cache[1] || (_cache[1] = ($event) => isFocused.value = false),
					onPointerup: handleSelectCustomEvent,
					onPointerdown: _cache[2] || (_cache[2] = (event) => {
						event.currentTarget.focus({ preventScroll: true });
					}),
					onTouchend: _cache[3] || (_cache[3] = withModifiers(() => {}, ["prevent", "stop"])),
					onPointermove: handlePointerMove,
					onPointerleave: handlePointerLeave,
					onKeydown: handleKeyDown
				}, {
					default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
					_: 3
				}, 8, [
					"aria-labelledby",
					"data-highlighted",
					"aria-selected",
					"data-state",
					"aria-disabled",
					"data-disabled",
					"tabindex",
					"as",
					"as-child"
				])]),
				_: 3
			}, 8, ["value"]);
		};
	}
});
var SelectItemIndicator_default = /* @__PURE__ */ defineComponent({
	__name: "SelectItemIndicator",
	props: {
		asChild: {
			type: Boolean,
			required: false
		},
		as: {
			type: null,
			required: false,
			default: "span"
		}
	},
	setup(__props) {
		const props = __props;
		const itemContext = injectSelectItemContext();
		return (_ctx, _cache) => {
			return unref(itemContext).isSelected.value ? (openBlock(), createBlock(unref(Primitive), mergeProps({
				key: 0,
				"aria-hidden": "true"
			}, props), {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 16)) : createCommentVNode("v-if", true);
		};
	}
});
var SelectItemText_default = /* @__PURE__ */ defineComponent({
	inheritAttrs: false,
	__name: "SelectItemText",
	props: {
		asChild: {
			type: Boolean,
			required: false
		},
		as: {
			type: null,
			required: false,
			default: "span"
		}
	},
	setup(__props) {
		const props = __props;
		const rootContext = injectSelectRootContext();
		const contentContext = injectSelectContentContext();
		const itemContext = injectSelectItemContext();
		const { forwardRef, currentElement: itemTextElement } = useForwardExpose();
		const optionProps = computed(() => {
			return {
				value: itemContext.value,
				disabled: itemContext.disabled.value,
				textContent: itemTextElement.value?.textContent ?? itemContext.value?.toString() ?? ""
			};
		});
		onMounted(() => {
			if (!itemTextElement.value) return;
			itemContext.onItemTextChange(itemTextElement.value);
			contentContext.itemTextRefCallback(itemTextElement.value, itemContext.value, itemContext.disabled.value);
			rootContext.onOptionAdd(optionProps.value);
		});
		onUnmounted(() => {
			rootContext.onOptionRemove(optionProps.value);
		});
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(Primitive), mergeProps({
				id: unref(itemContext).textId,
				ref: unref(forwardRef)
			}, {
				...props,
				..._ctx.$attrs
			}), {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 16, ["id"]);
		};
	}
});
var SelectLabel_default = /* @__PURE__ */ defineComponent({
	__name: "SelectLabel",
	props: {
		for: {
			type: String,
			required: false
		},
		asChild: {
			type: Boolean,
			required: false
		},
		as: {
			type: null,
			required: false,
			default: "div"
		}
	},
	setup(__props) {
		const props = __props;
		const groupContext = injectSelectGroupContext({ id: "" });
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(Primitive), mergeProps(props, { id: unref(groupContext).id }), {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 16, ["id"]);
		};
	}
});
var SelectPortal_default = /* @__PURE__ */ defineComponent({
	__name: "SelectPortal",
	props: {
		to: {
			type: null,
			required: false
		},
		disabled: {
			type: Boolean,
			required: false
		},
		defer: {
			type: Boolean,
			required: false
		},
		forceMount: {
			type: Boolean,
			required: false
		}
	},
	setup(__props) {
		const props = __props;
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(Teleport_default), normalizeProps(guardReactiveProps(props)), {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 16);
		};
	}
});
var SelectScrollButtonImpl_default = /* @__PURE__ */ defineComponent({
	__name: "SelectScrollButtonImpl",
	emits: ["autoScroll"],
	setup(__props, { emit: __emit }) {
		const emits = __emit;
		const { getItems } = useCollection();
		const contentContext = injectSelectContentContext();
		const autoScrollTimerRef = ref(null);
		function clearAutoScrollTimer() {
			if (autoScrollTimerRef.value !== null) {
				window.clearInterval(autoScrollTimerRef.value);
				autoScrollTimerRef.value = null;
			}
		}
		watchEffect(() => {
			getItems().map((i$1) => i$1.ref).find((item$4) => item$4 === getActiveElement())?.scrollIntoView({ block: "nearest" });
		});
		function handlePointerDown() {
			if (autoScrollTimerRef.value === null) autoScrollTimerRef.value = window.setInterval(() => {
				emits("autoScroll");
			}, 50);
		}
		function handlePointerMove() {
			contentContext.onItemLeave?.();
			if (autoScrollTimerRef.value === null) autoScrollTimerRef.value = window.setInterval(() => {
				emits("autoScroll");
			}, 50);
		}
		onBeforeUnmount(() => clearAutoScrollTimer());
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(Primitive), mergeProps({
				"aria-hidden": "true",
				style: { flexShrink: 0 }
			}, _ctx.$parent?.$props, {
				onPointerdown: handlePointerDown,
				onPointermove: handlePointerMove,
				onPointerleave: _cache[0] || (_cache[0] = () => {
					clearAutoScrollTimer();
				})
			}), {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 16);
		};
	}
});
var SelectScrollDownButton_default = /* @__PURE__ */ defineComponent({
	__name: "SelectScrollDownButton",
	props: {
		asChild: {
			type: Boolean,
			required: false
		},
		as: {
			type: null,
			required: false
		}
	},
	setup(__props) {
		const contentContext = injectSelectContentContext();
		const alignedPositionContext = contentContext.position === "item-aligned" ? injectSelectItemAlignedPositionContext() : void 0;
		const { forwardRef, currentElement } = useForwardExpose();
		const canScrollDown = ref(false);
		watchEffect((cleanupFn) => {
			if (contentContext.viewport?.value && contentContext.isPositioned?.value) {
				const viewport$1 = contentContext.viewport.value;
				function handleScroll() {
					const maxScroll = viewport$1.scrollHeight - viewport$1.clientHeight;
					canScrollDown.value = Math.ceil(viewport$1.scrollTop) < maxScroll;
				}
				handleScroll();
				viewport$1.addEventListener("scroll", handleScroll);
				cleanupFn(() => viewport$1.removeEventListener("scroll", handleScroll));
			}
		});
		watch(currentElement, () => {
			if (currentElement.value) alignedPositionContext?.onScrollButtonChange(currentElement.value);
		});
		return (_ctx, _cache) => {
			return canScrollDown.value ? (openBlock(), createBlock(SelectScrollButtonImpl_default, {
				key: 0,
				ref: unref(forwardRef),
				onAutoScroll: _cache[0] || (_cache[0] = () => {
					const { viewport: viewport$1, selectedItem } = unref(contentContext);
					if (viewport$1?.value && selectedItem?.value) viewport$1.value.scrollTop = viewport$1.value.scrollTop + selectedItem.value.offsetHeight;
				})
			}, {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 512)) : createCommentVNode("v-if", true);
		};
	}
});
var SelectScrollUpButton_default = /* @__PURE__ */ defineComponent({
	__name: "SelectScrollUpButton",
	props: {
		asChild: {
			type: Boolean,
			required: false
		},
		as: {
			type: null,
			required: false
		}
	},
	setup(__props) {
		const contentContext = injectSelectContentContext();
		const alignedPositionContext = contentContext.position === "item-aligned" ? injectSelectItemAlignedPositionContext() : void 0;
		const { forwardRef, currentElement } = useForwardExpose();
		const canScrollUp = ref(false);
		watchEffect((cleanupFn) => {
			if (contentContext.viewport?.value && contentContext.isPositioned?.value) {
				const viewport$1 = contentContext.viewport.value;
				function handleScroll() {
					canScrollUp.value = viewport$1.scrollTop > 0;
				}
				handleScroll();
				viewport$1.addEventListener("scroll", handleScroll);
				cleanupFn(() => viewport$1.removeEventListener("scroll", handleScroll));
			}
		});
		watch(currentElement, () => {
			if (currentElement.value) alignedPositionContext?.onScrollButtonChange(currentElement.value);
		});
		return (_ctx, _cache) => {
			return canScrollUp.value ? (openBlock(), createBlock(SelectScrollButtonImpl_default, {
				key: 0,
				ref: unref(forwardRef),
				onAutoScroll: _cache[0] || (_cache[0] = () => {
					const { viewport: viewport$1, selectedItem } = unref(contentContext);
					if (viewport$1?.value && selectedItem?.value) viewport$1.value.scrollTop = viewport$1.value.scrollTop - selectedItem.value.offsetHeight;
				})
			}, {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 512)) : createCommentVNode("v-if", true);
		};
	}
});
var SelectSeparator_default = /* @__PURE__ */ defineComponent({
	__name: "SelectSeparator",
	props: {
		asChild: {
			type: Boolean,
			required: false
		},
		as: {
			type: null,
			required: false
		}
	},
	setup(__props) {
		const props = __props;
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(Primitive), mergeProps({ "aria-hidden": "true" }, props), {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 16);
		};
	}
});
var SelectTrigger_default = /* @__PURE__ */ defineComponent({
	__name: "SelectTrigger",
	props: {
		disabled: {
			type: Boolean,
			required: false
		},
		reference: {
			type: null,
			required: false
		},
		asChild: {
			type: Boolean,
			required: false
		},
		as: {
			type: null,
			required: false,
			default: "button"
		}
	},
	setup(__props) {
		const props = __props;
		const rootContext = injectSelectRootContext();
		const { forwardRef, currentElement: triggerElement } = useForwardExpose();
		const isDisabled = computed(() => rootContext.disabled?.value || props.disabled);
		rootContext.contentId ||= useId(void 0, "reka-select-content");
		onMounted(() => {
			rootContext.onTriggerChange(triggerElement.value);
		});
		const { getItems } = useCollection();
		const { search, handleTypeaheadSearch, resetTypeahead } = useTypeahead();
		function handleOpen() {
			if (!isDisabled.value) {
				rootContext.onOpenChange(true);
				resetTypeahead();
			}
		}
		function handlePointerOpen(event) {
			handleOpen();
			rootContext.triggerPointerDownPosRef.value = {
				x: Math.round(event.pageX),
				y: Math.round(event.pageY)
			};
		}
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(PopperAnchor_default), {
				"as-child": "",
				reference: _ctx.reference
			}, {
				default: withCtx(() => [createVNode(unref(Primitive), {
					ref: unref(forwardRef),
					role: "combobox",
					type: _ctx.as === "button" ? "button" : void 0,
					"aria-controls": unref(rootContext).contentId,
					"aria-expanded": unref(rootContext).open.value || false,
					"aria-required": unref(rootContext).required?.value,
					"aria-autocomplete": "none",
					disabled: isDisabled.value,
					dir: unref(rootContext)?.dir.value,
					"data-state": unref(rootContext)?.open.value ? "open" : "closed",
					"data-disabled": isDisabled.value ? "" : void 0,
					"data-placeholder": unref(shouldShowPlaceholder)(unref(rootContext).modelValue?.value) ? "" : void 0,
					"as-child": _ctx.asChild,
					as: _ctx.as,
					onClick: _cache[0] || (_cache[0] = (event) => {
						(event?.currentTarget)?.focus();
					}),
					onPointerdown: _cache[1] || (_cache[1] = (event) => {
						if (event.pointerType === "touch") return event.preventDefault();
						const target$1 = event.target;
						if (target$1.hasPointerCapture(event.pointerId)) target$1.releasePointerCapture(event.pointerId);
						if (event.button === 0 && event.ctrlKey === false) {
							handlePointerOpen(event);
							event.preventDefault();
						}
					}),
					onPointerup: _cache[2] || (_cache[2] = withModifiers((event) => {
						if (event.pointerType === "touch") handlePointerOpen(event);
					}, ["prevent"])),
					onKeydown: _cache[3] || (_cache[3] = (event) => {
						const isTypingAhead = unref(search) !== "";
						if (!(event.ctrlKey || event.altKey || event.metaKey) && event.key.length === 1) {
							if (isTypingAhead && event.key === " ") return;
						}
						unref(handleTypeaheadSearch)(event.key, unref(getItems)());
						if (unref(OPEN_KEYS).includes(event.key)) {
							handleOpen();
							event.preventDefault();
						}
					})
				}, {
					default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
					_: 3
				}, 8, [
					"type",
					"aria-controls",
					"aria-expanded",
					"aria-required",
					"disabled",
					"dir",
					"data-state",
					"data-disabled",
					"data-placeholder",
					"as-child",
					"as"
				])]),
				_: 3
			}, 8, ["reference"]);
		};
	}
});
var SelectValue_default = /* @__PURE__ */ defineComponent({
	__name: "SelectValue",
	props: {
		placeholder: {
			type: String,
			required: false,
			default: ""
		},
		asChild: {
			type: Boolean,
			required: false
		},
		as: {
			type: null,
			required: false,
			default: "span"
		}
	},
	setup(__props) {
		const props = __props;
		const { forwardRef, currentElement } = useForwardExpose();
		const rootContext = injectSelectRootContext();
		onMounted(() => {
			rootContext.valueElement = currentElement;
		});
		const selectedLabel = computed(() => {
			let list$1 = [];
			const options$1 = Array.from(rootContext.optionsSet.value);
			const getOption = (value) => options$1.find((option) => valueComparator(value, option.value, rootContext.by));
			if (Array.isArray(rootContext.modelValue.value)) list$1 = rootContext.modelValue.value.map((value) => getOption(value)?.textContent ?? "");
			else list$1 = [getOption(rootContext.modelValue.value)?.textContent ?? ""];
			return list$1.filter(Boolean);
		});
		const slotText = computed(() => {
			return selectedLabel.value.length ? selectedLabel.value.join(", ") : props.placeholder;
		});
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(Primitive), {
				ref: unref(forwardRef),
				as: _ctx.as,
				"as-child": _ctx.asChild,
				style: { pointerEvents: "none" },
				"data-placeholder": selectedLabel.value.length ? void 0 : props.placeholder
			}, {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default", {
					selectedLabel: selectedLabel.value,
					modelValue: unref(rootContext).modelValue.value
				}, () => [createTextVNode(toDisplayString(slotText.value), 1)])]),
				_: 3
			}, 8, [
				"as",
				"as-child",
				"data-placeholder"
			]);
		};
	}
});
var SelectViewport_default = /* @__PURE__ */ defineComponent({
	__name: "SelectViewport",
	props: {
		nonce: {
			type: String,
			required: false
		},
		asChild: {
			type: Boolean,
			required: false
		},
		as: {
			type: null,
			required: false
		}
	},
	setup(__props) {
		const props = __props;
		const { nonce: propNonce } = toRefs(props);
		const nonce = useNonce(propNonce);
		const contentContext = injectSelectContentContext();
		const alignedPositionContext = contentContext.position === "item-aligned" ? injectSelectItemAlignedPositionContext() : void 0;
		const { forwardRef, currentElement } = useForwardExpose();
		onMounted(() => {
			contentContext?.onViewportChange(currentElement.value);
		});
		const prevScrollTopRef = ref(0);
		function handleScroll(event) {
			const viewport$1 = event.currentTarget;
			const { shouldExpandOnScrollRef, contentWrapper } = alignedPositionContext ?? {};
			if (shouldExpandOnScrollRef?.value && contentWrapper?.value) {
				const scrolledBy = Math.abs(prevScrollTopRef.value - viewport$1.scrollTop);
				if (scrolledBy > 0) {
					const availableHeight = window.innerHeight - 20;
					const cssMinHeight = Number.parseFloat(contentWrapper.value.style.minHeight);
					const cssHeight = Number.parseFloat(contentWrapper.value.style.height);
					const prevHeight = Math.max(cssMinHeight, cssHeight);
					if (prevHeight < availableHeight) {
						const nextHeight = prevHeight + scrolledBy;
						const clampedNextHeight = Math.min(availableHeight, nextHeight);
						const heightDiff = nextHeight - clampedNextHeight;
						contentWrapper.value.style.height = `${clampedNextHeight}px`;
						if (contentWrapper.value.style.bottom === "0px") {
							viewport$1.scrollTop = heightDiff > 0 ? heightDiff : 0;
							contentWrapper.value.style.justifyContent = "flex-end";
						}
					}
				}
			}
			prevScrollTopRef.value = viewport$1.scrollTop;
		}
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock(Fragment, null, [createVNode(unref(Primitive), mergeProps({
				ref: unref(forwardRef),
				"data-reka-select-viewport": "",
				role: "presentation"
			}, {
				..._ctx.$attrs,
				...props
			}, {
				style: {
					position: "relative",
					flex: 1,
					overflow: "hidden auto"
				},
				onScroll: handleScroll
			}), {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 16), createVNode(unref(Primitive), {
				as: "style",
				nonce: unref(nonce)
			}, {
				default: withCtx(() => _cache[0] || (_cache[0] = [createTextVNode(" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-reka-select-viewport] { scrollbar-width:none; -ms-overflow-style: none; -webkit-overflow-scrolling: touch; } [data-reka-select-viewport]::-webkit-scrollbar { display: none; } ")])),
				_: 1,
				__: [0]
			}, 8, ["nonce"])], 64);
		};
	}
});
var N8nScrollArea_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "N8nScrollArea",
	props: {
		type: { default: "hover" },
		dir: { default: "ltr" },
		scrollHideDelay: { default: 600 },
		maxHeight: { default: void 0 },
		maxWidth: { default: void 0 },
		enableHorizontalScroll: {
			type: Boolean,
			default: false
		},
		enableVerticalScroll: {
			type: Boolean,
			default: true
		},
		asChild: {
			type: Boolean,
			default: false
		}
	},
	setup(__props, { expose: __expose }) {
		const props = __props;
		const rootRef = ref();
		const viewportStyle = computed(() => {
			const style = {};
			if (props.maxHeight) style.maxHeight = props.maxHeight;
			if (props.maxWidth) style.maxWidth = props.maxWidth;
			return style;
		});
		function getViewportElement() {
			if (!rootRef.value?.viewport) return void 0;
			const viewport$1 = rootRef.value.viewport;
			if (typeof viewport$1 === "object" && "value" in viewport$1) return viewport$1.value;
			if (viewport$1 instanceof HTMLElement) return viewport$1;
		}
		async function scrollToBottom(options$1 = {}) {
			await nextTick();
			const viewport$1 = getViewportElement();
			if (viewport$1 && typeof viewport$1.scrollTo === "function") viewport$1.scrollTo({
				top: viewport$1.scrollHeight,
				behavior: options$1.smooth ? "smooth" : "auto"
			});
			else if (viewport$1) viewport$1.scrollTop = viewport$1.scrollHeight;
		}
		async function scrollToTop(options$1 = {}) {
			await nextTick();
			const viewport$1 = getViewportElement();
			if (viewport$1 && typeof viewport$1.scrollTo === "function") viewport$1.scrollTo({
				top: 0,
				behavior: options$1.smooth ? "smooth" : "auto"
			});
			else if (viewport$1) viewport$1.scrollTop = 0;
		}
		function getScrollPosition() {
			const viewport$1 = getViewportElement();
			if (viewport$1) return {
				top: viewport$1.scrollTop,
				left: viewport$1.scrollLeft,
				height: viewport$1.scrollHeight,
				width: viewport$1.scrollWidth
			};
			return null;
		}
		__expose({
			scrollToBottom,
			scrollToTop,
			getScrollPosition
		});
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(ScrollAreaRoot_default), {
				ref_key: "rootRef",
				ref: rootRef,
				type: _ctx.type,
				dir: _ctx.dir,
				"scroll-hide-delay": _ctx.scrollHideDelay,
				class: normalizeClass(_ctx.$style.scrollAreaRoot)
			}, {
				default: withCtx(() => [
					createVNode(unref(ScrollAreaViewport_default), {
						"as-child": _ctx.asChild,
						class: normalizeClass(_ctx.$style.viewport),
						style: normalizeStyle(viewportStyle.value)
					}, {
						default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
						_: 3
					}, 8, [
						"as-child",
						"class",
						"style"
					]),
					_ctx.enableVerticalScroll ? (openBlock(), createBlock(unref(ScrollAreaScrollbar_default), {
						key: 0,
						orientation: "vertical",
						class: normalizeClass(_ctx.$style.scrollbar)
					}, {
						default: withCtx(() => [createVNode(unref(ScrollAreaThumb_default), { class: normalizeClass(_ctx.$style.thumb) }, null, 8, ["class"])]),
						_: 1
					}, 8, ["class"])) : createCommentVNode("", true),
					_ctx.enableHorizontalScroll ? (openBlock(), createBlock(unref(ScrollAreaScrollbar_default), {
						key: 1,
						orientation: "horizontal",
						class: normalizeClass(_ctx.$style.scrollbar)
					}, {
						default: withCtx(() => [createVNode(unref(ScrollAreaThumb_default), { class: normalizeClass(_ctx.$style.thumb) }, null, 8, ["class"])]),
						_: 1
					}, 8, ["class"])) : createCommentVNode("", true),
					_ctx.enableHorizontalScroll && _ctx.enableVerticalScroll ? (openBlock(), createBlock(unref(ScrollAreaCorner_default), { key: 2 })) : createCommentVNode("", true)
				]),
				_: 3
			}, 8, [
				"type",
				"dir",
				"scroll-hide-delay",
				"class"
			]);
		};
	}
});
var N8nScrollArea_vue_vue_type_style_index_0_lang_module_default = {
	scrollAreaRoot: "_scrollAreaRoot_1vuxm_123",
	viewport: "_viewport_1vuxm_131",
	scrollbar: "_scrollbar_1vuxm_138",
	thumb: "_thumb_1vuxm_158"
};
var N8nScrollArea_default$1 = /* @__PURE__ */ __plugin_vue_export_helper_default(N8nScrollArea_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": N8nScrollArea_vue_vue_type_style_index_0_lang_module_default }]]);
var N8nSendStopButton_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "N8nSendStopButton",
	props: {
		streaming: {
			type: Boolean,
			default: false
		},
		disabled: {
			type: Boolean,
			default: false
		},
		size: { default: "small" }
	},
	emits: ["send", "stop"],
	setup(__props, { emit: __emit }) {
		const emit = __emit;
		function handleSend() {
			emit("send");
		}
		function handleStop() {
			emit("stop");
		}
		return (_ctx, _cache) => {
			return _ctx.streaming ? (openBlock(), createBlock(unref(N8nButton_default), {
				key: 0,
				class: normalizeClass(_ctx.$style.stopButton),
				type: "primary",
				size: _ctx.size,
				icon: "filled-square",
				"icon-size": "small",
				square: "",
				onClick: handleStop
			}, null, 8, ["class", "size"])) : (openBlock(), createBlock(unref(N8nButton_default), {
				key: 1,
				class: normalizeClass(_ctx.$style.sendButton),
				type: "primary",
				size: _ctx.size,
				"icon-size": "large",
				square: "",
				icon: "arrow-up",
				disabled: _ctx.disabled,
				onClick: handleSend
			}, null, 8, [
				"class",
				"size",
				"disabled"
			]));
		};
	}
});
var N8nSendStopButton_vue_vue_type_style_index_0_lang_module_default = {
	sendButton: "_sendButton_15g2i_123",
	stopButton: "_stopButton_15g2i_127"
};
var N8nSendStopButton_default = /* @__PURE__ */ __plugin_vue_export_helper_default(N8nSendStopButton_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": N8nSendStopButton_vue_vue_type_style_index_0_lang_module_default }]]);
var _hoisted_1$34 = [
	"placeholder",
	"disabled",
	"maxlength"
];
var _hoisted_2$21 = [
	"placeholder",
	"disabled",
	"maxlength"
];
var INFINITE_CREDITS = -1;
var singleLineHeight = 24;
var lineHeight = 18;
var N8nPromptInput_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "N8nPromptInput",
	props: {
		modelValue: { default: "" },
		placeholder: { default: "" },
		maxLength: { default: 5e3 },
		maxLinesBeforeScroll: { default: 10 },
		minLines: { default: 1 },
		streaming: {
			type: Boolean,
			default: false
		},
		disabled: {
			type: Boolean,
			default: false
		},
		creditsQuota: { default: void 0 },
		creditsRemaining: { default: void 0 },
		showAskOwnerTooltip: {
			type: Boolean,
			default: false
		},
		refocusAfterSend: {
			type: Boolean,
			default: false
		},
		autofocus: {
			type: Boolean,
			default: false
		}
	},
	emits: [
		"update:modelValue",
		"submit",
		"stop",
		"focus",
		"blur",
		"upgrade-click"
	],
	setup(__props, { expose: __expose, emit: __emit }) {
		const props = __props;
		const emit = __emit;
		const { t: t$1 } = useI18n();
		const textareaRef = ref();
		const containerRef = ref();
		const scrollAreaRef = ref();
		const isFocused = ref(false);
		const textValue = ref(props.modelValue || "");
		const textareaHeight = ref(props.minLines > 1 ? lineHeight * props.minLines : singleLineHeight);
		const isMultiline = ref(props.minLines > 1);
		const textAreaMaxHeight = computed(() => {
			return props.maxLinesBeforeScroll * 18;
		});
		const { characterCount: characterCount$1, isOverLimit, isAtLimit } = useCharacterLimit({
			value: textValue,
			maxLength: toRef(props, "maxLength")
		});
		const showWarningBanner = computed(() => isAtLimit.value);
		const sendDisabled = computed(() => !textValue.value.trim() || props.streaming || props.disabled || isOverLimit.value || props.creditsRemaining === 0);
		const containerStyle = computed(() => {
			return { minHeight: isMultiline.value ? "80px" : "40px" };
		});
		const showCredits = computed(() => {
			return props.creditsQuota !== void 0 && props.creditsRemaining !== void 0 && props.creditsQuota !== INFINITE_CREDITS;
		});
		const creditsInfo = computed(() => {
			if (!showCredits.value || props.creditsRemaining === void 0) return "";
			return t$1("promptInput.creditsInfo", {
				remaining: props.creditsRemaining,
				total: props.creditsQuota
			});
		});
		const getNextMonth = () => {
			const now$1 = /* @__PURE__ */ new Date();
			return new Date(now$1.getFullYear(), now$1.getMonth() + 1, 1).toLocaleDateString("en-US", {
				month: "long",
				day: "numeric",
				year: "numeric"
			});
		};
		const creditsTooltipContent = computed(() => {
			if (!showCredits.value) return "";
			const nextMonthDate = getNextMonth();
			return [
				t$1("promptInput.remainingCredits", { count: props.creditsRemaining ?? 0 }),
				t$1("promptInput.monthlyCredits", { count: props.creditsQuota ?? 0 }),
				t$1("promptInput.creditsRenew", { date: nextMonthDate }),
				t$1("promptInput.creditsExpire", { date: nextMonthDate })
			].join("<br />");
		});
		const hasNoCredits = computed(() => {
			return showCredits.value && props.creditsRemaining === 0;
		});
		const textareaStyle = computed(() => {
			if (!isMultiline.value) return {};
			return {
				height: `${textareaHeight.value}px`,
				overflowY: "hidden"
			};
		});
		function adjustHeight() {
			const wasFocused = document.activeElement === textareaRef.value;
			const wasMultiline = isMultiline.value;
			const minHeight = props.minLines > 1 ? lineHeight * props.minLines : singleLineHeight;
			if (!textValue.value || textValue.value === "") {
				if (props.minLines > 1) {
					isMultiline.value = true;
					textareaHeight.value = minHeight;
					if (textareaRef.value) textareaRef.value.style.height = `${minHeight}px`;
				} else {
					isMultiline.value = false;
					textareaHeight.value = singleLineHeight;
					if (textareaRef.value) textareaRef.value.style.height = `${singleLineHeight}px`;
				}
				return;
			}
			if (!textareaRef.value) return;
			let viewportEl = null;
			let savedScrollTop = 0;
			if (wasMultiline && scrollAreaRef.value) {
				viewportEl = scrollAreaRef.value.$el?.querySelector("[data-reka-scroll-area-viewport]");
				if (viewportEl) savedScrollTop = viewportEl.scrollTop;
			}
			const currentHeight = textareaRef.value.style.height;
			textareaRef.value.style.height = "auto";
			const scrollHeight = textareaRef.value.scrollHeight;
			textareaRef.value.style.height = currentHeight;
			const shouldBeMultiline = props.minLines > 1 || scrollHeight > singleLineHeight || textValue.value.includes("\n");
			const newHeight = Math.max(scrollHeight, minHeight);
			textareaHeight.value = newHeight;
			isMultiline.value = shouldBeMultiline;
			if (!isMultiline.value) textareaRef.value.style.height = `${singleLineHeight}px`;
			else {
				textareaRef.value.style.height = `${newHeight}px`;
				if (viewportEl && wasMultiline && savedScrollTop > 0) viewportEl.scrollTop = savedScrollTop;
			}
			if (wasMultiline !== isMultiline.value || wasFocused) nextTick(() => {
				textareaRef.value?.focus();
			});
		}
		watch(() => props.modelValue, async (newValue) => {
			textValue.value = newValue || "";
			await nextTick();
			await new Promise(requestAnimationFrame);
			adjustHeight();
		});
		watch(textValue, (newValue, oldValue) => {
			emit("update:modelValue", newValue);
			if (newValue !== oldValue) nextTick(() => adjustHeight());
		});
		async function refocusTextArea() {
			await nextTick();
			await new Promise(requestAnimationFrame);
			textareaRef.value?.focus();
		}
		async function handleSubmit() {
			emit("submit");
			if (props.refocusAfterSend) await refocusTextArea();
		}
		async function handleStop() {
			emit("stop");
			if (props.refocusAfterSend) await refocusTextArea();
		}
		async function handleKeyDown(event) {
			const hasModifier = event.ctrlKey || event.metaKey;
			const isPrintableChar = event.key.length === 1 && !hasModifier;
			const isDeletionKey = event.key === "Backspace" || event.key === "Delete";
			const atMaxLength = characterCount$1.value >= props.maxLength;
			const isSubmitKey = event.key === "Enter" && !event.shiftKey;
			const isNewlineKey = event.key === "Enter" && event.shiftKey;
			if (atMaxLength && isPrintableChar && !isDeletionKey) {
				event.preventDefault();
				return;
			}
			if (isSubmitKey) {
				event.preventDefault();
				if (!sendDisabled.value) await handleSubmit();
			}
			if (isNewlineKey) {
				event.preventDefault();
				const textarea$1 = event.target;
				const start = textarea$1.selectionStart;
				const end$1 = textarea$1.selectionEnd;
				textValue.value = textValue.value.substring(0, start) + "\n" + textValue.value.substring(end$1);
				await nextTick();
				if (textareaRef.value) textareaRef.value.selectionStart = textareaRef.value.selectionEnd = start + 1;
			}
		}
		function handleFocus(event) {
			isFocused.value = true;
			emit("focus", event);
		}
		function handleBlur(event) {
			isFocused.value = false;
			emit("blur", event);
		}
		function focusInput() {
			textareaRef.value?.focus();
		}
		onMounted(() => {
			nextTick(() => adjustHeight());
			if (props.autofocus) focusInput();
		});
		__expose({ focusInput });
		return (_ctx, _cache) => {
			const _directive_n8n_html = resolveDirective("n8n-html");
			return openBlock(), createElementBlock("div", { class: normalizeClass(_ctx.$style.wrapper) }, [createBaseVNode("div", {
				ref_key: "containerRef",
				ref: containerRef,
				class: normalizeClass([_ctx.$style.container, {
					[_ctx.$style.focused]: isFocused.value,
					[_ctx.$style.multiline]: isMultiline.value,
					[_ctx.$style.disabled]: _ctx.disabled || hasNoCredits.value,
					[_ctx.$style.withBottomBorder]: !!showCredits.value
				}]),
				style: normalizeStyle(containerStyle.value)
			}, [showWarningBanner.value ? (openBlock(), createBlock(Callout_default, {
				key: 0,
				slim: "",
				icon: "info",
				theme: "warning",
				class: normalizeClass(_ctx.$style.warningCallout)
			}, {
				default: withCtx(() => [createTextVNode(toDisplayString(unref(t$1)("assistantChat.characterLimit", { limit: _ctx.maxLength.toString() })), 1)]),
				_: 1
			}, 8, ["class"])) : createCommentVNode("", true), !isMultiline.value ? (openBlock(), createElementBlock("div", {
				key: 1,
				class: normalizeClass(_ctx.$style.singleLineWrapper)
			}, [withDirectives(createBaseVNode("textarea", {
				ref_key: "textareaRef",
				ref: textareaRef,
				"onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => textValue.value = $event),
				class: normalizeClass([
					_ctx.$style.singleLineTextarea,
					"ignore-key-press-node-creator",
					"ignore-key-press-canvas"
				]),
				placeholder: hasNoCredits.value ? "" : _ctx.placeholder,
				disabled: _ctx.disabled || hasNoCredits.value,
				maxlength: _ctx.maxLength,
				rows: "1",
				onKeydown: handleKeyDown,
				onFocus: handleFocus,
				onBlur: handleBlur,
				onInput: adjustHeight
			}, null, 42, _hoisted_1$34), [[vModelText, textValue.value]]), createBaseVNode("div", { class: normalizeClass(_ctx.$style.inlineActions) }, [createVNode(unref(N8nSendStopButton_default), {
				"data-test-id": "send-message-button",
				streaming: _ctx.streaming,
				disabled: sendDisabled.value,
				onSend: handleSubmit,
				onStop: handleStop
			}, null, 8, ["streaming", "disabled"])], 2)], 2)) : (openBlock(), createElementBlock(Fragment, { key: 2 }, [createVNode(N8nScrollArea_default$1, {
				ref_key: "scrollAreaRef",
				ref: scrollAreaRef,
				class: normalizeClass(_ctx.$style.scrollAreaWrapper),
				"max-height": `${textAreaMaxHeight.value}px`,
				type: "auto"
			}, {
				default: withCtx(() => [withDirectives(createBaseVNode("textarea", {
					ref_key: "textareaRef",
					ref: textareaRef,
					"onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => textValue.value = $event),
					class: normalizeClass([
						_ctx.$style.multilineTextarea,
						"ignore-key-press-node-creator",
						"ignore-key-press-canvas"
					]),
					style: normalizeStyle(textareaStyle.value),
					placeholder: hasNoCredits.value ? "" : _ctx.placeholder,
					disabled: _ctx.disabled || hasNoCredits.value,
					maxlength: _ctx.maxLength,
					onKeydown: handleKeyDown,
					onFocus: handleFocus,
					onBlur: handleBlur,
					onInput: adjustHeight
				}, null, 46, _hoisted_2$21), [[vModelText, textValue.value]])]),
				_: 1
			}, 8, ["class", "max-height"]), createBaseVNode("div", { class: normalizeClass(_ctx.$style.bottomActions) }, [createVNode(unref(N8nSendStopButton_default), {
				"data-test-id": "send-message-button",
				streaming: _ctx.streaming,
				disabled: sendDisabled.value,
				onSend: handleSubmit,
				onStop: handleStop
			}, null, 8, ["streaming", "disabled"])], 2)], 64))], 6), showCredits.value ? (openBlock(), createElementBlock("div", {
				key: 0,
				class: normalizeClass(_ctx.$style.creditsBar)
			}, [createBaseVNode("div", { class: normalizeClass(_ctx.$style.creditsInfoWrapper) }, [withDirectives(createBaseVNode("span", { class: normalizeClass({ [_ctx.$style.noCredits]: hasNoCredits.value }) }, null, 2), [[_directive_n8n_html, creditsInfo.value]]), createVNode(Tooltip_default, {
				content: creditsTooltipContent.value,
				"popper-class": _ctx.$style.infoPopper,
				"show-after": 300,
				placement: "top"
			}, {
				default: withCtx(() => [createVNode(Icon_default, {
					icon: "info",
					size: "small"
				})]),
				_: 1
			}, 8, ["content", "popper-class"])], 2), createVNode(Tooltip_default, {
				disabled: !_ctx.showAskOwnerTooltip,
				content: unref(t$1)("promptInput.askAdminToUpgrade"),
				placement: "top",
				"show-after": 300,
				enterable: false
			}, {
				default: withCtx(() => [createVNode(unref(N8nLink_default), {
					size: "small",
					theme: "text",
					onClick: _cache[2] || (_cache[2] = () => emit("upgrade-click"))
				}, {
					default: withCtx(() => [createTextVNode(toDisplayString(unref(t$1)("promptInput.getMore")), 1)]),
					_: 1
				})]),
				_: 1
			}, 8, ["disabled", "content"])], 2)) : createCommentVNode("", true)], 2);
		};
	}
});
var N8nPromptInput_vue_vue_type_style_index_0_lang_module_default = {
	wrapper: "_wrapper_npkfd_123",
	container: "_container_npkfd_129",
	withBottomBorder: "_withBottomBorder_npkfd_141",
	focused: "_focused_npkfd_144",
	multiline: "_multiline_npkfd_148",
	disabled: "_disabled_npkfd_151",
	warningCallout: "_warningCallout_npkfd_160",
	singleLineWrapper: "_singleLineWrapper_npkfd_164",
	singleLineTextarea: "_singleLineTextarea_npkfd_171",
	inlineActions: "_inlineActions_npkfd_191",
	scrollAreaWrapper: "_scrollAreaWrapper_npkfd_197",
	multilineTextarea: "_multilineTextarea_npkfd_202",
	bottomActions: "_bottomActions_npkfd_222",
	creditsBar: "_creditsBar_npkfd_231",
	creditsInfoWrapper: "_creditsInfoWrapper_npkfd_239",
	infoPopper: "_infoPopper_npkfd_250",
	noCredits: "_noCredits_npkfd_258",
	characterCount: "_characterCount_npkfd_262",
	overLimit: "_overLimit_npkfd_267"
};
var N8nPromptInput_default = /* @__PURE__ */ __plugin_vue_export_helper_default(N8nPromptInput_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": N8nPromptInput_vue_vue_type_style_index_0_lang_module_default }]]);
var _hoisted_1$33 = ["disabled", "onClick"];
var N8nPromptInputSuggestions_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "N8nPromptInputSuggestions",
	props: {
		suggestions: { default: () => [] },
		disabled: {
			type: Boolean,
			default: false
		},
		streaming: {
			type: Boolean,
			default: false
		}
	},
	emits: ["suggestionClick"],
	setup(__props, { emit: __emit }) {
		const emit = __emit;
		const props = __props;
		function onSuggestionClick(suggestion) {
			if (props.disabled || props.streaming) return;
			emit("suggestionClick", suggestion);
		}
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("article", {
				class: normalizeClass(_ctx.$style.container),
				"data-test-id": "workflow-suggestions"
			}, [
				createBaseVNode("section", { class: normalizeClass(_ctx.$style.promptContainer) }, [renderSlot(_ctx.$slots, "prompt-input")], 2),
				_ctx.suggestions.length > 0 && !_ctx.streaming ? (openBlock(), createElementBlock("section", {
					key: 0,
					class: normalizeClass(_ctx.$style.pillsContainer),
					role: "group",
					"aria-label": "Workflow suggestions"
				}, [(openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.suggestions, (suggestion) => {
					return openBlock(), createElementBlock("button", {
						key: suggestion.id,
						class: normalizeClass(_ctx.$style.suggestionPill),
						disabled: _ctx.streaming || _ctx.disabled,
						type: "button",
						onClick: ($event) => onSuggestionClick(suggestion)
					}, toDisplayString(suggestion.summary), 11, _hoisted_1$33);
				}), 128))], 2)) : createCommentVNode("", true),
				renderSlot(_ctx.$slots, "footer")
			], 2);
		};
	}
});
var N8nPromptInputSuggestions_vue_vue_type_style_index_0_lang_module_default = {
	container: "_container_mailq_124",
	promptContainer: "_promptContainer_mailq_134",
	pillsContainer: "_pillsContainer_mailq_142",
	suggestionPill: "_suggestionPill_mailq_150"
};
var N8nPromptInputSuggestions_default = /* @__PURE__ */ __plugin_vue_export_helper_default(N8nPromptInputSuggestions_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": N8nPromptInputSuggestions_vue_vue_type_style_index_0_lang_module_default }]]);
var _hoisted_1$32 = { key: 0 };
var _hoisted_2$20 = ["data-test-id"];
var AskAssistantChat_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "AskAssistantChat",
	props: {
		user: { default: () => ({
			firstName: "",
			lastName: ""
		}) },
		messages: { default: () => [] },
		streaming: { type: Boolean },
		disabled: { type: Boolean },
		loadingMessage: { default: void 0 },
		sessionId: { default: void 0 },
		inputPlaceholder: { default: void 0 },
		scrollOnNewMessage: {
			type: Boolean,
			default: false
		},
		showStop: { type: Boolean },
		creditsQuota: {},
		creditsRemaining: {},
		showAskOwnerTooltip: { type: Boolean },
		maxCharacterLength: { default: void 0 },
		suggestions: {}
	},
	emits: [
		"close",
		"stop",
		"message",
		"codeReplace",
		"codeUndo",
		"feedback",
		"upgrade-click"
	],
	setup(__props, { expose: __expose, emit: __emit }) {
		const { t: t$1 } = useI18n();
		const $style = useCssModule();
		const emit = __emit;
		const onClose = () => emit("close");
		const props = __props;
		function normalizeMessages(messages$1) {
			return messages$1.map((msg, index) => ({
				...msg,
				id: msg.id || `msg-${index}`,
				read: msg.read ?? true
			}));
		}
		function filterOutHiddenMessages(messages$1) {
			return messages$1.filter((message$2) => Boolean(getSupportedMessageComponent(message$2.type)) || message$2.type === "custom");
		}
		function groupToolMessagesIntoThinking(messages$1, options$1 = {}) {
			const result = [];
			let i$1 = 0;
			while (i$1 < messages$1.length) {
				const currentMsg = messages$1[i$1];
				if (!isToolMessage(currentMsg)) {
					result.push(currentMsg);
					i$1++;
					continue;
				}
				const toolGroup = [currentMsg];
				let j$1 = i$1 + 1;
				while (j$1 < messages$1.length) {
					const msg = messages$1[j$1];
					if (!isToolMessage(msg)) break;
					toolGroup.push(msg);
					j$1++;
				}
				const uniqueToolsMap = /* @__PURE__ */ new Map();
				for (const tool of toolGroup) {
					const key$2 = tool.toolName;
					uniqueToolsMap.set(key$2, tool);
				}
				const uniqueTools = Array.from(uniqueToolsMap.values());
				const isLastToolGroup = j$1 >= messages$1.length;
				const allToolsCompleted = uniqueTools.every((m$2) => m$2.status === "completed");
				const hasRunningTool = uniqueTools.some((m$2) => m$2.status === "running");
				const items = uniqueTools.map((m$2) => ({
					id: `tool-${m$2.toolName}`,
					displayTitle: m$2.customDisplayTitle || m$2.displayTitle || m$2.toolName.split("_").map((word) => word.charAt(0).toUpperCase() + word.slice(1)).join(" "),
					status: m$2.status
				}));
				if (isLastToolGroup && allToolsCompleted && options$1.streaming && options$1.loadingMessage) items.push({
					id: "thinking-item",
					displayTitle: options$1.loadingMessage,
					status: "running"
				});
				const runningTool = uniqueTools.find((m$2) => m$2.status === "running");
				let latestStatus;
				if (hasRunningTool) latestStatus = runningTool?.customDisplayTitle || runningTool?.displayTitle || runningTool?.toolName.split("_").map((word) => word.charAt(0).toUpperCase() + word.slice(1)).join(" ") || "Processing...";
				else if (isLastToolGroup && allToolsCompleted && options$1.streaming && options$1.loadingMessage) latestStatus = options$1.loadingMessage;
				else if (allToolsCompleted) latestStatus = "Workflow generated";
				else latestStatus = "Processing...";
				const thinkingGroup = {
					id: "thinking-group",
					role: "assistant",
					type: "thinking-group",
					items,
					latestStatusText: latestStatus
				};
				result.push(thinkingGroup);
				i$1 = j$1;
			}
			const hasThinkingGroup = result.some((msg) => msg.type === "thinking-group");
			if (options$1.streaming && options$1.loadingMessage && !hasThinkingGroup) {
				const initialThinkingGroup = {
					id: "thinking-group",
					role: "assistant",
					type: "thinking-group",
					items: [{
						id: "thinking-item",
						displayTitle: options$1.loadingMessage,
						status: "running"
					}],
					latestStatusText: options$1.loadingMessage
				};
				result.push(initialThinkingGroup);
			}
			return result;
		}
		const normalizedMessages = computed(() => {
			return groupToolMessagesIntoThinking(filterOutHiddenMessages(normalizeMessages(props.messages)), {
				streaming: props.streaming,
				loadingMessage: props.loadingMessage
			});
		});
		const lastMessageQuickReplies = computed(() => {
			if (!props.messages?.length || props.streaming) return [];
			const lastMessage = props.messages[props.messages.length - 1];
			return "quickReplies" in lastMessage && lastMessage.quickReplies?.length ? lastMessage.quickReplies : [];
		});
		const textInputValue = ref("");
		const promptInputRef = ref();
		const scrollAreaRef = ref();
		const messagesRef = ref(null);
		const inputWrapperRef = ref(null);
		const sessionEnded = computed(() => {
			return isEndOfSessionEvent(props.messages?.[props.messages.length - 1]);
		});
		const sendDisabled = computed(() => {
			return !textInputValue.value || props.streaming || sessionEnded.value || props.disabled;
		});
		const showPlaceholder = computed(() => {
			return !props.messages?.length && !props.loadingMessage && !props.sessionId;
		});
		const showSuggestions = computed(() => {
			return showPlaceholder.value && props.suggestions && props.suggestions.length > 0;
		});
		const hasAnyThinkingGroup = computed(() => {
			return normalizedMessages.value.some((msg) => msg.type === "thinking-group");
		});
		const showBottomInput = computed(() => {
			return !showSuggestions.value;
		});
		function isEndOfSessionEvent(event) {
			return event?.type === "event" && event?.eventName === "end-session";
		}
		async function onSuggestionClick(suggestion) {
			textInputValue.value = suggestion.prompt;
			await nextTick();
			await new Promise(requestAnimationFrame);
			promptInputRef.value?.focusInput();
		}
		function onQuickReply(opt) {
			emit("message", opt.text, opt.type, opt.isFeedback);
		}
		function onSendMessage() {
			emit("message", textInputValue.value);
			textInputValue.value = "";
		}
		function onRateMessage(feedback) {
			emit("feedback", feedback);
		}
		function scrollToBottom() {
			scrollAreaRef.value?.scrollToBottom({ smooth: true });
		}
		function scrollToBottomImmediate() {
			scrollAreaRef.value?.scrollToBottom({ smooth: false });
		}
		watch(sendDisabled, () => {
			promptInputRef.value?.focusInput();
		});
		watch(() => props.messages, async (messages$1) => {
			if (props.scrollOnNewMessage && messages$1.length > 0) {
				await nextTick();
				scrollToBottom();
			}
		}, {
			immediate: true,
			deep: true
		});
		let isMounted = true;
		watch(showBottomInput, async (isShown) => {
			if (!isShown) return;
			await nextTick();
			if (!isMounted || !inputWrapperRef.value || !scrollAreaRef.value) return;
			scrollToBottomImmediate();
		}, { immediate: true });
		onUnmounted(() => {
			isMounted = false;
		});
		function getMessageStyles(message$2, messageCount) {
			const isToolOrThinking = message$2.type === "tool" || message$2.type === "thinking-group";
			const nextMsg = normalizedMessages.value[messageCount + 1];
			const nextIsToolOrThinking = nextMsg?.type === "tool" || nextMsg?.type === "thinking-group";
			return { [$style.lastToolMessage]: isToolOrThinking && (messageCount === normalizedMessages.value.length - 1 && !props.loadingMessage || messageCount < normalizedMessages.value.length - 1 && !nextIsToolOrThinking) };
		}
		function getMessageColor(message$2) {
			if (isTaskAbortedMessage(message$2)) return "var(--color--text)";
		}
		__expose({ focusInput: () => {
			promptInputRef.value?.focusInput();
		} });
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", { class: normalizeClass(unref($style).container) }, [
				createBaseVNode("div", { class: normalizeClass(unref($style).header) }, [createBaseVNode("div", { class: normalizeClass(unref($style).chatTitle) }, [createBaseVNode("div", { class: normalizeClass(unref($style).headerText) }, [createBaseVNode("div", { class: normalizeClass(unref($style).assistantTitle) }, [createVNode(AssistantIcon_default, { size: "large" }), createVNode(AssistantText_default, {
					size: "large",
					text: unref(t$1)("assistantChat.aiAssistantLabel")
				}, null, 8, ["text"])], 2), createBaseVNode("span", { class: normalizeClass(unref($style).betaTag) }, toDisplayString(unref(t$1)("assistantChat.aiAssistantBetaLabel")), 3)], 2), renderSlot(_ctx.$slots, "header")], 2), createBaseVNode("div", {
					class: normalizeClass(unref($style).back),
					"data-test-id": "close-chat-button",
					onClick: onClose
				}, [createVNode(unref(N8nIcon_default), {
					icon: "arrow-right",
					color: "text-base"
				})], 2)], 2),
				createBaseVNode("div", { class: normalizeClass(unref($style).body) }, [normalizedMessages.value?.length || _ctx.loadingMessage ? (openBlock(), createElementBlock("div", {
					key: 0,
					class: normalizeClass(unref($style).messages)
				}, [createVNode(N8nScrollArea_default$1, {
					ref_key: "scrollAreaRef",
					ref: scrollAreaRef,
					type: "hover",
					"enable-vertical-scroll": true,
					"enable-horizontal-scroll": false
				}, {
					default: withCtx(() => [createBaseVNode("div", {
						ref_key: "messagesRef",
						ref: messagesRef,
						class: normalizeClass(unref($style).messagesContent)
					}, [normalizedMessages.value?.length ? (openBlock(), createElementBlock("div", _hoisted_1$32, [(openBlock(true), createElementBlock(Fragment, null, renderList(normalizedMessages.value, (message$2, i$1) => {
						return openBlock(), createElementBlock("data", {
							key: message$2.id,
							"data-test-id": message$2.role === "assistant" ? "chat-message-assistant" : "chat-message-user"
						}, [unref(isThinkingGroupMessage)(message$2) ? (openBlock(), createBlock(ThinkingMessage_default, {
							key: 0,
							items: message$2.items,
							"latest-status-text": message$2.latestStatusText,
							"is-streaming": _ctx.streaming,
							class: normalizeClass(getMessageStyles(message$2, i$1))
						}, null, 8, [
							"items",
							"latest-status-text",
							"is-streaming",
							"class"
						])) : (openBlock(), createBlock(MessageWrapper_default, {
							key: 1,
							message: message$2,
							"is-first-of-role": i$1 === 0 || message$2.role !== normalizedMessages.value[i$1 - 1].role,
							user: _ctx.user,
							streaming: _ctx.streaming,
							"is-last-message": i$1 === normalizedMessages.value.length - 1,
							class: normalizeClass(getMessageStyles(message$2, i$1)),
							color: getMessageColor(message$2),
							onCodeReplace: () => emit("codeReplace", i$1),
							onCodeUndo: () => emit("codeUndo", i$1),
							onFeedback: onRateMessage
						}, createSlots({ _: 2 }, [_ctx.$slots["custom-message"] ? {
							name: "custom-message",
							fn: withCtx((customMessageProps) => [renderSlot(_ctx.$slots, "custom-message", mergeProps({ ref_for: true }, customMessageProps))]),
							key: "0"
						} : void 0]), 1032, [
							"message",
							"is-first-of-role",
							"user",
							"streaming",
							"is-last-message",
							"class",
							"color",
							"onCodeReplace",
							"onCodeUndo"
						])), lastMessageQuickReplies.value.length && i$1 === normalizedMessages.value.length - 1 ? (openBlock(), createElementBlock("div", {
							key: 2,
							class: normalizeClass(unref($style).quickReplies)
						}, [createBaseVNode("div", { class: normalizeClass(unref($style).quickRepliesTitle) }, toDisplayString(unref(t$1)("assistantChat.quickRepliesTitle")), 3), (openBlock(true), createElementBlock(Fragment, null, renderList(lastMessageQuickReplies.value, (opt) => {
							return openBlock(), createElementBlock("div", {
								key: opt.type,
								"data-test-id": "quick-replies"
							}, [opt.text ? (openBlock(), createBlock(unref(N8nButton_default), {
								key: 0,
								type: "secondary",
								size: "mini",
								onClick: () => onQuickReply(opt)
							}, {
								default: withCtx(() => [createTextVNode(toDisplayString(opt.text), 1)]),
								_: 2
							}, 1032, ["onClick"])) : createCommentVNode("", true)]);
						}), 128))], 2)) : createCommentVNode("", true)], 8, _hoisted_2$20);
					}), 128)), renderSlot(_ctx.$slots, "messagesFooter")])) : createCommentVNode("", true), _ctx.loadingMessage && !hasAnyThinkingGroup.value ? (openBlock(), createElementBlock("div", {
						key: 1,
						class: normalizeClass({
							[unref($style).message]: true,
							[unref($style).loading]: normalizedMessages.value?.length,
							[unref($style).lastToolMessage]: true
						})
					}, [createVNode(AssistantLoadingMessage_default, { message: _ctx.loadingMessage }, null, 8, ["message"])], 2)) : createCommentVNode("", true)], 2)]),
					_: 3
				}, 512)], 2)) : showPlaceholder.value ? (openBlock(), createElementBlock("div", {
					key: 1,
					class: normalizeClass(unref($style).placeholder),
					"data-test-id": "placeholder-message"
				}, [showSuggestions.value ? (openBlock(), createElementBlock("div", {
					key: 0,
					class: normalizeClass(unref($style).suggestionsContainer)
				}, [createVNode(unref(N8nPromptInputSuggestions_default), {
					suggestions: _ctx.suggestions,
					disabled: _ctx.disabled,
					streaming: _ctx.streaming,
					onSuggestionClick
				}, {
					"prompt-input": withCtx(() => [createVNode(unref(N8nPromptInput_default), {
						ref_key: "promptInputRef",
						ref: promptInputRef,
						modelValue: textInputValue.value,
						"onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => textInputValue.value = $event),
						placeholder: unref(t$1)("assistantChat.blankStateInputPlaceholder"),
						disabled: _ctx.disabled,
						streaming: _ctx.streaming,
						"credits-quota": _ctx.creditsQuota,
						"credits-remaining": _ctx.creditsRemaining,
						"show-ask-owner-tooltip": _ctx.showAskOwnerTooltip,
						"max-length": _ctx.maxCharacterLength,
						"min-lines": 2,
						"data-test-id": "chat-suggestions-input",
						autofocus: "",
						onUpgradeClick: _cache[1] || (_cache[1] = ($event) => emit("upgrade-click")),
						onSubmit: onSendMessage,
						onStop: _cache[2] || (_cache[2] = ($event) => emit("stop"))
					}, null, 8, [
						"modelValue",
						"placeholder",
						"disabled",
						"streaming",
						"credits-quota",
						"credits-remaining",
						"show-ask-owner-tooltip",
						"max-length"
					])]),
					_: 1
				}, 8, [
					"suggestions",
					"disabled",
					"streaming"
				])], 2)) : _ctx.$slots.placeholder ? (openBlock(), createElementBlock("div", {
					key: 1,
					class: normalizeClass(unref($style).info)
				}, [renderSlot(_ctx.$slots, "placeholder")], 2)) : (openBlock(), createElementBlock(Fragment, { key: 2 }, [createBaseVNode("div", { class: normalizeClass(unref($style).greeting) }, "Hi " + toDisplayString(_ctx.user?.firstName) + " ", 3), createBaseVNode("div", { class: normalizeClass(unref($style).info) }, [
					createBaseVNode("p", null, toDisplayString(unref(t$1)("assistantChat.placeholder.1")), 1),
					createBaseVNode("p", null, [
						createTextVNode(toDisplayString(unref(t$1)("assistantChat.placeholder.2")) + " ", 1),
						createVNode(InlineAskAssistantButton_default$1, {
							size: "small",
							static: true
						}),
						createTextVNode(" " + toDisplayString(unref(t$1)("assistantChat.placeholder.3")), 1)
					]),
					createBaseVNode("p", null, toDisplayString(unref(t$1)("assistantChat.placeholder.4")), 1)
				], 2)], 64))], 2)) : createCommentVNode("", true)], 2),
				showBottomInput.value ? (openBlock(), createElementBlock("div", {
					key: 0,
					ref_key: "inputWrapperRef",
					ref: inputWrapperRef,
					class: normalizeClass({
						[unref($style).inputWrapper]: true,
						[unref($style).disabledInput]: sessionEnded.value
					}),
					"data-test-id": "chat-input-wrapper"
				}, [_ctx.$slots.inputPlaceholder ? (openBlock(), createElementBlock("div", {
					key: 0,
					class: normalizeClass(unref($style).inputPlaceholder)
				}, [renderSlot(_ctx.$slots, "inputPlaceholder")], 2)) : (openBlock(), createBlock(unref(N8nPromptInput_default), {
					key: 1,
					ref_key: "promptInputRef",
					ref: promptInputRef,
					modelValue: textInputValue.value,
					"onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => textInputValue.value = $event),
					placeholder: _ctx.inputPlaceholder || unref(t$1)("assistantChat.inputPlaceholder"),
					disabled: sessionEnded.value || _ctx.disabled,
					streaming: _ctx.streaming,
					"credits-quota": _ctx.creditsQuota,
					"credits-remaining": _ctx.creditsRemaining,
					"show-ask-owner-tooltip": _ctx.showAskOwnerTooltip,
					"max-length": _ctx.maxCharacterLength,
					"refocus-after-send": true,
					"data-test-id": "chat-input",
					autofocus: "",
					onUpgradeClick: _cache[4] || (_cache[4] = ($event) => emit("upgrade-click")),
					onSubmit: onSendMessage,
					onStop: _cache[5] || (_cache[5] = ($event) => emit("stop"))
				}, null, 8, [
					"modelValue",
					"placeholder",
					"disabled",
					"streaming",
					"credits-quota",
					"credits-remaining",
					"show-ask-owner-tooltip",
					"max-length"
				]))], 2)) : createCommentVNode("", true)
			], 2);
		};
	}
});
var AskAssistantChat_vue_vue_type_style_index_0_lang_module_default = {
	container: "_container_1q5k3_123",
	header: "_header_1q5k3_131",
	betaTag: "_betaTag_1q5k3_147",
	body: "_body_1q5k3_153",
	placeholder: "_placeholder_1q5k3_166",
	suggestionsContainer: "_suggestionsContainer_1q5k3_174",
	messages: "_messages_1q5k3_183",
	messagesContent: "_messagesContent_1q5k3_191",
	message: "_message_1q5k3_183",
	lastToolMessage: "_lastToolMessage_1q5k3_205",
	chatTitle: "_chatTitle_1q5k3_209",
	headerText: "_headerText_1q5k3_214",
	assistantTitle: "_assistantTitle_1q5k3_218",
	greeting: "_greeting_1q5k3_222",
	info: "_info_1q5k3_228",
	back: "_back_1q5k3_236",
	quickReplies: "_quickReplies_1q5k3_240",
	quickRepliesTitle: "_quickRepliesTitle_1q5k3_247",
	inputWrapper: "_inputWrapper_1q5k3_252",
	disabledInput: "_disabledInput_1q5k3_272",
	inputPlaceholder: "_inputPlaceholder_1q5k3_279"
};
var AskAssistantChat_default = /* @__PURE__ */ __plugin_vue_export_helper_default(AskAssistantChat_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": AskAssistantChat_vue_vue_type_style_index_0_lang_module_default }]]);
var AskAssistantIcon_default = AssistantIcon_default;
var AssistantAvatar_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "AssistantAvatar",
	props: { size: { default: "small" } },
	setup(__props) {
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", { class: normalizeClass([_ctx.$style.container, _ctx.$style[_ctx.size]]) }, [createVNode(AssistantIcon_default, {
				size: _ctx.size,
				theme: "blank"
			}, null, 8, ["size"])], 2);
		};
	}
});
var AssistantAvatar_vue_vue_type_style_index_0_lang_module_default = {
	container: "_container_9x10h_123",
	small: "_small_9x10h_131",
	mini: "_mini_9x10h_136"
};
var AskAssistantAvatar_default = /* @__PURE__ */ __plugin_vue_export_helper_default(AssistantAvatar_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": AssistantAvatar_vue_vue_type_style_index_0_lang_module_default }]]);
var AskAssistantText_default = AssistantText_default;
var Badge_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	name: "N8nBadge",
	__name: "Badge",
	props: {
		theme: { default: "default" },
		size: { default: "small" },
		bold: {
			type: Boolean,
			default: false
		},
		showBorder: {
			type: Boolean,
			default: true
		}
	},
	setup(__props) {
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("span", { class: normalizeClass(["n8n-badge", {
				[_ctx.$style[_ctx.theme]]: true,
				[_ctx.$style.border]: _ctx.showBorder
			}]) }, [createVNode(unref(N8nText_default), {
				size: _ctx.size,
				bold: _ctx.bold,
				compact: true
			}, {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 8, ["size", "bold"])], 2);
		};
	}
});
const badge$1 = "_badge_fatqt_123";
const border$1 = "_border_fatqt_129";
const success$1 = "_success_fatqt_140 _badge_fatqt_123";
const warning$2 = "_warning_fatqt_147 _badge_fatqt_123";
const danger$1 = "_danger_fatqt_154 _badge_fatqt_123";
const primary = "_primary_fatqt_161 _badge_fatqt_123";
const secondary = "_secondary_fatqt_170 _badge_fatqt_123";
const tertiary = "_tertiary_fatqt_177 _badge_fatqt_123";
var Badge_vue_vue_type_style_index_0_lang_module_default = {
	badge: badge$1,
	border: border$1,
	"default": "_default_fatqt_133 _badge_fatqt_123",
	success: success$1,
	warning: warning$2,
	danger: danger$1,
	primary,
	secondary,
	tertiary
};
var N8nBadge_default = /* @__PURE__ */ __plugin_vue_export_helper_default(Badge_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": Badge_vue_vue_type_style_index_0_lang_module_default }]]);
function useDeviceSupport() {
	const isTouchDevice = ref(window.matchMedia("(any-pointer: coarse)").matches && !window.matchMedia("(any-pointer: fine)").matches);
	const userAgent = ref(navigator.userAgent.toLowerCase());
	const isIOs = ref(userAgent.value.includes("iphone") || userAgent.value.includes("ipad") || userAgent.value.includes("ipod"));
	const isAndroidOs = ref(userAgent.value.includes("android"));
	const isMacOs = ref(userAgent.value.includes("macintosh") || isIOs.value);
	const isMobileDevice = ref(isIOs.value || isAndroidOs.value);
	const controlKeyCode = ref(isMacOs.value ? "Meta" : "Control");
	const controlKeyText = computed(() => isMacOs.value ? "" : "Ctrl");
	function isCtrlKeyPressed(e) {
		if (isMacOs.value) return e.metaKey;
		return e.ctrlKey;
	}
	return {
		userAgent: userAgent.value,
		isTouchDevice: isTouchDevice.value,
		isAndroidOs: isAndroidOs.value,
		isIOs: isIOs.value,
		isMacOs: isMacOs.value,
		isMobileDevice: isMobileDevice.value,
		controlKeyCode: controlKeyCode.value,
		controlKeyText,
		isCtrlKeyPressed
	};
}
var N8nKeyboardShortcut_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "N8nKeyboardShortcut",
	props: {
		metaKey: { type: Boolean },
		altKey: { type: Boolean },
		shiftKey: { type: Boolean },
		keys: {}
	},
	setup(__props) {
		const props = __props;
		const { isMacOs, controlKeyText } = useDeviceSupport();
		const keys$1 = computed(() => {
			const allKeys = props.keys.map((key$2) => key$2.charAt(0).toUpperCase() + key$2.slice(1));
			if (props.metaKey) allKeys.unshift(controlKeyText.value);
			if (props.altKey) allKeys.unshift(isMacOs ? "" : "Alt");
			if (props.shiftKey) allKeys.unshift("");
			return allKeys;
		});
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", { class: normalizeClass(_ctx.$style.shortcut) }, [(openBlock(true), createElementBlock(Fragment, null, renderList(keys$1.value, (key$2) => {
				return openBlock(), createElementBlock("div", {
					key: key$2,
					class: normalizeClass(_ctx.$style.keyWrapper)
				}, [createBaseVNode("div", { class: normalizeClass(_ctx.$style.key) }, toDisplayString(key$2), 3)], 2);
			}), 128))], 2);
		};
	}
});
var N8nKeyboardShortcut_vue_vue_type_style_index_0_lang_module_default = {
	shortcut: "_shortcut_160kg_123",
	keyWrapper: "_keyWrapper_160kg_129",
	key: "_key_160kg_129"
};
var N8nKeyboardShortcut_default = /* @__PURE__ */ __plugin_vue_export_helper_default(N8nKeyboardShortcut_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": N8nKeyboardShortcut_vue_vue_type_style_index_0_lang_module_default }]]);
var _hoisted_1$31 = ["data-test-id"];
var _hoisted_2$19 = ["onClick"];
var ActionDropdown_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "ActionDropdown",
	props: {
		items: {},
		placement: { default: "bottom" },
		activatorIcon: { default: "ellipsis" },
		activatorSize: { default: "medium" },
		iconSize: { default: "medium" },
		trigger: { default: "click" },
		hideArrow: {
			type: Boolean,
			default: false
		},
		teleported: {
			type: Boolean,
			default: true
		},
		disabled: {
			type: Boolean,
			default: false
		},
		extraPopperClass: {},
		maxHeight: { default: "" }
	},
	emits: [
		"select",
		"visibleChange",
		"badge-click"
	],
	setup(__props, { expose: __expose, emit: __emit }) {
		const props = __props;
		const testIdPrefix = useAttrs()["data-test-id"];
		const $style = useCssModule();
		const getItemClasses = (item$4) => {
			return {
				[$style.itemContainer]: true,
				[$style.disabled]: !!item$4.disabled,
				[$style.hasCustomStyling]: item$4.customClass !== void 0,
				...item$4.customClass !== void 0 ? { [item$4.customClass]: true } : {}
			};
		};
		const emit = __emit;
		const elementDropdown = ref();
		const popperClass = computed(() => `${$style.shadow}${props.hideArrow ? ` ${$style.hideArrow}` : ""} ${props.extraPopperClass ?? ""}`);
		const onSelect = (action) => emit("select", action);
		const onVisibleChange = (open$1) => emit("visibleChange", open$1);
		const onButtonBlur = (event) => {
			if (elementDropdown.value?.handleClose && event.relatedTarget === null) elementDropdown.value.handleClose();
		};
		const open = () => elementDropdown.value?.handleOpen();
		const close = () => elementDropdown.value?.handleClose();
		__expose({
			open,
			close
		});
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", { class: normalizeClass(["action-dropdown-container", unref($style).actionDropdownContainer]) }, [createVNode(unref(ElDropdown), {
				ref_key: "elementDropdown",
				ref: elementDropdown,
				placement: _ctx.placement,
				trigger: _ctx.trigger,
				"popper-class": popperClass.value,
				teleported: _ctx.teleported,
				disabled: _ctx.disabled,
				"max-height": _ctx.maxHeight,
				onCommand: onSelect,
				onVisibleChange
			}, {
				dropdown: withCtx(() => [createVNode(unref(ElDropdownMenu), { class: normalizeClass(unref($style).userActionsMenu) }, {
					default: withCtx(() => [(openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.items, (item$4) => {
						return openBlock(), createBlock(unref(ElDropdownItem), {
							key: item$4.id,
							command: item$4.id,
							disabled: item$4.disabled,
							divided: item$4.divided,
							class: normalizeClass(unref($style).elementItem)
						}, {
							default: withCtx(() => [createBaseVNode("div", {
								class: normalizeClass(getItemClasses(item$4)),
								"data-test-id": `${unref(testIdPrefix)}-item-${item$4.id}`
							}, [
								item$4.icon ? (openBlock(), createElementBlock("span", {
									key: 0,
									class: normalizeClass(unref($style).icon)
								}, [createVNode(unref(N8nIcon_default), {
									icon: item$4.icon,
									size: _ctx.iconSize
								}, null, 8, ["icon", "size"])], 2)) : createCommentVNode("", true),
								createBaseVNode("span", { class: normalizeClass(unref($style).label) }, [renderSlot(_ctx.$slots, "menuItem", mergeProps({ ref_for: true }, item$4), () => [createTextVNode(toDisplayString(item$4.label), 1)])], 2),
								item$4.checked ? (openBlock(), createBlock(unref(N8nIcon_default), {
									key: 1,
									class: normalizeClass(unref($style).checkIcon),
									icon: "check",
									size: _ctx.iconSize
								}, null, 8, ["class", "size"])) : createCommentVNode("", true),
								item$4.badge ? (openBlock(), createElementBlock("span", {
									key: 2,
									class: normalizeClass({ [unref($style).clickableBadge]: item$4.disabled }),
									onClick: withModifiers(($event) => item$4.disabled && _ctx.$emit("badge-click", item$4.id), ["stop"])
								}, [createVNode(unref(N8nBadge_default), mergeProps({
									theme: "primary",
									size: "xsmall",
									ref_for: true
								}, item$4.badgeProps), {
									default: withCtx(() => [createTextVNode(toDisplayString(item$4.badge), 1)]),
									_: 2
								}, 1040)], 10, _hoisted_2$19)) : createCommentVNode("", true),
								item$4.shortcut ? (openBlock(), createBlock(unref(N8nKeyboardShortcut_default), mergeProps({
									key: 3,
									ref_for: true
								}, item$4.shortcut, { class: unref($style).shortcut }), null, 16, ["class"])) : createCommentVNode("", true)
							], 10, _hoisted_1$31)]),
							_: 2
						}, 1032, [
							"command",
							"disabled",
							"divided",
							"class"
						]);
					}), 128))]),
					_: 3
				}, 8, ["class"])]),
				default: withCtx(() => [_ctx.$slots.activator ? renderSlot(_ctx.$slots, "activator", { key: 0 }) : (openBlock(), createBlock(unref(N8nIconButton_default), {
					key: 1,
					type: "tertiary",
					text: "",
					class: normalizeClass(unref($style).activator),
					size: _ctx.activatorSize,
					icon: _ctx.activatorIcon,
					onBlur: onButtonBlur
				}, null, 8, [
					"class",
					"size",
					"icon"
				]))]),
				_: 3
			}, 8, [
				"placement",
				"trigger",
				"popper-class",
				"teleported",
				"disabled",
				"max-height"
			])], 2);
		};
	}
});
var ActionDropdown_vue_vue_type_style_index_0_lang_module_default = {
	userActionsMenu: "_userActionsMenu_1kea5_123",
	elementItem: "_elementItem_1kea5_127",
	hideArrow: "_hideArrow_1kea5_131",
	shadow: "_shadow_1kea5_135",
	activator: "_activator_1kea5_139",
	itemContainer: "_itemContainer_1kea5_143",
	disabled: "_disabled_1kea5_152",
	shortcut: "_shortcut_1kea5_152",
	icon: "_icon_1kea5_156",
	label: "_label_1kea5_168",
	checkIcon: "_checkIcon_1kea5_173",
	hasCustomStyling: "_hasCustomStyling_1kea5_182",
	clickableBadge: "_clickableBadge_1kea5_186"
};
var N8nActionDropdown_default = /* @__PURE__ */ __plugin_vue_export_helper_default(ActionDropdown_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": ActionDropdown_vue_vue_type_style_index_0_lang_module_default }]]);
var isHTMLElement = (element) => {
	return element !== void 0 && element instanceof HTMLElement;
};
var isScrollable = (element) => {
	const computedStyle = window.getComputedStyle(element);
	const overflowY = computedStyle.overflowY;
	const overflowX = computedStyle.overflowX;
	if (!(overflowY === "auto" || overflowY === "scroll" || overflowX === "auto" || overflowX === "scroll")) return false;
	return element.scrollHeight > element.clientHeight || element.scrollWidth > element.clientWidth;
};
var findFirstScrollableParent = (element) => {
	let parent = element.parentElement;
	while (parent && parent !== document.body) {
		if (isScrollable(parent)) return parent;
		parent = parent.parentElement;
	}
	if (document.body && isScrollable(document.body)) return document.body;
	if (document.documentElement && isScrollable(document.documentElement)) return document.documentElement;
	return null;
};
function useParentScroll(elementRef, onScroll) {
	const scrollListeners = ref([]);
	const detachScrollListeners = () => {
		scrollListeners.value.forEach(({ element, handler }) => {
			element.removeEventListener("scroll", handler, { capture: true });
		});
		scrollListeners.value = [];
	};
	const attachScrollListeners = () => {
		nextTick(() => {
			const element = elementRef.value;
			const dropdownElement = element && "$el" in element ? element.$el : element;
			if (!isHTMLElement(dropdownElement)) return;
			detachScrollListeners();
			const scrollableParent = findFirstScrollableParent(dropdownElement);
			if (scrollableParent) {
				const handler = () => onScroll();
				scrollableParent.addEventListener("scroll", handler, {
					passive: true,
					capture: true
				});
				scrollListeners.value.push({
					element: scrollableParent,
					handler
				});
			}
		});
	};
	onBeforeUnmount(() => {
		detachScrollListeners();
	});
	return {
		attachScrollListeners,
		detachScrollListeners
	};
}
var _hoisted_1$30 = { key: 0 };
var _hoisted_2$18 = { key: 1 };
var Loading_vue_vue_type_script_setup_true_lang_default$1 = /* @__PURE__ */ defineComponent({
	__name: "Loading",
	props: {
		animated: {
			type: Boolean,
			default: true
		},
		loading: {
			type: Boolean,
			default: true
		},
		rows: { default: 1 },
		cols: { default: 0 },
		shrinkLast: {
			type: Boolean,
			default: true
		},
		variant: { default: "p" }
	},
	setup(__props) {
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(ElSkeleton), {
				loading: _ctx.loading,
				animated: _ctx.animated,
				class: normalizeClass(["n8n-loading", `n8n-loading-${_ctx.variant}`])
			}, createSlots({ _: 2 }, [_ctx.cols ? {
				name: "template",
				fn: withCtx(() => [(openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.cols, (i$1) => {
					return openBlock(), createBlock(unref(ElSkeletonItem), { key: i$1 });
				}), 128))]),
				key: "0"
			} : {
				name: "template",
				fn: withCtx(() => [_ctx.variant === "h1" ? (openBlock(), createElementBlock("div", _hoisted_1$30, [(openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.rows, (item$4, index) => {
					return openBlock(), createElementBlock("div", {
						key: index,
						class: normalizeClass({ [_ctx.$style.h1Last]: item$4 === _ctx.rows && _ctx.rows > 1 && _ctx.shrinkLast })
					}, [createVNode(unref(ElSkeletonItem), { variant: _ctx.variant }, null, 8, ["variant"])], 2);
				}), 128))])) : _ctx.variant === "p" ? (openBlock(), createElementBlock("div", _hoisted_2$18, [(openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.rows, (item$4, index) => {
					return openBlock(), createElementBlock("div", {
						key: index,
						class: normalizeClass({ [_ctx.$style.pLast]: item$4 === _ctx.rows && _ctx.rows > 1 && _ctx.shrinkLast })
					}, [createVNode(unref(ElSkeletonItem), { variant: _ctx.variant }, null, 8, ["variant"])], 2);
				}), 128))])) : _ctx.variant === "custom" ? (openBlock(), createElementBlock("div", {
					key: 2,
					class: normalizeClass(_ctx.$style.custom)
				}, [createVNode(unref(ElSkeletonItem))], 2)) : (openBlock(), createBlock(unref(ElSkeletonItem), {
					key: 3,
					variant: _ctx.variant
				}, null, 8, ["variant"]))]),
				key: "1"
			}]), 1032, [
				"loading",
				"animated",
				"class"
			]);
		};
	}
});
var Loading_vue_vue_type_style_index_0_lang_module_default$1 = {
	h1Last: "_h1Last_zujtd_123",
	pLast: "_pLast_zujtd_127",
	custom: "_custom_zujtd_131"
};
var Loading_default$1 = /* @__PURE__ */ __plugin_vue_export_helper_default(Loading_vue_vue_type_script_setup_true_lang_default$1, [["__cssModules", { "$style": Loading_vue_vue_type_style_index_0_lang_module_default$1 }]]);
var N8nLoading_default = Loading_default$1;
var ActionToggle_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	name: "N8nActionToggle",
	__name: "ActionToggle",
	props: {
		actions: { default: () => [] },
		placement: { default: "bottom" },
		size: { default: "medium" },
		iconSize: { default: "medium" },
		theme: { default: "default" },
		iconOrientation: { default: "vertical" },
		loading: {
			type: Boolean,
			default: false
		},
		loadingRowCount: { default: 3 },
		disabled: {
			type: Boolean,
			default: false
		},
		popperClass: { default: "" },
		trigger: { default: "click" },
		closeOnParentScroll: {
			type: Boolean,
			default: true
		}
	},
	emits: [
		"action",
		"visible-change",
		"item-mouseup"
	],
	setup(__props, { expose: __expose, emit: __emit }) {
		const props = __props;
		const actionToggleRef = ref(null);
		const emit = __emit;
		const { attachScrollListeners, detachScrollListeners } = useParentScroll(actionToggleRef, () => {
			if (props.closeOnParentScroll) actionToggleRef.value?.handleClose();
		});
		const onCommand = (value) => emit("action", value);
		const onVisibleChange = (value) => {
			emit("visible-change", value);
			if (props.closeOnParentScroll) if (value) attachScrollListeners();
			else detachScrollListeners();
		};
		const openActionToggle = (isOpen) => {
			if (isOpen) actionToggleRef.value?.handleOpen();
			else actionToggleRef.value?.handleClose();
		};
		const onActionMouseUp = (action) => {
			emit("item-mouseup", action);
			actionToggleRef.value?.handleClose();
		};
		__expose({ openActionToggle });
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("span", {
				class: normalizeClass(["action-toggle", _ctx.$style.container]),
				"data-test-id": "action-toggle",
				onClick: _cache[0] || (_cache[0] = withModifiers(() => {}, ["stop", "prevent"]))
			}, [createVNode(unref(ElDropdown), {
				ref_key: "actionToggleRef",
				ref: actionToggleRef,
				placement: _ctx.placement,
				size: _ctx.size,
				disabled: _ctx.disabled,
				"popper-class": _ctx.popperClass,
				trigger: _ctx.trigger,
				onCommand,
				onVisibleChange
			}, {
				dropdown: withCtx(() => [_ctx.loading ? (openBlock(), createBlock(unref(ElDropdownMenu), {
					key: 0,
					class: normalizeClass(_ctx.$style["loading-dropdown"]),
					"data-test-id": "action-toggle-loading-dropdown"
				}, {
					default: withCtx(() => [(openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.loadingRowCount, (index) => {
						return openBlock(), createBlock(unref(ElDropdownItem), {
							key: index,
							disabled: true
						}, {
							default: withCtx(() => [createVNode(unref(N8nLoading_default), {
								class: normalizeClass(_ctx.$style.loading),
								animated: "",
								variant: "text"
							}, null, 8, ["class"])]),
							_: 2
						}, 1024);
					}), 128))]),
					_: 1
				}, 8, ["class"])) : (openBlock(), createBlock(unref(ElDropdownMenu), {
					key: 1,
					"data-test-id": "action-toggle-dropdown"
				}, {
					default: withCtx(() => [(openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.actions, (action) => {
						return openBlock(), createBlock(unref(ElDropdownItem), {
							key: action.value,
							command: action.value,
							disabled: action.disabled,
							"data-test-id": `action-${action.value}`,
							onMouseup: ($event) => onActionMouseUp(action)
						}, {
							default: withCtx(() => [createTextVNode(toDisplayString(action.label) + " ", 1), createBaseVNode("div", { class: normalizeClass(_ctx.$style.iconContainer) }, [action.type === "external-link" ? (openBlock(), createBlock(unref(N8nIcon_default), {
								key: 0,
								icon: "external-link",
								size: "xsmall",
								color: "text-base"
							})) : createCommentVNode("", true)], 2)]),
							_: 2
						}, 1032, [
							"command",
							"disabled",
							"data-test-id",
							"onMouseup"
						]);
					}), 128))]),
					_: 1
				}))]),
				default: withCtx(() => [renderSlot(_ctx.$slots, "default", {}, () => [createBaseVNode("span", { class: normalizeClass({
					[_ctx.$style.button]: true,
					[_ctx.$style[_ctx.theme]]: !!_ctx.theme
				}) }, [createVNode(unref(N8nIcon_default), {
					icon: _ctx.iconOrientation === "horizontal" ? "ellipsis" : "ellipsis-vertical",
					size: _ctx.iconSize
				}, null, 8, ["icon", "size"])], 2)])]),
				_: 3
			}, 8, [
				"placement",
				"size",
				"disabled",
				"popper-class",
				"trigger"
			])], 2);
		};
	}
});
const container$10 = "_container_i52uh_123";
const button$3 = "_button_i52uh_127";
const dark = "_dark_i52uh_142";
const iconContainer = "_iconContainer_i52uh_149";
const loading$1 = "_loading_i52uh_157";
var ActionToggle_vue_vue_type_style_index_0_lang_module_default = {
	container: container$10,
	button: button$3,
	dark,
	iconContainer,
	"loading-dropdown": "_loading-dropdown_i52uh_157",
	loading: loading$1
};
var N8nActionToggle_default = /* @__PURE__ */ __plugin_vue_export_helper_default(ActionToggle_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": ActionToggle_vue_vue_type_style_index_0_lang_module_default }]]);
var m$1 = (e) => {
	let t$1 = 0;
	for (let i$1 = 0; i$1 < e.length; i$1++) {
		const o$1 = e.charCodeAt(i$1);
		t$1 = (t$1 << 5) - t$1 + o$1, t$1 = t$1 & t$1;
	}
	return Math.abs(t$1);
}, I = (e, t$1) => Math.floor(e / Math.pow(10, t$1) % 10), C = (e, t$1) => !(I(e, t$1) % 2), h$1 = (e, t$1, i$1) => {
	const o$1 = e % t$1;
	return i$1 && I(e, i$1) % 2 === 0 ? -o$1 : o$1;
}, u = (e, t$1, i$1) => t$1[e % i$1], F = (e) => {
	e.slice(0, 1) === "#" && (e = e.slice(1));
	const t$1 = parseInt(e.substring(0, 2), 16), i$1 = parseInt(e.substring(2, 4), 16), o$1 = parseInt(e.substring(4, 6), 16);
	return (t$1 * 299 + i$1 * 587 + o$1 * 114) / 1e3 >= 128 ? "#000000" : "#FFFFFF";
}, B = 4, E = 80;
function z(e, t$1) {
	const i$1 = m$1(e), o$1 = t$1 && t$1.length;
	return Array.from({ length: B }, (s, n) => ({
		color: u(i$1 + n, t$1, o$1),
		translateX: h$1(i$1 * (n + 1), E / 2 - (n + 17), 1),
		translateY: h$1(i$1 * (n + 1), E / 2 - (n + 17), 2),
		rotate: h$1(i$1 * (n + 1), 360),
		isSquare: C(i$1, 2)
	}));
}
var b$1 = defineComponent({
	props: {
		colors: {
			type: Array,
			required: !0
		},
		name: {
			type: String,
			required: !0
		},
		square: {
			type: Boolean,
			required: !1,
			default: !1
		},
		size: {
			type: Number,
			required: !0
		},
		title: {
			type: Boolean,
			required: !1,
			default: !1
		}
	},
	setup(e) {
		return {
			properties: computed(() => z(e.name, e.colors)),
			SIZE: E
		};
	}
}), g = (e, t$1) => {
	const i$1 = e.__vccOpts || e;
	for (const [o$1, r] of t$1) i$1[o$1] = r;
	return i$1;
}, A = [
	"viewBox",
	"width",
	"height"
], M = { key: 0 }, N = ["width", "height"], U = [
	"width",
	"height",
	"rx"
], L = { mask: "url(#mask__bauhaus)" }, O = [
	"width",
	"height",
	"fill"
], T = [
	"x",
	"y",
	"width",
	"height",
	"fill",
	"transform"
], X = [
	"cx",
	"cy",
	"fill",
	"r",
	"transform"
], Y = [
	"y1",
	"x2",
	"y2",
	"stroke",
	"transform"
];
function R(e, t$1, i$1, o$1, r, s) {
	return openBlock(), createElementBlock("svg", {
		viewBox: `0 0 ${e.SIZE} ${e.SIZE}`,
		fill: "none",
		role: "img",
		xmlns: "http://www.w3.org/2000/svg",
		width: e.size,
		height: e.size
	}, [
		e.title ? (openBlock(), createElementBlock("title", M, toDisplayString(e.name), 1)) : createCommentVNode("", !0),
		createBaseVNode("mask", {
			id: "mask__bauhaus",
			maskUnits: "userSpaceOnUse",
			x: 0,
			y: 0,
			width: e.SIZE,
			height: e.SIZE
		}, [createBaseVNode("rect", {
			width: e.SIZE,
			height: e.SIZE,
			rx: e.square ? void 0 : e.SIZE * 2,
			fill: "#FFFFFF"
		}, null, 8, U)], 8, N),
		createBaseVNode("g", L, [
			createBaseVNode("rect", {
				width: e.SIZE,
				height: e.SIZE,
				fill: e.properties[0].color
			}, null, 8, O),
			createBaseVNode("rect", {
				x: (e.SIZE - 60) / 2,
				y: (e.SIZE - 20) / 2,
				width: e.SIZE,
				height: e.properties[1].isSquare ? e.SIZE : e.SIZE / 8,
				fill: e.properties[1].color,
				transform: `translate(${e.properties[1].translateX} ${e.properties[1].translateY}) rotate(${e.properties[1].rotate} ${e.SIZE / 2} ${e.SIZE / 2})`
			}, null, 8, T),
			createBaseVNode("circle", {
				cx: e.SIZE / 2,
				cy: e.SIZE / 2,
				fill: e.properties[2].color,
				r: e.SIZE / 5,
				transform: `translate(${e.properties[2].translateX} ${e.properties[2].translateY})`
			}, null, 8, X),
			createBaseVNode("line", {
				x1: 0,
				y1: e.SIZE / 2,
				x2: e.SIZE,
				y2: e.SIZE / 2,
				"stroke-width": 2,
				stroke: e.properties[3].color,
				transform: `translate(${e.properties[3].translateX} ${e.properties[3].translateY}) rotate(${e.properties[3].rotate} ${e.SIZE / 2} ${e.SIZE / 2})`
			}, null, 8, Y)
		])
	], 8, A);
}
var D = /* @__PURE__ */ g(b$1, [["render", R]]), c = 36;
function H(e, t$1) {
	const i$1 = m$1(e), o$1 = t$1 && t$1.length, r = u(i$1, t$1, o$1), s = h$1(i$1, 10, 1), n = s < 5 ? s + c / 9 : s, y = h$1(i$1, 10, 2), _ = y < 5 ? y + c / 9 : y;
	return {
		wrapperColor: r,
		faceColor: F(r),
		backgroundColor: u(i$1 + 13, t$1, o$1),
		wrapperTranslateX: n,
		wrapperTranslateY: _,
		wrapperRotate: h$1(i$1, 360),
		wrapperScale: 1 + h$1(i$1, c / 12) / 10,
		isMouthOpen: C(i$1, 2),
		isCircle: C(i$1, 1),
		eyeSpread: h$1(i$1, 5),
		mouthSpread: h$1(i$1, 3),
		faceRotate: h$1(i$1, 10, 3),
		faceTranslateX: n > c / 6 ? n / 2 : h$1(i$1, 8, 1),
		faceTranslateY: _ > c / 6 ? _ / 2 : h$1(i$1, 7, 2)
	};
}
var G = defineComponent({
	props: {
		colors: {
			type: Array,
			required: !0
		},
		name: {
			type: String,
			required: !0
		},
		square: {
			type: Boolean,
			required: !1,
			default: !1
		},
		size: {
			type: Number,
			required: !0
		},
		title: {
			type: Boolean,
			required: !1,
			default: !1
		}
	},
	setup(e) {
		return {
			data: computed(() => H(e.name, e.colors)),
			SIZE: c
		};
	}
}), P = [
	"viewBox",
	"width",
	"height"
], V = { key: 0 }, j = ["width", "height"], J = [
	"width",
	"height",
	"rx"
], K = { mask: "url(#mask__beam)" }, Q = [
	"width",
	"height",
	"fill"
], W = [
	"width",
	"height",
	"transform",
	"fill",
	"rx"
], x$1 = ["transform"], ee = ["d", "stroke"], le = ["d", "fill"], te = [
	"x",
	"width",
	"fill"
], ie = [
	"x",
	"width",
	"fill"
];
function oe(e, t$1, i$1, o$1, r, s) {
	return openBlock(), createElementBlock("svg", {
		viewBox: `0 0 ${e.SIZE} ${e.SIZE}`,
		fill: "none",
		role: "img",
		xmlns: "http://www.w3.org/2000/svg",
		width: e.size,
		height: e.size
	}, [
		e.title ? (openBlock(), createElementBlock("title", V, toDisplayString(e.name), 1)) : createCommentVNode("", !0),
		createBaseVNode("mask", {
			id: "mask__beam",
			maskUnits: "userSpaceOnUse",
			x: 0,
			y: 0,
			width: e.SIZE,
			height: e.SIZE
		}, [createBaseVNode("rect", {
			width: e.SIZE,
			height: e.SIZE,
			rx: e.square ? void 0 : e.SIZE * 2,
			fill: "#FFFFFF"
		}, null, 8, J)], 8, j),
		createBaseVNode("g", K, [
			createBaseVNode("rect", {
				width: e.SIZE,
				height: e.SIZE,
				fill: e.data.backgroundColor
			}, null, 8, Q),
			createBaseVNode("rect", {
				x: 0,
				y: 0,
				width: e.SIZE,
				height: e.SIZE,
				transform: `translate(${e.data.wrapperTranslateX} ${e.data.wrapperTranslateY}) rotate(${e.data.wrapperRotate} ${e.SIZE / 2} ${e.SIZE / 2}) scale(${e.data.wrapperScale})`,
				fill: e.data.wrapperColor,
				rx: e.data.isCircle ? e.SIZE : e.SIZE / 6
			}, null, 8, W),
			createBaseVNode("g", { transform: `translate(${e.data.faceTranslateX} ${e.data.faceTranslateY}) rotate(${e.data.faceRotate} ${e.SIZE / 2} ${e.SIZE / 2})` }, [
				e.data.isMouthOpen ? (openBlock(), createElementBlock("path", {
					key: 0,
					d: `M15 ${19 + e.data.mouthSpread}c2 1
        4 1 6 0`,
					stroke: e.data.faceColor,
					fill: "none",
					"stroke-linecap": "round"
				}, null, 8, ee)) : (openBlock(), createElementBlock("path", {
					key: 1,
					d: `M13,${19 + e.data.mouthSpread} a1,0.75 0 0,0 10,0`,
					fill: e.data.faceColor
				}, null, 8, le)),
				createBaseVNode("rect", {
					x: 14 - e.data.eyeSpread,
					y: 14,
					width: 1.5,
					height: 2,
					rx: 1,
					stroke: "none",
					fill: e.data.faceColor
				}, null, 8, te),
				createBaseVNode("rect", {
					x: 20 + e.data.eyeSpread,
					y: 14,
					width: 1.5,
					height: 2,
					rx: 1,
					stroke: "none",
					fill: e.data.faceColor
				}, null, 8, ie)
			], 8, x$1)
		])
	], 8, P);
}
var re = /* @__PURE__ */ g(G, [["render", oe]]), se = 3, S = 80;
function ne(e, t$1) {
	const i$1 = m$1(e), o$1 = t$1 && t$1.length;
	return Array.from({ length: se }, (s, n) => ({
		color: u(i$1 + n, t$1, o$1),
		translateX: h$1(i$1 * (n + 1), S / 10, 1),
		translateY: h$1(i$1 * (n + 1), S / 10, 2),
		scale: 1.2 + h$1(i$1 * (n + 1), S / 20) / 10,
		rotate: h$1(i$1 * (n + 1), 360, 1)
	}));
}
var he = defineComponent({
	props: {
		colors: {
			type: Array,
			required: !0
		},
		name: {
			type: String,
			required: !0
		},
		square: {
			type: Boolean,
			required: !1,
			default: !1
		},
		size: {
			type: Number,
			required: !0
		},
		title: {
			type: Boolean,
			required: !1,
			default: !1
		}
	},
	setup(e) {
		return {
			properties: computed(() => ne(e.name, e.colors)),
			SIZE: S
		};
	}
});
var ae = (e) => (pushScopeId("data-v-3c8b58b0"), e = e(), popScopeId(), e), de$1 = [
	"viewBox",
	"width",
	"height"
], fe = { key: 0 }, ue = ["width", "height"], pe = [
	"width",
	"height",
	"rx"
], ge = { mask: "url(#mask__marble)" }, ce = [
	"width",
	"height",
	"fill"
], we = ["fill", "transform"], $e = ["fill", "transform"], me = /* @__PURE__ */ ae(() => /* @__PURE__ */ createBaseVNode("defs", null, [/* @__PURE__ */ createBaseVNode("filter", {
	id: "prefix__filter0_f",
	filterUnits: "userSpaceOnUse",
	"color-interpolation-filters": "sRGB"
}, [
	/* @__PURE__ */ createBaseVNode("feFlood", {
		"flood-opacity": 0,
		result: "BackgroundImageFix"
	}),
	/* @__PURE__ */ createBaseVNode("feBlend", {
		in: "SourceGraphic",
		in2: "BackgroundImageFix",
		result: "shape"
	}),
	/* @__PURE__ */ createBaseVNode("feGaussianBlur", {
		stdDeviation: 7,
		result: "effect1_foregroundBlur"
	})
])], -1));
function ye(e, t$1, i$1, o$1, r, s) {
	return openBlock(), createElementBlock("svg", {
		viewBox: `0 0 ${e.SIZE} ${e.SIZE}`,
		fill: "none",
		role: "img",
		xmlns: "http://www.w3.org/2000/svg",
		width: e.size,
		height: e.size
	}, [
		e.title ? (openBlock(), createElementBlock("title", fe, toDisplayString(e.name), 1)) : createCommentVNode("", !0),
		createBaseVNode("mask", {
			id: "mask__marble",
			maskUnits: "userSpaceOnUse",
			x: 0,
			y: 0,
			width: e.SIZE,
			height: e.SIZE
		}, [createBaseVNode("rect", {
			width: e.SIZE,
			height: e.SIZE,
			rx: e.square ? void 0 : e.SIZE * 2,
			fill: "#FFFFFF"
		}, null, 8, pe)], 8, ue),
		createBaseVNode("g", ge, [
			createBaseVNode("rect", {
				width: e.SIZE,
				height: e.SIZE,
				fill: e.properties[0].color
			}, null, 8, ce),
			createBaseVNode("path", {
				filter: "url(#prefix__filter0_f)",
				d: "M32.414 59.35L50.376 70.5H72.5v-71H33.728L26.5 13.381l19.057 27.08L32.414 59.35z",
				fill: e.properties[1].color,
				transform: `translate(${e.properties[1].translateX} ${e.properties[1].translateY}) rotate(${e.properties[1].rotate} ${e.SIZE / 2} ${e.SIZE / 2}) scale(${e.properties[2].scale})`
			}, null, 8, we),
			createBaseVNode("path", {
				filter: "url(#prefix__filter0_f)",
				class: "mix-blend-overlay",
				d: "M22.216 24L0 46.75l14.108 38.129L78 86l-3.081-59.276-22.378 4.005 12.972 20.186-23.35 27.395L22.215 24z",
				fill: e.properties[2].color,
				transform: `translate(${e.properties[2].translateX} ${e.properties[2].translateY}) rotate(${e.properties[2].rotate} ${e.SIZE / 2} ${e.SIZE / 2}) scale(${e.properties[2].scale})`
			}, null, 8, $e)
		]),
		me
	], 8, de$1);
}
var Se = /* @__PURE__ */ g(he, [["render", ye], ["__scopeId", "data-v-3c8b58b0"]]), _e = 64, Ce = 80;
function Ee(e, t$1) {
	const i$1 = m$1(e), o$1 = t$1 && t$1.length;
	return Array.from({ length: _e }, (s, n) => u(i$1 % n, t$1, o$1));
}
var Ie = defineComponent({
	props: {
		colors: {
			type: Array,
			required: !0
		},
		name: {
			type: String,
			required: !0
		},
		square: {
			type: Boolean,
			required: !1,
			default: !1
		},
		size: {
			type: Number,
			required: !0
		},
		title: {
			type: Boolean,
			required: !1,
			default: !1
		}
	},
	setup(e) {
		return {
			pixelColors: computed(() => Ee(e.name, e.colors)),
			SIZE: Ce
		};
	}
}), Ze = [
	"viewBox",
	"width",
	"height"
], ve = { key: 0 }, qe = ["width", "height"], ke = [
	"width",
	"height",
	"rx"
], Fe = { mask: "url(#mask__pixel)" }, Be = ["fill"], ze = ["fill"], be = ["fill"], Ae = ["fill"], Me = ["fill"], Ne = ["fill"], Ue = ["fill"], Le = ["fill"], Oe = ["fill"], Te = ["fill"], Xe = ["fill"], Ye = ["fill"], Re = ["fill"], De = ["fill"], He = ["fill"], Ge = ["fill"], Pe = ["fill"], Ve = ["fill"], je = ["fill"], Je = ["fill"], Ke = ["fill"], Qe = ["fill"], We = ["fill"], xe = ["fill"], el = ["fill"], ll = ["fill"], tl = ["fill"], il = ["fill"], ol = ["fill"], rl = ["fill"], sl = ["fill"], nl = ["fill"], hl = ["fill"], al = ["fill"], dl = ["fill"], fl = ["fill"], ul = ["fill"], pl = ["fill"], gl = ["fill"], cl$1 = ["fill"], wl = ["fill"], $l = ["fill"], ml = ["fill"], yl = ["fill"], Sl = ["fill"], _l = ["fill"], Cl = ["fill"], El = ["fill"], Il = ["fill"], Zl = ["fill"], vl = ["fill"], ql = ["fill"], kl = ["fill"], Fl = ["fill"], Bl = ["fill"], zl = ["fill"], bl = ["fill"], Al = ["fill"], Ml = ["fill"], Nl = ["fill"], Ul = ["fill"], Ll = ["fill"], Ol = ["fill"], Tl = ["fill"];
function Xl(e, t$1, i$1, o$1, r, s) {
	return openBlock(), createElementBlock("svg", {
		viewBox: `0 0 ${e.SIZE} ${e.SIZE}`,
		fill: "none",
		role: "img",
		xmlns: "http://www.w3.org/2000/svg",
		width: e.size,
		height: e.size
	}, [
		e.title ? (openBlock(), createElementBlock("title", ve, toDisplayString(e.name), 1)) : createCommentVNode("", !0),
		createBaseVNode("mask", {
			id: "mask__pixel",
			"mask-type": "alpha",
			maskUnits: "userSpaceOnUse",
			x: 0,
			y: 0,
			width: e.SIZE,
			height: e.SIZE
		}, [createBaseVNode("rect", {
			width: e.SIZE,
			height: e.SIZE,
			rx: e.square ? void 0 : e.SIZE * 2,
			fill: "#FFFFFF"
		}, null, 8, ke)], 8, qe),
		createBaseVNode("g", Fe, [
			createBaseVNode("rect", {
				width: 10,
				height: 10,
				fill: e.pixelColors[0]
			}, null, 8, Be),
			createBaseVNode("rect", {
				x: 20,
				width: 10,
				height: 10,
				fill: e.pixelColors[1]
			}, null, 8, ze),
			createBaseVNode("rect", {
				x: 40,
				width: 10,
				height: 10,
				fill: e.pixelColors[2]
			}, null, 8, be),
			createBaseVNode("rect", {
				x: 60,
				width: 10,
				height: 10,
				fill: e.pixelColors[3]
			}, null, 8, Ae),
			createBaseVNode("rect", {
				x: 10,
				width: 10,
				height: 10,
				fill: e.pixelColors[4]
			}, null, 8, Me),
			createBaseVNode("rect", {
				x: 30,
				width: 10,
				height: 10,
				fill: e.pixelColors[5]
			}, null, 8, Ne),
			createBaseVNode("rect", {
				x: 50,
				width: 10,
				height: 10,
				fill: e.pixelColors[6]
			}, null, 8, Ue),
			createBaseVNode("rect", {
				x: 70,
				width: 10,
				height: 10,
				fill: e.pixelColors[7]
			}, null, 8, Le),
			createBaseVNode("rect", {
				y: 10,
				width: 10,
				height: 10,
				fill: e.pixelColors[8]
			}, null, 8, Oe),
			createBaseVNode("rect", {
				y: 20,
				width: 10,
				height: 10,
				fill: e.pixelColors[9]
			}, null, 8, Te),
			createBaseVNode("rect", {
				y: 30,
				width: 10,
				height: 10,
				fill: e.pixelColors[10]
			}, null, 8, Xe),
			createBaseVNode("rect", {
				y: 40,
				width: 10,
				height: 10,
				fill: e.pixelColors[11]
			}, null, 8, Ye),
			createBaseVNode("rect", {
				y: 50,
				width: 10,
				height: 10,
				fill: e.pixelColors[12]
			}, null, 8, Re),
			createBaseVNode("rect", {
				y: 60,
				width: 10,
				height: 10,
				fill: e.pixelColors[13]
			}, null, 8, De),
			createBaseVNode("rect", {
				y: 70,
				width: 10,
				height: 10,
				fill: e.pixelColors[14]
			}, null, 8, He),
			createBaseVNode("rect", {
				x: 20,
				y: 10,
				width: 10,
				height: 10,
				fill: e.pixelColors[15]
			}, null, 8, Ge),
			createBaseVNode("rect", {
				x: 20,
				y: 20,
				width: 10,
				height: 10,
				fill: e.pixelColors[16]
			}, null, 8, Pe),
			createBaseVNode("rect", {
				x: 20,
				y: 30,
				width: 10,
				height: 10,
				fill: e.pixelColors[17]
			}, null, 8, Ve),
			createBaseVNode("rect", {
				x: 20,
				y: 40,
				width: 10,
				height: 10,
				fill: e.pixelColors[18]
			}, null, 8, je),
			createBaseVNode("rect", {
				x: 20,
				y: 50,
				width: 10,
				height: 10,
				fill: e.pixelColors[19]
			}, null, 8, Je),
			createBaseVNode("rect", {
				x: 20,
				y: 60,
				width: 10,
				height: 10,
				fill: e.pixelColors[20]
			}, null, 8, Ke),
			createBaseVNode("rect", {
				x: 20,
				y: 70,
				width: 10,
				height: 10,
				fill: e.pixelColors[21]
			}, null, 8, Qe),
			createBaseVNode("rect", {
				x: 40,
				y: 10,
				width: 10,
				height: 10,
				fill: e.pixelColors[22]
			}, null, 8, We),
			createBaseVNode("rect", {
				x: 40,
				y: 20,
				width: 10,
				height: 10,
				fill: e.pixelColors[23]
			}, null, 8, xe),
			createBaseVNode("rect", {
				x: 40,
				y: 30,
				width: 10,
				height: 10,
				fill: e.pixelColors[24]
			}, null, 8, el),
			createBaseVNode("rect", {
				x: 40,
				y: 40,
				width: 10,
				height: 10,
				fill: e.pixelColors[25]
			}, null, 8, ll),
			createBaseVNode("rect", {
				x: 40,
				y: 50,
				width: 10,
				height: 10,
				fill: e.pixelColors[26]
			}, null, 8, tl),
			createBaseVNode("rect", {
				x: 40,
				y: 60,
				width: 10,
				height: 10,
				fill: e.pixelColors[27]
			}, null, 8, il),
			createBaseVNode("rect", {
				x: 40,
				y: 70,
				width: 10,
				height: 10,
				fill: e.pixelColors[28]
			}, null, 8, ol),
			createBaseVNode("rect", {
				x: 60,
				y: 10,
				width: 10,
				height: 10,
				fill: e.pixelColors[29]
			}, null, 8, rl),
			createBaseVNode("rect", {
				x: 60,
				y: 20,
				width: 10,
				height: 10,
				fill: e.pixelColors[30]
			}, null, 8, sl),
			createBaseVNode("rect", {
				x: 60,
				y: 30,
				width: 10,
				height: 10,
				fill: e.pixelColors[31]
			}, null, 8, nl),
			createBaseVNode("rect", {
				x: 60,
				y: 40,
				width: 10,
				height: 10,
				fill: e.pixelColors[32]
			}, null, 8, hl),
			createBaseVNode("rect", {
				x: 60,
				y: 50,
				width: 10,
				height: 10,
				fill: e.pixelColors[33]
			}, null, 8, al),
			createBaseVNode("rect", {
				x: 60,
				y: 60,
				width: 10,
				height: 10,
				fill: e.pixelColors[34]
			}, null, 8, dl),
			createBaseVNode("rect", {
				x: 60,
				y: 70,
				width: 10,
				height: 10,
				fill: e.pixelColors[35]
			}, null, 8, fl),
			createBaseVNode("rect", {
				x: 10,
				y: 10,
				width: 10,
				height: 10,
				fill: e.pixelColors[36]
			}, null, 8, ul),
			createBaseVNode("rect", {
				x: 10,
				y: 20,
				width: 10,
				height: 10,
				fill: e.pixelColors[37]
			}, null, 8, pl),
			createBaseVNode("rect", {
				x: 10,
				y: 30,
				width: 10,
				height: 10,
				fill: e.pixelColors[38]
			}, null, 8, gl),
			createBaseVNode("rect", {
				x: 10,
				y: 40,
				width: 10,
				height: 10,
				fill: e.pixelColors[39]
			}, null, 8, cl$1),
			createBaseVNode("rect", {
				x: 10,
				y: 50,
				width: 10,
				height: 10,
				fill: e.pixelColors[40]
			}, null, 8, wl),
			createBaseVNode("rect", {
				x: 10,
				y: 60,
				width: 10,
				height: 10,
				fill: e.pixelColors[41]
			}, null, 8, $l),
			createBaseVNode("rect", {
				x: 10,
				y: 70,
				width: 10,
				height: 10,
				fill: e.pixelColors[42]
			}, null, 8, ml),
			createBaseVNode("rect", {
				x: 30,
				y: 10,
				width: 10,
				height: 10,
				fill: e.pixelColors[43]
			}, null, 8, yl),
			createBaseVNode("rect", {
				x: 30,
				y: 20,
				width: 10,
				height: 10,
				fill: e.pixelColors[44]
			}, null, 8, Sl),
			createBaseVNode("rect", {
				x: 30,
				y: 30,
				width: 10,
				height: 10,
				fill: e.pixelColors[45]
			}, null, 8, _l),
			createBaseVNode("rect", {
				x: 30,
				y: 40,
				width: 10,
				height: 10,
				fill: e.pixelColors[46]
			}, null, 8, Cl),
			createBaseVNode("rect", {
				x: 30,
				y: 50,
				width: 10,
				height: 10,
				fill: e.pixelColors[47]
			}, null, 8, El),
			createBaseVNode("rect", {
				x: 30,
				y: 60,
				width: 10,
				height: 10,
				fill: e.pixelColors[48]
			}, null, 8, Il),
			createBaseVNode("rect", {
				x: 30,
				y: 70,
				width: 10,
				height: 10,
				fill: e.pixelColors[49]
			}, null, 8, Zl),
			createBaseVNode("rect", {
				x: 50,
				y: 10,
				width: 10,
				height: 10,
				fill: e.pixelColors[50]
			}, null, 8, vl),
			createBaseVNode("rect", {
				x: 50,
				y: 20,
				width: 10,
				height: 10,
				fill: e.pixelColors[51]
			}, null, 8, ql),
			createBaseVNode("rect", {
				x: 50,
				y: 30,
				width: 10,
				height: 10,
				fill: e.pixelColors[52]
			}, null, 8, kl),
			createBaseVNode("rect", {
				x: 50,
				y: 40,
				width: 10,
				height: 10,
				fill: e.pixelColors[53]
			}, null, 8, Fl),
			createBaseVNode("rect", {
				x: 50,
				y: 50,
				width: 10,
				height: 10,
				fill: e.pixelColors[54]
			}, null, 8, Bl),
			createBaseVNode("rect", {
				x: 50,
				y: 60,
				width: 10,
				height: 10,
				fill: e.pixelColors[55]
			}, null, 8, zl),
			createBaseVNode("rect", {
				x: 50,
				y: 70,
				width: 10,
				height: 10,
				fill: e.pixelColors[56]
			}, null, 8, bl),
			createBaseVNode("rect", {
				x: 70,
				y: 10,
				width: 10,
				height: 10,
				fill: e.pixelColors[57]
			}, null, 8, Al),
			createBaseVNode("rect", {
				x: 70,
				y: 20,
				width: 10,
				height: 10,
				fill: e.pixelColors[58]
			}, null, 8, Ml),
			createBaseVNode("rect", {
				x: 70,
				y: 30,
				width: 10,
				height: 10,
				fill: e.pixelColors[59]
			}, null, 8, Nl),
			createBaseVNode("rect", {
				x: 70,
				y: 40,
				width: 10,
				height: 10,
				fill: e.pixelColors[60]
			}, null, 8, Ul),
			createBaseVNode("rect", {
				x: 70,
				y: 50,
				width: 10,
				height: 10,
				fill: e.pixelColors[61]
			}, null, 8, Ll),
			createBaseVNode("rect", {
				x: 70,
				y: 60,
				width: 10,
				height: 10,
				fill: e.pixelColors[62]
			}, null, 8, Ol),
			createBaseVNode("rect", {
				x: 70,
				y: 70,
				width: 10,
				height: 10,
				fill: e.pixelColors[63]
			}, null, 8, Tl)
		])
	], 8, Ze);
}
var Yl = /* @__PURE__ */ g(Ie, [["render", Xl]]), Rl = 90, Dl = 5;
function Hl(e, t$1) {
	const i$1 = m$1(e), o$1 = t$1 && t$1.length, r = Array.from({ length: Dl }, (n, y) => u(i$1 + y, t$1, o$1)), s = [];
	return s[0] = r[0], s[1] = r[1], s[2] = r[1], s[3] = r[2], s[4] = r[2], s[5] = r[3], s[6] = r[3], s[7] = r[0], s[8] = r[4], s;
}
var Gl = defineComponent({
	props: {
		colors: {
			type: Array,
			required: !0
		},
		name: {
			type: String,
			required: !0
		},
		square: {
			type: Boolean,
			required: !1,
			default: !1
		},
		size: {
			type: Number,
			required: !0
		},
		title: {
			type: Boolean,
			required: !1,
			default: !1
		}
	},
	setup(e) {
		return {
			ringColors: computed(() => Hl(e.name, e.colors)),
			SIZE: Rl
		};
	}
}), Pl = [
	"viewBox",
	"width",
	"height"
], Vl = { key: 0 }, jl = ["width", "height"], Jl = [
	"width",
	"height",
	"rx"
], Kl = { mask: "url(#mask__ring)" }, Ql = ["fill"], Wl = ["fill"], xl = ["fill"], et = ["fill"], lt = ["fill"], tt = ["fill"], it$1 = ["fill"], ot = ["fill"], rt = ["fill"];
function st(e, t$1, i$1, o$1, r, s) {
	return openBlock(), createElementBlock("svg", {
		viewBox: `0 0 ${e.SIZE} ${e.SIZE}`,
		fill: "none",
		role: "img",
		xmlns: "http://www.w3.org/2000/svg",
		width: e.size,
		height: e.size
	}, [
		e.title ? (openBlock(), createElementBlock("title", Vl, toDisplayString(e.name), 1)) : createCommentVNode("", !0),
		createBaseVNode("mask", {
			id: "mask__ring",
			maskUnits: "userSpaceOnUse",
			x: 0,
			y: 0,
			width: e.SIZE,
			height: e.SIZE
		}, [createBaseVNode("rect", {
			width: e.SIZE,
			height: e.SIZE,
			rx: e.square ? void 0 : e.SIZE * 2,
			fill: "#FFFFFF"
		}, null, 8, Jl)], 8, jl),
		createBaseVNode("g", Kl, [
			createBaseVNode("path", {
				d: "M0 0h90v45H0z",
				fill: e.ringColors[0]
			}, null, 8, Ql),
			createBaseVNode("path", {
				d: "M0 45h90v45H0z",
				fill: e.ringColors[1]
			}, null, 8, Wl),
			createBaseVNode("path", {
				d: "M83 45a38 38 0 00-76 0h76z",
				fill: e.ringColors[2]
			}, null, 8, xl),
			createBaseVNode("path", {
				d: "M83 45a38 38 0 01-76 0h76z",
				fill: e.ringColors[3]
			}, null, 8, et),
			createBaseVNode("path", {
				d: "M77 45a32 32 0 10-64 0h64z",
				fill: e.ringColors[4]
			}, null, 8, lt),
			createBaseVNode("path", {
				d: "M77 45a32 32 0 11-64 0h64z",
				fill: e.ringColors[5]
			}, null, 8, tt),
			createBaseVNode("path", {
				d: "M71 45a26 26 0 00-52 0h52z",
				fill: e.ringColors[6]
			}, null, 8, it$1),
			createBaseVNode("path", {
				d: "M71 45a26 26 0 01-52 0h52z",
				fill: e.ringColors[7]
			}, null, 8, ot),
			createBaseVNode("circle", {
				cx: 45,
				cy: 45,
				r: 23,
				fill: e.ringColors[8]
			}, null, 8, rt)
		])
	], 8, Pl);
}
var nt = /* @__PURE__ */ g(Gl, [["render", st]]), ht = 4, at = 80;
function dt(e, t$1) {
	const i$1 = m$1(e), o$1 = t$1 && t$1.length;
	return Array.from({ length: ht }, (s, n) => u(i$1 + n, t$1, o$1));
}
var ft = defineComponent({
	props: {
		colors: {
			type: Array,
			required: !0
		},
		name: {
			type: String,
			required: !0
		},
		square: {
			type: Boolean,
			required: !1,
			default: !1
		},
		size: {
			type: Number,
			required: !0
		},
		title: {
			type: Boolean,
			required: !1,
			default: !1
		}
	},
	setup(e) {
		return {
			sunsetColors: computed(() => dt(e.name, e.colors)),
			formattedName: computed(() => e.name.replace(/\s/g, "")),
			SIZE: at
		};
	}
}), ut = [
	"viewBox",
	"width",
	"height"
], pt = { key: 0 }, gt = ["width", "height"], ct = [
	"width",
	"height",
	"rx"
], wt = { mask: "url(#mask__sunset)" }, $t = ["fill"], mt = ["fill"], yt = [
	"id",
	"x1",
	"x2",
	"y2"
], St = ["stop-color"], _t = ["stop-color"], Ct = [
	"id",
	"x1",
	"y1",
	"x2",
	"y2"
], Et = ["stop-color"], It = ["stop-color"];
function Zt(e, t$1, i$1, o$1, r, s) {
	return openBlock(), createElementBlock("svg", {
		viewBox: `0 0 ${e.SIZE} ${e.SIZE}`,
		fill: "none",
		role: "img",
		xmlns: "http://www.w3.org/2000/svg",
		width: e.size,
		height: e.size
	}, [
		e.title ? (openBlock(), createElementBlock("title", pt, toDisplayString(e.name), 1)) : createCommentVNode("", !0),
		createBaseVNode("mask", {
			id: "mask__sunset",
			maskUnits: "userSpaceOnUse",
			x: 0,
			y: 0,
			width: e.SIZE,
			height: e.SIZE
		}, [createBaseVNode("rect", {
			width: e.SIZE,
			height: e.SIZE,
			rx: e.square ? void 0 : e.SIZE * 2,
			fill: "#FFFFFF"
		}, null, 8, ct)], 8, gt),
		createBaseVNode("g", wt, [createBaseVNode("path", {
			fill: `url(#gradient_paint0_linear_${e.formattedName})`,
			d: "M0 0h80v40H0z"
		}, null, 8, $t), createBaseVNode("path", {
			fill: `url(#gradient_paint1_linear_${e.formattedName})`,
			d: "M0 40h80v40H0z"
		}, null, 8, mt)]),
		createBaseVNode("defs", null, [createBaseVNode("linearGradient", {
			id: `gradient_paint0_linear_${e.formattedName}`,
			x1: e.SIZE / 2,
			y1: 0,
			x2: e.SIZE / 2,
			y2: e.SIZE / 2,
			gradientUnits: "userSpaceOnUse"
		}, [createBaseVNode("stop", { "stop-color": e.sunsetColors[0] }, null, 8, St), createBaseVNode("stop", {
			offset: 1,
			"stop-color": e.sunsetColors[1]
		}, null, 8, _t)], 8, yt), createBaseVNode("linearGradient", {
			id: `gradient_paint1_linear_${e.formattedName}`,
			x1: e.SIZE / 2,
			y1: e.SIZE / 2,
			x2: e.SIZE / 2,
			y2: e.SIZE,
			gradientUnits: "userSpaceOnUse"
		}, [createBaseVNode("stop", { "stop-color": e.sunsetColors[2] }, null, 8, Et), createBaseVNode("stop", {
			offset: 1,
			"stop-color": e.sunsetColors[3]
		}, null, 8, It)], 8, Ct)])
	], 8, ut);
}
var vt = /* @__PURE__ */ g(ft, [["render", Zt]]), qt = defineComponent({
	name: "Avatar",
	props: {
		variant: {
			type: String,
			required: !1,
			default: "marble",
			validator(e) {
				return [
					"bauhaus",
					"beam",
					"marble",
					"pixel",
					"ring",
					"sunset"
				].includes(e);
			}
		},
		colors: {
			type: Array,
			required: !1,
			default: () => [
				"#92A1C6",
				"#146A7C",
				"#F0AB3D",
				"#C271B4",
				"#C20D90"
			]
		},
		name: {
			type: String,
			required: !1,
			default: "Clara Barton"
		},
		square: {
			type: Boolean,
			required: !1,
			default: !1
		},
		size: {
			type: Number,
			required: !1,
			default: 40
		},
		title: {
			type: Boolean,
			required: !1,
			default: !1
		}
	},
	setup() {
		return {};
	},
	components: {
		AvatarBauhaus: D,
		AvatarBeam: re,
		AvatarMarble: Se,
		AvatarPixel: Yl,
		AvatarRing: nt,
		AvatarSunset: vt
	}
});
function kt(e, t$1, i$1, o$1, r, s) {
	return openBlock(), createBlock(resolveDynamicComponent(`avatar-${e.variant}`), {
		colors: e.colors,
		name: e.name,
		square: e.square,
		size: e.size,
		title: e.title
	}, null, 8, [
		"colors",
		"name",
		"square",
		"size",
		"title"
	]);
}
var zt = /* @__PURE__ */ g(qt, [["render", kt]]);
const getInitials = (label$3) => {
	const isSegmenterSupported = typeof Intl !== "undefined" && "Segmenter" in Intl;
	const segmentWord = (word) => {
		if (isSegmenterSupported) return [...new Intl.Segmenter().segment(word)].map((s) => s.segment);
		return word.split("");
	};
	const getFirstSegment = (word) => word[0] || "";
	const getFirstTwoSegments = (word) => word.slice(0, 2).join("");
	const words = label$3.split(" ").filter(Boolean).map(segmentWord);
	if (words.length === 0) return "";
	if (words.length === 1) return getFirstTwoSegments(words[0]);
	return words.slice(0, 2).map(getFirstSegment).join("");
};
var Avatar_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	name: "N8nAvatar",
	__name: "Avatar",
	props: {
		firstName: { default: "" },
		lastName: { default: "" },
		size: { default: "medium" },
		colors: { default: () => [
			"--color--primary",
			"--color--secondary",
			"--avatar--color--accent-1",
			"--avatar--color--accent-2",
			"--color--primary--tint-1"
		] }
	},
	setup(__props) {
		const props = __props;
		const name$1 = computed(() => `${props.firstName} ${props.lastName}`.trim());
		const initials$1 = computed(() => getInitials(name$1.value));
		const getColors = (colors) => {
			const style = getComputedStyle(document.body);
			return colors.map((color) => style.getPropertyValue(color));
		};
		const sizes = {
			xxsmall: 16,
			xsmall: 20,
			small: 28,
			large: 48,
			medium: 40
		};
		const getSize = (size$2) => sizes[size$2];
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("span", mergeProps({ class: ["n8n-avatar", _ctx.$style.container] }, _ctx.$attrs), [name$1.value ? (openBlock(), createBlock(unref(zt), {
				key: 0,
				size: getSize(_ctx.size),
				name: name$1.value,
				variant: "marble",
				colors: getColors(_ctx.colors)
			}, null, 8, [
				"size",
				"name",
				"colors"
			])) : (openBlock(), createElementBlock("div", {
				key: 1,
				class: normalizeClass([_ctx.$style.empty, _ctx.$style[_ctx.size]])
			}, null, 2)), _ctx.firstName || _ctx.lastName ? (openBlock(), createElementBlock("span", {
				key: 2,
				class: normalizeClass([_ctx.$style.initials, _ctx.$style[`text-${_ctx.size}`]])
			}, toDisplayString(initials$1.value), 3)) : createCommentVNode("", true)], 16);
		};
	}
});
const container$9 = "_container_odrs4_123";
const empty = "_empty_odrs4_133";
const initials = "_initials_odrs4_140";
const xsmall$1 = "_xsmall_odrs4_154";
const small$6 = "_small_odrs4_159";
const medium$5 = "_medium_odrs4_164";
const large$2 = "_large_odrs4_169";
var Avatar_vue_vue_type_style_index_0_lang_module_default = {
	container: container$9,
	empty,
	initials,
	"text-xxsmall": "_text-xxsmall_odrs4_149",
	"text-xsmall": "_text-xsmall_odrs4_150",
	xsmall: xsmall$1,
	small: small$6,
	medium: medium$5,
	large: large$2
};
var N8nAvatar_default = /* @__PURE__ */ __plugin_vue_export_helper_default(Avatar_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": Avatar_vue_vue_type_style_index_0_lang_module_default }]]);
var BlockUi_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "BlockUi",
	props: { show: {
		type: Boolean,
		default: false
	} },
	setup(__props) {
		return (_ctx, _cache) => {
			return openBlock(), createBlock(Transition, {
				name: "fade",
				mode: "out-in"
			}, {
				default: withCtx(() => [withDirectives(createBaseVNode("div", {
					class: normalizeClass(["n8n-block-ui", _ctx.$style.uiBlocker]),
					role: "dialog",
					"aria-hidden": true
				}, null, 2), [[vShow, _ctx.show]])]),
				_: 1
			});
		};
	}
});
var BlockUi_vue_vue_type_style_index_0_lang_module_default = { uiBlocker: "_uiBlocker_1cuek_123" };
var N8nBlockUi_default = /* @__PURE__ */ __plugin_vue_export_helper_default(BlockUi_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": BlockUi_vue_vue_type_style_index_0_lang_module_default }], ["__scopeId", "data-v-39f743f2"]]);
var CanvasThinkingPill_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	name: "N8nCanvasThinkingPill",
	__name: "CanvasThinkingPill",
	props: { showStop: { type: Boolean } },
	emits: ["stop"],
	setup(__props, { emit: __emit }) {
		const emit = __emit;
		const { t: t$1 } = useI18n();
		const $style = useCssModule();
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", { class: normalizeClass(unref($style).thinkingPill) }, [createBaseVNode("div", { class: normalizeClass(unref($style).iconWrapper) }, [createVNode(AssistantIcon_default, { theme: "blank" })], 2), createBaseVNode("span", { class: normalizeClass(unref($style).text) }, [createTextVNode(toDisplayString(unref(t$1)("aiAssistant.builder.canvas.thinking")) + " ", 1), _ctx.showStop ? (openBlock(), createBlock(unref(N8nButton_default), {
				key: 0,
				class: normalizeClass(unref($style).stopButton),
				label: "Stop",
				type: "secondary",
				size: "mini",
				onClick: _cache[0] || (_cache[0] = ($event) => emit("stop"))
			}, null, 8, ["class"])) : createCommentVNode("", true)], 2)], 2);
		};
	}
});
var CanvasThinkingPill_vue_vue_type_style_index_0_lang_module_default = {
	thinkingPill: "_thinkingPill_bl3f7_123",
	iconWrapper: "_iconWrapper_bl3f7_139",
	stopButton: "_stopButton_bl3f7_149",
	text: "_text_bl3f7_153"
};
var CanvasThinkingPill_default = /* @__PURE__ */ __plugin_vue_export_helper_default(CanvasThinkingPill_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": CanvasThinkingPill_vue_vue_type_style_index_0_lang_module_default }]]);
var Card_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	name: "N8nCard",
	__name: "Card",
	props: { hoverable: {
		type: Boolean,
		default: false
	} },
	setup(__props) {
		const props = __props;
		const $style = useCssModule();
		const classes = computed(() => ({
			card: true,
			[$style.card]: true,
			[$style.hoverable]: props.hoverable
		}));
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", mergeProps({ class: classes.value }, _ctx.$attrs), [
				_ctx.$slots.prepend ? (openBlock(), createElementBlock("div", {
					key: 0,
					"data-test-id": "card-prepend",
					class: normalizeClass(unref($style).icon)
				}, [renderSlot(_ctx.$slots, "prepend")], 2)) : createCommentVNode("", true),
				createBaseVNode("div", {
					class: normalizeClass(unref($style).content),
					"data-test-id": "card-content"
				}, [
					_ctx.$slots.header ? (openBlock(), createElementBlock("div", {
						key: 0,
						class: normalizeClass(unref($style).header)
					}, [renderSlot(_ctx.$slots, "header")], 2)) : createCommentVNode("", true),
					_ctx.$slots.default ? (openBlock(), createElementBlock("div", {
						key: 1,
						class: normalizeClass(unref($style).body)
					}, [renderSlot(_ctx.$slots, "default")], 2)) : createCommentVNode("", true),
					_ctx.$slots.footer ? (openBlock(), createElementBlock("div", {
						key: 2,
						class: normalizeClass(unref($style).footer)
					}, [renderSlot(_ctx.$slots, "footer")], 2)) : createCommentVNode("", true)
				], 2),
				_ctx.$slots.append ? (openBlock(), createElementBlock("div", {
					key: 1,
					"data-test-id": "card-append",
					class: normalizeClass([unref($style).append, "n8n-card-append"])
				}, [renderSlot(_ctx.$slots, "append")], 2)) : createCommentVNode("", true)
			], 16);
		};
	}
});
var Card_vue_vue_type_style_index_0_lang_module_default = {
	card: "_card_5i7ns_123",
	header: "_header_5i7ns_134",
	footer: "_footer_5i7ns_135",
	content: "_content_5i7ns_142",
	body: "_body_5i7ns_150",
	icon: "_icon_5i7ns_158",
	hoverable: "_hoverable_5i7ns_166",
	append: "_append_5i7ns_177"
};
var N8nCard_default = /* @__PURE__ */ __plugin_vue_export_helper_default(Card_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": Card_vue_vue_type_style_index_0_lang_module_default }]]);
var _hoisted_1$29 = ["for"];
var _hoisted_2$17 = ["data-test-id"];
var _hoisted_3$8 = ["data-test-id"];
var _hoisted_4$5 = ["data-test-id"];
var InputLabel_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	name: "N8nInputLabel",
	__name: "InputLabel",
	props: {
		compact: {
			type: Boolean,
			default: false
		},
		color: {},
		label: {},
		tooltipText: {},
		inputName: {},
		required: { type: Boolean },
		bold: {
			type: Boolean,
			default: true
		},
		size: { default: "medium" },
		underline: { type: Boolean },
		showTooltip: { type: Boolean },
		showOptions: { type: Boolean }
	},
	setup(__props) {
		const addTargetBlank = (html) => html && html.includes("href=") ? html.replace(/href=/g, "target=\"_blank\" href=") : html;
		return (_ctx, _cache) => {
			const _directive_n8n_html = resolveDirective("n8n-html");
			return openBlock(), createElementBlock("div", mergeProps({ class: {
				[_ctx.$style.container]: true,
				[_ctx.$style.withOptions]: _ctx.$slots.options
			} }, _ctx.$attrs, { "data-test-id": "input-label" }), [createBaseVNode("div", { class: normalizeClass(_ctx.$style.labelRow) }, [_ctx.label || _ctx.$slots.options ? (openBlock(), createElementBlock("label", {
				key: 0,
				for: _ctx.inputName,
				class: normalizeClass({
					"n8n-input-label": true,
					[_ctx.$style.inputLabel]: true,
					[_ctx.$style.heading]: !!_ctx.label,
					[_ctx.$style.underline]: _ctx.underline,
					[_ctx.$style[_ctx.size]]: true,
					[_ctx.$style.overflow]: !!_ctx.$slots.options
				})
			}, [createBaseVNode("div", { class: normalizeClass(_ctx.$style["main-content"]) }, [_ctx.label ? (openBlock(), createElementBlock("div", {
				key: 0,
				class: normalizeClass(_ctx.$style.title)
			}, [createVNode(unref(N8nText_default), {
				bold: _ctx.bold,
				size: _ctx.size,
				compact: _ctx.compact,
				color: _ctx.color,
				class: normalizeClass({ [_ctx.$style.textEllipses]: _ctx.showOptions })
			}, {
				default: withCtx(() => [createTextVNode(toDisplayString(_ctx.label) + " ", 1), _ctx.required ? (openBlock(), createBlock(unref(N8nText_default), {
					key: 0,
					color: "primary",
					bold: _ctx.bold,
					size: _ctx.size
				}, {
					default: withCtx(() => _cache[0] || (_cache[0] = [createTextVNode("*")])),
					_: 1
				}, 8, ["bold", "size"])) : createCommentVNode("", true)]),
				_: 1
			}, 8, [
				"bold",
				"size",
				"compact",
				"color",
				"class"
			])], 2)) : createCommentVNode("", true), _ctx.tooltipText && _ctx.label ? (openBlock(), createElementBlock("span", {
				key: 1,
				class: normalizeClass([_ctx.$style.infoIcon, _ctx.showTooltip ? _ctx.$style.visible : _ctx.$style.hidden])
			}, [createVNode(unref(N8nTooltip_default), {
				placement: "top",
				"popper-class": _ctx.$style.tooltipPopper,
				"show-after": 300
			}, {
				content: withCtx(() => [withDirectives(createBaseVNode("div", null, null, 512), [[_directive_n8n_html, addTargetBlank(_ctx.tooltipText)]])]),
				default: withCtx(() => [createVNode(unref(N8nIcon_default), {
					class: normalizeClass(_ctx.$style.icon),
					icon: "circle-help",
					size: "small"
				}, null, 8, ["class"])]),
				_: 1
			}, 8, ["popper-class"])], 2)) : createCommentVNode("", true)], 2), createBaseVNode("div", { class: normalizeClass(_ctx.$style["trailing-content"]) }, [
				_ctx.$slots.options && _ctx.label ? (openBlock(), createElementBlock("div", {
					key: 0,
					class: normalizeClass({
						[_ctx.$style.overlay]: true,
						[_ctx.$style.visible]: _ctx.showOptions
					})
				}, null, 2)) : createCommentVNode("", true),
				_ctx.$slots.options ? (openBlock(), createElementBlock("div", {
					key: 1,
					class: normalizeClass({
						[_ctx.$style.options]: true,
						[_ctx.$style.visible]: _ctx.showOptions
					}),
					"data-test-id": `${_ctx.inputName}-parameter-input-options-container`
				}, [renderSlot(_ctx.$slots, "options")], 10, _hoisted_2$17)) : createCommentVNode("", true),
				_ctx.$slots.issues ? (openBlock(), createElementBlock("div", {
					key: 2,
					class: normalizeClass(_ctx.$style.issues),
					"data-test-id": `${_ctx.inputName}-parameter-input-issues-container`
				}, [renderSlot(_ctx.$slots, "issues")], 10, _hoisted_3$8)) : createCommentVNode("", true)
			], 2)], 10, _hoisted_1$29)) : createCommentVNode("", true), _ctx.$slots.persistentOptions ? (openBlock(), createElementBlock("div", {
				key: 1,
				class: "pl-4xs",
				"data-test-id": `${_ctx.inputName}-parameter-input-persistent-options-container`
			}, [renderSlot(_ctx.$slots, "persistentOptions")], 8, _hoisted_4$5)) : createCommentVNode("", true)], 2), renderSlot(_ctx.$slots, "default")], 16);
		};
	}
});
const container$8 = "_container_chkiw_123";
const labelRow = "_labelRow_chkiw_132";
const infoIcon$1 = "_infoIcon_chkiw_140";
const icon$4 = "_icon_chkiw_147";
const inputLabel = "_inputLabel_chkiw_159";
const options = "_options_chkiw_164";
const overlay = "_overlay_chkiw_169";
const withOptions = "_withOptions_chkiw_175";
const title$1 = "_title_chkiw_175";
const issues = "_issues_chkiw_204";
const hidden$1 = "_hidden_chkiw_225";
const visible = "_visible_chkiw_229";
const overflow = "_overflow_chkiw_233";
const textEllipses = "_textEllipses_chkiw_238";
const heading$1 = "_heading_chkiw_243";
const small$5 = "_small_chkiw_246";
const medium$4 = "_medium_chkiw_249";
const underline = "_underline_chkiw_253";
const tooltipPopper$1 = "_tooltipPopper_chkiw_257";
var InputLabel_vue_vue_type_style_index_0_lang_module_default = {
	container: container$8,
	labelRow,
	"main-content": "_main-content_chkiw_137",
	infoIcon: infoIcon$1,
	icon: icon$4,
	"trailing-content": "_trailing-content_chkiw_151",
	inputLabel,
	options,
	overlay,
	withOptions,
	title: title$1,
	issues,
	hidden: hidden$1,
	visible,
	overflow,
	textEllipses,
	heading: heading$1,
	small: small$5,
	medium: medium$4,
	underline,
	tooltipPopper: tooltipPopper$1
};
var N8nInputLabel_default = /* @__PURE__ */ __plugin_vue_export_helper_default(InputLabel_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": InputLabel_vue_vue_type_style_index_0_lang_module_default }]]);
var Checkbox_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	name: "N8nCheckbox",
	__name: "Checkbox",
	props: {
		label: {},
		disabled: {
			type: Boolean,
			default: false
		},
		tooltipText: {},
		indeterminate: {
			type: Boolean,
			default: false
		},
		modelValue: {
			type: Boolean,
			default: false
		},
		labelSize: { default: "medium" }
	},
	emits: ["update:modelValue"],
	setup(__props, { emit: __emit }) {
		const emit = __emit;
		const onUpdateModelValue = (value) => emit("update:modelValue", value);
		const checkbox = ref();
		const onLabelClick = () => {
			if (!checkbox?.value) return;
			checkbox.value.$el.click();
		};
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(ElCheckbox), mergeProps(_ctx.$props, {
				ref_key: "checkbox",
				ref: checkbox,
				class: ["n8n-checkbox", _ctx.$style.n8nCheckbox],
				disabled: _ctx.disabled,
				indeterminate: _ctx.indeterminate,
				"model-value": _ctx.modelValue,
				"onUpdate:modelValue": onUpdateModelValue
			}), {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default"), _ctx.label ? (openBlock(), createBlock(unref(N8nInputLabel_default), {
					key: 0,
					label: _ctx.label,
					"tooltip-text": _ctx.tooltipText,
					bold: false,
					size: _ctx.labelSize,
					onClick: withModifiers(onLabelClick, ["prevent"])
				}, null, 8, [
					"label",
					"tooltip-text",
					"size"
				])) : createCommentVNode("", true)]),
				_: 3
			}, 16, [
				"class",
				"disabled",
				"indeterminate",
				"model-value"
			]);
		};
	}
});
var Checkbox_vue_vue_type_style_index_0_lang_module_default = { n8nCheckbox: "_n8nCheckbox_mqnz8_123" };
var N8nCheckbox_default = /* @__PURE__ */ __plugin_vue_export_helper_default(Checkbox_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": Checkbox_vue_vue_type_style_index_0_lang_module_default }]]);
var _hoisted_1$28 = { class: "progress-circle" };
var _hoisted_2$16 = ["width", "height"];
var _hoisted_3$7 = ["stroke-width", "r"];
var _hoisted_4$4 = ["stroke-width", "r"];
var CircleLoader_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "CircleLoader",
	props: {
		radius: {},
		progress: {},
		strokeWidth: { default: 4 }
	},
	setup(__props) {
		const props = __props;
		const diameter = computed(() => 2 * (props.radius + props.strokeWidth));
		const circumference = computed(() => 2 * Math.PI * props.radius);
		const strokeDashoffset = computed(() => circumference.value - props.progress / 100 * circumference.value);
		const cx = computed(() => props.radius + props.strokeWidth);
		const cy = computed(() => props.radius + props.strokeWidth);
		const style = computed(() => ({
			strokeDasharray: `${circumference.value}`,
			strokeDashoffset: `${strokeDashoffset.value}`
		}));
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", _hoisted_1$28, [(openBlock(), createElementBlock("svg", {
				class: "progress-ring",
				width: diameter.value,
				height: diameter.value
			}, [createBaseVNode("circle", mergeProps({
				class: _ctx.$style.progressRingCircle,
				"stroke-width": _ctx.strokeWidth,
				stroke: "#DCDFE6",
				fill: "transparent",
				r: _ctx.radius
			}, {
				cx: cx.value,
				cy: cy.value
			}), null, 16, _hoisted_3$7), createBaseVNode("circle", mergeProps({
				class: _ctx.$style.progressRingCircle,
				stroke: "#5C4EC2",
				"stroke-width": _ctx.strokeWidth,
				fill: "transparent",
				r: _ctx.radius
			}, {
				cx: cx.value,
				cy: cy.value,
				style: style.value
			}), null, 16, _hoisted_4$4)], 8, _hoisted_2$16))]);
		};
	}
});
var CircleLoader_vue_vue_type_style_index_0_lang_module_default = { progressRingCircle: "_progressRingCircle_15w7u_2" };
var N8nCircleLoader_default = /* @__PURE__ */ __plugin_vue_export_helper_default(CircleLoader_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": CircleLoader_vue_vue_type_style_index_0_lang_module_default }]]);
var ColorPicker_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	name: "N8nColorPicker",
	__name: "ColorPicker",
	props: {
		disabled: {
			type: Boolean,
			default: false
		},
		size: { default: "large" },
		showAlpha: {
			type: Boolean,
			default: false
		},
		colorFormat: { default: "hex" },
		popperClass: { default: "" },
		predefine: { default: void 0 },
		modelValue: { default: void 0 },
		showInput: {
			type: Boolean,
			default: true
		},
		name: { default: uid("color-picker") }
	},
	emits: [
		"update:modelValue",
		"change",
		"active-change"
	],
	setup(__props, { emit: __emit }) {
		const props = __props;
		const color = ref(props.modelValue);
		const colorPickerProps$1 = computed(() => {
			const { showInput, modelValue, size: size$2,...rest } = props;
			return rest;
		});
		const emit = __emit;
		const onChange = (value) => {
			emit("change", value);
		};
		const onInput = (value) => {
			color.value = value;
		};
		const onActiveChange = (value) => {
			emit("active-change", value);
		};
		const onColorSelect = (value) => {
			emit("update:modelValue", value);
		};
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("span", { class: normalizeClass(["n8n-color-picker", _ctx.$style.component]) }, [createVNode(unref(ElColorPicker), mergeProps(colorPickerProps$1.value, {
				"model-value": _ctx.modelValue,
				size: props.size,
				onChange,
				onActiveChange,
				"onUpdate:modelValue": onColorSelect
			}), null, 16, ["model-value", "size"]), _ctx.showInput ? (openBlock(), createBlock(unref(N8nInput_default), {
				key: 0,
				class: normalizeClass(_ctx.$style.input),
				disabled: props.disabled,
				size: props.size,
				"model-value": color.value,
				name: _ctx.name,
				type: "text",
				"onUpdate:modelValue": onInput
			}, null, 8, [
				"class",
				"disabled",
				"size",
				"model-value",
				"name"
			])) : createCommentVNode("", true)], 2);
		};
	}
});
var ColorPicker_vue_vue_type_style_index_0_lang_module_default = {
	component: "_component_1c8bu_123",
	input: "_input_1c8bu_128"
};
var N8nColorPicker_default = /* @__PURE__ */ __plugin_vue_export_helper_default(ColorPicker_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": ColorPicker_vue_vue_type_style_index_0_lang_module_default }], ["__scopeId", "data-v-5fee5dc0"]]);
var N8nOption_default = /* @__PURE__ */ defineComponent({
	__name: "Option",
	props: {
		value: { type: [
			String,
			Number,
			Boolean,
			Object
		] },
		label: {},
		disabled: { type: Boolean }
	},
	setup(__props) {
		const props = __props;
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(ElOption), normalizeProps(guardReactiveProps(props)), {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 16);
		};
	}
});
var N8nPagination_default = /* @__PURE__ */ defineComponent({
	__name: "Pagination",
	props: { ...paginationProps },
	setup(__props) {
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(ElPagination), mergeProps({
				class: "is-background",
				layout: "prev, pager, next"
			}, {
				..._ctx.$props,
				..._ctx.$attrs
			}), null, 16);
		};
	}
});
var Select_vue_vue_type_script_setup_true_lang_default$1 = /* @__PURE__ */ defineComponent({
	__name: "Select",
	props: {
		...ElSelect.props,
		modelValue: {},
		size: {
			type: String,
			default: "large"
		},
		placeholder: { type: String },
		disabled: { type: Boolean },
		filterable: { type: Boolean },
		defaultFirstOption: { type: Boolean },
		multiple: { type: Boolean },
		multipleLimit: {
			type: Number,
			default: 0
		},
		filterMethod: { type: Function },
		loading: { type: Boolean },
		loadingText: { type: String },
		popperClass: { type: String },
		popperAppendToBody: { type: Boolean },
		limitPopperWidth: { type: Boolean },
		noDataText: { type: String }
	},
	setup(__props, { expose: __expose }) {
		const props = __props;
		const attrs = useAttrs();
		const innerSelect = ref(null);
		const listeners = computed(() => {
			return Object.entries(attrs).reduce((acc, [key$2, value]) => {
				if (isEventBindingElementAttribute(value, key$2)) acc[key$2] = value;
				return acc;
			}, {});
		});
		const computedSize = computed(() => {
			if (props.size === "mini") return "small";
			if (props.size === "medium") return "default";
			if (props.size === "xlarge") return;
			return props.size;
		});
		const classes = computed(() => {
			return props.size === "xlarge" ? "xlarge" : "";
		});
		const focus$1 = () => {
			innerSelect.value?.focus();
		};
		const blur = () => {
			innerSelect.value?.blur();
		};
		const focusOnInput = () => {
			if (!innerSelect.value) return;
			const inputRef = innerSelect.value.$refs.selectWrapper;
			const inputElement = inputRef?.querySelector("input");
			if (inputElement) inputElement.focus();
			else inputRef?.focus();
		};
		__expose({
			focus: focus$1,
			blur,
			focusOnInput,
			innerSelect
		});
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", { class: normalizeClass({
				"n8n-select": true,
				[_ctx.$style.container]: true,
				[_ctx.$style.withPrepend]: !!_ctx.$slots.prepend
			}) }, [_ctx.$slots.prepend ? (openBlock(), createElementBlock("div", {
				key: 0,
				class: normalizeClass(_ctx.$style.prepend)
			}, [renderSlot(_ctx.$slots, "prepend")], 2)) : createCommentVNode("", true), createVNode(unref(ElSelect), mergeProps({
				..._ctx.$props,
				...listeners.value
			}, {
				ref_key: "innerSelect",
				ref: innerSelect,
				"multiple-limit": props.multipleLimit,
				"model-value": props.modelValue ?? void 0,
				size: computedSize.value,
				"popper-class": props.popperClass,
				class: _ctx.$style[classes.value]
			}), createSlots({
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 2
			}, [
				_ctx.$slots.prefix ? {
					name: "prefix",
					fn: withCtx(() => [renderSlot(_ctx.$slots, "prefix")]),
					key: "0"
				} : void 0,
				_ctx.$slots.suffix ? {
					name: "suffix",
					fn: withCtx(() => [renderSlot(_ctx.$slots, "suffix")]),
					key: "1"
				} : void 0,
				_ctx.$slots.footer ? {
					name: "footer",
					fn: withCtx(() => [renderSlot(_ctx.$slots, "footer")]),
					key: "2"
				} : void 0,
				_ctx.$slots.empty ? {
					name: "empty",
					fn: withCtx(() => [renderSlot(_ctx.$slots, "empty")]),
					key: "3"
				} : void 0
			]), 1040, [
				"multiple-limit",
				"model-value",
				"size",
				"popper-class",
				"class"
			])], 2);
		};
	}
});
var Select_vue_vue_type_style_index_0_lang_module_default$1 = {
	xlarge: "_xlarge_e4dfb_123",
	container: "_container_e4dfb_130",
	withPrepend: "_withPrepend_e4dfb_135",
	prepend: "_prepend_e4dfb_145"
};
var N8nSelect_default = /* @__PURE__ */ __plugin_vue_export_helper_default(Select_vue_vue_type_script_setup_true_lang_default$1, [["__cssModules", { "$style": Select_vue_vue_type_style_index_0_lang_module_default$1 }]]);
var TableBase_vue_vue_type_style_index_0_lang_module_default = {
	n8nTableScroll: "_n8nTableScroll_5vz7z_123",
	n8nTable: "_n8nTable_5vz7z_123"
};
var _sfc_main = {};
function _sfc_render(_ctx, _cache) {
	return openBlock(), createElementBlock("div", { class: normalizeClass(_ctx.$style.n8nTable) }, [createBaseVNode("div", { class: normalizeClass(_ctx.$style.n8nTableScroll) }, [createBaseVNode("table", null, [renderSlot(_ctx.$slots, "default")])], 2)], 2);
}
var TableBase_default = /* @__PURE__ */ __plugin_vue_export_helper_default(_sfc_main, [["render", _sfc_render], ["__cssModules", { "$style": TableBase_vue_vue_type_style_index_0_lang_module_default }]]);
var _hoisted_1$27 = { key: 1 };
var _hoisted_2$15 = { class: "pagination" };
var _hoisted_3$6 = { class: "pageSizeSelector" };
var ALL_ROWS = -1;
var N8nDatatable_default = /* @__PURE__ */ __plugin_vue_export_helper_default(/* @__PURE__ */ defineComponent({
	name: "N8nDatatable",
	__name: "Datatable",
	props: {
		columns: {},
		rows: {},
		currentPage: { default: 1 },
		pagination: {
			type: Boolean,
			default: true
		},
		rowsPerPage: { default: 10 }
	},
	emits: ["update:currentPage", "update:rowsPerPage"],
	setup(__props, { emit: __emit }) {
		const props = __props;
		const emit = __emit;
		const { t: t$1 } = useI18n();
		const rowsPerPageOptions = ref([
			1,
			10,
			25,
			50,
			100
		]);
		const totalPages = computed(() => {
			return Math.ceil(props.rows.length / props.rowsPerPage);
		});
		const totalRows = computed(() => {
			return props.rows.length;
		});
		const visibleRows = computed(() => {
			if (props.rowsPerPage === ALL_ROWS) return props.rows;
			const start = (props.currentPage - 1) * props.rowsPerPage;
			const end$1 = start + props.rowsPerPage;
			return props.rows.slice(start, end$1);
		});
		function onUpdateCurrentPage(value) {
			emit("update:currentPage", value);
		}
		function onRowsPerPageChange(value) {
			emit("update:rowsPerPage", value);
			if (value === ALL_ROWS) {
				onUpdateCurrentPage(1);
				return;
			}
			const maxPage = Math.ceil(totalRows.value / value);
			if (maxPage < props.currentPage) onUpdateCurrentPage(maxPage);
		}
		function getTdValue(row, column$1) {
			return getValueByPath(row, column$1.path);
		}
		function getThStyle(column$1) {
			return { ...column$1.width ? { width: column$1.width } : {} };
		}
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", mergeProps({ class: "datatable datatableWrapper" }, _ctx.$attrs), [
				createVNode(unref(TableBase_default), null, {
					default: withCtx(() => [createBaseVNode("thead", null, [createBaseVNode("tr", null, [(openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.columns, (column$1) => {
						return openBlock(), createElementBlock("th", {
							key: column$1.id,
							class: normalizeClass(column$1.classes),
							style: normalizeStyle(getThStyle(column$1))
						}, toDisplayString(column$1.label), 7);
					}), 128))])]), createBaseVNode("tbody", null, [(openBlock(true), createElementBlock(Fragment, null, renderList(visibleRows.value, (row) => {
						return renderSlot(_ctx.$slots, "row", {
							columns: _ctx.columns,
							row,
							getTdValue
						}, () => [(openBlock(), createElementBlock("tr", { key: row.id }, [(openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.columns, (column$1) => {
							return openBlock(), createElementBlock("td", {
								key: column$1.id,
								class: normalizeClass(column$1.classes)
							}, [column$1.render ? (openBlock(), createBlock(resolveDynamicComponent(column$1.render), {
								key: 0,
								row,
								column: column$1
							}, null, 8, ["row", "column"])) : (openBlock(), createElementBlock("span", _hoisted_1$27, toDisplayString(getTdValue(row, column$1)), 1))], 2);
						}), 128))]))], true);
					}), 256))])]),
					_: 3
				}),
				renderSlot(_ctx.$slots, "postdata", {}, void 0, true),
				createBaseVNode("div", _hoisted_2$15, [totalPages.value > 1 ? (openBlock(), createBlock(unref(N8nPagination_default), {
					key: 0,
					background: "",
					"pager-count": 5,
					"page-size": _ctx.rowsPerPage,
					layout: "prev, pager, next",
					total: totalRows.value,
					"current-page": _ctx.currentPage,
					"onUpdate:currentPage": onUpdateCurrentPage
				}, null, 8, [
					"page-size",
					"total",
					"current-page"
				])) : createCommentVNode("", true), createBaseVNode("div", _hoisted_3$6, [createVNode(unref(N8nSelect_default), {
					size: "mini",
					"model-value": _ctx.rowsPerPage,
					teleported: "",
					"onUpdate:modelValue": onRowsPerPageChange
				}, {
					prepend: withCtx(() => [createTextVNode(toDisplayString(unref(t$1)("datatable.pageSize")), 1)]),
					default: withCtx(() => [(openBlock(true), createElementBlock(Fragment, null, renderList(rowsPerPageOptions.value, (size$2) => {
						return openBlock(), createBlock(unref(N8nOption_default), {
							key: size$2,
							label: `${size$2}`,
							value: size$2
						}, null, 8, ["label", "value"]);
					}), 128)), createVNode(unref(N8nOption_default), {
						label: `All`,
						value: ALL_ROWS
					})]),
					_: 1
				}, 8, ["model-value"])])])
			], 16);
		};
	}
}), [["__scopeId", "data-v-0091143d"]]);
var ExternalLink_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	name: "N8nExternalLink",
	__name: "ExternalLink",
	props: {
		href: { default: void 0 },
		size: { default: void 0 },
		newWindow: {
			type: Boolean,
			default: true
		}
	},
	setup(__props) {
		return (_ctx, _cache) => {
			return openBlock(), createBlock(resolveDynamicComponent(_ctx.href ? "a" : "button"), mergeProps({
				href: _ctx.href,
				target: _ctx.href && _ctx.newWindow ? "_blank" : void 0,
				rel: _ctx.href && _ctx.newWindow ? "noopener noreferrer" : void 0,
				class: _ctx.$style.link
			}, _ctx.$attrs), {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default"), createVNode(unref(N8nIcon_default), {
					icon: "external-link",
					size: _ctx.size
				}, null, 8, ["size"])]),
				_: 3
			}, 16, [
				"href",
				"target",
				"rel",
				"class"
			]);
		};
	}
});
var ExternalLink_vue_vue_type_style_index_0_lang_module_default = { link: "_link_h1bca_123" };
var N8nExternalLink_default = /* @__PURE__ */ __plugin_vue_export_helper_default(ExternalLink_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": ExternalLink_vue_vue_type_style_index_0_lang_module_default }]]);
const emailRegex = /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
const VALIDATORS = {
	REQUIRED: { validate: (value) => {
		if (typeof value === "string" && !!value.trim()) return false;
		if (typeof value === "number" || typeof value === "boolean") return false;
		return { messageKey: "formInput.validator.fieldRequired" };
	} },
	MIN_LENGTH: { validate: (value, config$1) => {
		if (typeof value === "string" && value.length < config$1.minimum) return {
			messageKey: "formInput.validator.minCharactersRequired",
			options: config$1
		};
		return false;
	} },
	MAX_LENGTH: { validate: (value, config$1) => {
		if (typeof value === "string" && value.length > config$1.maximum) return {
			messageKey: "formInput.validator.maxCharactersRequired",
			options: config$1
		};
		return false;
	} },
	CONTAINS_NUMBER: { validate: (value, config$1) => {
		if (typeof value !== "string") return false;
		if ((value.match(/\d/g) || []).length < config$1.minimum) return {
			messageKey: "formInput.validator.numbersRequired",
			options: config$1
		};
		return false;
	} },
	VALID_EMAIL: { validate: (value) => {
		if (!emailRegex.test(String(value).trim().toLowerCase())) return { messageKey: "formInput.validator.validEmailRequired" };
		return false;
	} },
	CONTAINS_UPPERCASE: { validate: (value, config$1) => {
		if (typeof value !== "string") return false;
		if ((value.match(/[A-Z]/g) || []).length < config$1.minimum) return {
			messageKey: "formInput.validator.uppercaseCharsRequired",
			options: config$1
		};
		return false;
	} },
	DEFAULT_PASSWORD_RULES: { rules: [{
		rules: [
			{
				name: "MIN_LENGTH",
				config: { minimum: 8 }
			},
			{
				name: "CONTAINS_NUMBER",
				config: { minimum: 1 }
			},
			{
				name: "CONTAINS_UPPERCASE",
				config: { minimum: 1 }
			}
		],
		defaultError: { messageKey: "formInput.validator.defaultPasswordRequirements" }
	}, {
		name: "MAX_LENGTH",
		config: { maximum: 64 }
	}] },
	MATCH_REGEX: { validate: (value, config$1) => {
		if (!config$1.regex.test(`${value}`)) return {
			message: config$1.message,
			options: config$1
		};
		return false;
	} }
};
const getValidationError = (value, validators, validator, config$1) => {
	if (validator.hasOwnProperty("rules")) {
		const rules = validator.rules;
		for (let i$1 = 0; i$1 < rules.length; i$1++) {
			if (rules[i$1].hasOwnProperty("rules")) {
				const error$1 = getValidationError(value, validators, rules[i$1], config$1);
				if (error$1) return error$1;
			}
			if (rules[i$1].hasOwnProperty("name")) {
				const rule = rules[i$1];
				if (!validators[rule.name]) continue;
				const error$1 = getValidationError(value, validators, validators[rule.name], rule.config);
				if (error$1 && "defaultError" in validator && validator.defaultError) return validator.defaultError;
				else if (error$1) return error$1;
			}
		}
	} else if (validator.hasOwnProperty("validate")) return validator.validate(value, config$1);
	return false;
};
var _hoisted_1$26 = ["onKeydown"];
var _hoisted_2$14 = ["textContent"];
var _hoisted_3$5 = ["textContent"];
var FormInput_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "FormInput",
	props: {
		modelValue: { type: [
			String,
			Number,
			Boolean,
			null
		] },
		label: {},
		infoText: {},
		required: { type: Boolean },
		showRequiredAsterisk: {
			type: Boolean,
			default: true
		},
		type: { default: "text" },
		placeholder: {},
		tooltipText: {},
		showValidationWarnings: { type: Boolean },
		validateOnBlur: {
			type: Boolean,
			default: true
		},
		documentationUrl: {},
		documentationText: { default: "Open docs" },
		validationRules: {},
		validators: {},
		maxlength: {},
		options: {},
		autocomplete: {},
		name: {},
		focusInitially: { type: Boolean },
		labelSize: { default: "medium" },
		disabled: { type: Boolean },
		activeLabel: {},
		activeColor: {},
		inactiveLabel: {},
		inactiveColor: {},
		teleported: {
			type: Boolean,
			default: true
		},
		tagSize: { default: "large" },
		autosize: {
			type: [Boolean, Object],
			default: false
		}
	},
	emits: [
		"validate",
		"update:modelValue",
		"focus",
		"blur",
		"enter"
	],
	setup(__props, { expose: __expose, emit: __emit }) {
		const props = __props;
		const emit = __emit;
		const state = reactive({
			hasBlurred: false,
			isTyping: false
		});
		const inputRef = ref(null);
		function getInputValidationError() {
			const rules = props.validationRules || [];
			const validators = {
				...VALIDATORS,
				...props.validators || {}
			};
			if (props.required) {
				const error$1 = getValidationError(props.modelValue, validators, validators.REQUIRED);
				if (error$1) return error$1;
			}
			for (let i$1 = 0; i$1 < rules.length; i$1++) {
				if (rules[i$1].hasOwnProperty("name")) {
					const rule = rules[i$1];
					if (validators[rule.name]) {
						const error$1 = getValidationError(props.modelValue, validators, validators[rule.name], rule.config);
						if (error$1) return error$1;
					}
				}
				if (rules[i$1].hasOwnProperty("rules")) {
					const rule = rules[i$1];
					const error$1 = getValidationError(props.modelValue, validators, rule);
					if (error$1) return error$1;
				}
			}
			return null;
		}
		function onBlur() {
			state.hasBlurred = true;
			state.isTyping = false;
			emit("blur");
		}
		function onUpdateModelValue(value) {
			state.isTyping = true;
			emit("update:modelValue", value);
		}
		function onFocus() {
			emit("focus");
		}
		function onEnter(event) {
			event.stopPropagation();
			event.preventDefault();
			emit("enter");
		}
		const validationError = computed(() => {
			const error$1 = getInputValidationError();
			if (error$1) if ("messageKey" in error$1) return { message: t(error$1.messageKey, error$1.options) };
			else return { message: error$1.message };
			return null;
		});
		const showErrors = computed(() => !!validationError.value && (props.validateOnBlur && state.hasBlurred && !state.isTyping || props.showValidationWarnings));
		onMounted(() => {
			emit("validate", !validationError.value);
			if (props.focusInitially && inputRef.value) inputRef.value.focus();
		});
		watch(validationError, (error$1) => emit("validate", !error$1));
		__expose({ inputRef });
		return (_ctx, _cache) => {
			return _ctx.type === "checkbox" ? (openBlock(), createBlock(unref(N8nCheckbox_default), {
				key: 0,
				ref_key: "inputRef",
				ref: inputRef,
				label: _ctx.label,
				disabled: _ctx.disabled,
				"label-size": _ctx.labelSize,
				"model-value": _ctx.modelValue,
				"onUpdate:modelValue": onUpdateModelValue,
				onFocus
			}, null, 8, [
				"label",
				"disabled",
				"label-size",
				"model-value"
			])) : _ctx.type === "toggle" ? (openBlock(), createBlock(unref(N8nInputLabel_default), {
				key: 1,
				"input-name": _ctx.name,
				label: _ctx.label,
				"tooltip-text": _ctx.tooltipText,
				required: _ctx.required && _ctx.showRequiredAsterisk,
				size: _ctx.labelSize
			}, {
				content: withCtx(() => [createTextVNode(toDisplayString(_ctx.tooltipText), 1)]),
				default: withCtx(() => [createVNode(unref(ElSwitch), {
					"model-value": _ctx.modelValue,
					"active-color": _ctx.activeColor,
					"inactive-color": _ctx.inactiveColor,
					"onUpdate:modelValue": onUpdateModelValue
				}, null, 8, [
					"model-value",
					"active-color",
					"inactive-color"
				])]),
				_: 1
			}, 8, [
				"input-name",
				"label",
				"tooltip-text",
				"required",
				"size"
			])) : (openBlock(), createBlock(unref(N8nInputLabel_default), {
				key: 2,
				"input-name": _ctx.name,
				label: _ctx.label,
				"tooltip-text": _ctx.tooltipText,
				required: _ctx.required && _ctx.showRequiredAsterisk,
				size: _ctx.labelSize
			}, {
				default: withCtx(() => [createBaseVNode("div", {
					class: normalizeClass(showErrors.value ? _ctx.$style.errorInput : ""),
					onKeydown: [_cache[0] || (_cache[0] = withModifiers(() => {}, ["stop"])), withKeys(withModifiers(onEnter, ["exact"]), ["enter"])]
				}, [_ctx.$slots.default ? renderSlot(_ctx.$slots, "default", { key: 0 }) : _ctx.type === "select" || _ctx.type === "multi-select" ? (openBlock(), createBlock(unref(N8nSelect_default), {
					key: 1,
					ref_key: "inputRef",
					ref: inputRef,
					class: normalizeClass({ [_ctx.$style.multiSelectSmallTags]: _ctx.tagSize === "small" }),
					"model-value": _ctx.modelValue,
					placeholder: _ctx.placeholder,
					multiple: _ctx.type === "multi-select",
					disabled: _ctx.disabled,
					name: _ctx.name,
					teleported: _ctx.teleported,
					size: _ctx.tagSize,
					"onUpdate:modelValue": onUpdateModelValue,
					onFocus,
					onBlur
				}, {
					default: withCtx(() => [(openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.options || [], (option) => {
						return openBlock(), createBlock(unref(N8nOption_default), {
							key: option.value,
							value: option.value,
							label: option.label,
							disabled: !!option.disabled,
							size: "small"
						}, null, 8, [
							"value",
							"label",
							"disabled"
						]);
					}), 128))]),
					_: 1
				}, 8, [
					"class",
					"model-value",
					"placeholder",
					"multiple",
					"disabled",
					"name",
					"teleported",
					"size"
				])) : (openBlock(), createBlock(unref(N8nInput_default), {
					key: 2,
					ref_key: "inputRef",
					ref: inputRef,
					name: _ctx.name,
					type: _ctx.type,
					placeholder: _ctx.placeholder,
					"model-value": _ctx.modelValue,
					maxlength: _ctx.maxlength,
					autocomplete: _ctx.autocomplete,
					disabled: _ctx.disabled,
					size: _ctx.tagSize,
					autosize: _ctx.autosize,
					"onUpdate:modelValue": onUpdateModelValue,
					onBlur,
					onFocus
				}, null, 8, [
					"name",
					"type",
					"placeholder",
					"model-value",
					"maxlength",
					"autocomplete",
					"disabled",
					"size",
					"autosize"
				]))], 42, _hoisted_1$26), showErrors.value ? (openBlock(), createElementBlock("div", {
					key: 0,
					class: normalizeClass(_ctx.$style.errors)
				}, [createBaseVNode("span", { textContent: toDisplayString(validationError.value?.message) }, null, 8, _hoisted_2$14), _ctx.documentationUrl && _ctx.documentationText ? (openBlock(), createBlock(unref(N8nLink_default), {
					key: 0,
					to: _ctx.documentationUrl,
					"new-window": true,
					size: "small",
					theme: "danger"
				}, {
					default: withCtx(() => [createTextVNode(toDisplayString(_ctx.documentationText), 1)]),
					_: 1
				}, 8, ["to"])) : createCommentVNode("", true)], 2)) : _ctx.infoText ? (openBlock(), createElementBlock("div", {
					key: 1,
					class: normalizeClass(_ctx.$style.infoText)
				}, [createBaseVNode("span", {
					size: "small",
					textContent: toDisplayString(_ctx.infoText)
				}, null, 8, _hoisted_3$5)], 2)) : createCommentVNode("", true)]),
				_: 3
			}, 8, [
				"input-name",
				"label",
				"tooltip-text",
				"required",
				"size"
			]));
		};
	}
});
var FormInput_vue_vue_type_style_index_0_lang_module_default = {
	infoText: "_infoText_zsg8d_123",
	errors: "_errors_zsg8d_130 _infoText_zsg8d_123",
	errorInput: "_errorInput_zsg8d_135",
	multiSelectSmallTags: "_multiSelectSmallTags_zsg8d_139"
};
var N8nFormInput_default = /* @__PURE__ */ __plugin_vue_export_helper_default(FormInput_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": FormInput_vue_vue_type_style_index_0_lang_module_default }]]);
var ResizeObserver_default = /* @__PURE__ */ defineComponent({
	__name: "ResizeObserver",
	props: {
		enabled: {
			type: Boolean,
			default: true
		},
		breakpoints: { default: () => [] }
	},
	setup(__props) {
		const props = __props;
		const observer = ref(null);
		const breakpoint = ref("");
		const root = ref(null);
		const sortedBreakpoints = computed(() => [...props.breakpoints].sort((a$1, b$2) => a$1.width - b$2.width));
		const getBreakpointFromWidth = (width) => {
			return sortedBreakpoints.value.find((sortedBreakpoint) => width < sortedBreakpoint.width)?.bp ?? "default";
		};
		onMounted(() => {
			if (!props.enabled) return;
			if (!root.value) return;
			breakpoint.value = getBreakpointFromWidth(root.value.offsetWidth);
			observer.value = new ResizeObserver((entries) => {
				entries.forEach((entry) => {
					requestAnimationFrame(() => {
						breakpoint.value = getBreakpointFromWidth(entry.contentRect.width);
					});
				});
			});
			observer.value.observe(root.value);
		});
		onBeforeUnmount(() => {
			if (observer.value) observer.value.disconnect();
		});
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", {
				ref_key: "root",
				ref: root
			}, [renderSlot(_ctx.$slots, "default", { bp: breakpoint.value })], 512);
		};
	}
});
var FormInputs_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "FormInputs",
	props: {
		inputs: {},
		eventBus: { default: createFormEventBus },
		columnView: {
			type: Boolean,
			default: false
		},
		verticalSpacing: { default: "" },
		teleported: {
			type: Boolean,
			default: true
		}
	},
	emits: [
		"update",
		"update:modelValue",
		"submit",
		"ready"
	],
	setup(__props, { expose: __expose, emit: __emit }) {
		const props = __props;
		const emit = __emit;
		const showValidationWarnings = ref(false);
		const values = reactive({});
		const validity = ref({});
		const filteredInputs = computed(() => {
			return props.inputs.filter((input$4) => typeof input$4.shouldDisplay === "function" ? input$4.shouldDisplay(values) : true);
		});
		const isReadyToSubmit = computed(() => {
			return Object.values(validity.value).every((valid) => !!valid);
		});
		watch(isReadyToSubmit, (ready) => {
			emit("ready", ready);
		});
		function onUpdateModelValue(name$1, value) {
			values[name$1] = value;
			emit("update", {
				name: name$1,
				value
			});
			emit("update:modelValue", values);
		}
		function onValidate(name$1, isValid) {
			validity.value = {
				...validity.value,
				[name$1]: isValid
			};
		}
		function getValues() {
			return { ...values };
		}
		__expose({ getValues });
		function onSubmit() {
			showValidationWarnings.value = true;
			if (!isReadyToSubmit.value) return;
			emit("submit", filteredInputs.value.reduce((valuesToSubmit, input$4) => {
				if (values[input$4.name]) valuesToSubmit[input$4.name] = values[input$4.name];
				return valuesToSubmit;
			}, {}));
		}
		onMounted(() => {
			for (const input$4 of props.inputs) if ("initialValue" in input$4) values[input$4.name] = input$4.initialValue;
			if (props.eventBus) props.eventBus.on("submit", onSubmit);
		});
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(ResizeObserver_default), { breakpoints: [{
				bp: "md",
				width: 500
			}] }, {
				default: withCtx(({ bp }) => [createBaseVNode("div", { class: normalizeClass(bp === "md" || _ctx.columnView ? _ctx.$style.grid : _ctx.$style.gridMulti) }, [(openBlock(true), createElementBlock(Fragment, null, renderList(filteredInputs.value, (input$4, index) => {
					return openBlock(), createElementBlock("div", {
						key: input$4.name,
						class: normalizeClass({ [`mt-${_ctx.verticalSpacing}`]: _ctx.verticalSpacing && index > 0 })
					}, [input$4.properties.type === "info" ? (openBlock(), createBlock(unref(N8nText_default), {
						key: 0,
						color: "text-base",
						tag: "div",
						size: input$4.properties.labelSize,
						align: input$4.properties.labelAlignment,
						class: "form-text"
					}, {
						default: withCtx(() => [createTextVNode(toDisplayString(input$4.properties.label), 1)]),
						_: 2
					}, 1032, ["size", "align"])) : (openBlock(), createBlock(unref(N8nFormInput_default), mergeProps({
						key: 1,
						ref_for: true
					}, input$4.properties, {
						name: input$4.name,
						label: input$4.properties.label || "",
						"model-value": values[input$4.name],
						"data-test-id": input$4.name,
						"show-validation-warnings": showValidationWarnings.value,
						teleported: _ctx.teleported,
						"onUpdate:modelValue": (value) => onUpdateModelValue(input$4.name, value),
						onValidate: (value) => onValidate(input$4.name, value),
						onEnter: onSubmit
					}), null, 16, [
						"name",
						"label",
						"model-value",
						"data-test-id",
						"show-validation-warnings",
						"teleported",
						"onUpdate:modelValue",
						"onValidate"
					]))], 2);
				}), 128))], 2)]),
				_: 1
			});
		};
	}
});
var FormInputs_vue_vue_type_style_index_0_lang_module_default = {
	grid: "_grid_1yuvb_123",
	gridMulti: "_gridMulti_1yuvb_129 _grid_1yuvb_123"
};
var N8nFormInputs_default = /* @__PURE__ */ __plugin_vue_export_helper_default(FormInputs_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": FormInputs_vue_vue_type_style_index_0_lang_module_default }]]);
var FormBox_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	name: "N8nFormBox",
	__name: "FormBox",
	props: {
		title: { default: "" },
		inputs: { default: () => [] },
		buttonText: {},
		buttonLoading: {
			type: Boolean,
			default: false
		},
		secondaryButtonText: {},
		redirectText: { default: "" },
		redirectLink: { default: "" }
	},
	emits: [
		"submit",
		"update",
		"secondaryClick"
	],
	setup(__props, { emit: __emit }) {
		const formBus = createFormEventBus();
		const emit = __emit;
		const onUpdateModelValue = (e) => emit("update", e);
		const onSubmit = (e) => emit("submit", e);
		const onButtonClick = () => formBus.emit("submit");
		const onSecondaryButtonClick = (event) => emit("secondaryClick", event);
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", { class: normalizeClass(["n8n-form-box", _ctx.$style.container]) }, [
				_ctx.title ? (openBlock(), createElementBlock("div", {
					key: 0,
					class: normalizeClass(_ctx.$style.heading)
				}, [createVNode(unref(N8nHeading_default), { size: "xlarge" }, {
					default: withCtx(() => [createTextVNode(toDisplayString(_ctx.title), 1)]),
					_: 1
				})], 2)) : createCommentVNode("", true),
				createBaseVNode("div", { class: normalizeClass(_ctx.$style.inputsContainer) }, [createVNode(unref(N8nFormInputs_default), {
					inputs: _ctx.inputs,
					"event-bus": unref(formBus),
					"column-view": true,
					onUpdate: onUpdateModelValue,
					onSubmit
				}, null, 8, ["inputs", "event-bus"])], 2),
				_ctx.secondaryButtonText || _ctx.buttonText ? (openBlock(), createElementBlock("div", {
					key: 1,
					class: normalizeClass(_ctx.$style.buttonsContainer)
				}, [_ctx.secondaryButtonText ? (openBlock(), createElementBlock("span", {
					key: 0,
					class: normalizeClass(_ctx.$style.secondaryButtonContainer)
				}, [createVNode(unref(N8nLink_default), {
					size: "medium",
					theme: "text",
					onClick: onSecondaryButtonClick
				}, {
					default: withCtx(() => [createTextVNode(toDisplayString(_ctx.secondaryButtonText), 1)]),
					_: 1
				})], 2)) : createCommentVNode("", true), _ctx.buttonText ? (openBlock(), createBlock(unref(N8nButton_default), {
					key: 1,
					label: _ctx.buttonText,
					loading: _ctx.buttonLoading,
					"data-test-id": "form-submit-button",
					size: "large",
					onClick: onButtonClick
				}, null, 8, ["label", "loading"])) : createCommentVNode("", true)], 2)) : createCommentVNode("", true),
				createBaseVNode("div", { class: normalizeClass(_ctx.$style.actionContainer) }, [_ctx.redirectText && _ctx.redirectLink ? (openBlock(), createBlock(unref(N8nLink_default), {
					key: 0,
					to: _ctx.redirectLink
				}, {
					default: withCtx(() => [createTextVNode(toDisplayString(_ctx.redirectText), 1)]),
					_: 1
				}, 8, ["to"])) : createCommentVNode("", true)], 2),
				renderSlot(_ctx.$slots, "default")
			], 2);
		};
	}
});
var FormBox_vue_vue_type_style_index_0_lang_module_default = {
	heading: "_heading_1yh30_123",
	container: "_container_1yh30_129",
	inputsContainer: "_inputsContainer_1yh30_137",
	actionContainer: "_actionContainer_1yh30_141",
	buttonsContainer: "_buttonsContainer_1yh30_146 _actionContainer_1yh30_141",
	secondaryButtonContainer: "_secondaryButtonContainer_1yh30_151",
	withLabel: "_withLabel_1yh30_157"
};
var N8nFormBox_default = /* @__PURE__ */ __plugin_vue_export_helper_default(FormBox_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": FormBox_vue_vue_type_style_index_0_lang_module_default }]]);
var InlineAskAssistantButton_default = InlineAskAssistantButton_default$1;
var _hoisted_1$25 = ["onClick"];
var InfoAccordion_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	name: "N8nInfoAccordion",
	__name: "InfoAccordion",
	props: {
		title: {},
		description: {},
		items: { default: () => [] },
		initiallyExpanded: {
			type: Boolean,
			default: false
		},
		headerIcon: {},
		eventBus: { default: () => createEventBus() }
	},
	emits: ["click:body", "tooltipClick"],
	setup(__props, { emit: __emit }) {
		const props = __props;
		const emit = __emit;
		const expanded$2 = ref(false);
		onMounted(() => {
			props.eventBus.on("expand", () => {
				expanded$2.value = true;
			});
			expanded$2.value = props.initiallyExpanded;
		});
		const toggle = () => {
			expanded$2.value = !expanded$2.value;
		};
		const onClick = (e) => emit("click:body", e);
		const onTooltipClick = (item$4, event) => emit("tooltipClick", item$4, event);
		return (_ctx, _cache) => {
			const _directive_n8n_html = resolveDirective("n8n-html");
			return openBlock(), createElementBlock("div", { class: normalizeClass(["accordion", _ctx.$style.container]) }, [createBaseVNode("div", {
				class: normalizeClass({
					[_ctx.$style.header]: true,
					[_ctx.$style.expanded]: expanded$2.value
				}),
				onClick: toggle
			}, [
				_ctx.headerIcon ? (openBlock(), createBlock(unref(N8nIcon_default), {
					key: 0,
					icon: _ctx.headerIcon.icon,
					color: _ctx.headerIcon.color,
					size: "small"
				}, null, 8, ["icon", "color"])) : createCommentVNode("", true),
				createVNode(unref(N8nText_default), {
					class: normalizeClass(_ctx.$style.headerText),
					color: "text-base",
					size: "small",
					align: "left",
					bold: ""
				}, {
					default: withCtx(() => [createTextVNode(toDisplayString(_ctx.title), 1)]),
					_: 1
				}, 8, ["class"]),
				createVNode(unref(N8nIcon_default), {
					icon: expanded$2.value ? "chevron-up" : "chevron-down",
					bold: ""
				}, null, 8, ["icon"])
			], 2), expanded$2.value ? (openBlock(), createElementBlock("div", {
				key: 0,
				class: normalizeClass({
					[_ctx.$style.description]: true,
					[_ctx.$style.collapsed]: !expanded$2.value
				}),
				onClick
			}, [
				_ctx.items.length > 0 ? (openBlock(), createElementBlock("div", {
					key: 0,
					class: normalizeClass(_ctx.$style.accordionItems)
				}, [(openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.items, (item$4) => {
					return openBlock(), createElementBlock("div", {
						key: item$4.id,
						class: normalizeClass(_ctx.$style.accordionItem)
					}, [createVNode(unref(N8nTooltip_default), { disabled: !item$4.tooltip }, {
						content: withCtx(() => [withDirectives(createBaseVNode("div", { onClick: ($event) => onTooltipClick(item$4.id, $event) }, null, 8, _hoisted_1$25), [[_directive_n8n_html, item$4.tooltip]])]),
						default: withCtx(() => [createVNode(unref(N8nIcon_default), {
							icon: item$4.icon,
							color: item$4.iconColor,
							size: "small",
							class: "mr-2xs"
						}, null, 8, ["icon", "color"])]),
						_: 2
					}, 1032, ["disabled"]), createVNode(unref(N8nText_default), {
						size: "small",
						color: "text-base"
					}, {
						default: withCtx(() => [createTextVNode(toDisplayString(item$4.label), 1)]),
						_: 2
					}, 1024)], 2);
				}), 128))], 2)) : createCommentVNode("", true),
				createVNode(unref(N8nText_default), {
					color: "text-base",
					size: "small",
					align: "left"
				}, {
					default: withCtx(() => [withDirectives(createBaseVNode("span", null, null, 512), [[_directive_n8n_html, _ctx.description]])]),
					_: 1
				}),
				renderSlot(_ctx.$slots, "customContent")
			], 2)) : createCommentVNode("", true)], 2);
		};
	}
});
var InfoAccordion_vue_vue_type_style_index_0_lang_module_default = {
	container: "_container_ek7oz_123",
	header: "_header_ek7oz_127",
	expanded: "_expanded_ek7oz_136",
	accordionItems: "_accordionItems_ek7oz_140",
	accordionItem: "_accordionItem_ek7oz_140",
	description: "_description_ek7oz_152"
};
var N8nInfoAccordion_default = /* @__PURE__ */ __plugin_vue_export_helper_default(InfoAccordion_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": InfoAccordion_vue_vue_type_style_index_0_lang_module_default }]]);
var InfoTip_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	name: "N8nInfoTip",
	__name: "InfoTip",
	props: {
		theme: { default: "info" },
		type: { default: "note" },
		bold: {
			type: Boolean,
			default: true
		},
		tooltipPlacement: { default: "top" },
		enterable: {
			type: Boolean,
			default: true
		},
		size: { default: void 0 }
	},
	setup(__props) {
		const ICON_MAP = {
			info: "info",
			"info-light": "info",
			warning: "triangle-alert",
			"warning-light": "triangle",
			danger: "triangle-alert",
			success: "circle-check"
		};
		const COLOR_MAP = {
			info: "text-base",
			"info-light": "text-base",
			warning: "warning",
			"warning-light": "warning",
			danger: "danger",
			success: "success"
		};
		const props = __props;
		const iconData = computed(() => {
			return {
				icon: ICON_MAP[props.theme],
				color: COLOR_MAP[props.theme]
			};
		});
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", { class: normalizeClass({
				"n8n-info-tip": true,
				[_ctx.$style.infoTip]: true,
				[_ctx.$style[_ctx.theme]]: true,
				[_ctx.$style[_ctx.type]]: true,
				[_ctx.$style.bold]: _ctx.bold
			}) }, [_ctx.type === "tooltip" ? (openBlock(), createBlock(unref(N8nTooltip_default), {
				key: 0,
				placement: _ctx.tooltipPlacement,
				"popper-class": _ctx.$style.tooltipPopper,
				disabled: _ctx.type !== "tooltip",
				enterable: _ctx.enterable
			}, {
				content: withCtx(() => [createBaseVNode("span", null, [renderSlot(_ctx.$slots, "default")])]),
				default: withCtx(() => [createBaseVNode("span", { class: normalizeClass(_ctx.$style.iconText) }, [createVNode(unref(N8nIcon_default), {
					icon: iconData.value.icon,
					color: iconData.value.color,
					size: _ctx.size
				}, null, 8, [
					"icon",
					"color",
					"size"
				])], 2)]),
				_: 3
			}, 8, [
				"placement",
				"popper-class",
				"disabled",
				"enterable"
			])) : (openBlock(), createElementBlock("span", {
				key: 1,
				class: normalizeClass(_ctx.$style.iconText)
			}, [createVNode(unref(N8nIcon_default), {
				icon: iconData.value.icon,
				color: iconData.value.color,
				size: _ctx.size
			}, null, 8, [
				"icon",
				"color",
				"size"
			]), createBaseVNode("span", null, [renderSlot(_ctx.$slots, "default")])], 2))], 2);
		};
	}
});
var InfoTip_vue_vue_type_style_index_0_lang_module_default = {
	infoTip: "_infoTip_192r7_123",
	base: "_base_192r7_127",
	bold: "_bold_192r7_138",
	note: "_note_192r7_142 _base_192r7_127",
	tooltipPopper: "_tooltipPopper_192r7_149 _base_192r7_127",
	iconText: "_iconText_192r7_154"
};
var N8nInfoTip_default = /* @__PURE__ */ __plugin_vue_export_helper_default(InfoTip_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": InfoTip_vue_vue_type_style_index_0_lang_module_default }]]);
var N8nInputNumber_default = /* @__PURE__ */ defineComponent({
	__name: "InputNumber",
	props: {
		size: { default: void 0 },
		min: { default: -Infinity },
		max: { default: Infinity },
		step: { default: 1 },
		precision: { default: void 0 }
	},
	setup(__props) {
		const props = __props;
		const sizeMap = {
			mini: "small",
			small: "small",
			medium: "default",
			large: "large",
			xlarge: "large"
		};
		const resolvedSize = computed(() => props.size ? sizeMap[props.size] : void 0);
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(ElInputNumber), mergeProps({
				size: resolvedSize.value,
				min: _ctx.min,
				max: _ctx.max,
				step: _ctx.step,
				precision: _ctx.precision
			}, _ctx.$attrs), null, 16, [
				"size",
				"min",
				"max",
				"step",
				"precision"
			]);
		};
	}
});
var _hoisted_1$24 = {
	xmlns: "http://www.w3.org/2000/svg",
	width: "32",
	height: "30"
};
function render$1(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$24, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		fill: "#EA4B71",
		"fill-rule": "evenodd",
		d: "M27.2 16.4a3.2 3.2 0 0 1-3.1-2.4h-3.667a1.6 1.6 0 0 0-1.578 1.337l-.132.79A3.2 3.2 0 0 1 17.683 18a3.2 3.2 0 0 1 1.04 1.874l.132.789A1.6 1.6 0 0 0 20.433 22h.468a3.201 3.201 0 0 1 6.299.8 3.2 3.2 0 0 1-6.3.8h-.467a3.2 3.2 0 0 1-3.156-2.674l-.132-.789a1.6 1.6 0 0 0-1.578-1.337h-1.268a3.201 3.201 0 0 1-6.198 0H6.299A3.201 3.201 0 0 1 0 18a3.2 3.2 0 0 1 6.3-.8h1.8a3.201 3.201 0 0 1 6.2 0h1.267a1.6 1.6 0 0 0 1.578-1.337l.132-.79a3.2 3.2 0 0 1 3.156-2.673h3.668a3.201 3.201 0 0 1 6.299.8 3.2 3.2 0 0 1-3.2 3.2m0-1.6a1.6 1.6 0 1 0 0-3.2 1.6 1.6 0 0 0 0 3.2m-24 4.8a1.6 1.6 0 1 0 0-3.2 1.6 1.6 0 0 0 0 3.2m9.6-1.6a1.6 1.6 0 1 1-3.2 0 1.6 1.6 0 0 1 3.2 0m12.8 4.8a1.6 1.6 0 1 1-3.2 0 1.6 1.6 0 0 1 3.2 0",
		"clip-rule": "evenodd"
	}, null, -1)]));
}
var logo_icon_default = { render: render$1 };
var _hoisted_1$23 = {
	width: "26",
	height: "30"
};
function render(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$23, _cache[0] || (_cache[0] = [createBaseVNode("g", { fill: "#101330" }, [createBaseVNode("path", {
		"fill-rule": "evenodd",
		d: "M15.002 16.918v-.076c.558-.28 1.116-.762 1.116-1.716 0-1.372-1.13-2.198-2.69-2.198-1.598 0-2.74.877-2.74 2.224 0 .915.533 1.41 1.116 1.69v.076a2.16 2.16 0 0 0-1.42 2.059c0 1.385 1.141 2.351 3.032 2.351 1.89 0 2.994-.966 2.994-2.351a2.16 2.16 0 0 0-1.408-2.059m-1.587-2.82c.635 0 1.104.406 1.104 1.092s-.482 1.093-1.103 1.093c-.622 0-1.142-.407-1.142-1.093 0-.699.495-1.093 1.142-1.093m0 6.01c-.735 0-1.332-.47-1.332-1.27 0-.725.495-1.272 1.32-1.272.812 0 1.307.534 1.307 1.297 0 .775-.571 1.245-1.294 1.245",
		"clip-rule": "evenodd"
	}), createBaseVNode("path", { d: "M18.367 21.2h1.624v-3.442c0-1.131.685-1.627 1.46-1.627.76 0 1.357.509 1.357 1.55v3.52h1.624V17.35c0-1.664-.964-2.63-2.474-2.63-.952 0-1.485.381-1.865.877h-.102l-.14-.75h-1.484zm-14.376 0H2.367v-6.352h1.485l.14.75h.1c.381-.496.914-.877 1.866-.877 1.51 0 2.474.966 2.474 2.63v3.85H6.808V17.68c0-1.041-.596-1.55-1.358-1.55-.774 0-1.459.496-1.459 1.627z" })], -1)]));
}
var logo_text_default = { render };
var Logo_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "Logo",
	props: {
		size: {},
		collapsed: { type: Boolean },
		releaseChannel: {}
	},
	setup(__props) {
		const props = __props;
		const { size: size$2, releaseChannel } = props;
		const showLogoText = computed(() => {
			if (size$2 === "large") return true;
			return !props.collapsed;
		});
		const $style = useCssModule();
		const containerClasses = computed(() => {
			if (size$2 === "large") return [$style.logoContainer, $style.large];
			return [
				$style.logoContainer,
				$style.sidebar,
				props.collapsed ? $style.sidebarCollapsed : $style.sidebarExpanded
			];
		});
		const svg = useTemplateRef("logo");
		onMounted(() => {
			if (!releaseChannel || releaseChannel === "stable" || !("createObjectURL" in URL)) return;
			const logoEl = svg.value.$el;
			const logoColor = releaseChannel === "dev" ? "#838383" : "#E9984B";
			logoEl.querySelector("path")?.setAttribute("fill", logoColor);
			const blob = new Blob([logoEl.outerHTML], { type: "image/svg+xml" });
			useFavicon(URL.createObjectURL(blob));
		});
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", {
				class: normalizeClass(containerClasses.value),
				"data-test-id": "n8n-logo"
			}, [
				createVNode(unref(logo_icon_default), {
					ref: "logo",
					class: normalizeClass(unref($style).logo)
				}, null, 8, ["class"]),
				showLogoText.value ? (openBlock(), createBlock(unref(logo_text_default), {
					key: 0,
					class: normalizeClass(unref($style).logoText)
				}, null, 8, ["class"])) : createCommentVNode("", true),
				renderSlot(_ctx.$slots, "default")
			], 2);
		};
	}
});
var Logo_vue_vue_type_style_index_0_lang_module_default = {
	logoContainer: "_logoContainer_1pq21_123",
	logoText: "_logoText_1pq21_129",
	large: "_large_1pq21_136",
	logo: "_logo_1pq21_123",
	sidebarExpanded: "_sidebarExpanded_1pq21_149",
	sidebarCollapsed: "_sidebarCollapsed_1pq21_153"
};
var N8nLogo_default = /* @__PURE__ */ __plugin_vue_export_helper_default(Logo_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": Logo_vue_vue_type_style_index_0_lang_module_default }]]);
var full_exports = /* @__PURE__ */ __export({
	a: () => a,
	ab: () => ab,
	abacus: () => abacus,
	abc: () => abc,
	abcd: () => abcd,
	accept: () => accept,
	accordion: () => accordion,
	adhesive_bandage: () => adhesive_bandage,
	adult: () => adult,
	aerial_tramway: () => aerial_tramway,
	afghanistan: () => afghanistan,
	airplane: () => airplane,
	aland_islands: () => aland_islands,
	alarm_clock: () => "",
	albania: () => albania,
	alembic: () => alembic,
	algeria: () => algeria,
	alien: () => alien,
	ambulance: () => ambulance,
	american_samoa: () => american_samoa,
	amphora: () => amphora,
	anatomical_heart: () => anatomical_heart,
	anchor: () => "",
	andorra: () => andorra,
	angel: () => angel,
	anger: () => anger,
	angola: () => angola,
	angry: () => angry,
	anguilla: () => anguilla,
	anguished: () => anguished,
	ant: () => ant,
	antarctica: () => antarctica,
	antigua_barbuda: () => antigua_barbuda,
	apple: () => apple,
	aquarius: () => "",
	argentina: () => argentina,
	aries: () => "",
	armenia: () => armenia,
	arrow_backward: () => arrow_backward,
	arrow_double_down: () => "",
	arrow_double_up: () => "",
	arrow_down: () => arrow_down,
	arrow_down_small: () => arrow_down_small,
	arrow_forward: () => arrow_forward,
	arrow_heading_down: () => arrow_heading_down,
	arrow_heading_up: () => arrow_heading_up,
	arrow_left: () => arrow_left,
	arrow_lower_left: () => arrow_lower_left,
	arrow_lower_right: () => arrow_lower_right,
	arrow_right: () => arrow_right,
	arrow_right_hook: () => arrow_right_hook,
	arrow_up: () => arrow_up,
	arrow_up_down: () => arrow_up_down,
	arrow_up_small: () => arrow_up_small,
	arrow_upper_left: () => arrow_upper_left,
	arrow_upper_right: () => arrow_upper_right,
	arrows_clockwise: () => arrows_clockwise,
	arrows_counterclockwise: () => arrows_counterclockwise,
	art: () => art,
	articulated_lorry: () => articulated_lorry,
	artificial_satellite: () => artificial_satellite,
	artist: () => artist,
	aruba: () => aruba,
	ascension_island: () => ascension_island,
	asterisk: () => asterisk,
	astonished: () => astonished,
	astronaut: () => astronaut,
	athletic_shoe: () => athletic_shoe,
	atm: () => atm,
	atom_symbol: () => atom_symbol,
	australia: () => australia,
	austria: () => austria,
	auto_rickshaw: () => auto_rickshaw,
	avocado: () => avocado,
	axe: () => axe,
	azerbaijan: () => azerbaijan,
	b: () => b,
	baby: () => baby,
	baby_bottle: () => baby_bottle,
	baby_chick: () => baby_chick,
	baby_symbol: () => baby_symbol,
	back: () => back$1,
	bacon: () => bacon,
	badger: () => badger,
	badminton: () => badminton,
	bagel: () => bagel,
	baggage_claim: () => baggage_claim,
	baguette_bread: () => baguette_bread,
	bahamas: () => bahamas,
	bahrain: () => bahrain,
	balance_scale: () => balance_scale,
	bald_man: () => bald_man,
	bald_woman: () => bald_woman,
	ballet_shoes: () => ballet_shoes,
	balloon: () => balloon,
	ballot_box: () => ballot_box,
	ballot_box_with_check: () => ballot_box_with_check,
	bamboo: () => bamboo,
	banana: () => banana,
	bangbang: () => bangbang,
	bangladesh: () => bangladesh,
	banjo: () => banjo,
	bank: () => bank,
	bar_chart: () => bar_chart,
	barbados: () => barbados,
	barber: () => barber,
	baseball: () => "",
	basket: () => basket,
	basketball: () => basketball,
	basketball_man: () => basketball_man,
	basketball_woman: () => basketball_woman,
	bat: () => bat,
	bath: () => bath,
	bathtub: () => bathtub,
	battery: () => battery,
	beach_umbrella: () => beach_umbrella,
	bear: () => bear,
	bearded_person: () => bearded_person,
	beaver: () => beaver,
	bed: () => bed,
	bee: () => bee,
	beer: () => beer,
	beers: () => beers,
	beetle: () => beetle,
	beginner: () => beginner,
	belarus: () => belarus,
	belgium: () => belgium,
	belize: () => belize,
	bell: () => bell,
	bell_pepper: () => bell_pepper,
	bellhop_bell: () => bellhop_bell,
	benin: () => benin,
	bento: () => bento,
	bermuda: () => bermuda,
	beverage_box: () => beverage_box,
	bhutan: () => bhutan,
	bicyclist: () => bicyclist,
	bike: () => bike,
	biking_man: () => biking_man,
	biking_woman: () => biking_woman,
	bikini: () => bikini,
	billed_cap: () => billed_cap,
	biohazard: () => biohazard,
	bird: () => bird,
	birthday: () => birthday,
	bison: () => bison,
	black_cat: () => black_cat,
	black_circle: () => "",
	black_flag: () => black_flag,
	black_heart: () => black_heart,
	black_joker: () => black_joker,
	black_large_square: () => "",
	black_medium_small_square: () => "",
	black_medium_square: () => black_medium_square,
	black_nib: () => black_nib,
	black_small_square: () => black_small_square,
	black_square_button: () => black_square_button,
	blond_haired_man: () => blond_haired_man,
	blond_haired_person: () => blond_haired_person,
	blond_haired_woman: () => blond_haired_woman,
	blonde_woman: () => blonde_woman,
	blossom: () => blossom,
	blowfish: () => blowfish,
	blue_book: () => blue_book,
	blue_car: () => blue_car,
	blue_heart: () => blue_heart,
	blue_square: () => blue_square,
	blueberries: () => blueberries,
	blush: () => blush,
	boar: () => boar,
	boat: () => "",
	bolivia: () => bolivia,
	bomb: () => bomb,
	bone: () => bone,
	book: () => book,
	bookmark: () => bookmark,
	bookmark_tabs: () => bookmark_tabs,
	books: () => books,
	boom: () => boom,
	boomerang: () => boomerang,
	boot: () => boot,
	bosnia_herzegovina: () => bosnia_herzegovina,
	botswana: () => botswana,
	bouncing_ball_man: () => bouncing_ball_man,
	bouncing_ball_person: () => bouncing_ball_person,
	bouncing_ball_woman: () => bouncing_ball_woman,
	bouquet: () => bouquet,
	bouvet_island: () => bouvet_island,
	bow: () => bow,
	bow_and_arrow: () => bow_and_arrow,
	bowing_man: () => bowing_man,
	bowing_woman: () => bowing_woman,
	bowl_with_spoon: () => bowl_with_spoon,
	bowling: () => bowling,
	boxing_glove: () => boxing_glove,
	boy: () => boy,
	brain: () => brain,
	brazil: () => brazil,
	bread: () => bread,
	breast_feeding: () => breast_feeding,
	bricks: () => bricks,
	bride_with_veil: () => bride_with_veil,
	bridge_at_night: () => bridge_at_night,
	briefcase: () => briefcase,
	british_indian_ocean_territory: () => british_indian_ocean_territory,
	british_virgin_islands: () => british_virgin_islands,
	broccoli: () => broccoli,
	broken_heart: () => broken_heart,
	broom: () => broom,
	brown_circle: () => brown_circle,
	brown_heart: () => brown_heart,
	brown_square: () => brown_square,
	brunei: () => brunei,
	bubble_tea: () => bubble_tea,
	bucket: () => bucket,
	bug: () => bug,
	building_construction: () => building_construction,
	bulb: () => bulb,
	bulgaria: () => bulgaria,
	bullettrain_front: () => bullettrain_front,
	bullettrain_side: () => bullettrain_side,
	burkina_faso: () => burkina_faso,
	burrito: () => burrito,
	burundi: () => burundi,
	bus: () => bus,
	business_suit_levitating: () => business_suit_levitating,
	busstop: () => busstop,
	bust_in_silhouette: () => bust_in_silhouette,
	busts_in_silhouette: () => busts_in_silhouette,
	butter: () => butter,
	butterfly: () => butterfly,
	cactus: () => cactus,
	cake: () => cake,
	calendar: () => calendar,
	call_me_hand: () => call_me_hand,
	calling: () => calling,
	cambodia: () => cambodia,
	camel: () => camel,
	camera: () => camera,
	camera_flash: () => camera_flash,
	cameroon: () => cameroon,
	camping: () => camping,
	canada: () => canada,
	canary_islands: () => canary_islands,
	cancer: () => "",
	candle: () => candle,
	candy: () => candy,
	canned_food: () => canned_food,
	canoe: () => canoe,
	cape_verde: () => cape_verde,
	capital_abcd: () => capital_abcd,
	capricorn: () => "",
	car: () => car,
	card_file_box: () => card_file_box,
	card_index: () => card_index,
	card_index_dividers: () => card_index_dividers,
	caribbean_netherlands: () => caribbean_netherlands,
	carousel_horse: () => carousel_horse,
	carpentry_saw: () => carpentry_saw,
	carrot: () => carrot,
	cartwheeling: () => cartwheeling,
	cat: () => cat,
	cat2: () => cat2,
	cayman_islands: () => cayman_islands,
	cd: () => cd,
	central_african_republic: () => central_african_republic,
	ceuta_melilla: () => ceuta_melilla,
	chad: () => chad,
	chains: () => chains,
	chair: () => chair,
	champagne: () => champagne,
	chart: () => chart,
	chart_with_downwards_trend: () => chart_with_downwards_trend,
	chart_with_upwards_trend: () => chart_with_upwards_trend,
	checkered_flag: () => checkered_flag,
	cheese: () => cheese,
	cherries: () => cherries,
	cherry_blossom: () => cherry_blossom,
	chess_pawn: () => chess_pawn,
	chestnut: () => chestnut,
	chicken: () => chicken,
	child: () => child,
	children_crossing: () => children_crossing,
	chile: () => chile,
	chipmunk: () => chipmunk,
	chocolate_bar: () => chocolate_bar,
	chopsticks: () => chopsticks,
	christmas_island: () => christmas_island,
	christmas_tree: () => christmas_tree,
	church: () => "",
	cinema: () => cinema,
	circus_tent: () => circus_tent,
	city_sunrise: () => city_sunrise,
	city_sunset: () => city_sunset,
	cityscape: () => cityscape,
	cl: () => cl,
	clamp: () => clamp,
	clap: () => clap,
	clapper: () => clapper,
	classical_building: () => classical_building,
	climbing: () => climbing,
	climbing_man: () => climbing_man,
	climbing_woman: () => climbing_woman,
	clinking_glasses: () => clinking_glasses,
	clipboard: () => clipboard,
	clipperton_island: () => clipperton_island,
	clock1: () => clock1,
	clock10: () => clock10,
	clock1030: () => clock1030,
	clock11: () => clock11,
	clock1130: () => clock1130,
	clock12: () => clock12,
	clock1230: () => clock1230,
	clock130: () => clock130,
	clock2: () => clock2,
	clock230: () => clock230,
	clock3: () => clock3,
	clock330: () => clock330,
	clock4: () => clock4,
	clock430: () => clock430,
	clock5: () => clock5,
	clock530: () => clock530,
	clock6: () => clock6,
	clock630: () => clock630,
	clock7: () => clock7,
	clock730: () => clock730,
	clock8: () => clock8,
	clock830: () => clock830,
	clock9: () => clock9,
	clock930: () => clock930,
	closed_book: () => closed_book,
	closed_lock_with_key: () => closed_lock_with_key,
	closed_umbrella: () => closed_umbrella,
	cloud: () => cloud,
	cloud_with_lightning: () => cloud_with_lightning,
	cloud_with_lightning_and_rain: () => cloud_with_lightning_and_rain,
	cloud_with_rain: () => cloud_with_rain,
	cloud_with_snow: () => cloud_with_snow,
	clown_face: () => clown_face,
	clubs: () => clubs,
	cn: () => cn,
	coat: () => coat,
	cockroach: () => cockroach,
	cocktail: () => cocktail,
	coconut: () => coconut,
	cocos_islands: () => cocos_islands,
	coffee: () => "",
	coffin: () => coffin,
	coin: () => coin,
	cold_face: () => cold_face,
	cold_sweat: () => cold_sweat,
	collision: () => collision,
	colombia: () => colombia,
	comet: () => comet,
	comoros: () => comoros,
	compass: () => compass,
	computer: () => computer,
	computer_mouse: () => computer_mouse,
	confetti_ball: () => confetti_ball,
	confounded: () => confounded,
	confused: () => confused,
	congo_brazzaville: () => congo_brazzaville,
	congo_kinshasa: () => congo_kinshasa,
	congratulations: () => congratulations,
	construction: () => construction,
	construction_worker: () => construction_worker,
	construction_worker_man: () => construction_worker_man,
	construction_worker_woman: () => construction_worker_woman,
	control_knobs: () => control_knobs,
	convenience_store: () => convenience_store,
	cook: () => cook,
	cook_islands: () => cook_islands,
	cookie: () => cookie,
	cool: () => cool,
	cop: () => cop,
	copyright: () => copyright,
	corn: () => corn,
	costa_rica: () => costa_rica,
	cote_divoire: () => cote_divoire,
	couch_and_lamp: () => couch_and_lamp,
	couple: () => couple,
	couple_with_heart: () => couple_with_heart,
	couple_with_heart_man_man: () => couple_with_heart_man_man,
	couple_with_heart_woman_man: () => couple_with_heart_woman_man,
	couple_with_heart_woman_woman: () => couple_with_heart_woman_woman,
	couplekiss: () => couplekiss,
	couplekiss_man_man: () => couplekiss_man_man,
	couplekiss_man_woman: () => couplekiss_man_woman,
	couplekiss_woman_woman: () => couplekiss_woman_woman,
	cow: () => cow,
	cow2: () => cow2,
	cowboy_hat_face: () => cowboy_hat_face,
	crab: () => crab,
	crayon: () => crayon,
	credit_card: () => credit_card,
	crescent_moon: () => crescent_moon,
	cricket: () => cricket,
	cricket_game: () => cricket_game,
	croatia: () => croatia,
	crocodile: () => crocodile,
	croissant: () => croissant,
	crossed_fingers: () => crossed_fingers,
	crossed_flags: () => crossed_flags,
	crossed_swords: () => crossed_swords,
	crown: () => crown,
	cry: () => cry,
	crying_cat_face: () => crying_cat_face,
	crystal_ball: () => crystal_ball,
	cuba: () => cuba,
	cucumber: () => cucumber,
	cup_with_straw: () => cup_with_straw,
	cupcake: () => cupcake,
	cupid: () => cupid,
	curacao: () => curacao,
	curling_stone: () => curling_stone,
	curly_haired_man: () => curly_haired_man,
	curly_haired_woman: () => curly_haired_woman,
	curly_loop: () => "",
	currency_exchange: () => currency_exchange,
	curry: () => curry,
	cursing_face: () => cursing_face,
	custard: () => custard,
	customs: () => customs,
	cut_of_meat: () => cut_of_meat,
	cyclone: () => cyclone,
	cyprus: () => cyprus,
	czech_republic: () => czech_republic,
	dagger: () => dagger,
	dancer: () => dancer,
	dancers: () => dancers,
	dancing_men: () => dancing_men,
	dancing_women: () => dancing_women,
	dango: () => dango,
	dark_sunglasses: () => dark_sunglasses,
	dart: () => dart,
	dash: () => dash,
	date: () => date,
	de: () => de,
	deaf_man: () => deaf_man,
	deaf_person: () => deaf_person,
	deaf_woman: () => deaf_woman,
	deciduous_tree: () => deciduous_tree,
	deer: () => deer,
	default: () => full_default,
	denmark: () => denmark,
	department_store: () => department_store,
	derelict_house: () => derelict_house,
	desert: () => desert,
	desert_island: () => desert_island,
	desktop_computer: () => desktop_computer,
	detective: () => detective,
	diamond_shape_with_a_dot_inside: () => diamond_shape_with_a_dot_inside,
	diamonds: () => diamonds,
	diego_garcia: () => diego_garcia,
	disappointed: () => disappointed,
	disappointed_relieved: () => disappointed_relieved,
	disguised_face: () => disguised_face,
	diving_mask: () => diving_mask,
	diya_lamp: () => diya_lamp,
	dizzy: () => dizzy,
	dizzy_face: () => dizzy_face,
	djibouti: () => djibouti,
	dna: () => dna,
	do_not_litter: () => do_not_litter,
	dodo: () => dodo,
	dog: () => dog,
	dog2: () => dog2,
	dollar: () => dollar,
	dolls: () => dolls,
	dolphin: () => dolphin,
	dominica: () => dominica,
	dominican_republic: () => dominican_republic,
	door: () => door,
	doughnut: () => doughnut,
	dove: () => dove,
	dragon: () => dragon,
	dragon_face: () => dragon_face,
	dress: () => dress,
	dromedary_camel: () => dromedary_camel,
	drooling_face: () => drooling_face,
	drop_of_blood: () => drop_of_blood,
	droplet: () => droplet,
	drum: () => drum,
	duck: () => duck,
	dumpling: () => dumpling,
	dvd: () => dvd,
	eagle: () => eagle,
	ear: () => ear,
	ear_of_rice: () => ear_of_rice,
	ear_with_hearing_aid: () => ear_with_hearing_aid,
	earth_africa: () => earth_africa,
	earth_americas: () => earth_americas,
	earth_asia: () => earth_asia,
	ecuador: () => ecuador,
	egg: () => egg,
	eggplant: () => eggplant,
	egypt: () => egypt,
	eight: () => eight,
	eight_pointed_black_star: () => eight_pointed_black_star,
	eight_spoked_asterisk: () => eight_spoked_asterisk,
	eject_button: () => eject_button,
	el_salvador: () => el_salvador,
	electric_plug: () => electric_plug,
	elephant: () => elephant,
	elevator: () => elevator,
	elf: () => elf,
	elf_man: () => elf_man,
	elf_woman: () => elf_woman,
	email: () => email,
	end: () => end,
	england: () => england,
	envelope: () => envelope,
	envelope_with_arrow: () => envelope_with_arrow,
	equatorial_guinea: () => equatorial_guinea,
	eritrea: () => eritrea,
	es: () => es,
	estonia: () => estonia,
	ethiopia: () => ethiopia,
	eu: () => eu,
	euro: () => euro,
	european_castle: () => european_castle,
	european_post_office: () => european_post_office,
	european_union: () => european_union,
	evergreen_tree: () => evergreen_tree,
	exclamation: () => "",
	exploding_head: () => exploding_head,
	expressionless: () => expressionless,
	eye: () => eye,
	eye_speech_bubble: () => eye_speech_bubble,
	eyeglasses: () => eyeglasses,
	eyes: () => eyes,
	face_with_head_bandage: () => face_with_head_bandage,
	face_with_thermometer: () => face_with_thermometer,
	facepalm: () => facepalm,
	facepunch: () => facepunch,
	factory: () => factory,
	factory_worker: () => factory_worker,
	fairy: () => fairy,
	fairy_man: () => fairy_man,
	fairy_woman: () => fairy_woman,
	falafel: () => falafel,
	falkland_islands: () => falkland_islands,
	fallen_leaf: () => fallen_leaf,
	family: () => family,
	family_man_boy: () => family_man_boy,
	family_man_boy_boy: () => family_man_boy_boy,
	family_man_girl: () => family_man_girl,
	family_man_girl_boy: () => family_man_girl_boy,
	family_man_girl_girl: () => family_man_girl_girl,
	family_man_man_boy: () => family_man_man_boy,
	family_man_man_boy_boy: () => family_man_man_boy_boy,
	family_man_man_girl: () => family_man_man_girl,
	family_man_man_girl_boy: () => family_man_man_girl_boy,
	family_man_man_girl_girl: () => family_man_man_girl_girl,
	family_man_woman_boy: () => family_man_woman_boy,
	family_man_woman_boy_boy: () => family_man_woman_boy_boy,
	family_man_woman_girl: () => family_man_woman_girl,
	family_man_woman_girl_boy: () => family_man_woman_girl_boy,
	family_man_woman_girl_girl: () => family_man_woman_girl_girl,
	family_woman_boy: () => family_woman_boy,
	family_woman_boy_boy: () => family_woman_boy_boy,
	family_woman_girl: () => family_woman_girl,
	family_woman_girl_boy: () => family_woman_girl_boy,
	family_woman_girl_girl: () => family_woman_girl_girl,
	family_woman_woman_boy: () => family_woman_woman_boy,
	family_woman_woman_boy_boy: () => family_woman_woman_boy_boy,
	family_woman_woman_girl: () => family_woman_woman_girl,
	family_woman_woman_girl_boy: () => family_woman_woman_girl_boy,
	family_woman_woman_girl_girl: () => family_woman_woman_girl_girl,
	farmer: () => farmer,
	faroe_islands: () => faroe_islands,
	fast_forward: () => "",
	fax: () => fax,
	fearful: () => fearful,
	feather: () => feather,
	feet: () => feet,
	female_detective: () => female_detective,
	female_sign: () => female_sign,
	ferris_wheel: () => ferris_wheel,
	ferry: () => ferry,
	field_hockey: () => field_hockey,
	fiji: () => fiji,
	file_cabinet: () => file_cabinet,
	file_folder: () => file_folder,
	film_projector: () => film_projector,
	film_strip: () => film_strip,
	finland: () => finland,
	fire: () => fire,
	fire_engine: () => fire_engine,
	fire_extinguisher: () => fire_extinguisher,
	firecracker: () => firecracker,
	firefighter: () => firefighter,
	fireworks: () => fireworks,
	first_quarter_moon: () => first_quarter_moon,
	first_quarter_moon_with_face: () => first_quarter_moon_with_face,
	fish: () => fish,
	fish_cake: () => fish_cake,
	fishing_pole_and_fish: () => fishing_pole_and_fish,
	fist: () => "",
	fist_left: () => fist_left,
	fist_oncoming: () => fist_oncoming,
	fist_raised: () => "",
	fist_right: () => fist_right,
	five: () => five,
	flags: () => flags,
	flamingo: () => flamingo,
	flashlight: () => flashlight,
	flat_shoe: () => flat_shoe,
	flatbread: () => flatbread,
	fleur_de_lis: () => fleur_de_lis,
	flight_arrival: () => flight_arrival,
	flight_departure: () => flight_departure,
	flipper: () => flipper,
	floppy_disk: () => floppy_disk,
	flower_playing_cards: () => flower_playing_cards,
	flushed: () => flushed,
	fly: () => fly,
	flying_disc: () => flying_disc,
	flying_saucer: () => flying_saucer,
	fog: () => fog,
	foggy: () => foggy,
	fondue: () => fondue,
	foot: () => foot,
	football: () => football,
	footprints: () => footprints,
	fork_and_knife: () => fork_and_knife,
	fortune_cookie: () => fortune_cookie,
	fountain: () => "",
	fountain_pen: () => fountain_pen,
	four: () => four,
	four_leaf_clover: () => four_leaf_clover,
	fox_face: () => fox_face,
	fr: () => fr,
	framed_picture: () => framed_picture,
	free: () => free,
	french_guiana: () => french_guiana,
	french_polynesia: () => french_polynesia,
	french_southern_territories: () => french_southern_territories,
	fried_egg: () => fried_egg,
	fried_shrimp: () => fried_shrimp,
	fries: () => fries,
	frog: () => frog,
	frowning: () => frowning,
	frowning_face: () => frowning_face,
	frowning_man: () => frowning_man,
	frowning_person: () => frowning_person,
	frowning_woman: () => frowning_woman,
	fu: () => fu,
	fuelpump: () => "",
	full_moon: () => full_moon,
	full_moon_with_face: () => full_moon_with_face,
	funeral_urn: () => funeral_urn,
	gabon: () => gabon,
	gambia: () => gambia,
	game_die: () => game_die,
	garlic: () => garlic,
	gb: () => gb,
	gear: () => gear,
	gem: () => gem,
	gemini: () => "",
	genie: () => genie,
	genie_man: () => genie_man,
	genie_woman: () => genie_woman,
	georgia: () => georgia,
	ghana: () => ghana,
	ghost: () => ghost$1,
	gibraltar: () => gibraltar,
	gift: () => gift,
	gift_heart: () => gift_heart,
	giraffe: () => giraffe,
	girl: () => girl,
	globe_with_meridians: () => globe_with_meridians,
	gloves: () => gloves,
	goal_net: () => goal_net,
	goat: () => goat,
	goggles: () => goggles,
	golf: () => "",
	golfing: () => golfing,
	golfing_man: () => golfing_man,
	golfing_woman: () => golfing_woman,
	gorilla: () => gorilla,
	grapes: () => grapes,
	greece: () => greece,
	green_apple: () => green_apple,
	green_book: () => green_book,
	green_circle: () => green_circle,
	green_heart: () => green_heart,
	green_salad: () => green_salad,
	green_square: () => green_square,
	greenland: () => greenland,
	grenada: () => grenada,
	grey_exclamation: () => "",
	grey_question: () => "",
	grimacing: () => grimacing,
	grin: () => grin,
	grinning: () => grinning,
	guadeloupe: () => guadeloupe,
	guam: () => guam,
	guard: () => guard,
	guardsman: () => guardsman,
	guardswoman: () => guardswoman,
	guatemala: () => guatemala,
	guernsey: () => guernsey,
	guide_dog: () => guide_dog,
	guinea: () => guinea,
	guinea_bissau: () => guinea_bissau,
	guitar: () => guitar,
	gun: () => gun,
	guyana: () => guyana,
	haircut: () => haircut,
	haircut_man: () => haircut_man,
	haircut_woman: () => haircut_woman,
	haiti: () => haiti,
	hamburger: () => hamburger,
	hammer: () => hammer,
	hammer_and_pick: () => hammer_and_pick,
	hammer_and_wrench: () => hammer_and_wrench,
	hamster: () => hamster,
	hand: () => "",
	hand_over_mouth: () => hand_over_mouth,
	handbag: () => handbag,
	handball_person: () => handball_person,
	handshake: () => handshake,
	hankey: () => hankey,
	hash: () => hash,
	hatched_chick: () => hatched_chick,
	hatching_chick: () => hatching_chick,
	headphones: () => headphones,
	headstone: () => headstone,
	health_worker: () => health_worker,
	hear_no_evil: () => hear_no_evil,
	heard_mcdonald_islands: () => heard_mcdonald_islands,
	heart: () => heart,
	heart_decoration: () => heart_decoration,
	heart_eyes: () => heart_eyes,
	heart_eyes_cat: () => heart_eyes_cat,
	heartbeat: () => heartbeat,
	heartpulse: () => heartpulse,
	hearts: () => hearts,
	heavy_check_mark: () => heavy_check_mark,
	heavy_division_sign: () => "",
	heavy_dollar_sign: () => heavy_dollar_sign,
	heavy_exclamation_mark: () => "",
	heavy_heart_exclamation: () => heavy_heart_exclamation,
	heavy_minus_sign: () => "",
	heavy_multiplication_x: () => heavy_multiplication_x,
	heavy_plus_sign: () => "",
	hedgehog: () => hedgehog,
	helicopter: () => helicopter,
	herb: () => herb,
	hibiscus: () => hibiscus,
	high_brightness: () => high_brightness,
	high_heel: () => high_heel,
	hiking_boot: () => hiking_boot,
	hindu_temple: () => hindu_temple,
	hippopotamus: () => hippopotamus,
	hocho: () => hocho,
	hole: () => hole,
	honduras: () => honduras,
	honey_pot: () => honey_pot,
	honeybee: () => honeybee,
	hong_kong: () => hong_kong,
	hook: () => hook,
	horse: () => horse,
	horse_racing: () => horse_racing,
	hospital: () => hospital,
	hot_face: () => hot_face,
	hot_pepper: () => hot_pepper,
	hotdog: () => hotdog,
	hotel: () => hotel,
	hotsprings: () => hotsprings,
	hourglass: () => "",
	hourglass_flowing_sand: () => "",
	house: () => house,
	house_with_garden: () => house_with_garden,
	houses: () => houses,
	hugs: () => hugs,
	hungary: () => hungary,
	hushed: () => hushed,
	hut: () => hut,
	ice_cream: () => ice_cream,
	ice_cube: () => ice_cube,
	ice_hockey: () => ice_hockey,
	ice_skate: () => ice_skate,
	icecream: () => icecream,
	iceland: () => iceland,
	id: () => id,
	ideograph_advantage: () => ideograph_advantage,
	imp: () => imp,
	inbox_tray: () => inbox_tray,
	incoming_envelope: () => incoming_envelope,
	india: () => india,
	indonesia: () => indonesia,
	infinity: () => infinity,
	information_desk_person: () => information_desk_person,
	information_source: () => information_source,
	innocent: () => innocent,
	interrobang: () => interrobang,
	iphone: () => iphone,
	iran: () => iran,
	iraq: () => iraq,
	ireland: () => ireland,
	isle_of_man: () => isle_of_man,
	israel: () => israel,
	it: () => it,
	izakaya_lantern: () => izakaya_lantern,
	jack_o_lantern: () => jack_o_lantern,
	jamaica: () => jamaica,
	japan: () => japan,
	japanese_castle: () => japanese_castle,
	japanese_goblin: () => japanese_goblin,
	japanese_ogre: () => japanese_ogre,
	jeans: () => jeans,
	jersey: () => jersey,
	jigsaw: () => jigsaw,
	jordan: () => jordan,
	joy: () => joy,
	joy_cat: () => joy_cat,
	joystick: () => joystick,
	jp: () => jp,
	judge: () => judge,
	juggling_person: () => juggling_person,
	kaaba: () => kaaba,
	kangaroo: () => kangaroo,
	kazakhstan: () => kazakhstan,
	kenya: () => kenya,
	key: () => key,
	keyboard: () => keyboard,
	keycap_ten: () => keycap_ten,
	kick_scooter: () => kick_scooter,
	kimono: () => kimono,
	kiribati: () => kiribati,
	kiss: () => kiss,
	kissing: () => kissing,
	kissing_cat: () => kissing_cat,
	kissing_closed_eyes: () => kissing_closed_eyes,
	kissing_heart: () => kissing_heart,
	kissing_smiling_eyes: () => kissing_smiling_eyes,
	kite: () => kite,
	kiwi_fruit: () => kiwi_fruit,
	kneeling_man: () => kneeling_man,
	kneeling_person: () => kneeling_person,
	kneeling_woman: () => kneeling_woman,
	knife: () => knife,
	knot: () => knot,
	koala: () => koala,
	koko: () => koko,
	kosovo: () => kosovo,
	kr: () => kr,
	kuwait: () => kuwait,
	kyrgyzstan: () => kyrgyzstan,
	lab_coat: () => lab_coat,
	label: () => label$1,
	lacrosse: () => lacrosse,
	ladder: () => ladder,
	lady_beetle: () => lady_beetle,
	lantern: () => lantern,
	laos: () => laos,
	large_blue_circle: () => large_blue_circle,
	large_blue_diamond: () => large_blue_diamond,
	large_orange_diamond: () => large_orange_diamond,
	last_quarter_moon: () => last_quarter_moon,
	last_quarter_moon_with_face: () => last_quarter_moon_with_face,
	latin_cross: () => latin_cross,
	latvia: () => latvia,
	laughing: () => laughing,
	leafy_green: () => leafy_green,
	leaves: () => leaves,
	lebanon: () => lebanon,
	ledger: () => ledger,
	left_luggage: () => left_luggage,
	left_right_arrow: () => left_right_arrow,
	left_speech_bubble: () => left_speech_bubble,
	leftwards_arrow_with_hook: () => leftwards_arrow_with_hook,
	leg: () => leg,
	lemon: () => lemon,
	leo: () => "",
	leopard: () => leopard,
	lesotho: () => lesotho,
	level_slider: () => level_slider,
	liberia: () => liberia,
	libra: () => "",
	libya: () => libya,
	liechtenstein: () => liechtenstein,
	light_rail: () => light_rail,
	link: () => link$1,
	lion: () => lion,
	lips: () => lips,
	lipstick: () => lipstick,
	lithuania: () => lithuania,
	lizard: () => lizard,
	llama: () => llama,
	lobster: () => lobster,
	lock: () => lock,
	lock_with_ink_pen: () => lock_with_ink_pen,
	lollipop: () => lollipop,
	long_drum: () => long_drum,
	loop: () => "",
	lotion_bottle: () => lotion_bottle,
	lotus_position: () => lotus_position,
	lotus_position_man: () => lotus_position_man,
	lotus_position_woman: () => lotus_position_woman,
	loud_sound: () => loud_sound,
	loudspeaker: () => loudspeaker,
	love_hotel: () => love_hotel,
	love_letter: () => love_letter,
	love_you_gesture: () => love_you_gesture,
	low_brightness: () => low_brightness,
	luggage: () => luggage,
	lungs: () => lungs,
	luxembourg: () => luxembourg,
	lying_face: () => lying_face,
	m: () => m,
	macau: () => macau,
	macedonia: () => macedonia,
	madagascar: () => madagascar,
	mag: () => mag,
	mag_right: () => mag_right,
	mage: () => mage,
	mage_man: () => mage_man,
	mage_woman: () => mage_woman,
	magic_wand: () => magic_wand,
	magnet: () => magnet,
	mahjong: () => mahjong,
	mailbox: () => mailbox,
	mailbox_closed: () => mailbox_closed,
	mailbox_with_mail: () => mailbox_with_mail,
	mailbox_with_no_mail: () => mailbox_with_no_mail,
	malawi: () => malawi,
	malaysia: () => malaysia,
	maldives: () => maldives,
	male_detective: () => male_detective,
	male_sign: () => male_sign,
	mali: () => mali,
	malta: () => malta,
	mammoth: () => mammoth,
	man: () => man,
	man_artist: () => man_artist,
	man_astronaut: () => man_astronaut,
	man_cartwheeling: () => man_cartwheeling,
	man_cook: () => man_cook,
	man_dancing: () => man_dancing,
	man_facepalming: () => man_facepalming,
	man_factory_worker: () => man_factory_worker,
	man_farmer: () => man_farmer,
	man_feeding_baby: () => man_feeding_baby,
	man_firefighter: () => man_firefighter,
	man_health_worker: () => man_health_worker,
	man_in_manual_wheelchair: () => man_in_manual_wheelchair,
	man_in_motorized_wheelchair: () => man_in_motorized_wheelchair,
	man_in_tuxedo: () => man_in_tuxedo,
	man_judge: () => man_judge,
	man_juggling: () => man_juggling,
	man_mechanic: () => man_mechanic,
	man_office_worker: () => man_office_worker,
	man_pilot: () => man_pilot,
	man_playing_handball: () => man_playing_handball,
	man_playing_water_polo: () => man_playing_water_polo,
	man_scientist: () => man_scientist,
	man_shrugging: () => man_shrugging,
	man_singer: () => man_singer,
	man_student: () => man_student,
	man_teacher: () => man_teacher,
	man_technologist: () => man_technologist,
	man_with_gua_pi_mao: () => man_with_gua_pi_mao,
	man_with_probing_cane: () => man_with_probing_cane,
	man_with_turban: () => man_with_turban,
	man_with_veil: () => man_with_veil,
	mandarin: () => mandarin,
	mango: () => mango,
	mans_shoe: () => mans_shoe,
	mantelpiece_clock: () => mantelpiece_clock,
	manual_wheelchair: () => manual_wheelchair,
	maple_leaf: () => maple_leaf,
	marshall_islands: () => marshall_islands,
	martial_arts_uniform: () => martial_arts_uniform,
	martinique: () => martinique,
	mask: () => mask,
	massage: () => massage,
	massage_man: () => massage_man,
	massage_woman: () => massage_woman,
	mate: () => mate,
	mauritania: () => mauritania,
	mauritius: () => mauritius,
	mayotte: () => mayotte,
	meat_on_bone: () => meat_on_bone,
	mechanic: () => mechanic,
	mechanical_arm: () => mechanical_arm,
	mechanical_leg: () => mechanical_leg,
	medal_military: () => medal_military,
	medal_sports: () => medal_sports,
	medical_symbol: () => medical_symbol,
	mega: () => mega,
	melon: () => melon,
	memo: () => memo$1,
	men_wrestling: () => men_wrestling,
	menorah: () => menorah,
	mens: () => mens,
	mermaid: () => mermaid,
	merman: () => merman,
	merperson: () => merperson,
	metal: () => metal,
	metro: () => metro,
	mexico: () => mexico,
	microbe: () => microbe,
	micronesia: () => micronesia,
	microphone: () => microphone,
	microscope: () => microscope,
	middle_finger: () => middle_finger,
	military_helmet: () => military_helmet,
	milk_glass: () => milk_glass,
	milky_way: () => milky_way,
	minibus: () => minibus,
	minidisc: () => minidisc,
	mirror: () => mirror,
	mobile_phone_off: () => mobile_phone_off,
	moldova: () => moldova,
	monaco: () => monaco,
	money_mouth_face: () => money_mouth_face,
	money_with_wings: () => money_with_wings,
	moneybag: () => moneybag,
	mongolia: () => mongolia,
	monkey: () => monkey,
	monkey_face: () => monkey_face,
	monocle_face: () => monocle_face,
	monorail: () => monorail,
	montenegro: () => montenegro,
	montserrat: () => montserrat,
	moon: () => moon,
	moon_cake: () => moon_cake,
	morocco: () => morocco,
	mortar_board: () => mortar_board,
	mosque: () => mosque,
	mosquito: () => mosquito,
	motor_boat: () => motor_boat,
	motor_scooter: () => motor_scooter,
	motorcycle: () => motorcycle,
	motorized_wheelchair: () => motorized_wheelchair,
	motorway: () => motorway,
	mount_fuji: () => mount_fuji,
	mountain: () => mountain,
	mountain_bicyclist: () => mountain_bicyclist,
	mountain_biking_man: () => mountain_biking_man,
	mountain_biking_woman: () => mountain_biking_woman,
	mountain_cableway: () => mountain_cableway,
	mountain_railway: () => mountain_railway,
	mountain_snow: () => mountain_snow,
	mouse: () => mouse,
	mouse2: () => mouse2,
	mouse_trap: () => mouse_trap,
	movie_camera: () => movie_camera,
	moyai: () => moyai,
	mozambique: () => mozambique,
	mrs_claus: () => mrs_claus,
	muscle: () => muscle,
	mushroom: () => mushroom,
	musical_keyboard: () => musical_keyboard,
	musical_note: () => musical_note,
	musical_score: () => musical_score,
	mute: () => mute,
	mx_claus: () => mx_claus,
	myanmar: () => myanmar,
	nail_care: () => nail_care,
	name_badge: () => name_badge,
	namibia: () => namibia,
	national_park: () => national_park,
	nauru: () => nauru,
	nauseated_face: () => nauseated_face,
	nazar_amulet: () => nazar_amulet,
	necktie: () => necktie,
	negative_squared_cross_mark: () => "",
	nepal: () => nepal,
	nerd_face: () => nerd_face,
	nesting_dolls: () => nesting_dolls,
	netherlands: () => netherlands,
	neutral_face: () => neutral_face,
	new_caledonia: () => new_caledonia,
	new_moon: () => new_moon,
	new_moon_with_face: () => new_moon_with_face,
	new_zealand: () => new_zealand,
	newspaper: () => newspaper,
	newspaper_roll: () => newspaper_roll,
	next_track_button: () => next_track_button,
	ng: () => ng,
	ng_man: () => ng_man,
	ng_woman: () => ng_woman,
	nicaragua: () => nicaragua,
	niger: () => niger,
	nigeria: () => nigeria,
	night_with_stars: () => night_with_stars,
	nine: () => nine,
	ninja: () => ninja,
	niue: () => niue,
	no_bell: () => no_bell,
	no_bicycles: () => no_bicycles,
	no_entry: () => "",
	no_entry_sign: () => no_entry_sign,
	no_good: () => no_good,
	no_good_man: () => no_good_man,
	no_good_woman: () => no_good_woman,
	no_mobile_phones: () => no_mobile_phones,
	no_mouth: () => no_mouth,
	no_pedestrians: () => no_pedestrians,
	no_smoking: () => no_smoking,
	norfolk_island: () => norfolk_island,
	north_korea: () => north_korea,
	northern_mariana_islands: () => northern_mariana_islands,
	norway: () => norway,
	nose: () => nose,
	notebook: () => notebook,
	notebook_with_decorative_cover: () => notebook_with_decorative_cover,
	notes: () => notes,
	nut_and_bolt: () => nut_and_bolt,
	o: () => "",
	o2: () => o2,
	ocean: () => ocean,
	octopus: () => octopus,
	oden: () => oden,
	office: () => office,
	office_worker: () => office_worker,
	oil_drum: () => oil_drum,
	ok: () => ok,
	ok_hand: () => ok_hand,
	ok_man: () => ok_man,
	ok_person: () => ok_person,
	ok_woman: () => ok_woman,
	old_key: () => old_key,
	older_adult: () => older_adult,
	older_man: () => older_man,
	older_woman: () => older_woman,
	olive: () => olive,
	om: () => om,
	oman: () => oman,
	on: () => on,
	oncoming_automobile: () => oncoming_automobile,
	oncoming_bus: () => oncoming_bus,
	oncoming_police_car: () => oncoming_police_car,
	oncoming_taxi: () => oncoming_taxi,
	one: () => one,
	one_piece_swimsuit: () => one_piece_swimsuit,
	onion: () => onion,
	open_book: () => open_book,
	open_file_folder: () => open_file_folder,
	open_hands: () => open_hands,
	open_mouth: () => open_mouth,
	open_umbrella: () => open_umbrella,
	ophiuchus: () => "",
	orange: () => orange,
	orange_book: () => orange_book,
	orange_circle: () => orange_circle,
	orange_heart: () => orange_heart,
	orange_square: () => orange_square,
	orangutan: () => orangutan,
	orthodox_cross: () => orthodox_cross,
	otter: () => otter,
	outbox_tray: () => outbox_tray,
	owl: () => owl,
	ox: () => ox,
	oyster: () => oyster,
	page_facing_up: () => page_facing_up,
	page_with_curl: () => page_with_curl,
	pager: () => pager,
	paintbrush: () => paintbrush,
	pakistan: () => pakistan,
	palau: () => palau,
	palestinian_territories: () => palestinian_territories,
	palm_tree: () => palm_tree,
	palms_up_together: () => palms_up_together,
	panama: () => panama,
	pancakes: () => pancakes,
	panda_face: () => panda_face,
	paperclip: () => paperclip,
	paperclips: () => paperclips,
	papua_new_guinea: () => papua_new_guinea,
	parachute: () => parachute,
	paraguay: () => paraguay,
	parasol_on_ground: () => parasol_on_ground,
	parking: () => parking,
	parrot: () => parrot,
	part_alternation_mark: () => part_alternation_mark,
	partly_sunny: () => "",
	partying_face: () => partying_face,
	passenger_ship: () => passenger_ship,
	passport_control: () => passport_control,
	pause_button: () => pause_button,
	paw_prints: () => paw_prints,
	peace_symbol: () => peace_symbol,
	peach: () => peach,
	peacock: () => peacock,
	peanuts: () => peanuts,
	pear: () => pear,
	pen: () => pen,
	pencil: () => pencil,
	pencil2: () => pencil2,
	penguin: () => penguin,
	pensive: () => pensive,
	people_holding_hands: () => people_holding_hands,
	people_hugging: () => people_hugging,
	performing_arts: () => performing_arts,
	persevere: () => persevere,
	person_bald: () => person_bald,
	person_curly_hair: () => person_curly_hair,
	person_feeding_baby: () => person_feeding_baby,
	person_fencing: () => person_fencing,
	person_in_manual_wheelchair: () => person_in_manual_wheelchair,
	person_in_motorized_wheelchair: () => person_in_motorized_wheelchair,
	person_in_tuxedo: () => person_in_tuxedo,
	person_red_hair: () => person_red_hair,
	person_white_hair: () => person_white_hair,
	person_with_probing_cane: () => person_with_probing_cane,
	person_with_turban: () => person_with_turban,
	person_with_veil: () => person_with_veil,
	peru: () => peru,
	petri_dish: () => petri_dish,
	philippines: () => philippines,
	phone: () => phone,
	pick: () => pick,
	pickup_truck: () => pickup_truck,
	pie: () => pie,
	pig: () => pig,
	pig2: () => pig2,
	pig_nose: () => pig_nose,
	pill: () => pill,
	pilot: () => pilot,
	pinata: () => pinata,
	pinched_fingers: () => pinched_fingers,
	pinching_hand: () => pinching_hand,
	pineapple: () => pineapple,
	ping_pong: () => ping_pong,
	pirate_flag: () => pirate_flag,
	pisces: () => "",
	pitcairn_islands: () => pitcairn_islands,
	pizza: () => pizza,
	placard: () => placard,
	place_of_worship: () => place_of_worship,
	plate_with_cutlery: () => plate_with_cutlery,
	play_or_pause_button: () => play_or_pause_button,
	pleading_face: () => pleading_face,
	plunger: () => plunger,
	point_down: () => point_down,
	point_left: () => point_left,
	point_right: () => point_right,
	point_up: () => point_up,
	point_up_2: () => point_up_2,
	poland: () => poland,
	polar_bear: () => polar_bear,
	police_car: () => police_car,
	police_officer: () => police_officer,
	policeman: () => policeman,
	policewoman: () => policewoman,
	poodle: () => poodle,
	poop: () => poop,
	popcorn: () => popcorn,
	portugal: () => portugal,
	post_office: () => post_office,
	postal_horn: () => postal_horn,
	postbox: () => postbox,
	potable_water: () => potable_water,
	potato: () => potato,
	potted_plant: () => potted_plant,
	pouch: () => pouch,
	poultry_leg: () => poultry_leg,
	pound: () => pound,
	pout: () => pout,
	pouting_cat: () => pouting_cat,
	pouting_face: () => pouting_face,
	pouting_man: () => pouting_man,
	pouting_woman: () => pouting_woman,
	pray: () => pray,
	prayer_beads: () => prayer_beads,
	pregnant_woman: () => pregnant_woman,
	pretzel: () => pretzel,
	previous_track_button: () => previous_track_button,
	prince: () => prince,
	princess: () => princess,
	printer: () => printer,
	probing_cane: () => probing_cane,
	puerto_rico: () => puerto_rico,
	punch: () => punch,
	purple_circle: () => purple_circle,
	purple_heart: () => purple_heart,
	purple_square: () => purple_square,
	purse: () => purse,
	pushpin: () => pushpin,
	put_litter_in_its_place: () => put_litter_in_its_place,
	qatar: () => qatar,
	question: () => "",
	rabbit: () => rabbit,
	rabbit2: () => rabbit2,
	raccoon: () => raccoon,
	racehorse: () => racehorse,
	racing_car: () => racing_car,
	radio: () => radio,
	radio_button: () => radio_button,
	radioactive: () => radioactive,
	rage: () => rage,
	railway_car: () => railway_car,
	railway_track: () => railway_track,
	rainbow: () => rainbow,
	rainbow_flag: () => rainbow_flag,
	raised_back_of_hand: () => raised_back_of_hand,
	raised_eyebrow: () => raised_eyebrow,
	raised_hand: () => "",
	raised_hand_with_fingers_splayed: () => raised_hand_with_fingers_splayed,
	raised_hands: () => raised_hands,
	raising_hand: () => raising_hand,
	raising_hand_man: () => raising_hand_man,
	raising_hand_woman: () => raising_hand_woman,
	ram: () => ram,
	ramen: () => ramen,
	rat: () => rat,
	razor: () => razor,
	receipt: () => receipt,
	record_button: () => record_button,
	recycle: () => recycle,
	red_car: () => red_car,
	red_circle: () => red_circle,
	red_envelope: () => red_envelope,
	red_haired_man: () => red_haired_man,
	red_haired_woman: () => red_haired_woman,
	red_square: () => red_square,
	registered: () => registered,
	relaxed: () => relaxed,
	relieved: () => relieved,
	reminder_ribbon: () => reminder_ribbon,
	repeat: () => repeat,
	repeat_one: () => repeat_one,
	rescue_worker_helmet: () => rescue_worker_helmet,
	restroom: () => restroom,
	reunion: () => reunion,
	revolving_hearts: () => revolving_hearts,
	rewind: () => "",
	rhinoceros: () => rhinoceros,
	ribbon: () => ribbon,
	rice: () => rice,
	rice_ball: () => rice_ball,
	rice_cracker: () => rice_cracker,
	rice_scene: () => rice_scene,
	right_anger_bubble: () => right_anger_bubble,
	ring: () => ring,
	ringed_planet: () => ringed_planet,
	robot: () => robot,
	rock: () => rock,
	rocket: () => rocket,
	rofl: () => rofl,
	roll_eyes: () => roll_eyes,
	roll_of_paper: () => roll_of_paper,
	roller_coaster: () => roller_coaster,
	roller_skate: () => roller_skate,
	romania: () => romania,
	rooster: () => rooster,
	rose: () => rose,
	rosette: () => rosette,
	rotating_light: () => rotating_light,
	round_pushpin: () => round_pushpin,
	rowboat: () => rowboat,
	rowing_man: () => rowing_man,
	rowing_woman: () => rowing_woman,
	ru: () => ru,
	rugby_football: () => rugby_football,
	runner: () => runner,
	running: () => running,
	running_man: () => running_man,
	running_shirt_with_sash: () => running_shirt_with_sash,
	running_woman: () => running_woman,
	rwanda: () => rwanda,
	sa: () => sa,
	safety_pin: () => safety_pin,
	safety_vest: () => safety_vest,
	sagittarius: () => "",
	sailboat: () => "",
	sake: () => sake,
	salt: () => salt,
	samoa: () => samoa,
	san_marino: () => san_marino,
	sandal: () => sandal,
	sandwich: () => sandwich,
	santa: () => santa,
	sao_tome_principe: () => sao_tome_principe,
	sari: () => sari,
	sassy_man: () => sassy_man,
	sassy_woman: () => sassy_woman,
	satellite: () => satellite,
	satisfied: () => satisfied,
	saudi_arabia: () => saudi_arabia,
	sauna_man: () => sauna_man,
	sauna_person: () => sauna_person,
	sauna_woman: () => sauna_woman,
	sauropod: () => sauropod,
	saxophone: () => saxophone,
	scarf: () => scarf,
	school: () => school,
	school_satchel: () => school_satchel,
	scientist: () => scientist,
	scissors: () => scissors,
	scorpion: () => scorpion,
	scorpius: () => "",
	scotland: () => scotland,
	scream: () => scream,
	scream_cat: () => scream_cat,
	screwdriver: () => screwdriver,
	scroll: () => scroll,
	seal: () => seal,
	seat: () => seat,
	secret: () => secret,
	see_no_evil: () => see_no_evil,
	seedling: () => seedling,
	selfie: () => selfie,
	senegal: () => senegal,
	serbia: () => serbia,
	service_dog: () => service_dog,
	seven: () => seven,
	sewing_needle: () => sewing_needle,
	seychelles: () => seychelles,
	shallow_pan_of_food: () => shallow_pan_of_food,
	shamrock: () => shamrock,
	shark: () => shark,
	shaved_ice: () => shaved_ice,
	sheep: () => sheep,
	shell: () => shell,
	shield: () => shield,
	shinto_shrine: () => shinto_shrine,
	ship: () => ship,
	shirt: () => shirt,
	shit: () => shit,
	shoe: () => shoe,
	shopping: () => shopping,
	shopping_cart: () => shopping_cart,
	shorts: () => shorts,
	shower: () => shower,
	shrimp: () => shrimp,
	shrug: () => shrug,
	shushing_face: () => shushing_face,
	sierra_leone: () => sierra_leone,
	signal_strength: () => signal_strength,
	singapore: () => singapore,
	singer: () => singer,
	sint_maarten: () => sint_maarten,
	six: () => six,
	six_pointed_star: () => six_pointed_star,
	skateboard: () => skateboard,
	ski: () => ski,
	skier: () => skier,
	skull: () => skull,
	skull_and_crossbones: () => skull_and_crossbones,
	skunk: () => skunk,
	sled: () => sled,
	sleeping: () => sleeping,
	sleeping_bed: () => sleeping_bed,
	sleepy: () => sleepy,
	slightly_frowning_face: () => slightly_frowning_face,
	slightly_smiling_face: () => slightly_smiling_face,
	slot_machine: () => slot_machine,
	sloth: () => sloth,
	slovakia: () => slovakia,
	slovenia: () => slovenia,
	small_airplane: () => small_airplane,
	small_blue_diamond: () => small_blue_diamond,
	small_orange_diamond: () => small_orange_diamond,
	small_red_triangle: () => small_red_triangle,
	small_red_triangle_down: () => small_red_triangle_down,
	smile: () => smile,
	smile_cat: () => smile_cat,
	smiley: () => smiley,
	smiley_cat: () => smiley_cat,
	smiling_face_with_tear: () => smiling_face_with_tear,
	smiling_face_with_three_hearts: () => smiling_face_with_three_hearts,
	smiling_imp: () => smiling_imp,
	smirk: () => smirk,
	smirk_cat: () => smirk_cat,
	smoking: () => smoking,
	snail: () => snail,
	snake: () => snake,
	sneezing_face: () => sneezing_face,
	snowboarder: () => snowboarder,
	snowflake: () => snowflake,
	snowman: () => "",
	snowman_with_snow: () => snowman_with_snow,
	soap: () => soap,
	sob: () => sob,
	soccer: () => "",
	socks: () => socks,
	softball: () => softball,
	solomon_islands: () => solomon_islands,
	somalia: () => somalia,
	soon: () => soon,
	sos: () => sos,
	sound: () => sound,
	south_africa: () => south_africa,
	south_georgia_south_sandwich_islands: () => south_georgia_south_sandwich_islands,
	south_sudan: () => south_sudan,
	space_invader: () => space_invader,
	spades: () => spades,
	spaghetti: () => spaghetti,
	sparkle: () => sparkle,
	sparkler: () => sparkler,
	sparkles: () => "",
	sparkling_heart: () => sparkling_heart,
	speak_no_evil: () => speak_no_evil,
	speaker: () => speaker,
	speaking_head: () => speaking_head,
	speech_balloon: () => speech_balloon,
	speedboat: () => speedboat,
	spider: () => spider,
	spider_web: () => spider_web,
	spiral_calendar: () => spiral_calendar,
	spiral_notepad: () => spiral_notepad,
	sponge: () => sponge,
	spoon: () => spoon,
	squid: () => squid,
	sri_lanka: () => sri_lanka,
	st_barthelemy: () => st_barthelemy,
	st_helena: () => st_helena,
	st_kitts_nevis: () => st_kitts_nevis,
	st_lucia: () => st_lucia,
	st_martin: () => st_martin,
	st_pierre_miquelon: () => st_pierre_miquelon,
	st_vincent_grenadines: () => st_vincent_grenadines,
	stadium: () => stadium,
	standing_man: () => standing_man,
	standing_person: () => standing_person,
	standing_woman: () => standing_woman,
	star: () => "",
	star2: () => star2,
	star_and_crescent: () => star_and_crescent,
	star_of_david: () => star_of_david,
	star_struck: () => star_struck,
	stars: () => stars,
	station: () => station,
	statue_of_liberty: () => statue_of_liberty,
	steam_locomotive: () => steam_locomotive,
	stethoscope: () => stethoscope,
	stew: () => stew,
	stop_button: () => stop_button,
	stop_sign: () => stop_sign,
	stopwatch: () => stopwatch,
	straight_ruler: () => straight_ruler,
	strawberry: () => strawberry,
	stuck_out_tongue: () => stuck_out_tongue,
	stuck_out_tongue_closed_eyes: () => stuck_out_tongue_closed_eyes,
	stuck_out_tongue_winking_eye: () => stuck_out_tongue_winking_eye,
	student: () => student,
	studio_microphone: () => studio_microphone,
	stuffed_flatbread: () => stuffed_flatbread,
	sudan: () => sudan,
	sun_behind_large_cloud: () => sun_behind_large_cloud,
	sun_behind_rain_cloud: () => sun_behind_rain_cloud,
	sun_behind_small_cloud: () => sun_behind_small_cloud,
	sun_with_face: () => sun_with_face,
	sunflower: () => sunflower,
	sunglasses: () => sunglasses,
	sunny: () => sunny,
	sunrise: () => sunrise,
	sunrise_over_mountains: () => sunrise_over_mountains,
	superhero: () => superhero,
	superhero_man: () => superhero_man,
	superhero_woman: () => superhero_woman,
	supervillain: () => supervillain,
	supervillain_man: () => supervillain_man,
	supervillain_woman: () => supervillain_woman,
	surfer: () => surfer,
	surfing_man: () => surfing_man,
	surfing_woman: () => surfing_woman,
	suriname: () => suriname,
	sushi: () => sushi,
	suspension_railway: () => suspension_railway,
	svalbard_jan_mayen: () => svalbard_jan_mayen,
	swan: () => swan,
	swaziland: () => swaziland,
	sweat: () => sweat,
	sweat_drops: () => sweat_drops,
	sweat_smile: () => sweat_smile,
	sweden: () => sweden,
	sweet_potato: () => sweet_potato,
	swim_brief: () => swim_brief,
	swimmer: () => swimmer,
	swimming_man: () => swimming_man,
	swimming_woman: () => swimming_woman,
	switzerland: () => switzerland,
	symbols: () => symbols,
	synagogue: () => synagogue,
	syria: () => syria,
	syringe: () => syringe,
	taco: () => taco,
	tada: () => tada,
	taiwan: () => taiwan,
	tajikistan: () => tajikistan,
	takeout_box: () => takeout_box,
	tamale: () => tamale,
	tanabata_tree: () => tanabata_tree,
	tangerine: () => tangerine,
	tanzania: () => tanzania,
	taurus: () => "",
	taxi: () => taxi,
	tea: () => tea,
	teacher: () => teacher,
	teapot: () => teapot,
	technologist: () => technologist,
	teddy_bear: () => teddy_bear,
	telephone: () => telephone,
	telephone_receiver: () => telephone_receiver,
	telescope: () => telescope,
	tennis: () => tennis,
	tent: () => "",
	test_tube: () => test_tube,
	thailand: () => thailand,
	thermometer: () => thermometer,
	thinking: () => thinking,
	thong_sandal: () => thong_sandal,
	thought_balloon: () => thought_balloon,
	thread: () => thread,
	three: () => three,
	thumbsdown: () => thumbsdown,
	thumbsup: () => thumbsup,
	ticket: () => ticket,
	tickets: () => tickets,
	tiger: () => tiger,
	tiger2: () => tiger2,
	timer_clock: () => timer_clock,
	timor_leste: () => timor_leste,
	tipping_hand_man: () => tipping_hand_man,
	tipping_hand_person: () => tipping_hand_person,
	tipping_hand_woman: () => tipping_hand_woman,
	tired_face: () => tired_face,
	tm: () => tm,
	togo: () => togo,
	toilet: () => toilet,
	tokelau: () => tokelau,
	tokyo_tower: () => tokyo_tower,
	tomato: () => tomato,
	tonga: () => tonga,
	tongue: () => tongue,
	toolbox: () => toolbox,
	tooth: () => tooth,
	toothbrush: () => toothbrush,
	top: () => top$1,
	tophat: () => tophat,
	tornado: () => tornado,
	tr: () => tr,
	trackball: () => trackball,
	tractor: () => tractor,
	traffic_light: () => traffic_light,
	train: () => train,
	train2: () => train2,
	tram: () => tram,
	transgender_flag: () => transgender_flag,
	transgender_symbol: () => transgender_symbol,
	triangular_flag_on_post: () => triangular_flag_on_post,
	triangular_ruler: () => triangular_ruler,
	trident: () => trident,
	trinidad_tobago: () => trinidad_tobago,
	tristan_da_cunha: () => tristan_da_cunha,
	triumph: () => triumph,
	trolleybus: () => trolleybus,
	trophy: () => trophy,
	tropical_drink: () => tropical_drink,
	tropical_fish: () => tropical_fish,
	truck: () => truck,
	trumpet: () => trumpet,
	tshirt: () => tshirt,
	tulip: () => tulip,
	tumbler_glass: () => tumbler_glass,
	tunisia: () => tunisia,
	turkey: () => turkey,
	turkmenistan: () => turkmenistan,
	turks_caicos_islands: () => turks_caicos_islands,
	turtle: () => turtle,
	tuvalu: () => tuvalu,
	tv: () => tv,
	twisted_rightwards_arrows: () => twisted_rightwards_arrows,
	two: () => two,
	two_hearts: () => two_hearts,
	two_men_holding_hands: () => two_men_holding_hands,
	two_women_holding_hands: () => two_women_holding_hands,
	u6e80: () => u6e80,
	uganda: () => uganda,
	uk: () => uk,
	ukraine: () => ukraine,
	umbrella: () => "",
	unamused: () => unamused,
	underage: () => underage,
	unicorn: () => unicorn,
	united_arab_emirates: () => united_arab_emirates,
	united_nations: () => united_nations,
	unlock: () => unlock,
	up: () => up,
	upside_down_face: () => upside_down_face,
	uruguay: () => uruguay,
	us: () => us,
	us_outlying_islands: () => us_outlying_islands,
	us_virgin_islands: () => us_virgin_islands,
	uzbekistan: () => uzbekistan,
	v: () => v,
	vampire: () => vampire,
	vampire_man: () => vampire_man,
	vampire_woman: () => vampire_woman,
	vanuatu: () => vanuatu,
	vatican_city: () => vatican_city,
	venezuela: () => venezuela,
	vertical_traffic_light: () => vertical_traffic_light,
	vhs: () => vhs,
	vibration_mode: () => vibration_mode,
	video_camera: () => video_camera,
	video_game: () => video_game,
	vietnam: () => vietnam,
	violin: () => violin,
	virgo: () => "",
	volcano: () => volcano,
	volleyball: () => volleyball,
	vomiting_face: () => vomiting_face,
	vs: () => vs,
	vulcan_salute: () => vulcan_salute,
	waffle: () => waffle,
	wales: () => wales,
	walking: () => walking,
	walking_man: () => walking_man,
	walking_woman: () => walking_woman,
	wallis_futuna: () => wallis_futuna,
	waning_crescent_moon: () => waning_crescent_moon,
	waning_gibbous_moon: () => waning_gibbous_moon,
	warning: () => warning$1,
	wastebasket: () => wastebasket,
	watch: () => "",
	water_buffalo: () => water_buffalo,
	water_polo: () => water_polo,
	watermelon: () => watermelon,
	wave: () => wave,
	wavy_dash: () => wavy_dash,
	waxing_crescent_moon: () => waxing_crescent_moon,
	waxing_gibbous_moon: () => waxing_gibbous_moon,
	wc: () => wc,
	weary: () => weary,
	wedding: () => wedding,
	weight_lifting: () => weight_lifting,
	weight_lifting_man: () => weight_lifting_man,
	weight_lifting_woman: () => weight_lifting_woman,
	western_sahara: () => western_sahara,
	whale: () => whale,
	whale2: () => whale2,
	wheel_of_dharma: () => wheel_of_dharma,
	wheelchair: () => "",
	white_check_mark: () => "",
	white_circle: () => "",
	white_flag: () => white_flag,
	white_flower: () => white_flower,
	white_haired_man: () => white_haired_man,
	white_haired_woman: () => white_haired_woman,
	white_heart: () => white_heart,
	white_large_square: () => "",
	white_medium_small_square: () => "",
	white_medium_square: () => white_medium_square,
	white_small_square: () => white_small_square,
	white_square_button: () => white_square_button,
	wilted_flower: () => wilted_flower,
	wind_chime: () => wind_chime,
	wind_face: () => wind_face,
	window: () => window$1,
	wine_glass: () => wine_glass,
	wink: () => wink,
	wolf: () => wolf,
	woman: () => woman,
	woman_artist: () => woman_artist,
	woman_astronaut: () => woman_astronaut,
	woman_cartwheeling: () => woman_cartwheeling,
	woman_cook: () => woman_cook,
	woman_dancing: () => woman_dancing,
	woman_facepalming: () => woman_facepalming,
	woman_factory_worker: () => woman_factory_worker,
	woman_farmer: () => woman_farmer,
	woman_feeding_baby: () => woman_feeding_baby,
	woman_firefighter: () => woman_firefighter,
	woman_health_worker: () => woman_health_worker,
	woman_in_manual_wheelchair: () => woman_in_manual_wheelchair,
	woman_in_motorized_wheelchair: () => woman_in_motorized_wheelchair,
	woman_in_tuxedo: () => woman_in_tuxedo,
	woman_judge: () => woman_judge,
	woman_juggling: () => woman_juggling,
	woman_mechanic: () => woman_mechanic,
	woman_office_worker: () => woman_office_worker,
	woman_pilot: () => woman_pilot,
	woman_playing_handball: () => woman_playing_handball,
	woman_playing_water_polo: () => woman_playing_water_polo,
	woman_scientist: () => woman_scientist,
	woman_shrugging: () => woman_shrugging,
	woman_singer: () => woman_singer,
	woman_student: () => woman_student,
	woman_teacher: () => woman_teacher,
	woman_technologist: () => woman_technologist,
	woman_with_headscarf: () => woman_with_headscarf,
	woman_with_probing_cane: () => woman_with_probing_cane,
	woman_with_turban: () => woman_with_turban,
	woman_with_veil: () => woman_with_veil,
	womans_clothes: () => womans_clothes,
	womans_hat: () => womans_hat,
	women_wrestling: () => women_wrestling,
	womens: () => womens,
	wood: () => wood,
	woozy_face: () => woozy_face,
	world_map: () => world_map,
	worm: () => worm,
	worried: () => worried,
	wrench: () => wrench,
	wrestling: () => wrestling,
	writing_hand: () => writing_hand,
	x: () => "",
	yarn: () => yarn,
	yawning_face: () => yawning_face,
	yellow_circle: () => yellow_circle,
	yellow_heart: () => yellow_heart,
	yellow_square: () => yellow_square,
	yemen: () => yemen,
	yen: () => yen,
	yin_yang: () => yin_yang,
	yo_yo: () => yo_yo,
	yum: () => yum,
	zambia: () => zambia,
	zany_face: () => zany_face,
	zap: () => "",
	zebra: () => zebra,
	zero: () => zero,
	zimbabwe: () => zimbabwe,
	zipper_mouth_face: () => zipper_mouth_face,
	zombie: () => zombie,
	zombie_man: () => zombie_man,
	zombie_woman: () => zombie_woman,
	zzz: () => zzz
}), grinning, smiley, smile, grin, laughing, satisfied, sweat_smile, rofl, joy, slightly_smiling_face, upside_down_face, wink, blush, innocent, smiling_face_with_three_hearts, heart_eyes, star_struck, kissing_heart, kissing, relaxed, kissing_closed_eyes, kissing_smiling_eyes, smiling_face_with_tear, yum, stuck_out_tongue, stuck_out_tongue_winking_eye, zany_face, stuck_out_tongue_closed_eyes, money_mouth_face, hugs, hand_over_mouth, shushing_face, thinking, zipper_mouth_face, raised_eyebrow, neutral_face, expressionless, no_mouth, smirk, unamused, roll_eyes, grimacing, lying_face, relieved, pensive, sleepy, drooling_face, sleeping, mask, face_with_thermometer, face_with_head_bandage, nauseated_face, vomiting_face, sneezing_face, hot_face, cold_face, woozy_face, dizzy_face, exploding_head, cowboy_hat_face, partying_face, disguised_face, sunglasses, nerd_face, monocle_face, confused, worried, slightly_frowning_face, frowning_face, open_mouth, hushed, astonished, flushed, pleading_face, frowning, anguished, fearful, cold_sweat, disappointed_relieved, cry, sob, scream, confounded, persevere, disappointed, sweat, weary, tired_face, yawning_face, triumph, rage, pout, angry, cursing_face, smiling_imp, imp, skull, skull_and_crossbones, hankey, poop, shit, clown_face, japanese_ogre, japanese_goblin, ghost$1, alien, space_invader, robot, smiley_cat, smile_cat, joy_cat, heart_eyes_cat, smirk_cat, kissing_cat, scream_cat, crying_cat_face, pouting_cat, see_no_evil, hear_no_evil, speak_no_evil, kiss, love_letter, cupid, gift_heart, sparkling_heart, heartpulse, heartbeat, revolving_hearts, two_hearts, heart_decoration, heavy_heart_exclamation, broken_heart, heart, orange_heart, yellow_heart, green_heart, blue_heart, purple_heart, brown_heart, black_heart, white_heart, anger, boom, collision, dizzy, sweat_drops, dash, hole, bomb, speech_balloon, eye_speech_bubble, left_speech_bubble, right_anger_bubble, thought_balloon, zzz, wave, raised_back_of_hand, raised_hand_with_fingers_splayed, vulcan_salute, ok_hand, pinched_fingers, pinching_hand, v, crossed_fingers, love_you_gesture, metal, call_me_hand, point_left, point_right, point_up_2, middle_finger, fu, point_down, point_up, thumbsup, thumbsdown, fist_oncoming, facepunch, punch, fist_left, fist_right, clap, raised_hands, open_hands, palms_up_together, handshake, pray, writing_hand, nail_care, selfie, muscle, mechanical_arm, mechanical_leg, leg, foot, ear, ear_with_hearing_aid, nose, brain, anatomical_heart, lungs, tooth, bone, eyes, eye, tongue, lips, baby, child, boy, girl, adult, blond_haired_person, man, bearded_person, red_haired_man, curly_haired_man, white_haired_man, bald_man, woman, red_haired_woman, person_red_hair, curly_haired_woman, person_curly_hair, white_haired_woman, person_white_hair, bald_woman, person_bald, blond_haired_woman, blonde_woman, blond_haired_man, older_adult, older_man, older_woman, frowning_person, frowning_man, frowning_woman, pouting_face, pouting_man, pouting_woman, no_good, no_good_man, ng_man, no_good_woman, ng_woman, ok_person, ok_man, ok_woman, tipping_hand_person, information_desk_person, tipping_hand_man, sassy_man, tipping_hand_woman, sassy_woman, raising_hand, raising_hand_man, raising_hand_woman, deaf_person, deaf_man, deaf_woman, bow, bowing_man, bowing_woman, facepalm, man_facepalming, woman_facepalming, shrug, man_shrugging, woman_shrugging, health_worker, man_health_worker, woman_health_worker, student, man_student, woman_student, teacher, man_teacher, woman_teacher, judge, man_judge, woman_judge, farmer, man_farmer, woman_farmer, cook, man_cook, woman_cook, mechanic, man_mechanic, woman_mechanic, factory_worker, man_factory_worker, woman_factory_worker, office_worker, man_office_worker, woman_office_worker, scientist, man_scientist, woman_scientist, technologist, man_technologist, woman_technologist, singer, man_singer, woman_singer, artist, man_artist, woman_artist, pilot, man_pilot, woman_pilot, astronaut, man_astronaut, woman_astronaut, firefighter, man_firefighter, woman_firefighter, police_officer, cop, policeman, policewoman, detective, male_detective, female_detective, guard, guardsman, guardswoman, ninja, construction_worker, construction_worker_man, construction_worker_woman, prince, princess, person_with_turban, man_with_turban, woman_with_turban, man_with_gua_pi_mao, woman_with_headscarf, person_in_tuxedo, man_in_tuxedo, woman_in_tuxedo, person_with_veil, man_with_veil, woman_with_veil, bride_with_veil, pregnant_woman, breast_feeding, woman_feeding_baby, man_feeding_baby, person_feeding_baby, angel, santa, mrs_claus, mx_claus, superhero, superhero_man, superhero_woman, supervillain, supervillain_man, supervillain_woman, mage, mage_man, mage_woman, fairy, fairy_man, fairy_woman, vampire, vampire_man, vampire_woman, merperson, merman, mermaid, elf, elf_man, elf_woman, genie, genie_man, genie_woman, zombie, zombie_man, zombie_woman, massage, massage_man, massage_woman, haircut, haircut_man, haircut_woman, walking, walking_man, walking_woman, standing_person, standing_man, standing_woman, kneeling_person, kneeling_man, kneeling_woman, person_with_probing_cane, man_with_probing_cane, woman_with_probing_cane, person_in_motorized_wheelchair, man_in_motorized_wheelchair, woman_in_motorized_wheelchair, person_in_manual_wheelchair, man_in_manual_wheelchair, woman_in_manual_wheelchair, runner, running, running_man, running_woman, woman_dancing, dancer, man_dancing, business_suit_levitating, dancers, dancing_men, dancing_women, sauna_person, sauna_man, sauna_woman, climbing, climbing_man, climbing_woman, person_fencing, horse_racing, skier, snowboarder, golfing, golfing_man, golfing_woman, surfer, surfing_man, surfing_woman, rowboat, rowing_man, rowing_woman, swimmer, swimming_man, swimming_woman, bouncing_ball_person, bouncing_ball_man, basketball_man, bouncing_ball_woman, basketball_woman, weight_lifting, weight_lifting_man, weight_lifting_woman, bicyclist, biking_man, biking_woman, mountain_bicyclist, mountain_biking_man, mountain_biking_woman, cartwheeling, man_cartwheeling, woman_cartwheeling, wrestling, men_wrestling, women_wrestling, water_polo, man_playing_water_polo, woman_playing_water_polo, handball_person, man_playing_handball, woman_playing_handball, juggling_person, man_juggling, woman_juggling, lotus_position, lotus_position_man, lotus_position_woman, bath, sleeping_bed, people_holding_hands, two_women_holding_hands, couple, two_men_holding_hands, couplekiss, couplekiss_man_woman, couplekiss_man_man, couplekiss_woman_woman, couple_with_heart, couple_with_heart_woman_man, couple_with_heart_man_man, couple_with_heart_woman_woman, family, family_man_woman_boy, family_man_woman_girl, family_man_woman_girl_boy, family_man_woman_boy_boy, family_man_woman_girl_girl, family_man_man_boy, family_man_man_girl, family_man_man_girl_boy, family_man_man_boy_boy, family_man_man_girl_girl, family_woman_woman_boy, family_woman_woman_girl, family_woman_woman_girl_boy, family_woman_woman_boy_boy, family_woman_woman_girl_girl, family_man_boy, family_man_boy_boy, family_man_girl, family_man_girl_boy, family_man_girl_girl, family_woman_boy, family_woman_boy_boy, family_woman_girl, family_woman_girl_boy, family_woman_girl_girl, speaking_head, bust_in_silhouette, busts_in_silhouette, people_hugging, footprints, monkey_face, monkey, gorilla, orangutan, dog, dog2, guide_dog, service_dog, poodle, wolf, fox_face, raccoon, cat, cat2, black_cat, lion, tiger, tiger2, leopard, horse, racehorse, unicorn, zebra, deer, bison, cow, ox, water_buffalo, cow2, pig, pig2, boar, pig_nose, ram, sheep, goat, dromedary_camel, camel, llama, giraffe, elephant, mammoth, rhinoceros, hippopotamus, mouse, mouse2, rat, hamster, rabbit, rabbit2, chipmunk, beaver, hedgehog, bat, bear, polar_bear, koala, panda_face, sloth, otter, skunk, kangaroo, badger, feet, paw_prints, turkey, chicken, rooster, hatching_chick, baby_chick, hatched_chick, bird, penguin, dove, eagle, duck, swan, owl, dodo, feather, flamingo, peacock, parrot, frog, crocodile, turtle, lizard, snake, dragon_face, dragon, sauropod, whale, whale2, dolphin, flipper, seal, fish, tropical_fish, blowfish, shark, octopus, shell, snail, butterfly, bug, ant, bee, honeybee, beetle, lady_beetle, cricket, cockroach, spider, spider_web, scorpion, mosquito, fly, worm, microbe, bouquet, cherry_blossom, white_flower, rosette, rose, wilted_flower, hibiscus, sunflower, blossom, tulip, seedling, potted_plant, evergreen_tree, deciduous_tree, palm_tree, cactus, ear_of_rice, herb, shamrock, four_leaf_clover, maple_leaf, fallen_leaf, leaves, grapes, melon, watermelon, tangerine, orange, mandarin, lemon, banana, pineapple, mango, apple, green_apple, pear, peach, cherries, strawberry, blueberries, kiwi_fruit, tomato, olive, coconut, avocado, eggplant, potato, carrot, corn, hot_pepper, bell_pepper, cucumber, leafy_green, broccoli, garlic, onion, mushroom, peanuts, chestnut, bread, croissant, baguette_bread, flatbread, pretzel, bagel, pancakes, waffle, cheese, meat_on_bone, poultry_leg, cut_of_meat, bacon, hamburger, fries, pizza, hotdog, sandwich, taco, burrito, tamale, stuffed_flatbread, falafel, egg, fried_egg, shallow_pan_of_food, stew, fondue, bowl_with_spoon, green_salad, popcorn, butter, salt, canned_food, bento, rice_cracker, rice_ball, rice, curry, ramen, spaghetti, sweet_potato, oden, sushi, fried_shrimp, fish_cake, moon_cake, dango, dumpling, fortune_cookie, takeout_box, crab, lobster, shrimp, squid, oyster, icecream, shaved_ice, ice_cream, doughnut, cookie, birthday, cake, cupcake, pie, chocolate_bar, candy, lollipop, custard, honey_pot, baby_bottle, milk_glass, teapot, tea, sake, champagne, wine_glass, cocktail, tropical_drink, beer, beers, clinking_glasses, tumbler_glass, cup_with_straw, bubble_tea, beverage_box, mate, ice_cube, chopsticks, plate_with_cutlery, fork_and_knife, spoon, hocho, knife, amphora, earth_africa, earth_americas, earth_asia, globe_with_meridians, world_map, japan, compass, mountain_snow, mountain, volcano, mount_fuji, camping, beach_umbrella, desert, desert_island, national_park, stadium, classical_building, building_construction, bricks, rock, wood, hut, houses, derelict_house, house, house_with_garden, office, post_office, european_post_office, hospital, bank, hotel, love_hotel, convenience_store, school, department_store, factory, japanese_castle, european_castle, wedding, tokyo_tower, statue_of_liberty, mosque, hindu_temple, synagogue, shinto_shrine, kaaba, foggy, night_with_stars, cityscape, sunrise_over_mountains, sunrise, city_sunset, city_sunrise, bridge_at_night, hotsprings, carousel_horse, ferris_wheel, roller_coaster, barber, circus_tent, steam_locomotive, railway_car, bullettrain_side, bullettrain_front, train2, metro, light_rail, station, tram, monorail, mountain_railway, train, bus, oncoming_bus, trolleybus, minibus, ambulance, fire_engine, police_car, oncoming_police_car, taxi, oncoming_taxi, car, red_car, oncoming_automobile, blue_car, pickup_truck, truck, articulated_lorry, tractor, racing_car, motorcycle, motor_scooter, manual_wheelchair, motorized_wheelchair, auto_rickshaw, bike, kick_scooter, skateboard, roller_skate, busstop, motorway, railway_track, oil_drum, rotating_light, traffic_light, vertical_traffic_light, stop_sign, construction, canoe, speedboat, passenger_ship, ferry, motor_boat, ship, airplane, small_airplane, flight_departure, flight_arrival, parachute, seat, helicopter, suspension_railway, mountain_cableway, aerial_tramway, artificial_satellite, rocket, flying_saucer, bellhop_bell, luggage, stopwatch, timer_clock, mantelpiece_clock, clock12, clock1230, clock1, clock130, clock2, clock230, clock3, clock330, clock4, clock430, clock5, clock530, clock6, clock630, clock7, clock730, clock8, clock830, clock9, clock930, clock10, clock1030, clock11, clock1130, new_moon, waxing_crescent_moon, first_quarter_moon, moon, waxing_gibbous_moon, full_moon, waning_gibbous_moon, last_quarter_moon, waning_crescent_moon, crescent_moon, new_moon_with_face, first_quarter_moon_with_face, last_quarter_moon_with_face, thermometer, sunny, full_moon_with_face, sun_with_face, ringed_planet, star2, stars, milky_way, cloud, cloud_with_lightning_and_rain, sun_behind_small_cloud, sun_behind_large_cloud, sun_behind_rain_cloud, cloud_with_rain, cloud_with_snow, cloud_with_lightning, tornado, fog, wind_face, cyclone, rainbow, closed_umbrella, open_umbrella, parasol_on_ground, snowflake, snowman_with_snow, comet, fire, droplet, ocean, jack_o_lantern, christmas_tree, fireworks, sparkler, firecracker, balloon, tada, confetti_ball, tanabata_tree, bamboo, dolls, flags, wind_chime, rice_scene, red_envelope, ribbon, gift, reminder_ribbon, tickets, ticket, medal_military, trophy, medal_sports, softball, basketball, volleyball, football, rugby_football, tennis, flying_disc, bowling, cricket_game, field_hockey, ice_hockey, lacrosse, ping_pong, badminton, boxing_glove, martial_arts_uniform, goal_net, ice_skate, fishing_pole_and_fish, diving_mask, running_shirt_with_sash, ski, sled, curling_stone, dart, yo_yo, kite, crystal_ball, magic_wand, nazar_amulet, video_game, joystick, slot_machine, game_die, jigsaw, teddy_bear, pinata, nesting_dolls, spades, hearts, diamonds, clubs, chess_pawn, black_joker, mahjong, flower_playing_cards, performing_arts, framed_picture, art, thread, sewing_needle, yarn, knot, eyeglasses, dark_sunglasses, goggles, lab_coat, safety_vest, necktie, shirt, tshirt, jeans, scarf, gloves, coat, socks, dress, kimono, sari, one_piece_swimsuit, swim_brief, shorts, bikini, womans_clothes, purse, handbag, pouch, shopping, school_satchel, thong_sandal, mans_shoe, shoe, athletic_shoe, hiking_boot, flat_shoe, high_heel, sandal, ballet_shoes, boot, crown, womans_hat, tophat, mortar_board, billed_cap, military_helmet, rescue_worker_helmet, prayer_beads, lipstick, ring, gem, mute, speaker, sound, loud_sound, loudspeaker, mega, postal_horn, bell, no_bell, musical_score, musical_note, notes, studio_microphone, level_slider, control_knobs, microphone, headphones, radio, saxophone, accordion, guitar, musical_keyboard, trumpet, violin, banjo, drum, long_drum, iphone, calling, phone, telephone, telephone_receiver, pager, fax, battery, electric_plug, computer, desktop_computer, printer, keyboard, computer_mouse, trackball, minidisc, floppy_disk, cd, dvd, abacus, movie_camera, film_strip, film_projector, clapper, tv, camera, camera_flash, video_camera, vhs, mag, mag_right, candle, bulb, flashlight, izakaya_lantern, lantern, diya_lamp, notebook_with_decorative_cover, closed_book, book, open_book, green_book, blue_book, orange_book, books, notebook, ledger, page_with_curl, scroll, page_facing_up, newspaper, newspaper_roll, bookmark_tabs, bookmark, label$1, moneybag, coin, yen, dollar, euro, pound, money_with_wings, credit_card, receipt, chart, envelope, email, incoming_envelope, envelope_with_arrow, outbox_tray, inbox_tray, mailbox, mailbox_closed, mailbox_with_mail, mailbox_with_no_mail, postbox, ballot_box, pencil2, black_nib, fountain_pen, pen, paintbrush, crayon, memo$1, pencil, briefcase, file_folder, open_file_folder, card_index_dividers, date, calendar, spiral_notepad, spiral_calendar, card_index, chart_with_upwards_trend, chart_with_downwards_trend, bar_chart, clipboard, pushpin, round_pushpin, paperclip, paperclips, straight_ruler, triangular_ruler, scissors, card_file_box, file_cabinet, wastebasket, lock, unlock, lock_with_ink_pen, closed_lock_with_key, key, old_key, hammer, axe, pick, hammer_and_pick, hammer_and_wrench, dagger, crossed_swords, gun, boomerang, bow_and_arrow, shield, carpentry_saw, wrench, screwdriver, nut_and_bolt, gear, clamp, balance_scale, probing_cane, link$1, chains, hook, toolbox, magnet, ladder, alembic, test_tube, petri_dish, dna, microscope, telescope, satellite, syringe, drop_of_blood, pill, adhesive_bandage, stethoscope, door, elevator, mirror, window$1, bed, couch_and_lamp, chair, toilet, plunger, shower, bathtub, mouse_trap, razor, lotion_bottle, safety_pin, broom, basket, roll_of_paper, bucket, soap, toothbrush, sponge, fire_extinguisher, shopping_cart, smoking, coffin, headstone, funeral_urn, moyai, placard, atm, put_litter_in_its_place, potable_water, mens, womens, restroom, baby_symbol, wc, passport_control, customs, baggage_claim, left_luggage, warning$1, children_crossing, no_entry_sign, no_bicycles, no_smoking, do_not_litter, no_pedestrians, no_mobile_phones, underage, radioactive, biohazard, arrow_up, arrow_upper_right, arrow_right, arrow_lower_right, arrow_down, arrow_lower_left, arrow_left, arrow_upper_left, arrow_up_down, left_right_arrow, leftwards_arrow_with_hook, arrow_right_hook, arrow_heading_up, arrow_heading_down, arrows_clockwise, arrows_counterclockwise, back$1, end, on, soon, top$1, place_of_worship, atom_symbol, om, star_of_david, wheel_of_dharma, yin_yang, latin_cross, orthodox_cross, star_and_crescent, peace_symbol, menorah, six_pointed_star, twisted_rightwards_arrows, repeat, repeat_one, arrow_forward, next_track_button, play_or_pause_button, arrow_backward, previous_track_button, arrow_up_small, arrow_down_small, pause_button, stop_button, record_button, eject_button, cinema, low_brightness, high_brightness, signal_strength, vibration_mode, mobile_phone_off, female_sign, male_sign, transgender_symbol, heavy_multiplication_x, infinity, bangbang, interrobang, wavy_dash, currency_exchange, heavy_dollar_sign, medical_symbol, recycle, fleur_de_lis, trident, name_badge, beginner, ballot_box_with_check, heavy_check_mark, part_alternation_mark, eight_spoked_asterisk, eight_pointed_black_star, sparkle, copyright, registered, tm, hash, asterisk, zero, one, two, three, four, five, six, seven, eight, nine, keycap_ten, capital_abcd, abcd, symbols, abc, a, ab, b, cl, cool, free, information_source, id, m, ng, o2, ok, parking, sos, up, vs, koko, sa, ideograph_advantage, accept, congratulations, secret, u6e80, red_circle, orange_circle, yellow_circle, green_circle, large_blue_circle, purple_circle, brown_circle, red_square, orange_square, yellow_square, green_square, blue_square, purple_square, brown_square, black_medium_square, white_medium_square, black_small_square, white_small_square, large_orange_diamond, large_blue_diamond, small_orange_diamond, small_blue_diamond, small_red_triangle, small_red_triangle_down, diamond_shape_with_a_dot_inside, radio_button, white_square_button, black_square_button, checkered_flag, triangular_flag_on_post, crossed_flags, black_flag, white_flag, rainbow_flag, transgender_flag, pirate_flag, ascension_island, andorra, united_arab_emirates, afghanistan, antigua_barbuda, anguilla, albania, armenia, angola, antarctica, argentina, american_samoa, austria, australia, aruba, aland_islands, azerbaijan, bosnia_herzegovina, barbados, bangladesh, belgium, burkina_faso, bulgaria, bahrain, burundi, benin, st_barthelemy, bermuda, brunei, bolivia, caribbean_netherlands, brazil, bahamas, bhutan, bouvet_island, botswana, belarus, belize, canada, cocos_islands, congo_kinshasa, central_african_republic, congo_brazzaville, switzerland, cote_divoire, cook_islands, chile, cameroon, cn, colombia, clipperton_island, costa_rica, cuba, cape_verde, curacao, christmas_island, cyprus, czech_republic, de, diego_garcia, djibouti, denmark, dominica, dominican_republic, algeria, ceuta_melilla, ecuador, estonia, egypt, western_sahara, eritrea, es, ethiopia, eu, european_union, finland, fiji, falkland_islands, micronesia, faroe_islands, fr, gabon, gb, uk, grenada, georgia, french_guiana, guernsey, ghana, gibraltar, greenland, gambia, guinea, guadeloupe, equatorial_guinea, greece, south_georgia_south_sandwich_islands, guatemala, guam, guinea_bissau, guyana, hong_kong, heard_mcdonald_islands, honduras, croatia, haiti, hungary, canary_islands, indonesia, ireland, israel, isle_of_man, india, british_indian_ocean_territory, iraq, iran, iceland, it, jersey, jamaica, jordan, jp, kenya, kyrgyzstan, cambodia, kiribati, comoros, st_kitts_nevis, north_korea, kr, kuwait, cayman_islands, kazakhstan, laos, lebanon, st_lucia, liechtenstein, sri_lanka, liberia, lesotho, lithuania, luxembourg, latvia, libya, morocco, monaco, moldova, montenegro, st_martin, madagascar, marshall_islands, macedonia, mali, myanmar, mongolia, macau, northern_mariana_islands, martinique, mauritania, montserrat, malta, mauritius, maldives, malawi, mexico, malaysia, mozambique, namibia, new_caledonia, niger, norfolk_island, nigeria, nicaragua, netherlands, norway, nepal, nauru, niue, new_zealand, oman, panama, peru, french_polynesia, papua_new_guinea, philippines, pakistan, poland, st_pierre_miquelon, pitcairn_islands, puerto_rico, palestinian_territories, portugal, palau, paraguay, qatar, reunion, romania, serbia, ru, rwanda, saudi_arabia, solomon_islands, seychelles, sudan, sweden, singapore, st_helena, slovenia, svalbard_jan_mayen, slovakia, sierra_leone, san_marino, senegal, somalia, suriname, south_sudan, sao_tome_principe, el_salvador, sint_maarten, syria, swaziland, tristan_da_cunha, turks_caicos_islands, chad, french_southern_territories, togo, thailand, tajikistan, tokelau, timor_leste, turkmenistan, tunisia, tonga, tr, trinidad_tobago, tuvalu, taiwan, tanzania, ukraine, uganda, us_outlying_islands, united_nations, us, uruguay, uzbekistan, vatican_city, st_vincent_grenadines, venezuela, british_virgin_islands, us_virgin_islands, vietnam, vanuatu, wallis_futuna, samoa, kosovo, yemen, mayotte, south_africa, zambia, zimbabwe, england, scotland, wales, full_default;
var init_full = __esmMin((() => {
	grinning = "";
	smiley = "";
	smile = "";
	grin = "";
	laughing = "";
	satisfied = "";
	sweat_smile = "";
	rofl = "";
	joy = "";
	slightly_smiling_face = "";
	upside_down_face = "";
	wink = "";
	blush = "";
	innocent = "";
	smiling_face_with_three_hearts = "";
	heart_eyes = "";
	star_struck = "";
	kissing_heart = "";
	kissing = "";
	relaxed = "";
	kissing_closed_eyes = "";
	kissing_smiling_eyes = "";
	smiling_face_with_tear = "";
	yum = "";
	stuck_out_tongue = "";
	stuck_out_tongue_winking_eye = "";
	zany_face = "";
	stuck_out_tongue_closed_eyes = "";
	money_mouth_face = "";
	hugs = "";
	hand_over_mouth = "";
	shushing_face = "";
	thinking = "";
	zipper_mouth_face = "";
	raised_eyebrow = "";
	neutral_face = "";
	expressionless = "";
	no_mouth = "";
	smirk = "";
	unamused = "";
	roll_eyes = "";
	grimacing = "";
	lying_face = "";
	relieved = "";
	pensive = "";
	sleepy = "";
	drooling_face = "";
	sleeping = "";
	mask = "";
	face_with_thermometer = "";
	face_with_head_bandage = "";
	nauseated_face = "";
	vomiting_face = "";
	sneezing_face = "";
	hot_face = "";
	cold_face = "";
	woozy_face = "";
	dizzy_face = "";
	exploding_head = "";
	cowboy_hat_face = "";
	partying_face = "";
	disguised_face = "";
	sunglasses = "";
	nerd_face = "";
	monocle_face = "";
	confused = "";
	worried = "";
	slightly_frowning_face = "";
	frowning_face = "";
	open_mouth = "";
	hushed = "";
	astonished = "";
	flushed = "";
	pleading_face = "";
	frowning = "";
	anguished = "";
	fearful = "";
	cold_sweat = "";
	disappointed_relieved = "";
	cry = "";
	sob = "";
	scream = "";
	confounded = "";
	persevere = "";
	disappointed = "";
	sweat = "";
	weary = "";
	tired_face = "";
	yawning_face = "";
	triumph = "";
	rage = "";
	pout = "";
	angry = "";
	cursing_face = "";
	smiling_imp = "";
	imp = "";
	skull = "";
	skull_and_crossbones = "";
	hankey = "";
	poop = "";
	shit = "";
	clown_face = "";
	japanese_ogre = "";
	japanese_goblin = "";
	ghost$1 = "";
	alien = "";
	space_invader = "";
	robot = "";
	smiley_cat = "";
	smile_cat = "";
	joy_cat = "";
	heart_eyes_cat = "";
	smirk_cat = "";
	kissing_cat = "";
	scream_cat = "";
	crying_cat_face = "";
	pouting_cat = "";
	see_no_evil = "";
	hear_no_evil = "";
	speak_no_evil = "";
	kiss = "";
	love_letter = "";
	cupid = "";
	gift_heart = "";
	sparkling_heart = "";
	heartpulse = "";
	heartbeat = "";
	revolving_hearts = "";
	two_hearts = "";
	heart_decoration = "";
	heavy_heart_exclamation = "";
	broken_heart = "";
	heart = "";
	orange_heart = "";
	yellow_heart = "";
	green_heart = "";
	blue_heart = "";
	purple_heart = "";
	brown_heart = "";
	black_heart = "";
	white_heart = "";
	anger = "";
	boom = "";
	collision = "";
	dizzy = "";
	sweat_drops = "";
	dash = "";
	hole = "";
	bomb = "";
	speech_balloon = "";
	eye_speech_bubble = "";
	left_speech_bubble = "";
	right_anger_bubble = "";
	thought_balloon = "";
	zzz = "";
	wave = "";
	raised_back_of_hand = "";
	raised_hand_with_fingers_splayed = "";
	vulcan_salute = "";
	ok_hand = "";
	pinched_fingers = "";
	pinching_hand = "";
	v = "";
	crossed_fingers = "";
	love_you_gesture = "";
	metal = "";
	call_me_hand = "";
	point_left = "";
	point_right = "";
	point_up_2 = "";
	middle_finger = "";
	fu = "";
	point_down = "";
	point_up = "";
	thumbsup = "";
	thumbsdown = "";
	fist_oncoming = "";
	facepunch = "";
	punch = "";
	fist_left = "";
	fist_right = "";
	clap = "";
	raised_hands = "";
	open_hands = "";
	palms_up_together = "";
	handshake = "";
	pray = "";
	writing_hand = "";
	nail_care = "";
	selfie = "";
	muscle = "";
	mechanical_arm = "";
	mechanical_leg = "";
	leg = "";
	foot = "";
	ear = "";
	ear_with_hearing_aid = "";
	nose = "";
	brain = "";
	anatomical_heart = "";
	lungs = "";
	tooth = "";
	bone = "";
	eyes = "";
	eye = "";
	tongue = "";
	lips = "";
	baby = "";
	child = "";
	boy = "";
	girl = "";
	adult = "";
	blond_haired_person = "";
	man = "";
	bearded_person = "";
	red_haired_man = "";
	curly_haired_man = "";
	white_haired_man = "";
	bald_man = "";
	woman = "";
	red_haired_woman = "";
	person_red_hair = "";
	curly_haired_woman = "";
	person_curly_hair = "";
	white_haired_woman = "";
	person_white_hair = "";
	bald_woman = "";
	person_bald = "";
	blond_haired_woman = "";
	blonde_woman = "";
	blond_haired_man = "";
	older_adult = "";
	older_man = "";
	older_woman = "";
	frowning_person = "";
	frowning_man = "";
	frowning_woman = "";
	pouting_face = "";
	pouting_man = "";
	pouting_woman = "";
	no_good = "";
	no_good_man = "";
	ng_man = "";
	no_good_woman = "";
	ng_woman = "";
	ok_person = "";
	ok_man = "";
	ok_woman = "";
	tipping_hand_person = "";
	information_desk_person = "";
	tipping_hand_man = "";
	sassy_man = "";
	tipping_hand_woman = "";
	sassy_woman = "";
	raising_hand = "";
	raising_hand_man = "";
	raising_hand_woman = "";
	deaf_person = "";
	deaf_man = "";
	deaf_woman = "";
	bow = "";
	bowing_man = "";
	bowing_woman = "";
	facepalm = "";
	man_facepalming = "";
	woman_facepalming = "";
	shrug = "";
	man_shrugging = "";
	woman_shrugging = "";
	health_worker = "";
	man_health_worker = "";
	woman_health_worker = "";
	student = "";
	man_student = "";
	woman_student = "";
	teacher = "";
	man_teacher = "";
	woman_teacher = "";
	judge = "";
	man_judge = "";
	woman_judge = "";
	farmer = "";
	man_farmer = "";
	woman_farmer = "";
	cook = "";
	man_cook = "";
	woman_cook = "";
	mechanic = "";
	man_mechanic = "";
	woman_mechanic = "";
	factory_worker = "";
	man_factory_worker = "";
	woman_factory_worker = "";
	office_worker = "";
	man_office_worker = "";
	woman_office_worker = "";
	scientist = "";
	man_scientist = "";
	woman_scientist = "";
	technologist = "";
	man_technologist = "";
	woman_technologist = "";
	singer = "";
	man_singer = "";
	woman_singer = "";
	artist = "";
	man_artist = "";
	woman_artist = "";
	pilot = "";
	man_pilot = "";
	woman_pilot = "";
	astronaut = "";
	man_astronaut = "";
	woman_astronaut = "";
	firefighter = "";
	man_firefighter = "";
	woman_firefighter = "";
	police_officer = "";
	cop = "";
	policeman = "";
	policewoman = "";
	detective = "";
	male_detective = "";
	female_detective = "";
	guard = "";
	guardsman = "";
	guardswoman = "";
	ninja = "";
	construction_worker = "";
	construction_worker_man = "";
	construction_worker_woman = "";
	prince = "";
	princess = "";
	person_with_turban = "";
	man_with_turban = "";
	woman_with_turban = "";
	man_with_gua_pi_mao = "";
	woman_with_headscarf = "";
	person_in_tuxedo = "";
	man_in_tuxedo = "";
	woman_in_tuxedo = "";
	person_with_veil = "";
	man_with_veil = "";
	woman_with_veil = "";
	bride_with_veil = "";
	pregnant_woman = "";
	breast_feeding = "";
	woman_feeding_baby = "";
	man_feeding_baby = "";
	person_feeding_baby = "";
	angel = "";
	santa = "";
	mrs_claus = "";
	mx_claus = "";
	superhero = "";
	superhero_man = "";
	superhero_woman = "";
	supervillain = "";
	supervillain_man = "";
	supervillain_woman = "";
	mage = "";
	mage_man = "";
	mage_woman = "";
	fairy = "";
	fairy_man = "";
	fairy_woman = "";
	vampire = "";
	vampire_man = "";
	vampire_woman = "";
	merperson = "";
	merman = "";
	mermaid = "";
	elf = "";
	elf_man = "";
	elf_woman = "";
	genie = "";
	genie_man = "";
	genie_woman = "";
	zombie = "";
	zombie_man = "";
	zombie_woman = "";
	massage = "";
	massage_man = "";
	massage_woman = "";
	haircut = "";
	haircut_man = "";
	haircut_woman = "";
	walking = "";
	walking_man = "";
	walking_woman = "";
	standing_person = "";
	standing_man = "";
	standing_woman = "";
	kneeling_person = "";
	kneeling_man = "";
	kneeling_woman = "";
	person_with_probing_cane = "";
	man_with_probing_cane = "";
	woman_with_probing_cane = "";
	person_in_motorized_wheelchair = "";
	man_in_motorized_wheelchair = "";
	woman_in_motorized_wheelchair = "";
	person_in_manual_wheelchair = "";
	man_in_manual_wheelchair = "";
	woman_in_manual_wheelchair = "";
	runner = "";
	running = "";
	running_man = "";
	running_woman = "";
	woman_dancing = "";
	dancer = "";
	man_dancing = "";
	business_suit_levitating = "";
	dancers = "";
	dancing_men = "";
	dancing_women = "";
	sauna_person = "";
	sauna_man = "";
	sauna_woman = "";
	climbing = "";
	climbing_man = "";
	climbing_woman = "";
	person_fencing = "";
	horse_racing = "";
	skier = "";
	snowboarder = "";
	golfing = "";
	golfing_man = "";
	golfing_woman = "";
	surfer = "";
	surfing_man = "";
	surfing_woman = "";
	rowboat = "";
	rowing_man = "";
	rowing_woman = "";
	swimmer = "";
	swimming_man = "";
	swimming_woman = "";
	bouncing_ball_person = "";
	bouncing_ball_man = "";
	basketball_man = "";
	bouncing_ball_woman = "";
	basketball_woman = "";
	weight_lifting = "";
	weight_lifting_man = "";
	weight_lifting_woman = "";
	bicyclist = "";
	biking_man = "";
	biking_woman = "";
	mountain_bicyclist = "";
	mountain_biking_man = "";
	mountain_biking_woman = "";
	cartwheeling = "";
	man_cartwheeling = "";
	woman_cartwheeling = "";
	wrestling = "";
	men_wrestling = "";
	women_wrestling = "";
	water_polo = "";
	man_playing_water_polo = "";
	woman_playing_water_polo = "";
	handball_person = "";
	man_playing_handball = "";
	woman_playing_handball = "";
	juggling_person = "";
	man_juggling = "";
	woman_juggling = "";
	lotus_position = "";
	lotus_position_man = "";
	lotus_position_woman = "";
	bath = "";
	sleeping_bed = "";
	people_holding_hands = "";
	two_women_holding_hands = "";
	couple = "";
	two_men_holding_hands = "";
	couplekiss = "";
	couplekiss_man_woman = "";
	couplekiss_man_man = "";
	couplekiss_woman_woman = "";
	couple_with_heart = "";
	couple_with_heart_woman_man = "";
	couple_with_heart_man_man = "";
	couple_with_heart_woman_woman = "";
	family = "";
	family_man_woman_boy = "";
	family_man_woman_girl = "";
	family_man_woman_girl_boy = "";
	family_man_woman_boy_boy = "";
	family_man_woman_girl_girl = "";
	family_man_man_boy = "";
	family_man_man_girl = "";
	family_man_man_girl_boy = "";
	family_man_man_boy_boy = "";
	family_man_man_girl_girl = "";
	family_woman_woman_boy = "";
	family_woman_woman_girl = "";
	family_woman_woman_girl_boy = "";
	family_woman_woman_boy_boy = "";
	family_woman_woman_girl_girl = "";
	family_man_boy = "";
	family_man_boy_boy = "";
	family_man_girl = "";
	family_man_girl_boy = "";
	family_man_girl_girl = "";
	family_woman_boy = "";
	family_woman_boy_boy = "";
	family_woman_girl = "";
	family_woman_girl_boy = "";
	family_woman_girl_girl = "";
	speaking_head = "";
	bust_in_silhouette = "";
	busts_in_silhouette = "";
	people_hugging = "";
	footprints = "";
	monkey_face = "";
	monkey = "";
	gorilla = "";
	orangutan = "";
	dog = "";
	dog2 = "";
	guide_dog = "";
	service_dog = "";
	poodle = "";
	wolf = "";
	fox_face = "";
	raccoon = "";
	cat = "";
	cat2 = "";
	black_cat = "";
	lion = "";
	tiger = "";
	tiger2 = "";
	leopard = "";
	horse = "";
	racehorse = "";
	unicorn = "";
	zebra = "";
	deer = "";
	bison = "";
	cow = "";
	ox = "";
	water_buffalo = "";
	cow2 = "";
	pig = "";
	pig2 = "";
	boar = "";
	pig_nose = "";
	ram = "";
	sheep = "";
	goat = "";
	dromedary_camel = "";
	camel = "";
	llama = "";
	giraffe = "";
	elephant = "";
	mammoth = "";
	rhinoceros = "";
	hippopotamus = "";
	mouse = "";
	mouse2 = "";
	rat = "";
	hamster = "";
	rabbit = "";
	rabbit2 = "";
	chipmunk = "";
	beaver = "";
	hedgehog = "";
	bat = "";
	bear = "";
	polar_bear = "";
	koala = "";
	panda_face = "";
	sloth = "";
	otter = "";
	skunk = "";
	kangaroo = "";
	badger = "";
	feet = "";
	paw_prints = "";
	turkey = "";
	chicken = "";
	rooster = "";
	hatching_chick = "";
	baby_chick = "";
	hatched_chick = "";
	bird = "";
	penguin = "";
	dove = "";
	eagle = "";
	duck = "";
	swan = "";
	owl = "";
	dodo = "";
	feather = "";
	flamingo = "";
	peacock = "";
	parrot = "";
	frog = "";
	crocodile = "";
	turtle = "";
	lizard = "";
	snake = "";
	dragon_face = "";
	dragon = "";
	sauropod = "";
	whale = "";
	whale2 = "";
	dolphin = "";
	flipper = "";
	seal = "";
	fish = "";
	tropical_fish = "";
	blowfish = "";
	shark = "";
	octopus = "";
	shell = "";
	snail = "";
	butterfly = "";
	bug = "";
	ant = "";
	bee = "";
	honeybee = "";
	beetle = "";
	lady_beetle = "";
	cricket = "";
	cockroach = "";
	spider = "";
	spider_web = "";
	scorpion = "";
	mosquito = "";
	fly = "";
	worm = "";
	microbe = "";
	bouquet = "";
	cherry_blossom = "";
	white_flower = "";
	rosette = "";
	rose = "";
	wilted_flower = "";
	hibiscus = "";
	sunflower = "";
	blossom = "";
	tulip = "";
	seedling = "";
	potted_plant = "";
	evergreen_tree = "";
	deciduous_tree = "";
	palm_tree = "";
	cactus = "";
	ear_of_rice = "";
	herb = "";
	shamrock = "";
	four_leaf_clover = "";
	maple_leaf = "";
	fallen_leaf = "";
	leaves = "";
	grapes = "";
	melon = "";
	watermelon = "";
	tangerine = "";
	orange = "";
	mandarin = "";
	lemon = "";
	banana = "";
	pineapple = "";
	mango = "";
	apple = "";
	green_apple = "";
	pear = "";
	peach = "";
	cherries = "";
	strawberry = "";
	blueberries = "";
	kiwi_fruit = "";
	tomato = "";
	olive = "";
	coconut = "";
	avocado = "";
	eggplant = "";
	potato = "";
	carrot = "";
	corn = "";
	hot_pepper = "";
	bell_pepper = "";
	cucumber = "";
	leafy_green = "";
	broccoli = "";
	garlic = "";
	onion = "";
	mushroom = "";
	peanuts = "";
	chestnut = "";
	bread = "";
	croissant = "";
	baguette_bread = "";
	flatbread = "";
	pretzel = "";
	bagel = "";
	pancakes = "";
	waffle = "";
	cheese = "";
	meat_on_bone = "";
	poultry_leg = "";
	cut_of_meat = "";
	bacon = "";
	hamburger = "";
	fries = "";
	pizza = "";
	hotdog = "";
	sandwich = "";
	taco = "";
	burrito = "";
	tamale = "";
	stuffed_flatbread = "";
	falafel = "";
	egg = "";
	fried_egg = "";
	shallow_pan_of_food = "";
	stew = "";
	fondue = "";
	bowl_with_spoon = "";
	green_salad = "";
	popcorn = "";
	butter = "";
	salt = "";
	canned_food = "";
	bento = "";
	rice_cracker = "";
	rice_ball = "";
	rice = "";
	curry = "";
	ramen = "";
	spaghetti = "";
	sweet_potato = "";
	oden = "";
	sushi = "";
	fried_shrimp = "";
	fish_cake = "";
	moon_cake = "";
	dango = "";
	dumpling = "";
	fortune_cookie = "";
	takeout_box = "";
	crab = "";
	lobster = "";
	shrimp = "";
	squid = "";
	oyster = "";
	icecream = "";
	shaved_ice = "";
	ice_cream = "";
	doughnut = "";
	cookie = "";
	birthday = "";
	cake = "";
	cupcake = "";
	pie = "";
	chocolate_bar = "";
	candy = "";
	lollipop = "";
	custard = "";
	honey_pot = "";
	baby_bottle = "";
	milk_glass = "";
	teapot = "";
	tea = "";
	sake = "";
	champagne = "";
	wine_glass = "";
	cocktail = "";
	tropical_drink = "";
	beer = "";
	beers = "";
	clinking_glasses = "";
	tumbler_glass = "";
	cup_with_straw = "";
	bubble_tea = "";
	beverage_box = "";
	mate = "";
	ice_cube = "";
	chopsticks = "";
	plate_with_cutlery = "";
	fork_and_knife = "";
	spoon = "";
	hocho = "";
	knife = "";
	amphora = "";
	earth_africa = "";
	earth_americas = "";
	earth_asia = "";
	globe_with_meridians = "";
	world_map = "";
	japan = "";
	compass = "";
	mountain_snow = "";
	mountain = "";
	volcano = "";
	mount_fuji = "";
	camping = "";
	beach_umbrella = "";
	desert = "";
	desert_island = "";
	national_park = "";
	stadium = "";
	classical_building = "";
	building_construction = "";
	bricks = "";
	rock = "";
	wood = "";
	hut = "";
	houses = "";
	derelict_house = "";
	house = "";
	house_with_garden = "";
	office = "";
	post_office = "";
	european_post_office = "";
	hospital = "";
	bank = "";
	hotel = "";
	love_hotel = "";
	convenience_store = "";
	school = "";
	department_store = "";
	factory = "";
	japanese_castle = "";
	european_castle = "";
	wedding = "";
	tokyo_tower = "";
	statue_of_liberty = "";
	mosque = "";
	hindu_temple = "";
	synagogue = "";
	shinto_shrine = "";
	kaaba = "";
	foggy = "";
	night_with_stars = "";
	cityscape = "";
	sunrise_over_mountains = "";
	sunrise = "";
	city_sunset = "";
	city_sunrise = "";
	bridge_at_night = "";
	hotsprings = "";
	carousel_horse = "";
	ferris_wheel = "";
	roller_coaster = "";
	barber = "";
	circus_tent = "";
	steam_locomotive = "";
	railway_car = "";
	bullettrain_side = "";
	bullettrain_front = "";
	train2 = "";
	metro = "";
	light_rail = "";
	station = "";
	tram = "";
	monorail = "";
	mountain_railway = "";
	train = "";
	bus = "";
	oncoming_bus = "";
	trolleybus = "";
	minibus = "";
	ambulance = "";
	fire_engine = "";
	police_car = "";
	oncoming_police_car = "";
	taxi = "";
	oncoming_taxi = "";
	car = "";
	red_car = "";
	oncoming_automobile = "";
	blue_car = "";
	pickup_truck = "";
	truck = "";
	articulated_lorry = "";
	tractor = "";
	racing_car = "";
	motorcycle = "";
	motor_scooter = "";
	manual_wheelchair = "";
	motorized_wheelchair = "";
	auto_rickshaw = "";
	bike = "";
	kick_scooter = "";
	skateboard = "";
	roller_skate = "";
	busstop = "";
	motorway = "";
	railway_track = "";
	oil_drum = "";
	rotating_light = "";
	traffic_light = "";
	vertical_traffic_light = "";
	stop_sign = "";
	construction = "";
	canoe = "";
	speedboat = "";
	passenger_ship = "";
	ferry = "";
	motor_boat = "";
	ship = "";
	airplane = "";
	small_airplane = "";
	flight_departure = "";
	flight_arrival = "";
	parachute = "";
	seat = "";
	helicopter = "";
	suspension_railway = "";
	mountain_cableway = "";
	aerial_tramway = "";
	artificial_satellite = "";
	rocket = "";
	flying_saucer = "";
	bellhop_bell = "";
	luggage = "";
	stopwatch = "";
	timer_clock = "";
	mantelpiece_clock = "";
	clock12 = "";
	clock1230 = "";
	clock1 = "";
	clock130 = "";
	clock2 = "";
	clock230 = "";
	clock3 = "";
	clock330 = "";
	clock4 = "";
	clock430 = "";
	clock5 = "";
	clock530 = "";
	clock6 = "";
	clock630 = "";
	clock7 = "";
	clock730 = "";
	clock8 = "";
	clock830 = "";
	clock9 = "";
	clock930 = "";
	clock10 = "";
	clock1030 = "";
	clock11 = "";
	clock1130 = "";
	new_moon = "";
	waxing_crescent_moon = "";
	first_quarter_moon = "";
	moon = "";
	waxing_gibbous_moon = "";
	full_moon = "";
	waning_gibbous_moon = "";
	last_quarter_moon = "";
	waning_crescent_moon = "";
	crescent_moon = "";
	new_moon_with_face = "";
	first_quarter_moon_with_face = "";
	last_quarter_moon_with_face = "";
	thermometer = "";
	sunny = "";
	full_moon_with_face = "";
	sun_with_face = "";
	ringed_planet = "";
	star2 = "";
	stars = "";
	milky_way = "";
	cloud = "";
	cloud_with_lightning_and_rain = "";
	sun_behind_small_cloud = "";
	sun_behind_large_cloud = "";
	sun_behind_rain_cloud = "";
	cloud_with_rain = "";
	cloud_with_snow = "";
	cloud_with_lightning = "";
	tornado = "";
	fog = "";
	wind_face = "";
	cyclone = "";
	rainbow = "";
	closed_umbrella = "";
	open_umbrella = "";
	parasol_on_ground = "";
	snowflake = "";
	snowman_with_snow = "";
	comet = "";
	fire = "";
	droplet = "";
	ocean = "";
	jack_o_lantern = "";
	christmas_tree = "";
	fireworks = "";
	sparkler = "";
	firecracker = "";
	balloon = "";
	tada = "";
	confetti_ball = "";
	tanabata_tree = "";
	bamboo = "";
	dolls = "";
	flags = "";
	wind_chime = "";
	rice_scene = "";
	red_envelope = "";
	ribbon = "";
	gift = "";
	reminder_ribbon = "";
	tickets = "";
	ticket = "";
	medal_military = "";
	trophy = "";
	medal_sports = "";
	softball = "";
	basketball = "";
	volleyball = "";
	football = "";
	rugby_football = "";
	tennis = "";
	flying_disc = "";
	bowling = "";
	cricket_game = "";
	field_hockey = "";
	ice_hockey = "";
	lacrosse = "";
	ping_pong = "";
	badminton = "";
	boxing_glove = "";
	martial_arts_uniform = "";
	goal_net = "";
	ice_skate = "";
	fishing_pole_and_fish = "";
	diving_mask = "";
	running_shirt_with_sash = "";
	ski = "";
	sled = "";
	curling_stone = "";
	dart = "";
	yo_yo = "";
	kite = "";
	crystal_ball = "";
	magic_wand = "";
	nazar_amulet = "";
	video_game = "";
	joystick = "";
	slot_machine = "";
	game_die = "";
	jigsaw = "";
	teddy_bear = "";
	pinata = "";
	nesting_dolls = "";
	spades = "";
	hearts = "";
	diamonds = "";
	clubs = "";
	chess_pawn = "";
	black_joker = "";
	mahjong = "";
	flower_playing_cards = "";
	performing_arts = "";
	framed_picture = "";
	art = "";
	thread = "";
	sewing_needle = "";
	yarn = "";
	knot = "";
	eyeglasses = "";
	dark_sunglasses = "";
	goggles = "";
	lab_coat = "";
	safety_vest = "";
	necktie = "";
	shirt = "";
	tshirt = "";
	jeans = "";
	scarf = "";
	gloves = "";
	coat = "";
	socks = "";
	dress = "";
	kimono = "";
	sari = "";
	one_piece_swimsuit = "";
	swim_brief = "";
	shorts = "";
	bikini = "";
	womans_clothes = "";
	purse = "";
	handbag = "";
	pouch = "";
	shopping = "";
	school_satchel = "";
	thong_sandal = "";
	mans_shoe = "";
	shoe = "";
	athletic_shoe = "";
	hiking_boot = "";
	flat_shoe = "";
	high_heel = "";
	sandal = "";
	ballet_shoes = "";
	boot = "";
	crown = "";
	womans_hat = "";
	tophat = "";
	mortar_board = "";
	billed_cap = "";
	military_helmet = "";
	rescue_worker_helmet = "";
	prayer_beads = "";
	lipstick = "";
	ring = "";
	gem = "";
	mute = "";
	speaker = "";
	sound = "";
	loud_sound = "";
	loudspeaker = "";
	mega = "";
	postal_horn = "";
	bell = "";
	no_bell = "";
	musical_score = "";
	musical_note = "";
	notes = "";
	studio_microphone = "";
	level_slider = "";
	control_knobs = "";
	microphone = "";
	headphones = "";
	radio = "";
	saxophone = "";
	accordion = "";
	guitar = "";
	musical_keyboard = "";
	trumpet = "";
	violin = "";
	banjo = "";
	drum = "";
	long_drum = "";
	iphone = "";
	calling = "";
	phone = "";
	telephone = "";
	telephone_receiver = "";
	pager = "";
	fax = "";
	battery = "";
	electric_plug = "";
	computer = "";
	desktop_computer = "";
	printer = "";
	keyboard = "";
	computer_mouse = "";
	trackball = "";
	minidisc = "";
	floppy_disk = "";
	cd = "";
	dvd = "";
	abacus = "";
	movie_camera = "";
	film_strip = "";
	film_projector = "";
	clapper = "";
	tv = "";
	camera = "";
	camera_flash = "";
	video_camera = "";
	vhs = "";
	mag = "";
	mag_right = "";
	candle = "";
	bulb = "";
	flashlight = "";
	izakaya_lantern = "";
	lantern = "";
	diya_lamp = "";
	notebook_with_decorative_cover = "";
	closed_book = "";
	book = "";
	open_book = "";
	green_book = "";
	blue_book = "";
	orange_book = "";
	books = "";
	notebook = "";
	ledger = "";
	page_with_curl = "";
	scroll = "";
	page_facing_up = "";
	newspaper = "";
	newspaper_roll = "";
	bookmark_tabs = "";
	bookmark = "";
	label$1 = "";
	moneybag = "";
	coin = "";
	yen = "";
	dollar = "";
	euro = "";
	pound = "";
	money_with_wings = "";
	credit_card = "";
	receipt = "";
	chart = "";
	envelope = "";
	email = "";
	incoming_envelope = "";
	envelope_with_arrow = "";
	outbox_tray = "";
	inbox_tray = "";
	mailbox = "";
	mailbox_closed = "";
	mailbox_with_mail = "";
	mailbox_with_no_mail = "";
	postbox = "";
	ballot_box = "";
	pencil2 = "";
	black_nib = "";
	fountain_pen = "";
	pen = "";
	paintbrush = "";
	crayon = "";
	memo$1 = "";
	pencil = "";
	briefcase = "";
	file_folder = "";
	open_file_folder = "";
	card_index_dividers = "";
	date = "";
	calendar = "";
	spiral_notepad = "";
	spiral_calendar = "";
	card_index = "";
	chart_with_upwards_trend = "";
	chart_with_downwards_trend = "";
	bar_chart = "";
	clipboard = "";
	pushpin = "";
	round_pushpin = "";
	paperclip = "";
	paperclips = "";
	straight_ruler = "";
	triangular_ruler = "";
	scissors = "";
	card_file_box = "";
	file_cabinet = "";
	wastebasket = "";
	lock = "";
	unlock = "";
	lock_with_ink_pen = "";
	closed_lock_with_key = "";
	key = "";
	old_key = "";
	hammer = "";
	axe = "";
	pick = "";
	hammer_and_pick = "";
	hammer_and_wrench = "";
	dagger = "";
	crossed_swords = "";
	gun = "";
	boomerang = "";
	bow_and_arrow = "";
	shield = "";
	carpentry_saw = "";
	wrench = "";
	screwdriver = "";
	nut_and_bolt = "";
	gear = "";
	clamp = "";
	balance_scale = "";
	probing_cane = "";
	link$1 = "";
	chains = "";
	hook = "";
	toolbox = "";
	magnet = "";
	ladder = "";
	alembic = "";
	test_tube = "";
	petri_dish = "";
	dna = "";
	microscope = "";
	telescope = "";
	satellite = "";
	syringe = "";
	drop_of_blood = "";
	pill = "";
	adhesive_bandage = "";
	stethoscope = "";
	door = "";
	elevator = "";
	mirror = "";
	window$1 = "";
	bed = "";
	couch_and_lamp = "";
	chair = "";
	toilet = "";
	plunger = "";
	shower = "";
	bathtub = "";
	mouse_trap = "";
	razor = "";
	lotion_bottle = "";
	safety_pin = "";
	broom = "";
	basket = "";
	roll_of_paper = "";
	bucket = "";
	soap = "";
	toothbrush = "";
	sponge = "";
	fire_extinguisher = "";
	shopping_cart = "";
	smoking = "";
	coffin = "";
	headstone = "";
	funeral_urn = "";
	moyai = "";
	placard = "";
	atm = "";
	put_litter_in_its_place = "";
	potable_water = "";
	mens = "";
	womens = "";
	restroom = "";
	baby_symbol = "";
	wc = "";
	passport_control = "";
	customs = "";
	baggage_claim = "";
	left_luggage = "";
	warning$1 = "";
	children_crossing = "";
	no_entry_sign = "";
	no_bicycles = "";
	no_smoking = "";
	do_not_litter = "";
	no_pedestrians = "";
	no_mobile_phones = "";
	underage = "";
	radioactive = "";
	biohazard = "";
	arrow_up = "";
	arrow_upper_right = "";
	arrow_right = "";
	arrow_lower_right = "";
	arrow_down = "";
	arrow_lower_left = "";
	arrow_left = "";
	arrow_upper_left = "";
	arrow_up_down = "";
	left_right_arrow = "";
	leftwards_arrow_with_hook = "";
	arrow_right_hook = "";
	arrow_heading_up = "";
	arrow_heading_down = "";
	arrows_clockwise = "";
	arrows_counterclockwise = "";
	back$1 = "";
	end = "";
	on = "";
	soon = "";
	top$1 = "";
	place_of_worship = "";
	atom_symbol = "";
	om = "";
	star_of_david = "";
	wheel_of_dharma = "";
	yin_yang = "";
	latin_cross = "";
	orthodox_cross = "";
	star_and_crescent = "";
	peace_symbol = "";
	menorah = "";
	six_pointed_star = "";
	twisted_rightwards_arrows = "";
	repeat = "";
	repeat_one = "";
	arrow_forward = "";
	next_track_button = "";
	play_or_pause_button = "";
	arrow_backward = "";
	previous_track_button = "";
	arrow_up_small = "";
	arrow_down_small = "";
	pause_button = "";
	stop_button = "";
	record_button = "";
	eject_button = "";
	cinema = "";
	low_brightness = "";
	high_brightness = "";
	signal_strength = "";
	vibration_mode = "";
	mobile_phone_off = "";
	female_sign = "";
	male_sign = "";
	transgender_symbol = "";
	heavy_multiplication_x = "";
	infinity = "";
	bangbang = "";
	interrobang = "";
	wavy_dash = "";
	currency_exchange = "";
	heavy_dollar_sign = "";
	medical_symbol = "";
	recycle = "";
	fleur_de_lis = "";
	trident = "";
	name_badge = "";
	beginner = "";
	ballot_box_with_check = "";
	heavy_check_mark = "";
	part_alternation_mark = "";
	eight_spoked_asterisk = "";
	eight_pointed_black_star = "";
	sparkle = "";
	copyright = "";
	registered = "";
	tm = "";
	hash = "#";
	asterisk = "*";
	zero = "0";
	one = "1";
	two = "2";
	three = "3";
	four = "4";
	five = "5";
	six = "6";
	seven = "7";
	eight = "8";
	nine = "9";
	keycap_ten = "";
	capital_abcd = "";
	abcd = "";
	symbols = "";
	abc = "";
	a = "";
	ab = "";
	b = "";
	cl = "";
	cool = "";
	free = "";
	information_source = "";
	id = "";
	m = "";
	ng = "";
	o2 = "";
	ok = "";
	parking = "";
	sos = "";
	up = "";
	vs = "";
	koko = "";
	sa = "";
	ideograph_advantage = "";
	accept = "";
	congratulations = "";
	secret = "";
	u6e80 = "";
	red_circle = "";
	orange_circle = "";
	yellow_circle = "";
	green_circle = "";
	large_blue_circle = "";
	purple_circle = "";
	brown_circle = "";
	red_square = "";
	orange_square = "";
	yellow_square = "";
	green_square = "";
	blue_square = "";
	purple_square = "";
	brown_square = "";
	black_medium_square = "";
	white_medium_square = "";
	black_small_square = "";
	white_small_square = "";
	large_orange_diamond = "";
	large_blue_diamond = "";
	small_orange_diamond = "";
	small_blue_diamond = "";
	small_red_triangle = "";
	small_red_triangle_down = "";
	diamond_shape_with_a_dot_inside = "";
	radio_button = "";
	white_square_button = "";
	black_square_button = "";
	checkered_flag = "";
	triangular_flag_on_post = "";
	crossed_flags = "";
	black_flag = "";
	white_flag = "";
	rainbow_flag = "";
	transgender_flag = "";
	pirate_flag = "";
	ascension_island = "";
	andorra = "";
	united_arab_emirates = "";
	afghanistan = "";
	antigua_barbuda = "";
	anguilla = "";
	albania = "";
	armenia = "";
	angola = "";
	antarctica = "";
	argentina = "";
	american_samoa = "";
	austria = "";
	australia = "";
	aruba = "";
	aland_islands = "";
	azerbaijan = "";
	bosnia_herzegovina = "";
	barbados = "";
	bangladesh = "";
	belgium = "";
	burkina_faso = "";
	bulgaria = "";
	bahrain = "";
	burundi = "";
	benin = "";
	st_barthelemy = "";
	bermuda = "";
	brunei = "";
	bolivia = "";
	caribbean_netherlands = "";
	brazil = "";
	bahamas = "";
	bhutan = "";
	bouvet_island = "";
	botswana = "";
	belarus = "";
	belize = "";
	canada = "";
	cocos_islands = "";
	congo_kinshasa = "";
	central_african_republic = "";
	congo_brazzaville = "";
	switzerland = "";
	cote_divoire = "";
	cook_islands = "";
	chile = "";
	cameroon = "";
	cn = "";
	colombia = "";
	clipperton_island = "";
	costa_rica = "";
	cuba = "";
	cape_verde = "";
	curacao = "";
	christmas_island = "";
	cyprus = "";
	czech_republic = "";
	de = "";
	diego_garcia = "";
	djibouti = "";
	denmark = "";
	dominica = "";
	dominican_republic = "";
	algeria = "";
	ceuta_melilla = "";
	ecuador = "";
	estonia = "";
	egypt = "";
	western_sahara = "";
	eritrea = "";
	es = "";
	ethiopia = "";
	eu = "";
	european_union = "";
	finland = "";
	fiji = "";
	falkland_islands = "";
	micronesia = "";
	faroe_islands = "";
	fr = "";
	gabon = "";
	gb = "";
	uk = "";
	grenada = "";
	georgia = "";
	french_guiana = "";
	guernsey = "";
	ghana = "";
	gibraltar = "";
	greenland = "";
	gambia = "";
	guinea = "";
	guadeloupe = "";
	equatorial_guinea = "";
	greece = "";
	south_georgia_south_sandwich_islands = "";
	guatemala = "";
	guam = "";
	guinea_bissau = "";
	guyana = "";
	hong_kong = "";
	heard_mcdonald_islands = "";
	honduras = "";
	croatia = "";
	haiti = "";
	hungary = "";
	canary_islands = "";
	indonesia = "";
	ireland = "";
	israel = "";
	isle_of_man = "";
	india = "";
	british_indian_ocean_territory = "";
	iraq = "";
	iran = "";
	iceland = "";
	it = "";
	jersey = "";
	jamaica = "";
	jordan = "";
	jp = "";
	kenya = "";
	kyrgyzstan = "";
	cambodia = "";
	kiribati = "";
	comoros = "";
	st_kitts_nevis = "";
	north_korea = "";
	kr = "";
	kuwait = "";
	cayman_islands = "";
	kazakhstan = "";
	laos = "";
	lebanon = "";
	st_lucia = "";
	liechtenstein = "";
	sri_lanka = "";
	liberia = "";
	lesotho = "";
	lithuania = "";
	luxembourg = "";
	latvia = "";
	libya = "";
	morocco = "";
	monaco = "";
	moldova = "";
	montenegro = "";
	st_martin = "";
	madagascar = "";
	marshall_islands = "";
	macedonia = "";
	mali = "";
	myanmar = "";
	mongolia = "";
	macau = "";
	northern_mariana_islands = "";
	martinique = "";
	mauritania = "";
	montserrat = "";
	malta = "";
	mauritius = "";
	maldives = "";
	malawi = "";
	mexico = "";
	malaysia = "";
	mozambique = "";
	namibia = "";
	new_caledonia = "";
	niger = "";
	norfolk_island = "";
	nigeria = "";
	nicaragua = "";
	netherlands = "";
	norway = "";
	nepal = "";
	nauru = "";
	niue = "";
	new_zealand = "";
	oman = "";
	panama = "";
	peru = "";
	french_polynesia = "";
	papua_new_guinea = "";
	philippines = "";
	pakistan = "";
	poland = "";
	st_pierre_miquelon = "";
	pitcairn_islands = "";
	puerto_rico = "";
	palestinian_territories = "";
	portugal = "";
	palau = "";
	paraguay = "";
	qatar = "";
	reunion = "";
	romania = "";
	serbia = "";
	ru = "";
	rwanda = "";
	saudi_arabia = "";
	solomon_islands = "";
	seychelles = "";
	sudan = "";
	sweden = "";
	singapore = "";
	st_helena = "";
	slovenia = "";
	svalbard_jan_mayen = "";
	slovakia = "";
	sierra_leone = "";
	san_marino = "";
	senegal = "";
	somalia = "";
	suriname = "";
	south_sudan = "";
	sao_tome_principe = "";
	el_salvador = "";
	sint_maarten = "";
	syria = "";
	swaziland = "";
	tristan_da_cunha = "";
	turks_caicos_islands = "";
	chad = "";
	french_southern_territories = "";
	togo = "";
	thailand = "";
	tajikistan = "";
	tokelau = "";
	timor_leste = "";
	turkmenistan = "";
	tunisia = "";
	tonga = "";
	tr = "";
	trinidad_tobago = "";
	tuvalu = "";
	taiwan = "";
	tanzania = "";
	ukraine = "";
	uganda = "";
	us_outlying_islands = "";
	united_nations = "";
	us = "";
	uruguay = "";
	uzbekistan = "";
	vatican_city = "";
	st_vincent_grenadines = "";
	venezuela = "";
	british_virgin_islands = "";
	us_virgin_islands = "";
	vietnam = "";
	vanuatu = "";
	wallis_futuna = "";
	samoa = "";
	kosovo = "";
	yemen = "";
	mayotte = "";
	south_africa = "";
	zambia = "";
	zimbabwe = "";
	england = "";
	scotland = "";
	wales = "";
	full_default = {
		"100": "",
		"1234": "",
		grinning,
		smiley,
		smile,
		grin,
		laughing,
		satisfied,
		sweat_smile,
		rofl,
		joy,
		slightly_smiling_face,
		upside_down_face,
		wink,
		blush,
		innocent,
		smiling_face_with_three_hearts,
		heart_eyes,
		star_struck,
		kissing_heart,
		kissing,
		relaxed,
		kissing_closed_eyes,
		kissing_smiling_eyes,
		smiling_face_with_tear,
		yum,
		stuck_out_tongue,
		stuck_out_tongue_winking_eye,
		zany_face,
		stuck_out_tongue_closed_eyes,
		money_mouth_face,
		hugs,
		hand_over_mouth,
		shushing_face,
		thinking,
		zipper_mouth_face,
		raised_eyebrow,
		neutral_face,
		expressionless,
		no_mouth,
		smirk,
		unamused,
		roll_eyes,
		grimacing,
		lying_face,
		relieved,
		pensive,
		sleepy,
		drooling_face,
		sleeping,
		mask,
		face_with_thermometer,
		face_with_head_bandage,
		nauseated_face,
		vomiting_face,
		sneezing_face,
		hot_face,
		cold_face,
		woozy_face,
		dizzy_face,
		exploding_head,
		cowboy_hat_face,
		partying_face,
		disguised_face,
		sunglasses,
		nerd_face,
		monocle_face,
		confused,
		worried,
		slightly_frowning_face,
		frowning_face,
		open_mouth,
		hushed,
		astonished,
		flushed,
		pleading_face,
		frowning,
		anguished,
		fearful,
		cold_sweat,
		disappointed_relieved,
		cry,
		sob,
		scream,
		confounded,
		persevere,
		disappointed,
		sweat,
		weary,
		tired_face,
		yawning_face,
		triumph,
		rage,
		pout,
		angry,
		cursing_face,
		smiling_imp,
		imp,
		skull,
		skull_and_crossbones,
		hankey,
		poop,
		shit,
		clown_face,
		japanese_ogre,
		japanese_goblin,
		ghost: ghost$1,
		alien,
		space_invader,
		robot,
		smiley_cat,
		smile_cat,
		joy_cat,
		heart_eyes_cat,
		smirk_cat,
		kissing_cat,
		scream_cat,
		crying_cat_face,
		pouting_cat,
		see_no_evil,
		hear_no_evil,
		speak_no_evil,
		kiss,
		love_letter,
		cupid,
		gift_heart,
		sparkling_heart,
		heartpulse,
		heartbeat,
		revolving_hearts,
		two_hearts,
		heart_decoration,
		heavy_heart_exclamation,
		broken_heart,
		heart,
		orange_heart,
		yellow_heart,
		green_heart,
		blue_heart,
		purple_heart,
		brown_heart,
		black_heart,
		white_heart,
		anger,
		boom,
		collision,
		dizzy,
		sweat_drops,
		dash,
		hole,
		bomb,
		speech_balloon,
		eye_speech_bubble,
		left_speech_bubble,
		right_anger_bubble,
		thought_balloon,
		zzz,
		wave,
		raised_back_of_hand,
		raised_hand_with_fingers_splayed,
		hand: "",
		raised_hand: "",
		vulcan_salute,
		ok_hand,
		pinched_fingers,
		pinching_hand,
		v,
		crossed_fingers,
		love_you_gesture,
		metal,
		call_me_hand,
		point_left,
		point_right,
		point_up_2,
		middle_finger,
		fu,
		point_down,
		point_up,
		"+1": "",
		thumbsup,
		"-1": "",
		thumbsdown,
		fist_raised: "",
		fist: "",
		fist_oncoming,
		facepunch,
		punch,
		fist_left,
		fist_right,
		clap,
		raised_hands,
		open_hands,
		palms_up_together,
		handshake,
		pray,
		writing_hand,
		nail_care,
		selfie,
		muscle,
		mechanical_arm,
		mechanical_leg,
		leg,
		foot,
		ear,
		ear_with_hearing_aid,
		nose,
		brain,
		anatomical_heart,
		lungs,
		tooth,
		bone,
		eyes,
		eye,
		tongue,
		lips,
		baby,
		child,
		boy,
		girl,
		adult,
		blond_haired_person,
		man,
		bearded_person,
		red_haired_man,
		curly_haired_man,
		white_haired_man,
		bald_man,
		woman,
		red_haired_woman,
		person_red_hair,
		curly_haired_woman,
		person_curly_hair,
		white_haired_woman,
		person_white_hair,
		bald_woman,
		person_bald,
		blond_haired_woman,
		blonde_woman,
		blond_haired_man,
		older_adult,
		older_man,
		older_woman,
		frowning_person,
		frowning_man,
		frowning_woman,
		pouting_face,
		pouting_man,
		pouting_woman,
		no_good,
		no_good_man,
		ng_man,
		no_good_woman,
		ng_woman,
		ok_person,
		ok_man,
		ok_woman,
		tipping_hand_person,
		information_desk_person,
		tipping_hand_man,
		sassy_man,
		tipping_hand_woman,
		sassy_woman,
		raising_hand,
		raising_hand_man,
		raising_hand_woman,
		deaf_person,
		deaf_man,
		deaf_woman,
		bow,
		bowing_man,
		bowing_woman,
		facepalm,
		man_facepalming,
		woman_facepalming,
		shrug,
		man_shrugging,
		woman_shrugging,
		health_worker,
		man_health_worker,
		woman_health_worker,
		student,
		man_student,
		woman_student,
		teacher,
		man_teacher,
		woman_teacher,
		judge,
		man_judge,
		woman_judge,
		farmer,
		man_farmer,
		woman_farmer,
		cook,
		man_cook,
		woman_cook,
		mechanic,
		man_mechanic,
		woman_mechanic,
		factory_worker,
		man_factory_worker,
		woman_factory_worker,
		office_worker,
		man_office_worker,
		woman_office_worker,
		scientist,
		man_scientist,
		woman_scientist,
		technologist,
		man_technologist,
		woman_technologist,
		singer,
		man_singer,
		woman_singer,
		artist,
		man_artist,
		woman_artist,
		pilot,
		man_pilot,
		woman_pilot,
		astronaut,
		man_astronaut,
		woman_astronaut,
		firefighter,
		man_firefighter,
		woman_firefighter,
		police_officer,
		cop,
		policeman,
		policewoman,
		detective,
		male_detective,
		female_detective,
		guard,
		guardsman,
		guardswoman,
		ninja,
		construction_worker,
		construction_worker_man,
		construction_worker_woman,
		prince,
		princess,
		person_with_turban,
		man_with_turban,
		woman_with_turban,
		man_with_gua_pi_mao,
		woman_with_headscarf,
		person_in_tuxedo,
		man_in_tuxedo,
		woman_in_tuxedo,
		person_with_veil,
		man_with_veil,
		woman_with_veil,
		bride_with_veil,
		pregnant_woman,
		breast_feeding,
		woman_feeding_baby,
		man_feeding_baby,
		person_feeding_baby,
		angel,
		santa,
		mrs_claus,
		mx_claus,
		superhero,
		superhero_man,
		superhero_woman,
		supervillain,
		supervillain_man,
		supervillain_woman,
		mage,
		mage_man,
		mage_woman,
		fairy,
		fairy_man,
		fairy_woman,
		vampire,
		vampire_man,
		vampire_woman,
		merperson,
		merman,
		mermaid,
		elf,
		elf_man,
		elf_woman,
		genie,
		genie_man,
		genie_woman,
		zombie,
		zombie_man,
		zombie_woman,
		massage,
		massage_man,
		massage_woman,
		haircut,
		haircut_man,
		haircut_woman,
		walking,
		walking_man,
		walking_woman,
		standing_person,
		standing_man,
		standing_woman,
		kneeling_person,
		kneeling_man,
		kneeling_woman,
		person_with_probing_cane,
		man_with_probing_cane,
		woman_with_probing_cane,
		person_in_motorized_wheelchair,
		man_in_motorized_wheelchair,
		woman_in_motorized_wheelchair,
		person_in_manual_wheelchair,
		man_in_manual_wheelchair,
		woman_in_manual_wheelchair,
		runner,
		running,
		running_man,
		running_woman,
		woman_dancing,
		dancer,
		man_dancing,
		business_suit_levitating,
		dancers,
		dancing_men,
		dancing_women,
		sauna_person,
		sauna_man,
		sauna_woman,
		climbing,
		climbing_man,
		climbing_woman,
		person_fencing,
		horse_racing,
		skier,
		snowboarder,
		golfing,
		golfing_man,
		golfing_woman,
		surfer,
		surfing_man,
		surfing_woman,
		rowboat,
		rowing_man,
		rowing_woman,
		swimmer,
		swimming_man,
		swimming_woman,
		bouncing_ball_person,
		bouncing_ball_man,
		basketball_man,
		bouncing_ball_woman,
		basketball_woman,
		weight_lifting,
		weight_lifting_man,
		weight_lifting_woman,
		bicyclist,
		biking_man,
		biking_woman,
		mountain_bicyclist,
		mountain_biking_man,
		mountain_biking_woman,
		cartwheeling,
		man_cartwheeling,
		woman_cartwheeling,
		wrestling,
		men_wrestling,
		women_wrestling,
		water_polo,
		man_playing_water_polo,
		woman_playing_water_polo,
		handball_person,
		man_playing_handball,
		woman_playing_handball,
		juggling_person,
		man_juggling,
		woman_juggling,
		lotus_position,
		lotus_position_man,
		lotus_position_woman,
		bath,
		sleeping_bed,
		people_holding_hands,
		two_women_holding_hands,
		couple,
		two_men_holding_hands,
		couplekiss,
		couplekiss_man_woman,
		couplekiss_man_man,
		couplekiss_woman_woman,
		couple_with_heart,
		couple_with_heart_woman_man,
		couple_with_heart_man_man,
		couple_with_heart_woman_woman,
		family,
		family_man_woman_boy,
		family_man_woman_girl,
		family_man_woman_girl_boy,
		family_man_woman_boy_boy,
		family_man_woman_girl_girl,
		family_man_man_boy,
		family_man_man_girl,
		family_man_man_girl_boy,
		family_man_man_boy_boy,
		family_man_man_girl_girl,
		family_woman_woman_boy,
		family_woman_woman_girl,
		family_woman_woman_girl_boy,
		family_woman_woman_boy_boy,
		family_woman_woman_girl_girl,
		family_man_boy,
		family_man_boy_boy,
		family_man_girl,
		family_man_girl_boy,
		family_man_girl_girl,
		family_woman_boy,
		family_woman_boy_boy,
		family_woman_girl,
		family_woman_girl_boy,
		family_woman_girl_girl,
		speaking_head,
		bust_in_silhouette,
		busts_in_silhouette,
		people_hugging,
		footprints,
		monkey_face,
		monkey,
		gorilla,
		orangutan,
		dog,
		dog2,
		guide_dog,
		service_dog,
		poodle,
		wolf,
		fox_face,
		raccoon,
		cat,
		cat2,
		black_cat,
		lion,
		tiger,
		tiger2,
		leopard,
		horse,
		racehorse,
		unicorn,
		zebra,
		deer,
		bison,
		cow,
		ox,
		water_buffalo,
		cow2,
		pig,
		pig2,
		boar,
		pig_nose,
		ram,
		sheep,
		goat,
		dromedary_camel,
		camel,
		llama,
		giraffe,
		elephant,
		mammoth,
		rhinoceros,
		hippopotamus,
		mouse,
		mouse2,
		rat,
		hamster,
		rabbit,
		rabbit2,
		chipmunk,
		beaver,
		hedgehog,
		bat,
		bear,
		polar_bear,
		koala,
		panda_face,
		sloth,
		otter,
		skunk,
		kangaroo,
		badger,
		feet,
		paw_prints,
		turkey,
		chicken,
		rooster,
		hatching_chick,
		baby_chick,
		hatched_chick,
		bird,
		penguin,
		dove,
		eagle,
		duck,
		swan,
		owl,
		dodo,
		feather,
		flamingo,
		peacock,
		parrot,
		frog,
		crocodile,
		turtle,
		lizard,
		snake,
		dragon_face,
		dragon,
		sauropod,
		"t-rex": "",
		whale,
		whale2,
		dolphin,
		flipper,
		seal,
		fish,
		tropical_fish,
		blowfish,
		shark,
		octopus,
		shell,
		snail,
		butterfly,
		bug,
		ant,
		bee,
		honeybee,
		beetle,
		lady_beetle,
		cricket,
		cockroach,
		spider,
		spider_web,
		scorpion,
		mosquito,
		fly,
		worm,
		microbe,
		bouquet,
		cherry_blossom,
		white_flower,
		rosette,
		rose,
		wilted_flower,
		hibiscus,
		sunflower,
		blossom,
		tulip,
		seedling,
		potted_plant,
		evergreen_tree,
		deciduous_tree,
		palm_tree,
		cactus,
		ear_of_rice,
		herb,
		shamrock,
		four_leaf_clover,
		maple_leaf,
		fallen_leaf,
		leaves,
		grapes,
		melon,
		watermelon,
		tangerine,
		orange,
		mandarin,
		lemon,
		banana,
		pineapple,
		mango,
		apple,
		green_apple,
		pear,
		peach,
		cherries,
		strawberry,
		blueberries,
		kiwi_fruit,
		tomato,
		olive,
		coconut,
		avocado,
		eggplant,
		potato,
		carrot,
		corn,
		hot_pepper,
		bell_pepper,
		cucumber,
		leafy_green,
		broccoli,
		garlic,
		onion,
		mushroom,
		peanuts,
		chestnut,
		bread,
		croissant,
		baguette_bread,
		flatbread,
		pretzel,
		bagel,
		pancakes,
		waffle,
		cheese,
		meat_on_bone,
		poultry_leg,
		cut_of_meat,
		bacon,
		hamburger,
		fries,
		pizza,
		hotdog,
		sandwich,
		taco,
		burrito,
		tamale,
		stuffed_flatbread,
		falafel,
		egg,
		fried_egg,
		shallow_pan_of_food,
		stew,
		fondue,
		bowl_with_spoon,
		green_salad,
		popcorn,
		butter,
		salt,
		canned_food,
		bento,
		rice_cracker,
		rice_ball,
		rice,
		curry,
		ramen,
		spaghetti,
		sweet_potato,
		oden,
		sushi,
		fried_shrimp,
		fish_cake,
		moon_cake,
		dango,
		dumpling,
		fortune_cookie,
		takeout_box,
		crab,
		lobster,
		shrimp,
		squid,
		oyster,
		icecream,
		shaved_ice,
		ice_cream,
		doughnut,
		cookie,
		birthday,
		cake,
		cupcake,
		pie,
		chocolate_bar,
		candy,
		lollipop,
		custard,
		honey_pot,
		baby_bottle,
		milk_glass,
		coffee: "",
		teapot,
		tea,
		sake,
		champagne,
		wine_glass,
		cocktail,
		tropical_drink,
		beer,
		beers,
		clinking_glasses,
		tumbler_glass,
		cup_with_straw,
		bubble_tea,
		beverage_box,
		mate,
		ice_cube,
		chopsticks,
		plate_with_cutlery,
		fork_and_knife,
		spoon,
		hocho,
		knife,
		amphora,
		earth_africa,
		earth_americas,
		earth_asia,
		globe_with_meridians,
		world_map,
		japan,
		compass,
		mountain_snow,
		mountain,
		volcano,
		mount_fuji,
		camping,
		beach_umbrella,
		desert,
		desert_island,
		national_park,
		stadium,
		classical_building,
		building_construction,
		bricks,
		rock,
		wood,
		hut,
		houses,
		derelict_house,
		house,
		house_with_garden,
		office,
		post_office,
		european_post_office,
		hospital,
		bank,
		hotel,
		love_hotel,
		convenience_store,
		school,
		department_store,
		factory,
		japanese_castle,
		european_castle,
		wedding,
		tokyo_tower,
		statue_of_liberty,
		church: "",
		mosque,
		hindu_temple,
		synagogue,
		shinto_shrine,
		kaaba,
		fountain: "",
		tent: "",
		foggy,
		night_with_stars,
		cityscape,
		sunrise_over_mountains,
		sunrise,
		city_sunset,
		city_sunrise,
		bridge_at_night,
		hotsprings,
		carousel_horse,
		ferris_wheel,
		roller_coaster,
		barber,
		circus_tent,
		steam_locomotive,
		railway_car,
		bullettrain_side,
		bullettrain_front,
		train2,
		metro,
		light_rail,
		station,
		tram,
		monorail,
		mountain_railway,
		train,
		bus,
		oncoming_bus,
		trolleybus,
		minibus,
		ambulance,
		fire_engine,
		police_car,
		oncoming_police_car,
		taxi,
		oncoming_taxi,
		car,
		red_car,
		oncoming_automobile,
		blue_car,
		pickup_truck,
		truck,
		articulated_lorry,
		tractor,
		racing_car,
		motorcycle,
		motor_scooter,
		manual_wheelchair,
		motorized_wheelchair,
		auto_rickshaw,
		bike,
		kick_scooter,
		skateboard,
		roller_skate,
		busstop,
		motorway,
		railway_track,
		oil_drum,
		fuelpump: "",
		rotating_light,
		traffic_light,
		vertical_traffic_light,
		stop_sign,
		construction,
		anchor: "",
		boat: "",
		sailboat: "",
		canoe,
		speedboat,
		passenger_ship,
		ferry,
		motor_boat,
		ship,
		airplane,
		small_airplane,
		flight_departure,
		flight_arrival,
		parachute,
		seat,
		helicopter,
		suspension_railway,
		mountain_cableway,
		aerial_tramway,
		artificial_satellite,
		rocket,
		flying_saucer,
		bellhop_bell,
		luggage,
		hourglass: "",
		hourglass_flowing_sand: "",
		watch: "",
		alarm_clock: "",
		stopwatch,
		timer_clock,
		mantelpiece_clock,
		clock12,
		clock1230,
		clock1,
		clock130,
		clock2,
		clock230,
		clock3,
		clock330,
		clock4,
		clock430,
		clock5,
		clock530,
		clock6,
		clock630,
		clock7,
		clock730,
		clock8,
		clock830,
		clock9,
		clock930,
		clock10,
		clock1030,
		clock11,
		clock1130,
		new_moon,
		waxing_crescent_moon,
		first_quarter_moon,
		moon,
		waxing_gibbous_moon,
		full_moon,
		waning_gibbous_moon,
		last_quarter_moon,
		waning_crescent_moon,
		crescent_moon,
		new_moon_with_face,
		first_quarter_moon_with_face,
		last_quarter_moon_with_face,
		thermometer,
		sunny,
		full_moon_with_face,
		sun_with_face,
		ringed_planet,
		star: "",
		star2,
		stars,
		milky_way,
		cloud,
		partly_sunny: "",
		cloud_with_lightning_and_rain,
		sun_behind_small_cloud,
		sun_behind_large_cloud,
		sun_behind_rain_cloud,
		cloud_with_rain,
		cloud_with_snow,
		cloud_with_lightning,
		tornado,
		fog,
		wind_face,
		cyclone,
		rainbow,
		closed_umbrella,
		open_umbrella,
		umbrella: "",
		parasol_on_ground,
		zap: "",
		snowflake,
		snowman_with_snow,
		snowman: "",
		comet,
		fire,
		droplet,
		ocean,
		jack_o_lantern,
		christmas_tree,
		fireworks,
		sparkler,
		firecracker,
		sparkles: "",
		balloon,
		tada,
		confetti_ball,
		tanabata_tree,
		bamboo,
		dolls,
		flags,
		wind_chime,
		rice_scene,
		red_envelope,
		ribbon,
		gift,
		reminder_ribbon,
		tickets,
		ticket,
		medal_military,
		trophy,
		medal_sports,
		"1st_place_medal": "",
		"2nd_place_medal": "",
		"3rd_place_medal": "",
		soccer: "",
		baseball: "",
		softball,
		basketball,
		volleyball,
		football,
		rugby_football,
		tennis,
		flying_disc,
		bowling,
		cricket_game,
		field_hockey,
		ice_hockey,
		lacrosse,
		ping_pong,
		badminton,
		boxing_glove,
		martial_arts_uniform,
		goal_net,
		golf: "",
		ice_skate,
		fishing_pole_and_fish,
		diving_mask,
		running_shirt_with_sash,
		ski,
		sled,
		curling_stone,
		dart,
		yo_yo,
		kite,
		"8ball": "",
		crystal_ball,
		magic_wand,
		nazar_amulet,
		video_game,
		joystick,
		slot_machine,
		game_die,
		jigsaw,
		teddy_bear,
		pinata,
		nesting_dolls,
		spades,
		hearts,
		diamonds,
		clubs,
		chess_pawn,
		black_joker,
		mahjong,
		flower_playing_cards,
		performing_arts,
		framed_picture,
		art,
		thread,
		sewing_needle,
		yarn,
		knot,
		eyeglasses,
		dark_sunglasses,
		goggles,
		lab_coat,
		safety_vest,
		necktie,
		shirt,
		tshirt,
		jeans,
		scarf,
		gloves,
		coat,
		socks,
		dress,
		kimono,
		sari,
		one_piece_swimsuit,
		swim_brief,
		shorts,
		bikini,
		womans_clothes,
		purse,
		handbag,
		pouch,
		shopping,
		school_satchel,
		thong_sandal,
		mans_shoe,
		shoe,
		athletic_shoe,
		hiking_boot,
		flat_shoe,
		high_heel,
		sandal,
		ballet_shoes,
		boot,
		crown,
		womans_hat,
		tophat,
		mortar_board,
		billed_cap,
		military_helmet,
		rescue_worker_helmet,
		prayer_beads,
		lipstick,
		ring,
		gem,
		mute,
		speaker,
		sound,
		loud_sound,
		loudspeaker,
		mega,
		postal_horn,
		bell,
		no_bell,
		musical_score,
		musical_note,
		notes,
		studio_microphone,
		level_slider,
		control_knobs,
		microphone,
		headphones,
		radio,
		saxophone,
		accordion,
		guitar,
		musical_keyboard,
		trumpet,
		violin,
		banjo,
		drum,
		long_drum,
		iphone,
		calling,
		phone,
		telephone,
		telephone_receiver,
		pager,
		fax,
		battery,
		electric_plug,
		computer,
		desktop_computer,
		printer,
		keyboard,
		computer_mouse,
		trackball,
		minidisc,
		floppy_disk,
		cd,
		dvd,
		abacus,
		movie_camera,
		film_strip,
		film_projector,
		clapper,
		tv,
		camera,
		camera_flash,
		video_camera,
		vhs,
		mag,
		mag_right,
		candle,
		bulb,
		flashlight,
		izakaya_lantern,
		lantern,
		diya_lamp,
		notebook_with_decorative_cover,
		closed_book,
		book,
		open_book,
		green_book,
		blue_book,
		orange_book,
		books,
		notebook,
		ledger,
		page_with_curl,
		scroll,
		page_facing_up,
		newspaper,
		newspaper_roll,
		bookmark_tabs,
		bookmark,
		label: label$1,
		moneybag,
		coin,
		yen,
		dollar,
		euro,
		pound,
		money_with_wings,
		credit_card,
		receipt,
		chart,
		envelope,
		email,
		"e-mail": "",
		incoming_envelope,
		envelope_with_arrow,
		outbox_tray,
		inbox_tray,
		"package": "",
		mailbox,
		mailbox_closed,
		mailbox_with_mail,
		mailbox_with_no_mail,
		postbox,
		ballot_box,
		pencil2,
		black_nib,
		fountain_pen,
		pen,
		paintbrush,
		crayon,
		memo: memo$1,
		pencil,
		briefcase,
		file_folder,
		open_file_folder,
		card_index_dividers,
		date,
		calendar,
		spiral_notepad,
		spiral_calendar,
		card_index,
		chart_with_upwards_trend,
		chart_with_downwards_trend,
		bar_chart,
		clipboard,
		pushpin,
		round_pushpin,
		paperclip,
		paperclips,
		straight_ruler,
		triangular_ruler,
		scissors,
		card_file_box,
		file_cabinet,
		wastebasket,
		lock,
		unlock,
		lock_with_ink_pen,
		closed_lock_with_key,
		key,
		old_key,
		hammer,
		axe,
		pick,
		hammer_and_pick,
		hammer_and_wrench,
		dagger,
		crossed_swords,
		gun,
		boomerang,
		bow_and_arrow,
		shield,
		carpentry_saw,
		wrench,
		screwdriver,
		nut_and_bolt,
		gear,
		clamp,
		balance_scale,
		probing_cane,
		link: link$1,
		chains,
		hook,
		toolbox,
		magnet,
		ladder,
		alembic,
		test_tube,
		petri_dish,
		dna,
		microscope,
		telescope,
		satellite,
		syringe,
		drop_of_blood,
		pill,
		adhesive_bandage,
		stethoscope,
		door,
		elevator,
		mirror,
		window: window$1,
		bed,
		couch_and_lamp,
		chair,
		toilet,
		plunger,
		shower,
		bathtub,
		mouse_trap,
		razor,
		lotion_bottle,
		safety_pin,
		broom,
		basket,
		roll_of_paper,
		bucket,
		soap,
		toothbrush,
		sponge,
		fire_extinguisher,
		shopping_cart,
		smoking,
		coffin,
		headstone,
		funeral_urn,
		moyai,
		placard,
		atm,
		put_litter_in_its_place,
		potable_water,
		wheelchair: "",
		mens,
		womens,
		restroom,
		baby_symbol,
		wc,
		passport_control,
		customs,
		baggage_claim,
		left_luggage,
		warning: warning$1,
		children_crossing,
		no_entry: "",
		no_entry_sign,
		no_bicycles,
		no_smoking,
		do_not_litter,
		"non-potable_water": "",
		no_pedestrians,
		no_mobile_phones,
		underage,
		radioactive,
		biohazard,
		arrow_up,
		arrow_upper_right,
		arrow_right,
		arrow_lower_right,
		arrow_down,
		arrow_lower_left,
		arrow_left,
		arrow_upper_left,
		arrow_up_down,
		left_right_arrow,
		leftwards_arrow_with_hook,
		arrow_right_hook,
		arrow_heading_up,
		arrow_heading_down,
		arrows_clockwise,
		arrows_counterclockwise,
		back: back$1,
		end,
		on,
		soon,
		top: top$1,
		place_of_worship,
		atom_symbol,
		om,
		star_of_david,
		wheel_of_dharma,
		yin_yang,
		latin_cross,
		orthodox_cross,
		star_and_crescent,
		peace_symbol,
		menorah,
		six_pointed_star,
		aries: "",
		taurus: "",
		gemini: "",
		cancer: "",
		leo: "",
		virgo: "",
		libra: "",
		scorpius: "",
		sagittarius: "",
		capricorn: "",
		aquarius: "",
		pisces: "",
		ophiuchus: "",
		twisted_rightwards_arrows,
		repeat,
		repeat_one,
		arrow_forward,
		fast_forward: "",
		next_track_button,
		play_or_pause_button,
		arrow_backward,
		rewind: "",
		previous_track_button,
		arrow_up_small,
		arrow_double_up: "",
		arrow_down_small,
		arrow_double_down: "",
		pause_button,
		stop_button,
		record_button,
		eject_button,
		cinema,
		low_brightness,
		high_brightness,
		signal_strength,
		vibration_mode,
		mobile_phone_off,
		female_sign,
		male_sign,
		transgender_symbol,
		heavy_multiplication_x,
		heavy_plus_sign: "",
		heavy_minus_sign: "",
		heavy_division_sign: "",
		infinity,
		bangbang,
		interrobang,
		question: "",
		grey_question: "",
		grey_exclamation: "",
		exclamation: "",
		heavy_exclamation_mark: "",
		wavy_dash,
		currency_exchange,
		heavy_dollar_sign,
		medical_symbol,
		recycle,
		fleur_de_lis,
		trident,
		name_badge,
		beginner,
		o: "",
		white_check_mark: "",
		ballot_box_with_check,
		heavy_check_mark,
		x: "",
		negative_squared_cross_mark: "",
		curly_loop: "",
		loop: "",
		part_alternation_mark,
		eight_spoked_asterisk,
		eight_pointed_black_star,
		sparkle,
		copyright,
		registered,
		tm,
		hash,
		asterisk,
		zero,
		one,
		two,
		three,
		four,
		five,
		six,
		seven,
		eight,
		nine,
		keycap_ten,
		capital_abcd,
		abcd,
		symbols,
		abc,
		a,
		ab,
		b,
		cl,
		cool,
		free,
		information_source,
		id,
		m,
		"new": "",
		ng,
		o2,
		ok,
		parking,
		sos,
		up,
		vs,
		koko,
		sa,
		ideograph_advantage,
		accept,
		congratulations,
		secret,
		u6e80,
		red_circle,
		orange_circle,
		yellow_circle,
		green_circle,
		large_blue_circle,
		purple_circle,
		brown_circle,
		black_circle: "",
		white_circle: "",
		red_square,
		orange_square,
		yellow_square,
		green_square,
		blue_square,
		purple_square,
		brown_square,
		black_large_square: "",
		white_large_square: "",
		black_medium_square,
		white_medium_square,
		black_medium_small_square: "",
		white_medium_small_square: "",
		black_small_square,
		white_small_square,
		large_orange_diamond,
		large_blue_diamond,
		small_orange_diamond,
		small_blue_diamond,
		small_red_triangle,
		small_red_triangle_down,
		diamond_shape_with_a_dot_inside,
		radio_button,
		white_square_button,
		black_square_button,
		checkered_flag,
		triangular_flag_on_post,
		crossed_flags,
		black_flag,
		white_flag,
		rainbow_flag,
		transgender_flag,
		pirate_flag,
		ascension_island,
		andorra,
		united_arab_emirates,
		afghanistan,
		antigua_barbuda,
		anguilla,
		albania,
		armenia,
		angola,
		antarctica,
		argentina,
		american_samoa,
		austria,
		australia,
		aruba,
		aland_islands,
		azerbaijan,
		bosnia_herzegovina,
		barbados,
		bangladesh,
		belgium,
		burkina_faso,
		bulgaria,
		bahrain,
		burundi,
		benin,
		st_barthelemy,
		bermuda,
		brunei,
		bolivia,
		caribbean_netherlands,
		brazil,
		bahamas,
		bhutan,
		bouvet_island,
		botswana,
		belarus,
		belize,
		canada,
		cocos_islands,
		congo_kinshasa,
		central_african_republic,
		congo_brazzaville,
		switzerland,
		cote_divoire,
		cook_islands,
		chile,
		cameroon,
		cn,
		colombia,
		clipperton_island,
		costa_rica,
		cuba,
		cape_verde,
		curacao,
		christmas_island,
		cyprus,
		czech_republic,
		de,
		diego_garcia,
		djibouti,
		denmark,
		dominica,
		dominican_republic,
		algeria,
		ceuta_melilla,
		ecuador,
		estonia,
		egypt,
		western_sahara,
		eritrea,
		es,
		ethiopia,
		eu,
		european_union,
		finland,
		fiji,
		falkland_islands,
		micronesia,
		faroe_islands,
		fr,
		gabon,
		gb,
		uk,
		grenada,
		georgia,
		french_guiana,
		guernsey,
		ghana,
		gibraltar,
		greenland,
		gambia,
		guinea,
		guadeloupe,
		equatorial_guinea,
		greece,
		south_georgia_south_sandwich_islands,
		guatemala,
		guam,
		guinea_bissau,
		guyana,
		hong_kong,
		heard_mcdonald_islands,
		honduras,
		croatia,
		haiti,
		hungary,
		canary_islands,
		indonesia,
		ireland,
		israel,
		isle_of_man,
		india,
		british_indian_ocean_territory,
		iraq,
		iran,
		iceland,
		it,
		jersey,
		jamaica,
		jordan,
		jp,
		kenya,
		kyrgyzstan,
		cambodia,
		kiribati,
		comoros,
		st_kitts_nevis,
		north_korea,
		kr,
		kuwait,
		cayman_islands,
		kazakhstan,
		laos,
		lebanon,
		st_lucia,
		liechtenstein,
		sri_lanka,
		liberia,
		lesotho,
		lithuania,
		luxembourg,
		latvia,
		libya,
		morocco,
		monaco,
		moldova,
		montenegro,
		st_martin,
		madagascar,
		marshall_islands,
		macedonia,
		mali,
		myanmar,
		mongolia,
		macau,
		northern_mariana_islands,
		martinique,
		mauritania,
		montserrat,
		malta,
		mauritius,
		maldives,
		malawi,
		mexico,
		malaysia,
		mozambique,
		namibia,
		new_caledonia,
		niger,
		norfolk_island,
		nigeria,
		nicaragua,
		netherlands,
		norway,
		nepal,
		nauru,
		niue,
		new_zealand,
		oman,
		panama,
		peru,
		french_polynesia,
		papua_new_guinea,
		philippines,
		pakistan,
		poland,
		st_pierre_miquelon,
		pitcairn_islands,
		puerto_rico,
		palestinian_territories,
		portugal,
		palau,
		paraguay,
		qatar,
		reunion,
		romania,
		serbia,
		ru,
		rwanda,
		saudi_arabia,
		solomon_islands,
		seychelles,
		sudan,
		sweden,
		singapore,
		st_helena,
		slovenia,
		svalbard_jan_mayen,
		slovakia,
		sierra_leone,
		san_marino,
		senegal,
		somalia,
		suriname,
		south_sudan,
		sao_tome_principe,
		el_salvador,
		sint_maarten,
		syria,
		swaziland,
		tristan_da_cunha,
		turks_caicos_islands,
		chad,
		french_southern_territories,
		togo,
		thailand,
		tajikistan,
		tokelau,
		timor_leste,
		turkmenistan,
		tunisia,
		tonga,
		tr,
		trinidad_tobago,
		tuvalu,
		taiwan,
		tanzania,
		ukraine,
		uganda,
		us_outlying_islands,
		united_nations,
		us,
		uruguay,
		uzbekistan,
		vatican_city,
		st_vincent_grenadines,
		venezuela,
		british_virgin_islands,
		us_virgin_islands,
		vietnam,
		vanuatu,
		wallis_futuna,
		samoa,
		kosovo,
		yemen,
		mayotte,
		south_africa,
		zambia,
		zimbabwe,
		england,
		scotland,
		wales
	};
}));
var require_shortcuts = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = {
		angry: [">:(", ">:-("],
		blush: [":\")", ":-\")"],
		broken_heart: ["</3", "<\\3"],
		confused: [":/", ":-/"],
		cry: [
			":'(",
			":'-(",
			":,(",
			":,-("
		],
		frowning: [":(", ":-("],
		heart: ["<3"],
		imp: ["]:(", "]:-("],
		innocent: [
			"o:)",
			"O:)",
			"o:-)",
			"O:-)",
			"0:)",
			"0:-)"
		],
		joy: [
			":')",
			":'-)",
			":,)",
			":,-)",
			":'D",
			":'-D",
			":,D",
			":,-D"
		],
		kissing: [":*", ":-*"],
		laughing: ["x-)", "X-)"],
		neutral_face: [":|", ":-|"],
		open_mouth: [
			":o",
			":-o",
			":O",
			":-O"
		],
		rage: [":@", ":-@"],
		smile: [":D", ":-D"],
		smiley: [":)", ":-)"],
		smiling_imp: ["]:)", "]:-)"],
		sob: [
			":,'(",
			":,'-(",
			";(",
			";-("
		],
		stuck_out_tongue: [":P", ":-P"],
		sunglasses: ["8-)", "B-)"],
		sweat: [",:(", ",:-("],
		sweat_smile: [",:)", ",:-)"],
		unamused: [
			":s",
			":-S",
			":z",
			":-Z",
			":$",
			":-$"
		],
		wink: [";)", ";-)"]
	};
}));
var require_render = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = function emoji_html$1(tokens, idx) {
		return tokens[idx].content;
	};
}));
var require_replace = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = function create_rule(md, emojies, shortcuts, scanRE, replaceRE) {
		var arrayReplaceAt$2 = md.utils.arrayReplaceAt, ucm = md.utils.lib.ucmicro, ZPCc = new RegExp([
			ucm.Z.source,
			ucm.P.source,
			ucm.Cc.source
		].join("|"));
		function splitTextToken(text$7, level, Token$4) {
			var token, last_pos = 0, nodes = [];
			text$7.replace(replaceRE, function(match, offset$2, src) {
				var emoji_name;
				if (shortcuts.hasOwnProperty(match)) {
					emoji_name = shortcuts[match];
					if (offset$2 > 0 && !ZPCc.test(src[offset$2 - 1])) return;
					if (offset$2 + match.length < src.length && !ZPCc.test(src[offset$2 + match.length])) return;
				} else emoji_name = match.slice(1, -1);
				if (offset$2 > last_pos) {
					token = new Token$4("text", "", 0);
					token.content = text$7.slice(last_pos, offset$2);
					nodes.push(token);
				}
				token = new Token$4("emoji", "", 0);
				token.markup = emoji_name;
				token.content = emojies[emoji_name];
				nodes.push(token);
				last_pos = offset$2 + match.length;
			});
			if (last_pos < text$7.length) {
				token = new Token$4("text", "", 0);
				token.content = text$7.slice(last_pos);
				nodes.push(token);
			}
			return nodes;
		}
		return function emoji_replace$1(state) {
			var i$1, j$1, l, tokens, token, blockTokens = state.tokens, autolinkLevel = 0;
			for (j$1 = 0, l = blockTokens.length; j$1 < l; j$1++) {
				if (blockTokens[j$1].type !== "inline") continue;
				tokens = blockTokens[j$1].children;
				for (i$1 = tokens.length - 1; i$1 >= 0; i$1--) {
					token = tokens[i$1];
					if (token.type === "link_open" || token.type === "link_close") {
						if (token.info === "auto") autolinkLevel -= token.nesting;
					}
					if (token.type === "text" && autolinkLevel === 0 && scanRE.test(token.content)) blockTokens[j$1].children = tokens = arrayReplaceAt$2(tokens, i$1, splitTextToken(token.content, token.level, state.Token));
				}
			}
		};
	};
}));
var require_normalize_opts = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function quoteRE(str) {
		return str.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
	}
	module.exports = function normalize_opts$1(options$1) {
		var emojies = options$1.defs, shortcuts;
		if (options$1.enabled.length) emojies = Object.keys(emojies).reduce(function(acc, key$2) {
			if (options$1.enabled.indexOf(key$2) >= 0) acc[key$2] = emojies[key$2];
			return acc;
		}, {});
		shortcuts = Object.keys(options$1.shortcuts).reduce(function(acc, key$2) {
			if (!emojies[key$2]) return acc;
			if (Array.isArray(options$1.shortcuts[key$2])) {
				options$1.shortcuts[key$2].forEach(function(alias) {
					acc[alias] = key$2;
				});
				return acc;
			}
			acc[options$1.shortcuts[key$2]] = key$2;
			return acc;
		}, {});
		var keys$1 = Object.keys(emojies), names$1;
		if (keys$1.length === 0) names$1 = "^$";
		else names$1 = keys$1.map(function(name$1) {
			return ":" + name$1 + ":";
		}).concat(Object.keys(shortcuts)).sort().reverse().map(function(name$1) {
			return quoteRE(name$1);
		}).join("|");
		return {
			defs: emojies,
			shortcuts,
			scanRE: RegExp(names$1),
			replaceRE: RegExp(names$1, "g")
		};
	};
}));
var require_bare = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var emoji_html = require_render();
	var emoji_replace = require_replace();
	var normalize_opts = require_normalize_opts();
	module.exports = function emoji_plugin(md, options$1) {
		var opts = normalize_opts(md.utils.assign({}, {
			defs: {},
			shortcuts: {},
			enabled: []
		}, options$1 || {}));
		md.renderer.rules.emoji = emoji_html;
		md.core.ruler.after("linkify", "emoji", emoji_replace(md, opts.defs, opts.shortcuts, opts.scanRE, opts.replaceRE));
	};
}));
var require_markdown_it_emoji = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var emojies_defs = (init_full(), __toCommonJS(full_exports).default);
	var emojies_shortcuts = require_shortcuts();
	var bare_emoji_plugin = require_bare();
	module.exports = function emoji_plugin(md, options$1) {
		var defaults = {
			defs: emojies_defs,
			shortcuts: emojies_shortcuts,
			enabled: []
		};
		bare_emoji_plugin(md, md.utils.assign({}, defaults, options$1 || {}));
	};
}));
var require_markdown_it_task_lists = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var disableCheckboxes = true;
	var useLabelWrapper = false;
	var useLabelAfter = false;
	module.exports = function(md, options$1) {
		if (options$1) {
			disableCheckboxes = !options$1.enabled;
			useLabelWrapper = !!options$1.label;
			useLabelAfter = !!options$1.labelAfter;
		}
		md.core.ruler.after("inline", "github-task-lists", function(state) {
			var tokens = state.tokens;
			for (var i$1 = 2; i$1 < tokens.length; i$1++) if (isTodoItem(tokens, i$1)) {
				todoify(tokens[i$1], state.Token);
				attrSet(tokens[i$1 - 2], "class", "task-list-item" + (!disableCheckboxes ? " enabled" : ""));
				attrSet(tokens[parentToken(tokens, i$1 - 2)], "class", "contains-task-list");
			}
		});
	};
	function attrSet(token, name$1, value) {
		var index = token.attrIndex(name$1);
		var attr = [name$1, value];
		if (index < 0) token.attrPush(attr);
		else token.attrs[index] = attr;
	}
	function parentToken(tokens, index) {
		var targetLevel = tokens[index].level - 1;
		for (var i$1 = index - 1; i$1 >= 0; i$1--) if (tokens[i$1].level === targetLevel) return i$1;
		return -1;
	}
	function isTodoItem(tokens, index) {
		return isInline(tokens[index]) && isParagraph(tokens[index - 1]) && isListItem(tokens[index - 2]) && startsWithTodoMarkdown(tokens[index]);
	}
	function todoify(token, TokenConstructor) {
		token.children.unshift(makeCheckbox(token, TokenConstructor));
		token.children[1].content = token.children[1].content.slice(3);
		token.content = token.content.slice(3);
		if (useLabelWrapper) if (useLabelAfter) {
			token.children.pop();
			var id$1 = "task-item-" + Math.ceil(Math.random() * (1e4 * 1e3) - 1e3);
			token.children[0].content = token.children[0].content.slice(0, -1) + " id=\"" + id$1 + "\">";
			token.children.push(afterLabel(token.content, id$1, TokenConstructor));
		} else {
			token.children.unshift(beginLabel(TokenConstructor));
			token.children.push(endLabel(TokenConstructor));
		}
	}
	function makeCheckbox(token, TokenConstructor) {
		var checkbox = new TokenConstructor("html_inline", "", 0);
		var disabledAttr = disableCheckboxes ? " disabled=\"\" " : "";
		if (token.content.indexOf("[ ] ") === 0) checkbox.content = "<input class=\"task-list-item-checkbox\"" + disabledAttr + "type=\"checkbox\">";
		else if (token.content.indexOf("[x] ") === 0 || token.content.indexOf("[X] ") === 0) checkbox.content = "<input class=\"task-list-item-checkbox\" checked=\"\"" + disabledAttr + "type=\"checkbox\">";
		return checkbox;
	}
	function beginLabel(TokenConstructor) {
		var token = new TokenConstructor("html_inline", "", 0);
		token.content = "<label>";
		return token;
	}
	function endLabel(TokenConstructor) {
		var token = new TokenConstructor("html_inline", "", 0);
		token.content = "</label>";
		return token;
	}
	function afterLabel(content$4, id$1, TokenConstructor) {
		var token = new TokenConstructor("html_inline", "", 0);
		token.content = "<label class=\"task-list-item-label\" for=\"" + id$1 + "\">" + content$4 + "</label>";
		token.attrs = [{ for: id$1 }];
		return token;
	}
	function isInline(token) {
		return token.type === "inline";
	}
	function isParagraph(token) {
		return token.type === "paragraph_open";
	}
	function isListItem(token) {
		return token.type === "list_item_open";
	}
	function startsWithTodoMarkdown(token) {
		return token.content.indexOf("[ ] ") === 0 || token.content.indexOf("[x] ") === 0 || token.content.indexOf("[X] ") === 0;
	}
}));
var YOUTUBE_TAG_REGEX = /@\[youtube]\(([A-Za-z0-9_-]{11})\)/im;
const YOUTUBE_EMBED_SRC_REGEX = /^https:\/\/(?:www\.)?(youtube\.com|youtube-nocookie\.com)\/embed\/([A-Za-z0-9_-]{11})$/i;
var EMBED_FRAME_PERMISSIONS = [
	"accelerometer",
	"autoplay",
	"clipboard-write",
	"encrypted-media",
	"gyroscope",
	"picture-in-picture",
	"web-share",
	"fullscreen"
];
var YOUTUBE_NOCOOKIE_URL = "https://www.youtube-nocookie.com/embed/";
var YOUTUBE_STANDARD_URL = "https://www.youtube.com/embed/";
const markdownYoutubeEmbed = (md, options$1) => {
	const opts = {
		width: "100%",
		title: "YouTube video player",
		nocookie: true,
		...options$1
	};
	const parser = (state, silent) => {
		const { pos, src } = state;
		if (src.charCodeAt(pos) !== 64) return false;
		const match = YOUTUBE_TAG_REGEX.exec(src.slice(pos));
		if (!match) return false;
		if (!silent) {
			const token = state.push("youtube_embed", "", 0);
			token.meta = { videoId: match[1] };
		}
		state.pos += match[0].length;
		return true;
	};
	const youtubeUrl = opts.nocookie ? YOUTUBE_NOCOOKIE_URL : YOUTUBE_STANDARD_URL;
	md.inline.ruler.before("link", "youtube_embed", parser);
	md.renderer.rules.youtube_embed = (tokens, idx) => {
		const { videoId } = tokens[idx].meta;
		return `<iframe ${[
			serializeAttr("iframe", "width", `${opts.width}`),
			...opts.height ? [serializeAttr("iframe", "height", `${opts.height}`)] : [],
			serializeAttr("iframe", "src", `${youtubeUrl}${videoId}`),
			serializeAttr("iframe", "title", md.utils.escapeHtml(opts.title)),
			serializeAttr("iframe", "frameborder", "0"),
			serializeAttr("iframe", "allow", EMBED_FRAME_PERMISSIONS.join("; ")),
			serializeAttr("iframe", "referrerpolicy", "strict-origin-when-cross-origin")
		].join(" ")}></iframe>`;
	};
};
var import_markdown_it = /* @__PURE__ */ __toESM(require_markdown_it());
var import_markdown_it_emoji = /* @__PURE__ */ __toESM(require_markdown_it_emoji());
var import_markdown_it_link_attributes = /* @__PURE__ */ __toESM(require_markdown_it_link_attributes());
var import_markdown_it_task_lists = /* @__PURE__ */ __toESM(require_markdown_it_task_lists());
var import_lib = /* @__PURE__ */ __toESM(require_lib$1());
var _hoisted_1$22 = { class: "n8n-markdown" };
var _hoisted_2$13 = ["innerHTML"];
var Markdown_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "Markdown",
	props: {
		content: { default: "" },
		withMultiBreaks: {
			type: Boolean,
			default: false
		},
		images: { default: () => [] },
		loading: {
			type: Boolean,
			default: false
		},
		loadingBlocks: { default: 2 },
		loadingRows: { default: 3 },
		theme: { default: "markdown" },
		options: { default: () => ({
			markdown: {
				html: false,
				linkify: true,
				typographer: true,
				breaks: true
			},
			linkAttributes: { attrs: {
				target: "_blank",
				rel: "noopener"
			} },
			tasklists: {
				enabled: true,
				label: true,
				labelAfter: false
			},
			youtube: {}
		}) }
	},
	emits: ["markdown-click", "update-content"],
	setup(__props, { emit: __emit }) {
		const props = __props;
		const editor = ref(void 0);
		const { options: options$1 } = props;
		const md = new import_markdown_it.default(options$1.markdown).use(import_markdown_it_link_attributes.default, options$1.linkAttributes).use(import_markdown_it_emoji.default).use(import_markdown_it_task_lists.default, options$1.tasklists).use(markdownYoutubeEmbed, options$1.youtube);
		const xssWhiteList = {
			...import_lib.whiteList,
			label: ["class", "for"],
			iframe: [
				"width",
				"height",
				"src",
				"title",
				"frameborder",
				"allow",
				"referrerpolicy"
			]
		};
		const htmlContent = computed(() => {
			if (!props.content) return "";
			const imageUrls = {};
			if (props.images) props.images.forEach((image$2) => {
				if (!image$2) return;
				imageUrls[image$2.id] = image$2.url;
			});
			const fileIdRegex = /* @__PURE__ */ new RegExp("fileId:([0-9]+)");
			let contentToRender = props.content;
			if (props.withMultiBreaks) contentToRender = contentToRender.replaceAll("\n\n", "\n&nbsp;\n");
			return (0, import_lib.default)(md.render(contentToRender), {
				onTagAttr(tag$2, name$1, value) {
					if (tag$2 === "img" && name$1 === "src") {
						if (value.match(fileIdRegex)) {
							const imageUrl = imageUrls[value.split("fileId:")[1]];
							if (!imageUrl) return "";
							return serializeAttr(tag$2, name$1, imageUrl);
						}
						const isStaticImageFile = value.split("#")[0].match(/\.(jpeg|jpg|gif|png|webp)$/) !== null && value.startsWith("/static/");
						if (!value.startsWith("https://") && !isStaticImageFile) return "";
					}
					if (tag$2 === "iframe") {
						if (name$1 === "src") if (YOUTUBE_EMBED_SRC_REGEX.test(value)) return serializeAttr(tag$2, name$1, value);
						else return "";
						return;
					}
				},
				onTag(tag$2, code) {
					if (tag$2 === "img" && code.includes("alt=\"workflow-screenshot\"")) return "";
				},
				onIgnoreTag(tag$2, tagHTML) {
					if (tag$2 === "input" && tagHTML.includes("type=\"checkbox\"")) return tagHTML;
				},
				whiteList: xssWhiteList
			});
		});
		const emit = __emit;
		const onClick = (event) => {
			let clickedLink = null;
			if (event.target instanceof HTMLAnchorElement) clickedLink = event.target;
			if (event.target instanceof HTMLElement && event.target.matches("a *")) {
				const parentLink = event.target.closest("a");
				if (parentLink) clickedLink = parentLink;
			}
			if (clickedLink) emit("markdown-click", clickedLink, event);
		};
		const onChange = async (event) => {
			if (event.target instanceof HTMLInputElement && event.target.type === "checkbox") {
				const checkboxes = editor.value?.querySelectorAll("input[type=\"checkbox\"]");
				if (checkboxes) {
					const index = Array.from(checkboxes).indexOf(event.target);
					if (index !== -1) onCheckboxChange(index);
				}
			}
		};
		const onMouseDown = (event) => {
			if (event.target instanceof HTMLInputElement) event.stopPropagation();
		};
		const onCheckboxChange = (index) => {
			const currentContent = props.content;
			if (!currentContent) return;
			emit("update-content", toggleCheckbox(currentContent, index));
		};
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", _hoisted_1$22, [!_ctx.loading ? (openBlock(), createElementBlock("div", {
				key: 0,
				ref_key: "editor",
				ref: editor,
				class: normalizeClass(_ctx.$style[_ctx.theme]),
				onClick,
				onMousedown: onMouseDown,
				onChange,
				innerHTML: htmlContent.value
			}, null, 42, _hoisted_2$13)) : (openBlock(), createElementBlock("div", {
				key: 1,
				class: normalizeClass(_ctx.$style.markdown)
			}, [(openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.loadingBlocks, (_, index) => {
				return openBlock(), createElementBlock("div", { key: index }, [createVNode(unref(N8nLoading_default), {
					loading: _ctx.loading,
					rows: _ctx.loadingRows,
					animated: "",
					variant: "p"
				}, null, 8, ["loading", "rows"]), createBaseVNode("div", { class: normalizeClass(_ctx.$style.spacer) }, null, 2)]);
			}), 128))], 2))]);
		};
	}
});
var Markdown_vue_vue_type_style_index_0_lang_module_default = {
	markdown: "_markdown_11g25_123",
	label: "_label_11g25_165",
	sticky: "_sticky_11g25_186",
	spacer: "_spacer_11g25_282"
};
var N8nMarkdown_default = /* @__PURE__ */ __plugin_vue_export_helper_default(Markdown_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": Markdown_vue_vue_type_style_index_0_lang_module_default }]]);
var _hoisted_1$21 = ["data-test-id"];
var MenuItem_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "MenuItem",
	props: {
		item: {},
		active: { type: Boolean },
		empty: { type: Boolean },
		compact: { type: Boolean },
		level: {},
		open: { type: Boolean },
		ariaLabel: {}
	},
	emits: ["click"],
	setup(__props, { emit: __emit }) {
		const props = __props;
		const emit = __emit;
		const to = computed(() => {
			if (props.item.route) return props.item.route.to;
			if (props.item.link) return props.item.link.href;
		});
		const icon$11 = computed(() => {
			if (typeof props.item.icon === "object" && props.item.icon?.type === "icon") return props.item.icon.value;
			if (typeof props.item.icon === "string") return props.item.icon;
		});
		const iconColor = computed(() => {
			if (typeof props.item.icon === "string") return;
			return props.item.icon?.color;
		});
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", {
				"data-test-id": _ctx.item.id,
				class: normalizeClass(_ctx.$style.menuItemWrapper)
			}, [createVNode(unref(N8nTooltip_default), {
				placement: "right",
				disabled: !_ctx.compact,
				"show-after": 500
			}, createSlots({
				default: withCtx(() => [createVNode(unref(N8nRoute_default), {
					id: _ctx.item.id,
					to: to.value,
					role: "menuitem",
					class: normalizeClass([_ctx.$style.menuItem, { [_ctx.$style.active]: _ctx.active }]),
					"aria-label": props.ariaLabel,
					"data-test-id": "menu-item",
					onClick: _cache[0] || (_cache[0] = ($event) => emit("click"))
				}, {
					default: withCtx(() => [
						_ctx.item.icon ? (openBlock(), createElementBlock("div", {
							key: 0,
							class: normalizeClass([_ctx.$style.menuItemIcon, { [_ctx.$style.notification]: _ctx.item.notification }])
						}, [_ctx.item.icon && typeof _ctx.item.icon === "object" && _ctx.item.icon.type === "emoji" ? (openBlock(), createBlock(unref(N8nText_default), {
							key: 0,
							class: normalizeClass(_ctx.$style.menuItemEmoji),
							color: iconColor.value
						}, {
							default: withCtx(() => [createTextVNode(toDisplayString(_ctx.item.icon.value), 1)]),
							_: 1
						}, 8, ["class", "color"])) : icon$11.value ? (openBlock(), createBlock(unref(N8nIcon_default), {
							key: 1,
							color: iconColor.value,
							icon: icon$11.value
						}, null, 8, ["color", "icon"])) : createCommentVNode("", true)], 2)) : createCommentVNode("", true),
						!_ctx.compact ? (openBlock(), createBlock(unref(N8nText_default), {
							key: 1,
							class: normalizeClass(_ctx.$style.menuItemText)
						}, {
							default: withCtx(() => [createTextVNode(toDisplayString(_ctx.item.label), 1)]),
							_: 1
						}, 8, ["class"])) : createCommentVNode("", true),
						_ctx.item.children && !_ctx.compact ? (openBlock(), createBlock(unref(N8nIcon_default), {
							key: 2,
							icon: "chevron-right",
							color: "text-light"
						})) : createCommentVNode("", true)
					]),
					_: 1
				}, 8, [
					"id",
					"to",
					"class",
					"aria-label"
				])]),
				_: 2
			}, [_ctx.compact ? {
				name: "content",
				fn: withCtx(() => [createTextVNode(toDisplayString(_ctx.item.label), 1)]),
				key: "0"
			} : void 0]), 1032, ["disabled"])], 10, _hoisted_1$21);
		};
	}
});
var MenuItem_vue_vue_type_style_index_0_lang_module_default = {
	menuItemWrapper: "_menuItemWrapper_14738_123",
	menuItem: "_menuItem_14738_123",
	menuItemIcon: "_menuItemIcon_14738_144",
	active: "_active_14738_147",
	menuItemText: "_menuItemText_14738_160",
	notification: "_notification_14738_182",
	menuItemEmoji: "_menuItemEmoji_14738_193"
};
var N8nMenuItem_default = /* @__PURE__ */ __plugin_vue_export_helper_default(MenuItem_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": MenuItem_vue_vue_type_style_index_0_lang_module_default }]]);
var ConditionalRouterLink_default = /* @__PURE__ */ defineComponent({
	name: "ConditionalRouterLink",
	inheritAttrs: false,
	__name: "CondtionalRouterLink",
	props: {
		...RouterLink.props,
		to: {
			type: [String, Object],
			default: void 0
		}
	},
	setup(__props) {
		const props = __props;
		const attrs = useAttrs();
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", null, [props.to ? (openBlock(), createBlock(unref(RouterLink), mergeProps({ key: 0 }, props, { to: props.to }), {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 16, ["to"])) : unref(attrs).href ? (openBlock(), createElementBlock("a", normalizeProps(mergeProps({ key: 1 }, unref(attrs))), [renderSlot(_ctx.$slots, "default")], 16)) : renderSlot(_ctx.$slots, "default", { key: 2 })]);
		};
	}
});
var _hoisted_1$20 = { key: 0 };
var _hoisted_2$12 = { key: 0 };
var ROOT_MENU_INDEX = "-1";
var NavigationDropdown_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	name: "N8nNavigationDropdown",
	__name: "NavigationDropdown",
	props: {
		menu: {},
		disabled: { type: Boolean },
		teleport: { type: Boolean },
		submenuClass: {}
	},
	emits: ["itemClick", "select"],
	setup(__props, { expose: __expose, emit: __emit }) {
		const menuRef = ref(null);
		const emit = __emit;
		const open = () => {
			menuRef.value?.open(ROOT_MENU_INDEX);
		};
		const close = () => {
			menuRef.value?.close(ROOT_MENU_INDEX);
		};
		const menuTrigger = ref("click");
		const onOpen = (index) => {
			if (index !== ROOT_MENU_INDEX) return;
			menuTrigger.value = "hover";
		};
		const onClose = (index) => {
			if (index !== ROOT_MENU_INDEX) return;
			menuTrigger.value = "click";
		};
		__expose({
			open,
			close
		});
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(ElMenu), {
				ref_key: "menuRef",
				ref: menuRef,
				mode: "horizontal",
				"unique-opened": "",
				"menu-trigger": menuTrigger.value,
				ellipsis: false,
				class: normalizeClass(_ctx.$style.dropdown),
				onSelect: _cache[1] || (_cache[1] = ($event) => emit("select", $event)),
				onKeyup: withKeys(close, ["escape"]),
				onOpen,
				onClose
			}, {
				default: withCtx(() => [createVNode(unref(ElSubMenu), {
					index: ROOT_MENU_INDEX,
					class: normalizeClass(_ctx.$style.trigger),
					"popper-offset": -10,
					"popper-class": [_ctx.$style.submenu, _ctx.submenuClass ?? ""].join(" "),
					disabled: _ctx.disabled,
					teleported: _ctx.teleport
				}, {
					title: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
					default: withCtx(() => [(openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.menu, (item$4) => {
						return openBlock(), createElementBlock(Fragment, { key: item$4.id }, [item$4.isDivider ? (openBlock(), createElementBlock("hr", _hoisted_1$20)) : item$4.submenu ? (openBlock(), createBlock(unref(ElSubMenu), {
							key: 1,
							"popper-class": _ctx.$style.nestedSubmenu,
							index: item$4.id,
							"popper-offset": -10,
							"data-test-id": "navigation-submenu"
						}, {
							title: withCtx(() => [createBaseVNode("div", { class: normalizeClass(_ctx.$style.subMenuTitle) }, [renderSlot(_ctx.$slots, "item-icon", mergeProps({ ref_for: true }, { item: item$4 }), () => [item$4.icon ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [typeof item$4.icon === "string" || item$4.icon.type === "icon" ? (openBlock(), createBlock(unref(N8nIcon_default), {
								key: 0,
								class: normalizeClass({ [_ctx.$style.submenu__icon]: item$4.iconMargin !== false }),
								icon: typeof item$4.icon === "object" ? item$4.icon.value : item$4.icon,
								size: item$4.iconSize
							}, null, 8, [
								"class",
								"icon",
								"size"
							])) : item$4.icon.type === "emoji" ? (openBlock(), createBlock(unref(N8nText_default), {
								key: 1,
								class: normalizeClass({ [_ctx.$style.submenu__icon]: item$4.iconMargin !== false })
							}, {
								default: withCtx(() => [createTextVNode(toDisplayString(item$4.icon.value), 1)]),
								_: 2
							}, 1032, ["class"])) : createCommentVNode("", true)], 64)) : createCommentVNode("", true)]), createTextVNode(" " + toDisplayString(item$4.title), 1)], 2)]),
							default: withCtx(() => [(openBlock(true), createElementBlock(Fragment, null, renderList(item$4.submenu, (subitem) => {
								return openBlock(), createElementBlock(Fragment, { key: subitem.id }, [subitem.isDivider ? (openBlock(), createElementBlock("hr", _hoisted_2$12)) : (openBlock(), createBlock(unref(ConditionalRouterLink_default), {
									key: 1,
									to: !subitem.disabled && subitem.route || void 0
								}, {
									default: withCtx(() => [createVNode(unref(ElMenuItem), {
										"data-test-id": "navigation-submenu-item",
										index: subitem.id,
										disabled: subitem.disabled,
										class: normalizeClass({ [_ctx.$style.menuItemWithTooltip]: subitem.description }),
										onClick: _cache[0] || (_cache[0] = ($event) => emit("itemClick", $event))
									}, {
										default: withCtx(() => [
											renderSlot(_ctx.$slots, "item-icon", mergeProps({ ref_for: true }, { item: subitem }), () => [subitem.icon ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [typeof subitem.icon === "string" || subitem.icon.type === "icon" ? (openBlock(), createBlock(unref(N8nIcon_default), {
												key: 0,
												class: normalizeClass({ [_ctx.$style.submenu__icon]: subitem.iconMargin !== false }),
												icon: typeof subitem.icon === "object" ? subitem.icon.value : subitem.icon,
												size: subitem.iconSize
											}, null, 8, [
												"class",
												"icon",
												"size"
											])) : subitem.icon.type === "emoji" ? (openBlock(), createBlock(unref(N8nText_default), {
												key: 1,
												class: normalizeClass({ [_ctx.$style.submenu__icon]: subitem.iconMargin !== false })
											}, {
												default: withCtx(() => [createTextVNode(toDisplayString(subitem.icon.value), 1)]),
												_: 2
											}, 1032, ["class"])) : createCommentVNode("", true)], 64)) : createCommentVNode("", true)]),
											createBaseVNode("span", { class: normalizeClass(_ctx.$style.menuItemTitle) }, toDisplayString(subitem.title), 3),
											subitem.description ? (openBlock(), createBlock(unref(N8nTooltip_default), {
												key: 0,
												content: subitem.description,
												placement: "right",
												class: normalizeClass(_ctx.$style.infoTooltip)
											}, {
												default: withCtx(() => [createVNode(unref(N8nIcon_default), {
													icon: "info",
													size: "medium",
													class: normalizeClass(_ctx.$style.infoIcon)
												}, null, 8, ["class"])]),
												_: 2
											}, 1032, ["content", "class"])) : createCommentVNode("", true),
											renderSlot(_ctx.$slots, `item.append.${item$4.id}`, mergeProps({ ref_for: true }, { item: item$4 }))
										]),
										_: 2
									}, 1032, [
										"index",
										"disabled",
										"class"
									])]),
									_: 2
								}, 1032, ["to"]))], 64);
							}), 128))]),
							_: 2
						}, 1032, ["popper-class", "index"])) : (openBlock(), createBlock(unref(ConditionalRouterLink_default), {
							key: 2,
							to: !item$4.disabled && item$4.route || void 0
						}, {
							default: withCtx(() => [createVNode(unref(ElMenuItem), {
								index: item$4.id,
								disabled: item$4.disabled,
								"data-test-id": "navigation-menu-item"
							}, {
								default: withCtx(() => [createTextVNode(toDisplayString(item$4.title) + " ", 1), renderSlot(_ctx.$slots, `item.append.${item$4.id}`, mergeProps({ ref_for: true }, { item: item$4 }))]),
								_: 2
							}, 1032, ["index", "disabled"])]),
							_: 2
						}, 1032, ["to"]))], 64);
					}), 128))]),
					_: 3
				}, 8, [
					"class",
					"popper-class",
					"disabled",
					"teleported"
				])]),
				_: 3
			}, 8, ["menu-trigger", "class"]);
		};
	}
});
var NavigationDropdown_vue_vue_type_style_index_0_lang_module_default = {
	dropdown: "_dropdown_a2vc5_123",
	nestedSubmenu: "_nestedSubmenu_a2vc5_140",
	submenu: "_submenu_a2vc5_145",
	subMenuTitle: "_subMenuTitle_a2vc5_183",
	submenu__icon: "_submenu__icon_a2vc5_189",
	menuItemWithTooltip: "_menuItemWithTooltip_a2vc5_194",
	menuItemTitle: "_menuItemTitle_a2vc5_198",
	infoTooltip: "_infoTooltip_a2vc5_206",
	infoIcon: "_infoIcon_a2vc5_213"
};
var N8nNavigationDropdown_default = /* @__PURE__ */ __plugin_vue_export_helper_default(NavigationDropdown_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": NavigationDropdown_vue_vue_type_style_index_0_lang_module_default }]]);
var _hoisted_1$19 = ["textContent"];
var _hoisted_2$11 = ["textContent"];
var NodeCreatorNode_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "NodeCreatorNode",
	props: {
		active: { type: Boolean },
		isAi: { type: Boolean },
		isTrigger: { type: Boolean },
		description: {},
		tag: {},
		title: {},
		showActionArrow: { type: Boolean },
		isOfficial: { type: Boolean },
		hideNodeIcon: { type: Boolean }
	},
	emits: ["tooltipClick"],
	setup(__props) {
		const { t: t$1 } = useI18n();
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", mergeProps({ class: {
				[_ctx.$style.creatorNode]: true,
				[_ctx.$style.hasAction]: !_ctx.showActionArrow
			} }, _ctx.$attrs), [
				!_ctx.hideNodeIcon ? (openBlock(), createElementBlock("div", {
					key: 0,
					class: normalizeClass(_ctx.$style.nodeIcon)
				}, [renderSlot(_ctx.$slots, "icon", {}, void 0, true)], 2)) : createCommentVNode("", true),
				createBaseVNode("div", null, [createBaseVNode("div", { class: normalizeClass(_ctx.$style.details) }, [
					createBaseVNode("span", {
						class: normalizeClass(_ctx.$style.name),
						"data-test-id": "node-creator-item-name",
						textContent: toDisplayString(_ctx.title)
					}, null, 10, _hoisted_1$19),
					_ctx.tag ? (openBlock(), createBlock(unref(ElTag), {
						key: 0,
						class: normalizeClass(_ctx.$style.tag),
						"disable-transitions": "",
						size: "small",
						round: "",
						type: _ctx.tag.type ?? "success"
					}, {
						default: withCtx(() => [createTextVNode(toDisplayString(_ctx.tag.text), 1)]),
						_: 1
					}, 8, ["class", "type"])) : createCommentVNode("", true),
					_ctx.isTrigger ? (openBlock(), createBlock(unref(N8nIcon_default), {
						key: 1,
						icon: "bolt-filled",
						size: "xsmall",
						title: unref(t$1)("nodeCreator.nodeItem.triggerIconTitle"),
						class: normalizeClass(_ctx.$style.triggerIcon)
					}, null, 8, ["title", "class"])) : createCommentVNode("", true),
					renderSlot(_ctx.$slots, "extraDetails", {}, void 0, true)
				], 2), _ctx.description ? (openBlock(), createElementBlock("p", {
					key: 0,
					"data-test-id": "node-creator-item-description",
					class: normalizeClass(_ctx.$style.description),
					textContent: toDisplayString(_ctx.description)
				}, null, 10, _hoisted_2$11)) : createCommentVNode("", true)]),
				renderSlot(_ctx.$slots, "dragContent", {}, void 0, true),
				_ctx.showActionArrow ? (openBlock(), createElementBlock("button", {
					key: 1,
					class: normalizeClass(_ctx.$style.panelIcon)
				}, [createVNode(unref(N8nIcon_default), {
					icon: "arrow-right",
					size: "large"
				})], 2)) : createCommentVNode("", true)
			], 16);
		};
	}
});
var NodeCreatorNode_vue_vue_type_style_index_0_lang_module_default = {
	creatorNode: "_creatorNode_b7tre_123",
	hasAction: "_hasAction_b7tre_130",
	panelIcon: "_panelIcon_b7tre_134",
	tag: "_tag_b7tre_138",
	tooltipIcon: "_tooltipIcon_b7tre_161",
	details: "_details_b7tre_167",
	nodeIcon: "_nodeIcon_b7tre_173",
	name: "_name_b7tre_178",
	description: "_description_b7tre_184",
	aiIcon: "_aiIcon_b7tre_192",
	triggerIcon: "_triggerIcon_b7tre_196"
};
var N8nNodeCreatorNode_default = /* @__PURE__ */ __plugin_vue_export_helper_default(NodeCreatorNode_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": NodeCreatorNode_vue_vue_type_style_index_0_lang_module_default }], ["__scopeId", "data-v-f6e3257f"]]);
var _hoisted_1$18 = ["src"];
var IconContent_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "IconContent",
	props: {
		type: {},
		src: {},
		name: {},
		nodeTypeName: {},
		size: {},
		badge: {}
	},
	setup(__props) {
		const props = __props;
		const badgeSize = computed(() => {
			switch (props.size) {
				case 40: return 18;
				case 24: return 10;
				case 18:
				default: return 12;
			}
		});
		const fontStyleData = computed(() => {
			if (!props.size) return {};
			return { "max-width": `${props.size}px` };
		});
		const badgeStyleData = computed(() => {
			const size$2 = badgeSize.value;
			return {
				padding: `${Math.floor(size$2 / 4)}px`,
				right: `-${Math.floor(size$2 / 2)}px`,
				bottom: `-${Math.floor(size$2 / 2)}px`
			};
		});
		const supportedIconName = computed(() => {
			return isSupportedIconName(props.name) ? props.name : void 0;
		});
		return (_ctx, _cache) => {
			return _ctx.type !== "unknown" ? (openBlock(), createElementBlock("div", {
				key: 0,
				class: normalizeClass(_ctx.$style.icon)
			}, [_ctx.type === "file" ? (openBlock(), createElementBlock("img", {
				key: 0,
				src: _ctx.src,
				class: normalizeClass(_ctx.$style.nodeIconImage)
			}, null, 10, _hoisted_1$18)) : supportedIconName.value ? (openBlock(), createBlock(unref(N8nIcon_default), {
				key: 1,
				icon: supportedIconName.value,
				style: normalizeStyle(fontStyleData.value)
			}, null, 8, ["icon", "style"])) : (openBlock(), createElementBlock("div", {
				key: 2,
				class: normalizeClass(_ctx.$style.nodeIconPlaceholder)
			}, toDisplayString(_ctx.nodeTypeName ? _ctx.nodeTypeName.charAt(0) : "?"), 3)), _ctx.badge ? (openBlock(), createElementBlock("div", {
				key: 3,
				class: normalizeClass(_ctx.$style.badge),
				style: normalizeStyle(badgeStyleData.value)
			}, [createVNode(unref(N8nNodeIcon_default), {
				type: _ctx.badge.type,
				src: _ctx.badge.src,
				size: badgeSize.value
			}, null, 8, [
				"type",
				"src",
				"size"
			])], 6)) : createCommentVNode("", true)], 2)) : (openBlock(), createElementBlock("div", {
				key: 1,
				class: normalizeClass(_ctx.$style.nodeIconPlaceholder)
			}, toDisplayString(_ctx.nodeTypeName ? _ctx.nodeTypeName.charAt(0) : "?"), 3));
		};
	}
});
var IconContent_vue_vue_type_style_index_0_lang_module_default = {
	icon: "_icon_h187c_123",
	nodeIconPlaceholder: "_nodeIconPlaceholder_h187c_140",
	nodeIconImage: "_nodeIconImage_h187c_144",
	badge: "_badge_h187c_151"
};
var IconContent_default = /* @__PURE__ */ __plugin_vue_export_helper_default(IconContent_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": IconContent_vue_vue_type_style_index_0_lang_module_default }]]);
var NodeIcon_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "NodeIcon",
	props: {
		type: {},
		src: {},
		name: {},
		nodeTypeName: {},
		size: {},
		disabled: { type: Boolean },
		circle: { type: Boolean },
		color: {},
		showTooltip: { type: Boolean },
		tooltipPosition: { default: "top" },
		badge: {}
	},
	setup(__props) {
		const props = __props;
		const iconStyleData = computed(() => {
			if (!props.size) return { color: props.color || "" };
			return {
				color: props.color || "",
				width: `${props.size}px`,
				height: `${props.size}px`,
				"font-size": `${props.size}px`,
				"line-height": `${props.size}px`
			};
		});
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", mergeProps({ class: "n8n-node-icon" }, _ctx.$attrs), [createBaseVNode("div", {
				class: normalizeClass({
					[_ctx.$style.nodeIconWrapper]: true,
					[_ctx.$style.circle]: _ctx.circle,
					[_ctx.$style.disabled]: _ctx.disabled
				}),
				style: normalizeStyle(iconStyleData.value)
			}, [_ctx.showTooltip ? (openBlock(), createBlock(unref(N8nTooltip_default), {
				key: 0,
				placement: _ctx.tooltipPosition,
				disabled: !_ctx.showTooltip
			}, {
				content: withCtx(() => [createTextVNode(toDisplayString(_ctx.nodeTypeName), 1)]),
				default: withCtx(() => [createVNode(IconContent_default, {
					type: _ctx.type,
					src: _ctx.src,
					name: _ctx.name,
					"node-type-name": _ctx.nodeTypeName,
					size: _ctx.size,
					badge: _ctx.badge
				}, null, 8, [
					"type",
					"src",
					"name",
					"node-type-name",
					"size",
					"badge"
				])]),
				_: 1
			}, 8, ["placement", "disabled"])) : (openBlock(), createBlock(IconContent_default, {
				key: 1,
				type: _ctx.type,
				src: _ctx.src,
				name: _ctx.name,
				"node-type-name": _ctx.nodeTypeName,
				size: _ctx.size,
				badge: _ctx.badge
			}, null, 8, [
				"type",
				"src",
				"name",
				"node-type-name",
				"size",
				"badge"
			]))], 6)], 16);
		};
	}
});
var NodeIcon_vue_vue_type_style_index_0_lang_module_default = {
	nodeIconWrapper: "_nodeIconWrapper_zkhea_123",
	circle: "_circle_zkhea_135",
	disabled: "_disabled_zkhea_139"
};
var N8nNodeIcon_default = /* @__PURE__ */ __plugin_vue_export_helper_default(NodeIcon_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": NodeIcon_vue_vue_type_style_index_0_lang_module_default }]]);
var import_sanitize_html$1 = /* @__PURE__ */ __toESM(require_sanitize_html());
var _hoisted_1$17 = ["id"];
var _hoisted_2$10 = { class: "notice-content" };
var _hoisted_3$4 = ["id"];
var Notice_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "Notice",
	props: {
		id: { default: () => uid("notice") },
		theme: { default: "warning" },
		content: { default: "" },
		fullContent: { default: "" },
		compact: {
			type: Boolean,
			default: true
		}
	},
	emits: ["action"],
	setup(__props, { emit: __emit }) {
		const props = __props;
		const emit = __emit;
		const $style = useCssModule();
		const classes = computed(() => [
			"notice",
			$style.notice,
			$style[props.theme]
		]);
		const canTruncate = computed(() => props.fullContent !== void 0);
		const showFullContent = ref(false);
		const displayContent = computed(() => (0, import_sanitize_html$1.default)(showFullContent.value ? props.fullContent : props.content, { allowedAttributes: { a: [
			"data-key",
			"href",
			"target",
			"data-action",
			"data-action-parameter-connectiontype",
			"data-action-parameter-creatorview"
		] } }));
		const onClick = (event) => {
			if (!(event.target instanceof HTMLElement)) return;
			if (event.target.localName !== "a") return;
			const anchorKey = event.target.dataset?.key;
			if (anchorKey) {
				event.stopPropagation();
				event.preventDefault();
				if (anchorKey === "show-less") showFullContent.value = false;
				else if (canTruncate.value && anchorKey === "toggle-expand") showFullContent.value = !showFullContent.value;
				else emit("action", anchorKey);
			}
		};
		return (_ctx, _cache) => {
			const _directive_n8n_html = resolveDirective("n8n-html");
			return openBlock(), createElementBlock("div", {
				id: _ctx.id,
				class: normalizeClass(classes.value),
				role: "alert",
				onClick
			}, [createBaseVNode("div", _hoisted_2$10, [createVNode(unref(N8nText_default), {
				size: "small",
				compact: _ctx.compact
			}, {
				default: withCtx(() => [renderSlot(_ctx.$slots, "default", {}, () => [withDirectives(createBaseVNode("span", {
					id: `${_ctx.id}-content`,
					class: normalizeClass(showFullContent.value ? unref($style)["expanded"] : unref($style)["truncated"]),
					role: "region"
				}, null, 10, _hoisted_3$4), [[_directive_n8n_html, displayContent.value]])])]),
				_: 3
			}, 8, ["compact"])])], 10, _hoisted_1$17);
		};
	}
});
var Notice_vue_vue_type_style_index_0_lang_module_default = {
	notice: "_notice_18d4u_123",
	warning: "_warning_18d4u_140",
	danger: "_danger_18d4u_145",
	success: "_success_18d4u_150",
	info: "_info_18d4u_155",
	expanded: "_expanded_18d4u_160",
	truncated: "_truncated_18d4u_165"
};
var N8nNotice_default = /* @__PURE__ */ __plugin_vue_export_helper_default(Notice_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": Notice_vue_vue_type_style_index_0_lang_module_default }]]);
var _hoisted_1$16 = ["data-test-id", "onClick"];
var _hoisted_2$9 = ["data-test-id"];
var SelectableList_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "SelectableList",
	props: /* @__PURE__ */ mergeModels({
		inputs: { default: () => [] },
		disabled: {
			type: Boolean,
			default: false
		}
	}, {
		"modelValue": { required: true },
		"modelModifiers": {}
	}),
	emits: /* @__PURE__ */ mergeModels(["removeItem"], ["update:modelValue"]),
	setup(__props, { emit: __emit }) {
		const { t: t$1 } = useI18n();
		const emit = __emit;
		const props = __props;
		const selectedItems = useModel(__props, "modelValue");
		const inputMap = computed(() => Object.fromEntries(props.inputs.map((x$2) => [x$2.name, x$2])));
		const visibleSelectables = computed(() => {
			return props.inputs.filter((selectable) => !selectedItems.value.hasOwnProperty(selectable.name)).sort(itemComparator);
		});
		const sortedSelectedItems = computed(() => {
			return Object.entries(selectedItems.value).map(([name$1, initialValue]) => ({
				...inputMap.value[name$1],
				initialValue
			})).sort(itemComparator);
		});
		function addToSelectedItems(name$1) {
			selectedItems.value[name$1] = inputMap.value[name$1].initialValue;
		}
		function removeFromSelectedItems(name$1) {
			delete selectedItems.value[name$1];
			emit("removeItem", name$1);
		}
		function itemComparator(a$1, b$2) {
			return a$1.name.localeCompare(b$2.name);
		}
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", null, [!_ctx.disabled ? (openBlock(), createElementBlock("div", {
				key: 0,
				class: normalizeClass(_ctx.$style.selectableContainer)
			}, [(openBlock(true), createElementBlock(Fragment, null, renderList(visibleSelectables.value, (item$4) => {
				return openBlock(), createElementBlock("span", {
					key: item$4.name,
					class: normalizeClass(_ctx.$style.selectableCell),
					"data-test-id": `selectable-list-selectable-${item$4.name}`,
					onClick: ($event) => !props.disabled && addToSelectedItems(item$4.name)
				}, [renderSlot(_ctx.$slots, "addItem", mergeProps({ ref_for: true }, item$4), () => [createBaseVNode("div", { class: normalizeClass(_ctx.$style.selectableTextSize) }, toDisplayString(unref(t$1)("selectableList.addDefault")) + " " + toDisplayString(item$4.name), 3)])], 10, _hoisted_1$16);
			}), 128))], 2)) : createCommentVNode("", true), (openBlock(true), createElementBlock(Fragment, null, renderList(sortedSelectedItems.value, (item$4) => {
				return openBlock(), createElementBlock("div", {
					key: item$4.name,
					class: normalizeClass(_ctx.$style.slotComboContainer),
					"data-test-id": `selectable-list-slot-${item$4.name}`
				}, [!_ctx.disabled ? (openBlock(), createBlock(unref(N8nIcon_default), {
					key: 0,
					class: normalizeClass(_ctx.$style.slotRemoveIcon),
					size: "xsmall",
					icon: "trash-2",
					"data-test-id": `selectable-list-remove-slot-${item$4.name}`,
					onClick: ($event) => !_ctx.disabled && removeFromSelectedItems(item$4.name)
				}, null, 8, [
					"class",
					"data-test-id",
					"onClick"
				])) : createCommentVNode("", true), createBaseVNode("div", { class: normalizeClass(_ctx.$style.slotContainer) }, [renderSlot(_ctx.$slots, "displayItem", mergeProps({ ref_for: true }, item$4))], 2)], 10, _hoisted_2$9);
			}), 128))]);
		};
	}
});
var SelectableList_vue_vue_type_style_index_0_lang_module_default = {
	slotComboContainer: "_slotComboContainer_7j5gx_123",
	slotContainer: "_slotContainer_7j5gx_130",
	selectableContainer: "_selectableContainer_7j5gx_134",
	selectableCell: "_selectableCell_7j5gx_140",
	selectableTextSize: "_selectableTextSize_7j5gx_153",
	slotRemoveIcon: "_slotRemoveIcon_7j5gx_158"
};
var N8nSelectableList_default = /* @__PURE__ */ __plugin_vue_export_helper_default(SelectableList_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": SelectableList_vue_vue_type_style_index_0_lang_module_default }]]);
var N8nPopover_default = /* @__PURE__ */ defineComponent({
	__name: "Popover",
	props: { ...popoverProps },
	setup(__props) {
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("span", null, [createVNode(unref(ElPopover), normalizeProps(guardReactiveProps({
				..._ctx.$props,
				..._ctx.$attrs
			})), {
				reference: withCtx(() => [renderSlot(_ctx.$slots, "reference")]),
				default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				_: 3
			}, 16)]);
		};
	}
});
var N8nPopoverReka_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "N8nPopoverReka",
	props: {
		enableScrolling: {
			type: Boolean,
			default: true
		},
		enableSlideIn: {
			type: Boolean,
			default: true
		},
		suppressAutoFocus: {
			type: Boolean,
			default: false
		},
		scrollType: { default: "hover" },
		width: { default: void 0 },
		zIndex: { default: 999 },
		maxHeight: { default: void 0 },
		contentClass: {},
		side: {},
		align: {},
		sideFlip: {
			type: Boolean,
			default: void 0
		},
		sideOffset: { default: 5 },
		reference: {},
		open: {
			type: Boolean,
			default: void 0
		}
	},
	emits: ["update:open"],
	setup(__props, { emit: __emit }) {
		const props = __props;
		const emit = __emit;
		function handleOpenAutoFocus(e) {
			if (props.suppressAutoFocus) e.preventDefault();
		}
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(PopoverRoot_default), {
				open: _ctx.open,
				"onUpdate:open": _cache[0] || (_cache[0] = ($event) => emit("update:open", $event))
			}, {
				default: withCtx(() => [createVNode(unref(PopoverTrigger_default), { "as-child": true }, {
					default: withCtx(() => [renderSlot(_ctx.$slots, "trigger")]),
					_: 3
				}), createVNode(unref(PopoverPortal_default), null, {
					default: withCtx(() => [createVNode(unref(PopoverContent_default), {
						role: "dialog",
						side: _ctx.side,
						"side-flip": _ctx.sideFlip,
						align: _ctx.align,
						"side-offset": _ctx.sideOffset,
						class: normalizeClass([
							_ctx.$style.popoverContent,
							_ctx.contentClass,
							{ [_ctx.$style.enableSlideIn]: _ctx.enableSlideIn }
						]),
						style: normalizeStyle({
							width: _ctx.width,
							zIndex: _ctx.zIndex
						}),
						reference: _ctx.reference,
						onOpenAutoFocus: handleOpenAutoFocus
					}, {
						default: withCtx(() => [_ctx.enableScrolling ? (openBlock(), createBlock(N8nScrollArea_default$1, {
							key: 0,
							"max-height": _ctx.maxHeight,
							type: _ctx.scrollType,
							"enable-vertical-scroll": true,
							"enable-horizontal-scroll": false
						}, {
							default: withCtx(() => [renderSlot(_ctx.$slots, "content", { close: () => emit("update:open", false) })]),
							_: 3
						}, 8, ["max-height", "type"])) : renderSlot(_ctx.$slots, "content", {
							key: 1,
							close: () => emit("update:open", false)
						})]),
						_: 3
					}, 8, [
						"side",
						"side-flip",
						"align",
						"side-offset",
						"class",
						"style",
						"reference"
					])]),
					_: 3
				})]),
				_: 3
			}, 8, ["open"]);
		};
	}
});
var N8nPopoverReka_vue_vue_type_style_index_0_lang_module_default = {
	popoverContent: "_popoverContent_fp6jn_123",
	enableSlideIn: "_enableSlideIn_fp6jn_130",
	slideDownAndFade: "_slideDownAndFade_fp6jn_1",
	slideLeftAndFade: "_slideLeftAndFade_fp6jn_1",
	slideUpAndFade: "_slideUpAndFade_fp6jn_1",
	slideRightAndFade: "_slideRightAndFade_fp6jn_1"
};
var N8nPopoverReka_default$1 = /* @__PURE__ */ __plugin_vue_export_helper_default(N8nPopoverReka_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": N8nPopoverReka_vue_vue_type_style_index_0_lang_module_default }]]);
var N8nPopoverReka_default = N8nPopoverReka_default$1;
var Pulse_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	name: "N8nPulse",
	__name: "Pulse",
	setup(__props) {
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", { class: normalizeClass(["pulse", _ctx.$style.pulseContainer]) }, [createBaseVNode("div", { class: normalizeClass(_ctx.$style.pulse) }, [createBaseVNode("div", { class: normalizeClass(_ctx.$style.pulse2) }, [renderSlot(_ctx.$slots, "default")], 2)], 2)], 2);
		};
	}
});
var Pulse_vue_vue_type_style_index_0_lang_module_default = {
	pulseContainer: "_pulseContainer_1cqsj_123",
	pulse: "_pulse_1cqsj_123",
	pulse2: "_pulse2_1cqsj_139"
};
var N8nPulse_default = /* @__PURE__ */ __plugin_vue_export_helper_default(Pulse_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": Pulse_vue_vue_type_style_index_0_lang_module_default }]]);
var _hoisted_1$15 = ["aria-checked"];
var _hoisted_2$8 = ["data-test-id"];
var RadioButton_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "RadioButton",
	props: {
		label: {},
		value: {},
		active: {
			type: Boolean,
			default: false
		},
		disabled: {
			type: Boolean,
			default: false
		},
		size: { default: "medium" },
		square: {
			type: Boolean,
			default: false
		}
	},
	setup(__props) {
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("label", {
				role: "radio",
				tabindex: "-1",
				class: normalizeClass({
					"n8n-radio-button": true,
					[_ctx.$style.container]: true,
					[_ctx.$style.hoverable]: !_ctx.disabled,
					[_ctx.$style.square]: _ctx.square
				}),
				"aria-checked": _ctx.active
			}, [createBaseVNode("div", {
				class: normalizeClass({
					[_ctx.$style.button]: true,
					[_ctx.$style.active]: _ctx.active,
					[_ctx.$style[_ctx.size]]: true,
					[_ctx.$style.disabled]: _ctx.disabled
				}),
				"data-test-id": `radio-button-${_ctx.value}`
			}, [renderSlot(_ctx.$slots, "default", {}, () => [createTextVNode(toDisplayString(_ctx.label), 1)])], 10, _hoisted_2$8)], 10, _hoisted_1$15);
		};
	}
});
const container$4 = "_container_4oun4_123";
const hoverable = "_hoverable_4oun4_129";
const button$2 = "_button_4oun4_129";
const active = "_active_4oun4_129";
const input$2 = "_input_4oun4_133";
const square = "_square_4oun4_150";
const disabled$4 = "_disabled_4oun4_156";
const medium$3 = "_medium_4oun4_160";
const small$4 = "_small_4oun4_170";
var RadioButton_vue_vue_type_style_index_0_lang_module_default = {
	container: container$4,
	hoverable,
	button: button$2,
	active,
	input: input$2,
	square,
	disabled: disabled$4,
	medium: medium$3,
	"small-medium": "_small-medium_4oun4_170",
	small: small$4
};
var RadioButton_default = /* @__PURE__ */ __plugin_vue_export_helper_default(RadioButton_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": RadioButton_vue_vue_type_style_index_0_lang_module_default }]]);
var RadioButtons_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "RadioButtons",
	props: {
		modelValue: {},
		options: {},
		size: { default: "medium" },
		disabled: {
			type: Boolean,
			default: false
		},
		squareButtons: {
			type: Boolean,
			default: false
		}
	},
	emits: ["update:modelValue"],
	setup(__props, { emit: __emit }) {
		const props = __props;
		const emit = __emit;
		useSlots();
		const onClick = (option, event) => {
			if (props.disabled || option.disabled) return;
			emit("update:modelValue", option.value, event);
		};
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", {
				role: "radiogroup",
				class: normalizeClass({
					"n8n-radio-buttons": true,
					[_ctx.$style.radioGroup]: true,
					[_ctx.$style.disabled]: _ctx.disabled
				})
			}, [(openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.options, (option) => {
				return openBlock(), createBlock(RadioButton_default, mergeProps({
					key: `${option.value}`,
					ref_for: true
				}, option, {
					value: `${option.value}`,
					active: _ctx.modelValue === option.value,
					size: _ctx.size,
					disabled: _ctx.disabled || option.disabled,
					square: _ctx.squareButtons,
					onClick: withModifiers(($event) => onClick(option, $event), ["prevent", "stop"])
				}), {
					default: withCtx(() => [renderSlot(_ctx.$slots, "option", mergeProps({ ref_for: true }, option))]),
					_: 2
				}, 1040, [
					"value",
					"active",
					"size",
					"disabled",
					"square",
					"onClick"
				]);
			}), 128))], 2);
		};
	}
});
var RadioButtons_vue_vue_type_style_index_0_lang_module_default = {
	radioGroup: "_radioGroup_grrb6_123",
	disabled: "_disabled_grrb6_133"
};
var N8nRadioButtons_default = /* @__PURE__ */ __plugin_vue_export_helper_default(RadioButtons_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": RadioButtons_vue_vue_type_style_index_0_lang_module_default }]]);
var N8nRecycleScroller_default = /* @__PURE__ */ defineComponent({
	__name: "RecycleScroller",
	props: {
		itemSize: {},
		items: {},
		itemKey: {},
		offset: { default: 2 }
	},
	setup(__props) {
		const props = __props;
		const wrapperRef = ref(null);
		const scrollerRef = ref(null);
		const itemsRef = ref(null);
		const itemRefs = ref({});
		const scrollTop = ref(0);
		const wrapperHeight = ref(0);
		const windowHeight = ref(0);
		const itemSizeCache = ref({});
		const itemPositionCache = computed(() => {
			return props.items.reduce((acc, item$4, index) => {
				const key$2 = item$4[props.itemKey];
				const prevItem = props.items[index - 1];
				acc[key$2] = (prevItem ? acc[prevItem[props.itemKey]] : 0) + (prevItem ? itemSizeCache.value[prevItem[props.itemKey]] : 0);
				return acc;
			}, {});
		});
		const startIndex = computed(() => {
			const index = props.items.findIndex((item$4) => {
				return itemPositionCache.value[item$4[props.itemKey]] >= scrollTop.value;
			}) - 1 - props.offset;
			return index < 0 ? 0 : index;
		});
		const endIndex = computed(() => {
			const foundIndex = props.items.findIndex((item$4) => {
				return itemPositionCache.value[item$4[props.itemKey]] + itemSizeCache.value[item$4[props.itemKey]] >= scrollTop.value + wrapperHeight.value;
			});
			const index = foundIndex + props.offset;
			return foundIndex === -1 ? props.items.length - 1 : index;
		});
		const visibleItems = computed(() => {
			return props.items.slice(startIndex.value, endIndex.value + 1);
		});
		watch(() => visibleItems.value, (currentValue, previousValue) => {
			const difference = currentValue.filter((currentItem) => !previousValue.find((previousItem) => previousItem[props.itemKey] === currentItem[props.itemKey]));
			if (difference.length > 0) updateItemSizeCache(difference);
		});
		const scrollerHeight = computed(() => {
			const lastItem = props.items[props.items.length - 1];
			return (lastItem ? itemPositionCache.value[lastItem[props.itemKey]] : 0) + (lastItem ? itemSizeCache.value[lastItem[props.itemKey]] : props.itemSize);
		});
		const scrollerStyles = computed(() => ({ height: `${scrollerHeight.value}px` }));
		const itemsStyles = computed(() => {
			return { transform: `translateY(${itemPositionCache.value[props.items[startIndex.value][props.itemKey]]}px)` };
		});
		onBeforeMount(() => {
			initializeItemSizeCache();
		});
		onMounted(() => {
			if (wrapperRef.value) {
				wrapperRef.value.addEventListener("scroll", onScroll);
				updateItemSizeCache(visibleItems.value);
			}
			window.addEventListener("resize", onWindowResize);
			onWindowResize();
		});
		function initializeItemSizeCache() {
			props.items.forEach((item$4) => {
				itemSizeCache.value = {
					...itemSizeCache.value,
					[item$4[props.itemKey]]: props.itemSize
				};
			});
		}
		function updateItemSizeCache(items) {
			for (const item$4 of items) onUpdateItemSize(item$4);
		}
		function onUpdateItemSize(item$4) {
			nextTick(() => {
				const itemId = item$4[props.itemKey];
				const itemRef = itemRefs.value[itemId];
				const previousSize = itemSizeCache.value[itemId];
				const size$2 = itemRef ? itemRef.offsetHeight : props.itemSize;
				const difference = size$2 - previousSize;
				itemSizeCache.value = {
					...itemSizeCache.value,
					[item$4[props.itemKey]]: size$2
				};
				if (wrapperRef.value && scrollTop.value) {
					wrapperRef.value.scrollTop = wrapperRef.value.scrollTop + difference;
					scrollTop.value = wrapperRef.value.scrollTop;
				}
			});
		}
		function onWindowResize() {
			if (wrapperRef.value) {
				wrapperHeight.value = wrapperRef.value.offsetHeight;
				nextTick(() => {
					updateItemSizeCache(visibleItems.value);
				});
			}
			windowHeight.value = window.innerHeight;
		}
		function onScroll() {
			if (!wrapperRef.value) return;
			scrollTop.value = wrapperRef.value.scrollTop;
		}
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", {
				ref_key: "wrapperRef",
				ref: wrapperRef,
				class: "recycle-scroller-wrapper"
			}, [createBaseVNode("div", {
				ref_key: "scrollerRef",
				ref: scrollerRef,
				class: "recycle-scroller",
				style: normalizeStyle(scrollerStyles.value)
			}, [createBaseVNode("div", {
				ref_key: "itemsRef",
				ref: itemsRef,
				class: "recycle-scroller-items-wrapper",
				style: normalizeStyle(itemsStyles.value)
			}, [(openBlock(true), createElementBlock(Fragment, null, renderList(visibleItems.value, (item$4) => {
				return openBlock(), createElementBlock("div", {
					key: item$4[_ctx.itemKey],
					ref_for: true,
					ref: (element) => itemRefs.value[`${item$4[_ctx.itemKey]}`] = element,
					class: "recycle-scroller-item"
				}, [renderSlot(_ctx.$slots, "default", {
					item: item$4,
					updateItemSize: onUpdateItemSize
				})]);
			}), 128))], 4)], 4)], 512);
		};
	}
});
const directionsCursorMaps = {
	right: "ew-resize",
	top: "ns-resize",
	bottom: "ns-resize",
	left: "ew-resize",
	topLeft: "nw-resize",
	topRight: "ne-resize",
	bottomLeft: "sw-resize",
	bottomRight: "se-resize"
};
var _hoisted_1$14 = ["data-dir"];
var ResizeWrapper_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "ResizeWrapper",
	props: {
		isResizingEnabled: {
			type: Boolean,
			default: true
		},
		height: { default: 0 },
		width: { default: 0 },
		minHeight: { default: 0 },
		maxHeight: { default: Number.POSITIVE_INFINITY },
		minWidth: { default: 0 },
		maxWidth: { default: Number.POSITIVE_INFINITY },
		scale: { default: 1 },
		gridSize: { default: 20 },
		supportedDirections: { default: () => [] },
		outset: {
			type: Boolean,
			default: false
		},
		window: { default: void 0 }
	},
	emits: [
		"resizestart",
		"resize",
		"resizeend"
	],
	setup(__props, { emit: __emit }) {
		function closestNumber(value, divisor) {
			const q$1 = value / divisor;
			const n1 = divisor * q$1;
			const n2 = value * divisor > 0 ? divisor * (q$1 + 1) : divisor * (q$1 - 1);
			if (Math.abs(value - n1) < Math.abs(value - n2)) return n1;
			return n2;
		}
		function getSize(min$2, virtual, gridSize, max$2) {
			if (virtual <= 0) return min$2;
			const target$1 = closestNumber(virtual, gridSize);
			if (target$1 <= min$2) return min$2;
			if (target$1 >= max$2) return max$2;
			return target$1;
		}
		const props = __props;
		const $style = useCssModule();
		const emit = __emit;
		const enabledDirections = computed(() => {
			const availableDirections = Object.keys(directionsCursorMaps);
			if (!props.isResizingEnabled) return [];
			if (props.supportedDirections.length === 0) return availableDirections;
			return props.supportedDirections;
		});
		const state = {
			dir: ref(""),
			dHeight: ref(0),
			dWidth: ref(0),
			vHeight: ref(0),
			vWidth: ref(0),
			x: ref(0),
			y: ref(0)
		};
		const classes = computed(() => ({
			[$style.resize]: true,
			[$style.outset]: props.outset
		}));
		const mouseMove = (event) => {
			event.preventDefault();
			event.stopPropagation();
			let dWidth = 0;
			let dHeight = 0;
			let top$3 = false;
			let left$1 = false;
			if (state.dir.value.includes("right")) dWidth = event.pageX - state.x.value;
			if (state.dir.value.includes("left")) {
				dWidth = state.x.value - event.pageX;
				left$1 = true;
			}
			if (state.dir.value.includes("top")) {
				dHeight = state.y.value - event.pageY;
				top$3 = true;
			}
			if (state.dir.value.includes("bottom")) dHeight = event.pageY - state.y.value;
			const deltaWidth = (dWidth - state.dWidth.value) / props.scale;
			const deltaHeight = (dHeight - state.dHeight.value) / props.scale;
			state.vHeight.value = state.vHeight.value + deltaHeight;
			state.vWidth.value = state.vWidth.value + deltaWidth;
			const height = getSize(props.minHeight, state.vHeight.value, props.gridSize, props.maxHeight);
			const width = getSize(props.minWidth, state.vWidth.value, props.gridSize, props.maxWidth);
			const dX = left$1 && width !== props.width ? -1 * (width - props.width) : 0;
			const dY = top$3 && height !== props.height ? -1 * (height - props.height) : 0;
			const x$2 = event.x;
			const y = event.y;
			const direction = state.dir.value;
			emit("resize", {
				height,
				width,
				dX,
				dY,
				x: x$2,
				y,
				direction
			});
			state.dHeight.value = dHeight;
			state.dWidth.value = dWidth;
		};
		const mouseUp = (event) => {
			event.preventDefault();
			event.stopPropagation();
			emit("resizeend");
			(props.window ?? window).removeEventListener("mousemove", mouseMove);
			(props.window ?? window).removeEventListener("mouseup", mouseUp);
			document.body.style.cursor = "unset";
			state.dir.value = "";
		};
		const resizerMove = (event) => {
			event.preventDefault();
			event.stopPropagation();
			const targetResizer = event.target;
			if (targetResizer) state.dir.value = targetResizer.dataset.dir.toLocaleLowerCase();
			document.body.style.cursor = directionsCursorMaps[state.dir.value];
			state.x.value = event.pageX;
			state.y.value = event.pageY;
			state.dWidth.value = 0;
			state.dHeight.value = 0;
			state.vHeight.value = props.height;
			state.vWidth.value = props.width;
			(props.window ?? window).addEventListener("mousemove", mouseMove);
			(props.window ?? window).addEventListener("mouseup", mouseUp);
			emit("resizestart");
		};
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", { class: normalizeClass(classes.value) }, [(openBlock(true), createElementBlock(Fragment, null, renderList(enabledDirections.value, (direction) => {
				return openBlock(), createElementBlock("div", {
					key: direction,
					"data-dir": direction,
					class: normalizeClass({
						[unref($style).resizer]: true,
						[unref($style)[direction]]: true
					}),
					"data-test-id": "resize-handle",
					onMousedown: resizerMove
				}, null, 42, _hoisted_1$14);
			}), 128)), renderSlot(_ctx.$slots, "default")], 2);
		};
	}
});
var ResizeWrapper_vue_vue_type_style_index_0_lang_module_default = {
	resize: "_resize_jv5u1_123",
	resizer: "_resizer_jv5u1_133",
	right: "_right_jv5u1_138",
	top: "_top_jv5u1_146",
	bottom: "_bottom_jv5u1_154",
	left: "_left_jv5u1_162",
	topLeft: "_topLeft_jv5u1_170",
	topRight: "_topRight_jv5u1_178",
	bottomLeft: "_bottomLeft_jv5u1_186",
	bottomRight: "_bottomRight_jv5u1_194",
	outset: "_outset_jv5u1_202"
};
var N8nResizeWrapper_default = /* @__PURE__ */ __plugin_vue_export_helper_default(ResizeWrapper_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": ResizeWrapper_vue_vue_type_style_index_0_lang_module_default }]]);
const defaultStickyProps = {
	height: 180,
	width: 240,
	minHeight: 80,
	minWidth: 150,
	id: "0",
	editMode: false,
	readOnly: false,
	backgroundColor: 1
};
var Sticky_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "Sticky",
	props: /* @__PURE__ */ mergeDefaults({
		modelValue: {},
		height: {},
		width: {},
		minHeight: {},
		minWidth: {},
		id: {},
		defaultText: {},
		editMode: { type: Boolean },
		readOnly: { type: Boolean },
		backgroundColor: {}
	}, defaultStickyProps),
	emits: [
		"edit",
		"update:modelValue",
		"markdown-click"
	],
	setup(__props, { emit: __emit }) {
		const props = __props;
		const emit = __emit;
		const { t: t$1 } = useI18n();
		const isResizing = ref(false);
		const input$4 = ref(void 0);
		const resHeight = computed(() => {
			return props.height < props.minHeight ? props.minHeight : props.height;
		});
		const resWidth = computed(() => {
			return props.width < props.minWidth ? props.minWidth : props.width;
		});
		const inputName = computed(() => props.id ? `${props.id}-input` : void 0);
		const styles = computed(() => ({
			height: `${resHeight.value}px`,
			width: `${resWidth.value}px`
		}));
		const shouldShowFooter = computed(() => resHeight.value > 100 && resWidth.value > 155);
		watch(() => props.editMode, (newMode, prevMode) => {
			setTimeout(() => {
				if (newMode && !prevMode && input$4.value) {
					if (props.defaultText === props.modelValue) input$4.value.select();
					input$4.value.focus();
				}
			}, 100);
		});
		const onDoubleClick = () => {
			if (!props.readOnly) emit("edit", true);
		};
		const onInputBlur = () => {
			if (!isResizing.value) emit("edit", false);
		};
		const onUpdateModelValue = (value) => {
			emit("update:modelValue", value);
		};
		const onMarkdownClick = (link$3, event) => {
			emit("markdown-click", link$3, event);
		};
		const onInputScroll = (event) => {
			if (!event.ctrlKey && !event.metaKey) event.stopPropagation();
		};
		return (_ctx, _cache) => {
			const _directive_n8n_html = resolveDirective("n8n-html");
			return openBlock(), createElementBlock("div", {
				class: normalizeClass({
					"n8n-sticky": true,
					[_ctx.$style.sticky]: true,
					[_ctx.$style.clickable]: !isResizing.value,
					[_ctx.$style[`color-${_ctx.backgroundColor}`]]: true
				}),
				style: normalizeStyle(styles.value),
				onKeydown: _cache[4] || (_cache[4] = withModifiers(() => {}, ["prevent"]))
			}, [
				withDirectives(createBaseVNode("div", {
					class: normalizeClass(_ctx.$style.wrapper),
					onDblclick: withModifiers(onDoubleClick, ["stop"])
				}, [createVNode(unref(N8nMarkdown_default), {
					theme: "sticky",
					content: _ctx.modelValue,
					"with-multi-breaks": true,
					onMarkdownClick,
					onUpdateContent: onUpdateModelValue
				}, null, 8, ["content"])], 34), [[vShow, !_ctx.editMode]]),
				withDirectives(createBaseVNode("div", {
					class: normalizeClass({
						"full-height": !shouldShowFooter.value,
						"sticky-textarea": true
					}),
					onClick: _cache[0] || (_cache[0] = withModifiers(() => {}, ["stop"])),
					onMousedown: _cache[1] || (_cache[1] = withModifiers(() => {}, ["stop"])),
					onMouseup: _cache[2] || (_cache[2] = withModifiers(() => {}, ["stop"])),
					onKeydown: [withKeys(onInputBlur, ["esc"]), _cache[3] || (_cache[3] = withModifiers(() => {}, ["stop"]))]
				}, [createVNode(unref(N8nInput_default), {
					ref_key: "input",
					ref: input$4,
					"model-value": _ctx.modelValue,
					name: inputName.value,
					type: "textarea",
					rows: 5,
					onBlur: onInputBlur,
					"onUpdate:modelValue": onUpdateModelValue,
					onWheel: onInputScroll
				}, null, 8, ["model-value", "name"])], 34), [[vShow, _ctx.editMode]]),
				_ctx.editMode && shouldShowFooter.value ? (openBlock(), createElementBlock("div", {
					key: 0,
					class: normalizeClass(_ctx.$style.footer)
				}, [createVNode(unref(N8nText_default), {
					size: "xsmall",
					align: "right"
				}, {
					default: withCtx(() => [withDirectives(createBaseVNode("span", null, null, 512), [[_directive_n8n_html, unref(t$1)("sticky.markdownHint")]])]),
					_: 1
				})], 2)) : createCommentVNode("", true)
			], 38);
		};
	}
});
var Sticky_vue_vue_type_style_index_0_lang_module_default = {
	sticky: "_sticky_140qk_123",
	clickable: "_clickable_140qk_130",
	wrapper: "_wrapper_140qk_134",
	footer: "_footer_140qk_142",
	"color-2": "_color-2_140qk_148",
	"color-3": "_color-3_140qk_153",
	"color-4": "_color-4_140qk_158",
	"color-5": "_color-5_140qk_163",
	"color-6": "_color-6_140qk_168",
	"color-7": "_color-7_140qk_173"
};
var N8nSticky_default = /* @__PURE__ */ __plugin_vue_export_helper_default(Sticky_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": Sticky_vue_vue_type_style_index_0_lang_module_default }]]);
Boolean, Boolean, { ...defaultStickyProps };
var _hoisted_1$13 = { key: 1 };
var Tag_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	name: "N8nTag",
	__name: "Tag",
	props: {
		text: {},
		clickable: {
			type: Boolean,
			default: true
		}
	},
	setup(__props) {
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("span", mergeProps({ class: [
				"n8n-tag",
				_ctx.$style.tag,
				{ [_ctx.$style.clickable]: _ctx.clickable }
			] }, _ctx.$attrs), [_ctx.$slots["tag"] ? renderSlot(_ctx.$slots, "tag", { key: 0 }) : (openBlock(), createElementBlock("span", _hoisted_1$13, toDisplayString(_ctx.text), 1))], 16);
		};
	}
});
var Tag_vue_vue_type_style_index_0_lang_module_default = {
	tag: "_tag_19sw8_123",
	clickable: "_clickable_19sw8_138"
};
var Tag_default = /* @__PURE__ */ __plugin_vue_export_helper_default(Tag_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": Tag_vue_vue_type_style_index_0_lang_module_default }]]);
var N8nTag_default = Tag_default;
var _hoisted_1$12 = ["data-action-id", "onClick"];
var _hoisted_2$7 = { key: 0 };
var SuggestedActions_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	name: "N8nSuggestedActions",
	__name: "SuggestedActions",
	props: {
		title: {},
		actions: {},
		open: { type: Boolean },
		ignoreAllLabel: { default: void 0 },
		popoverAlignment: { default: void 0 },
		notice: { default: void 0 }
	},
	emits: [
		"action-click",
		"ignore-click",
		"ignore-all",
		"update:open"
	],
	setup(__props, { emit: __emit }) {
		const props = __props;
		const emit = __emit;
		const { t: t$1 } = useI18n();
		const ignoringActions = ref(/* @__PURE__ */ new Set());
		const completedCount = computed(() => props.actions.filter((action) => action.completed).length);
		const handleActionClick = (action) => {
			if (!action.completed) emit("action-click", action.id);
		};
		const handleIgnoreClick = (actionId) => {
			ignoringActions.value.add(actionId);
			setTimeout(() => {
				emit("ignore-click", actionId);
				ignoringActions.value.delete(actionId);
			}, 500);
		};
		return (_ctx, _cache) => {
			return completedCount.value !== _ctx.actions.length ? (openBlock(), createBlock(unref(N8nPopoverReka_default), {
				key: 0,
				open: _ctx.open,
				width: "360px",
				"max-height": "500px",
				align: _ctx.popoverAlignment,
				"onUpdate:open": _cache[2] || (_cache[2] = ($event) => _ctx.$emit("update:open", $event))
			}, {
				trigger: withCtx(() => [createBaseVNode("div", {
					class: normalizeClass([_ctx.$style.triggerContainer, _ctx.open ? _ctx.$style.activeTrigger : ""]),
					"data-test-id": "suggested-action-count"
				}, [createVNode(unref(N8nTag_default), { text: `${completedCount.value} / ${_ctx.actions.length}` }, null, 8, ["text"])], 2)]),
				content: withCtx(() => [createBaseVNode("div", { class: normalizeClass(_ctx.$style.popoverContent) }, [
					createVNode(unref(N8nHeading_default), { tag: "h4" }, {
						default: withCtx(() => [createTextVNode(toDisplayString(_ctx.title), 1)]),
						_: 1
					}),
					_ctx.notice ? (openBlock(), createBlock(unref(N8nCallout_default), {
						key: 0,
						theme: "warning"
					}, {
						default: withCtx(() => [createTextVNode(toDisplayString(_ctx.notice), 1)]),
						_: 1
					})) : createCommentVNode("", true),
					(openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.actions, (action) => {
						return openBlock(), createElementBlock("div", {
							key: action.id,
							class: normalizeClass([{
								[_ctx.$style.actionItem]: true,
								[_ctx.$style.ignoring]: ignoringActions.value.has(action.id),
								[_ctx.$style.actionable]: !action.completed
							}]),
							"data-test-id": "suggested-action-item",
							"data-action-id": action.id,
							onClick: withModifiers(() => handleActionClick(action), ["prevent", "stop"])
						}, [
							createBaseVNode("div", { class: normalizeClass(_ctx.$style.checkboxContainer) }, [action.completed ? (openBlock(), createBlock(unref(N8nIcon_default), {
								key: 0,
								icon: "circle-check",
								color: "success"
							})) : (openBlock(), createBlock(unref(N8nIcon_default), {
								key: 1,
								icon: "circle",
								color: "foreground-dark"
							}))], 2),
							createBaseVNode("div", { class: normalizeClass(_ctx.$style.actionItemBody) }, [createBaseVNode("div", { class: normalizeClass([action.completed ? "" : "mb-3xs", _ctx.$style.actionHeader]) }, [createVNode(unref(N8nText_default), {
								size: "medium",
								bold: true
							}, {
								default: withCtx(() => [createTextVNode(toDisplayString(action.title), 1)]),
								_: 2
							}, 1024)], 2), !action.completed ? (openBlock(), createElementBlock("div", _hoisted_2$7, [createVNode(unref(N8nText_default), {
								size: "small",
								color: "text-base"
							}, {
								default: withCtx(() => [createTextVNode(toDisplayString(action.description) + " ", 1), action.moreInfoLink ? (openBlock(), createBlock(unref(N8nLink_default), {
									key: 0,
									to: action.moreInfoLink,
									size: "small",
									theme: "text",
									"new-window": "",
									underline: "",
									onClick: _cache[0] || (_cache[0] = withModifiers(() => {}, ["stop"]))
								}, {
									default: withCtx(() => [createTextVNode(toDisplayString(unref(t$1)("generic.moreInfo")), 1)]),
									_: 2
								}, 1032, ["to"])) : createCommentVNode("", true)]),
								_: 2
							}, 1024)])) : createCommentVNode("", true)], 2),
							createVNode(unref(N8nLink_default), {
								theme: "text",
								title: unref(t$1)("generic.ignore"),
								"data-test-id": "suggested-action-ignore",
								onClick: withModifiers(($event) => handleIgnoreClick(action.id), ["prevent", "stop"])
							}, {
								default: withCtx(() => [!action.completed ? (openBlock(), createBlock(unref(N8nIcon_default), {
									key: 0,
									icon: "x",
									size: "large"
								})) : createCommentVNode("", true)]),
								_: 2
							}, 1032, ["title", "onClick"])
						], 10, _hoisted_1$12);
					}), 128)),
					createBaseVNode("div", { class: normalizeClass(_ctx.$style.ignoreAllContainer) }, [createVNode(unref(N8nLink_default), {
						theme: "text",
						size: "small",
						underline: "",
						"data-test-id": "suggested-action-ignore-all",
						onClick: _cache[1] || (_cache[1] = withModifiers(($event) => emit("ignore-all"), ["prevent", "stop"]))
					}, {
						default: withCtx(() => [createTextVNode(toDisplayString(_ctx.ignoreAllLabel ?? unref(t$1)("generic.ignoreAll")), 1)]),
						_: 1
					})], 2)
				], 2)]),
				_: 1
			}, 8, ["open", "align"])) : createCommentVNode("", true);
		};
	}
});
var SuggestedActions_vue_vue_type_style_index_0_lang_module_default = {
	triggerContainer: "_triggerContainer_btjxf_123",
	activeTrigger: "_activeTrigger_btjxf_129",
	popoverContent: "_popoverContent_btjxf_134",
	actionItem: "_actionItem_btjxf_141",
	ignoring: "_ignoring_btjxf_147",
	actionable: "_actionable_btjxf_154",
	actionHeader: "_actionHeader_btjxf_157",
	actionItemBody: "_actionItemBody_btjxf_164",
	checkboxContainer: "_checkboxContainer_btjxf_171",
	ignoreAllContainer: "_ignoreAllContainer_btjxf_176"
};
var SuggestedActions_default = /* @__PURE__ */ __plugin_vue_export_helper_default(SuggestedActions_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": SuggestedActions_vue_vue_type_style_index_0_lang_module_default }]]);
var _hoisted_1$11 = ["id", "data-test-id"];
var _hoisted_2$6 = ["onClick"];
var _hoisted_3$3 = ["href", "onClick"];
var _hoisted_4$3 = { key: 1 };
var _hoisted_5$2 = ["onClick"];
var Tabs_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "Tabs",
	props: {
		modelValue: { default: void 0 },
		options: { default: () => [] },
		size: { default: "medium" },
		variant: { default: "legacy" }
	},
	emits: ["tooltipClick", "update:modelValue"],
	setup(__props, { emit: __emit }) {
		const scrollPosition = ref(0);
		const canScrollRight = ref(false);
		const tabs$2 = ref(void 0);
		let resizeObserver = null;
		onMounted(() => {
			const container$18 = tabs$2.value;
			if (container$18) {
				container$18.addEventListener("scroll", (event) => {
					const width$1 = container$18.clientWidth;
					const scrollWidth = container$18.scrollWidth;
					scrollPosition.value = event.target.scrollLeft;
					canScrollRight.value = scrollWidth - width$1 > scrollPosition.value;
				});
				resizeObserver = new ResizeObserver(() => {
					const width$1 = container$18.clientWidth;
					canScrollRight.value = container$18.scrollWidth - width$1 > scrollPosition.value;
				});
				resizeObserver.observe(container$18);
				const width = container$18.clientWidth;
				canScrollRight.value = container$18.scrollWidth - width > scrollPosition.value;
			}
		});
		onUnmounted(() => {
			resizeObserver?.disconnect();
		});
		const emit = __emit;
		const handleTooltipClick = (tab$1, event) => emit("tooltipClick", tab$1, event);
		const handleTabClick = (tab$1) => emit("update:modelValue", tab$1);
		const scroll$1 = (left$1) => {
			const container$18 = tabs$2.value;
			if (container$18) container$18.scrollBy({
				left: left$1,
				top: 0,
				behavior: "smooth"
			});
		};
		const scrollLeft = () => scroll$1(-50);
		const scrollRight = () => scroll$1(50);
		return (_ctx, _cache) => {
			const _directive_n8n_html = resolveDirective("n8n-html");
			return openBlock(), createElementBlock("div", { class: normalizeClass([
				"n8n-tabs",
				_ctx.$style.container,
				_ctx.size === "small" ? _ctx.$style.small : "",
				_ctx.variant === "modern" ? _ctx.$style.modern : ""
			]) }, [
				scrollPosition.value > 0 ? (openBlock(), createElementBlock("div", {
					key: 0,
					class: normalizeClass(_ctx.$style.back),
					onClick: scrollLeft
				}, [createVNode(unref(N8nIcon_default), {
					class: normalizeClass(_ctx.$style.positionIcon),
					icon: "chevron-left",
					size: "small"
				}, null, 8, ["class"])], 2)) : createCommentVNode("", true),
				canScrollRight.value ? (openBlock(), createElementBlock("div", {
					key: 1,
					class: normalizeClass(_ctx.$style.next),
					onClick: scrollRight
				}, [createVNode(unref(N8nIcon_default), {
					class: normalizeClass(_ctx.$style.positionIcon),
					icon: "chevron-right",
					size: "small"
				}, null, 8, ["class"])], 2)) : createCommentVNode("", true),
				createBaseVNode("div", {
					ref_key: "tabs",
					ref: tabs$2,
					class: normalizeClass(_ctx.$style.tabs)
				}, [(openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.options, (option) => {
					return openBlock(), createElementBlock("div", {
						id: option.value.toString(),
						key: option.value,
						"data-test-id": `tab-${option.value.toString()}`,
						class: normalizeClass({ [_ctx.$style.alignRight]: option.align === "right" })
					}, [createVNode(unref(N8nTooltip_default), {
						disabled: !option.tooltip,
						placement: "bottom",
						"show-after": 100
					}, {
						content: withCtx(() => [withDirectives(createBaseVNode("div", { onClick: ($event) => handleTooltipClick(option.value, $event) }, null, 8, _hoisted_2$6), [[_directive_n8n_html, option.tooltip]])]),
						default: withCtx(() => [option.href ? (openBlock(), createElementBlock("a", {
							key: 0,
							target: "_blank",
							href: option.href,
							rel: "noopener noreferrer",
							class: normalizeClass([
								_ctx.$style.link,
								_ctx.$style.tab,
								option.label ? "" : _ctx.$style.noText
							]),
							onClick: () => handleTabClick(option.value)
						}, [createBaseVNode("div", null, [createTextVNode(toDisplayString(option.label) + " ", 1), createVNode(unref(N8nIcon_default), {
							class: normalizeClass(_ctx.$style.external),
							icon: option.icon ?? "external-link",
							size: "small"
						}, null, 8, ["class", "icon"])])], 10, _hoisted_3$3)) : option.to ? (openBlock(), createBlock(unref(RouterLink), {
							key: 1,
							to: option.to,
							class: normalizeClass([_ctx.$style.tab, {
								[_ctx.$style.activeTab]: _ctx.modelValue === option.value,
								[_ctx.$style.noText]: !option.label
							}])
						}, {
							default: withCtx(() => [
								option.icon ? (openBlock(), createBlock(unref(N8nIcon_default), {
									key: 0,
									icon: option.icon,
									size: "medium"
								}, null, 8, ["icon"])) : createCommentVNode("", true),
								option.label ? (openBlock(), createElementBlock("span", _hoisted_4$3, toDisplayString(option.label), 1)) : createCommentVNode("", true),
								option.tag ? (openBlock(), createBlock(Tag_default, {
									key: 2,
									text: option.tag,
									clickable: false
								}, null, 8, ["text"])) : createCommentVNode("", true)
							]),
							_: 2
						}, 1032, ["to", "class"])) : (openBlock(), createElementBlock("div", {
							key: 2,
							class: normalizeClass({
								[_ctx.$style.tab]: true,
								[_ctx.$style.activeTab]: _ctx.modelValue === option.value,
								[_ctx.$style.noText]: !option.label,
								[_ctx.$style.dangerTab]: option.variant === "danger"
							}),
							onClick: () => handleTabClick(option.value)
						}, [
							option.icon && option.iconPosition !== "right" ? (openBlock(), createBlock(unref(N8nIcon_default), {
								key: 0,
								icon: option.icon,
								class: normalizeClass(_ctx.$style.icon),
								size: "small"
							}, null, 8, ["icon", "class"])) : createCommentVNode("", true),
							option.label ? (openBlock(), createElementBlock("span", {
								key: 1,
								class: normalizeClass(_ctx.$style.notificationContainer)
							}, [createTextVNode(toDisplayString(option.label) + " ", 1), option.notification ? (openBlock(), createElementBlock("div", {
								key: 0,
								class: normalizeClass(_ctx.$style.notification)
							}, null, 2)) : createCommentVNode("", true)], 2)) : createCommentVNode("", true),
							option.icon && option.iconPosition === "right" ? (openBlock(), createBlock(unref(N8nIcon_default), {
								key: 2,
								icon: option.icon,
								class: normalizeClass(_ctx.$style.icon),
								size: "small"
							}, null, 8, ["icon", "class"])) : createCommentVNode("", true),
							option.tag ? (openBlock(), createBlock(Tag_default, {
								key: 3,
								text: option.tag,
								clickable: false
							}, null, 8, ["text"])) : createCommentVNode("", true)
						], 10, _hoisted_5$2))]),
						_: 2
					}, 1032, ["disabled"])], 10, _hoisted_1$11);
				}), 128))], 2)
			], 2);
		};
	}
});
var Tabs_vue_vue_type_style_index_0_lang_module_default = {
	container: "_container_66nao_123",
	modern: "_modern_66nao_129",
	tabs: "_tabs_66nao_134",
	small: "_small_66nao_150",
	tab: "_tab_66nao_134",
	activeTab: "_activeTab_66nao_184",
	alignRight: "_alignRight_66nao_193",
	link: "_link_66nao_197",
	external: "_external_66nao_205",
	noText: "_noText_66nao_209",
	icon: "_icon_66nao_214",
	dangerTab: "_dangerTab_66nao_218",
	button: "_button_66nao_225",
	notificationContainer: "_notificationContainer_66nao_236",
	notification: "_notification_66nao_236",
	back: "_back_66nao_257 _tab_66nao_134 _button_66nao_225",
	next: "_next_66nao_263 _tab_66nao_134 _button_66nao_225",
	positionIcon: "_positionIcon_66nao_269"
};
var N8nTabs_default = /* @__PURE__ */ __plugin_vue_export_helper_default(Tabs_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": Tabs_vue_vue_type_style_index_0_lang_module_default }]]);
var Tags_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	name: "N8nTags",
	__name: "Tags",
	props: {
		tags: { default: () => [] },
		truncate: {
			type: Boolean,
			default: false
		},
		truncateAt: { default: 3 },
		clickable: {
			type: Boolean,
			default: true
		}
	},
	emits: ["expand", "click:tag"],
	setup(__props, { emit: __emit }) {
		const props = __props;
		const emit = __emit;
		const { t: t$1 } = useI18n();
		const showAll = ref(false);
		const visibleTags = computed(() => {
			const { tags: tags$1, truncate: truncate$1, truncateAt } = props;
			if (truncate$1 && !showAll.value && tags$1.length > truncateAt) return tags$1.slice(0, truncateAt);
			return tags$1;
		});
		const hiddenTagsLength = computed(() => props.tags.length - props.truncateAt);
		const onExpand = () => {
			showAll.value = true;
			emit("expand", true);
		};
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", { class: normalizeClass(["n8n-tags", _ctx.$style.tags]) }, [(openBlock(true), createElementBlock(Fragment, null, renderList(visibleTags.value, (tag$2) => {
				return openBlock(), createBlock(unref(N8nTag_default), {
					key: tag$2.id,
					text: tag$2.name,
					clickable: _ctx.clickable,
					onClick: ($event) => emit("click:tag", tag$2.id, $event)
				}, null, 8, [
					"text",
					"clickable",
					"onClick"
				]);
			}), 128)), _ctx.truncate && !showAll.value && hiddenTagsLength.value > 0 ? (openBlock(), createBlock(unref(N8nLink_default), {
				key: 0,
				theme: "text",
				underline: "",
				size: "small",
				onClick: withModifiers(onExpand, ["stop", "prevent"])
			}, {
				default: withCtx(() => [createTextVNode(toDisplayString(unref(t$1)("tags.showMore", [`${hiddenTagsLength.value}`])), 1)]),
				_: 1
			})) : createCommentVNode("", true)], 2);
		};
	}
});
var Tags_vue_vue_type_style_index_0_lang_module_default = { tags: "_tags_1amla_123" };
var N8nTags_default = /* @__PURE__ */ __plugin_vue_export_helper_default(Tags_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": Tags_vue_vue_type_style_index_0_lang_module_default }]]);
var _hoisted_1$10 = {
	key: 0,
	class: "n8n-tree"
};
var _hoisted_2$5 = { key: 1 };
var _hoisted_3$2 = { key: 3 };
var _hoisted_4$2 = { key: 1 };
var _hoisted_5$1 = { key: 1 };
var Tree_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	name: "N8nTree",
	__name: "Tree",
	props: {
		value: { default: () => ({}) },
		path: { default: () => [] },
		depth: { default: 0 },
		nodeClass: { default: "" }
	},
	setup(__props) {
		const props = __props;
		const $style = useCssModule();
		const classes = computed(() => {
			return {
				[props.nodeClass]: !!props.nodeClass,
				[$style.indent]: props.depth > 0
			};
		});
		const isObject$3 = (data) => {
			return typeof data === "object" && data !== null;
		};
		const isSimple = (data) => {
			if (data === null || data === void 0) return true;
			if (typeof data === "object" && Object.keys(data).length === 0) return true;
			if (Array.isArray(data) && data.length === 0) return true;
			return typeof data !== "object";
		};
		const getPath = (key$2) => {
			if (Array.isArray(props.value)) return [...props.path, parseInt(key$2, 10)];
			return [...props.path, key$2];
		};
		const N8nTree = getCurrentInstance()?.type;
		return (_ctx, _cache) => {
			return isObject$3(_ctx.value) ? (openBlock(), createElementBlock("div", _hoisted_1$10, [(openBlock(true), createElementBlock(Fragment, null, renderList(Object.keys(_ctx.value), (label$3, i$1) => {
				return openBlock(), createElementBlock("div", {
					key: i$1,
					class: normalizeClass(classes.value)
				}, [isSimple(_ctx.value[label$3]) ? (openBlock(), createElementBlock("div", {
					key: 0,
					class: normalizeClass(unref($style).simple)
				}, [
					!!_ctx.$slots.label ? renderSlot(_ctx.$slots, "label", {
						key: 0,
						label: label$3,
						path: getPath(label$3)
					}) : (openBlock(), createElementBlock("span", _hoisted_2$5, toDisplayString(label$3), 1)),
					_cache[0] || (_cache[0] = createBaseVNode("span", null, ":", -1)),
					!!_ctx.$slots.value ? renderSlot(_ctx.$slots, "value", {
						key: 2,
						value: _ctx.value[label$3]
					}) : (openBlock(), createElementBlock("span", _hoisted_3$2, toDisplayString(_ctx.value[label$3]), 1))
				], 2)) : (openBlock(), createElementBlock("div", _hoisted_4$2, [!!_ctx.$slots.label ? renderSlot(_ctx.$slots, "label", {
					key: 0,
					label: label$3,
					path: getPath(label$3)
				}) : (openBlock(), createElementBlock("span", _hoisted_5$1, toDisplayString(label$3), 1)), isObject$3(_ctx.value[label$3]) ? (openBlock(), createBlock(unref(N8nTree), {
					key: 2,
					path: getPath(label$3),
					depth: _ctx.depth + 1,
					value: _ctx.value[label$3],
					"node-class": _ctx.nodeClass
				}, createSlots({ _: 2 }, [!!_ctx.$slots.label ? {
					name: "label",
					fn: withCtx((data) => [renderSlot(_ctx.$slots, "label", mergeProps({ ref_for: true }, data))]),
					key: "0"
				} : void 0, !!_ctx.$slots.value ? {
					name: "value",
					fn: withCtx((data) => [renderSlot(_ctx.$slots, "value", mergeProps({ ref_for: true }, data))]),
					key: "1"
				} : void 0]), 1032, [
					"path",
					"depth",
					"value",
					"node-class"
				])) : createCommentVNode("", true)]))], 2);
			}), 128))])) : createCommentVNode("", true);
		};
	}
});
var Tree_vue_vue_type_style_index_0_lang_module_default = {
	indent: "_indent_ggz6e_123",
	simple: "_simple_ggz6e_127"
};
var N8nTree_default = /* @__PURE__ */ __plugin_vue_export_helper_default(Tree_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": Tree_vue_vue_type_style_index_0_lang_module_default }]]);
var UserInfo_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "UserInfo",
	props: {
		firstName: {},
		lastName: {},
		email: {},
		isOwner: { type: Boolean },
		isPendingUser: { type: Boolean },
		isCurrentUser: { type: Boolean },
		disabled: {
			type: Boolean,
			default: false
		},
		settings: {},
		isSamlLoginEnabled: { type: Boolean },
		mfaEnabled: { type: Boolean }
	},
	setup(__props) {
		const props = __props;
		const { t: t$1 } = useI18n();
		const $style = useCssModule();
		const classes = computed(() => ({
			[$style.container]: true,
			[$style.disabled]: props.disabled
		}));
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", { class: normalizeClass(classes.value) }, [createBaseVNode("div", { class: normalizeClass(unref($style).avatarContainer) }, [createVNode(unref(N8nAvatar_default), {
				"first-name": _ctx.firstName,
				"last-name": _ctx.lastName
			}, null, 8, ["first-name", "last-name"])], 2), _ctx.isPendingUser ? (openBlock(), createElementBlock("div", {
				key: 0,
				class: normalizeClass(unref($style).pendingUser)
			}, [createVNode(unref(N8nText_default), { bold: true }, {
				default: withCtx(() => [createTextVNode(toDisplayString(_ctx.email), 1)]),
				_: 1
			}), createBaseVNode("span", { class: normalizeClass(unref($style).pendingBadge) }, [createVNode(unref(N8nBadge_default), { bold: true }, {
				default: withCtx(() => _cache[0] || (_cache[0] = [createTextVNode("Pending")])),
				_: 1
			})], 2)], 2)) : (openBlock(), createElementBlock("div", {
				key: 1,
				class: normalizeClass(unref($style).infoContainer)
			}, [createBaseVNode("div", null, [createVNode(unref(N8nText_default), {
				bold: true,
				color: "text-dark"
			}, {
				default: withCtx(() => [createTextVNode(toDisplayString(_ctx.firstName) + " " + toDisplayString(_ctx.lastName) + " " + toDisplayString(_ctx.isCurrentUser ? unref(t$1)("nds.userInfo.you") : ""), 1)]),
				_: 1
			}), _ctx.disabled ? (openBlock(), createElementBlock("span", {
				key: 0,
				class: normalizeClass(unref($style).pendingBadge)
			}, [createVNode(unref(N8nBadge_default), { bold: true }, {
				default: withCtx(() => _cache[1] || (_cache[1] = [createTextVNode("Disabled")])),
				_: 1
			})], 2)) : createCommentVNode("", true)]), createBaseVNode("div", null, [createVNode(unref(N8nText_default), {
				"data-test-id": "user-email",
				size: "small",
				color: "text-light"
			}, {
				default: withCtx(() => [createTextVNode(toDisplayString(_ctx.email), 1)]),
				_: 1
			})])], 2))], 2);
		};
	}
});
var UserInfo_vue_vue_type_style_index_0_lang_module_default = {
	container: "_container_r3yvw_123",
	avatarContainer: "_avatarContainer_r3yvw_128",
	infoContainer: "_infoContainer_r3yvw_135",
	pendingUser: "_pendingUser_r3yvw_143",
	pendingBadge: "_pendingBadge_r3yvw_150",
	disabled: "_disabled_r3yvw_154"
};
var N8nUserInfo_default = /* @__PURE__ */ __plugin_vue_export_helper_default(UserInfo_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": UserInfo_vue_vue_type_style_index_0_lang_module_default }]]);
var _hoisted_1$9 = {
	class: "user-stack",
	"data-test-id": "user-stack-container"
};
var UserStack_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "UserStack",
	props: {
		users: {},
		currentUserEmail: { default: "" },
		maxAvatars: { default: 2 },
		dropdownTrigger: { default: "hover" }
	},
	setup(__props) {
		const props = __props;
		const nonEmptyGroups = computed(() => {
			const users = {};
			for (const groupName$1 in props.users) if (props.users[groupName$1].length > 0) users[groupName$1] = props.users[groupName$1];
			return users;
		});
		const groupCount = computed(() => {
			return Object.keys(nonEmptyGroups.value).length;
		});
		const flatUserList = computed(() => {
			const users = [];
			for (const groupName$1 in props.users) users.push(...props.users[groupName$1]);
			return users;
		});
		const visibleAvatarCount = computed(() => {
			return flatUserList.value.length >= props.maxAvatars ? props.maxAvatars : flatUserList.value.length;
		});
		const hiddenUsersCount = computed(() => {
			return flatUserList.value.length - visibleAvatarCount.value;
		});
		const menuHeight = computed(() => {
			return groupCount.value > 1 ? 220 : 190;
		});
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", _hoisted_1$9, [createVNode(unref(ElDropdown), {
				trigger: _ctx.$props.dropdownTrigger,
				"max-height": menuHeight.value,
				"popper-class": "user-stack-popper"
			}, {
				dropdown: withCtx(() => [createVNode(unref(ElDropdownMenu), {
					class: "user-stack-list",
					"data-test-id": "user-stack-list"
				}, {
					default: withCtx(() => [(openBlock(true), createElementBlock(Fragment, null, renderList(nonEmptyGroups.value, (groupUsers$1, index) => {
						return openBlock(), createElementBlock("div", { key: index }, [createBaseVNode("div", { class: normalizeClass(_ctx.$style.groupContainer) }, [createVNode(unref(ElDropdownItem), null, {
							default: withCtx(() => [groupCount.value > 1 ? (openBlock(), createElementBlock("header", {
								key: 0,
								class: normalizeClass(_ctx.$style.groupName)
							}, toDisplayString(index), 3)) : createCommentVNode("", true)]),
							_: 2
						}, 1024), createBaseVNode("div", { class: normalizeClass(_ctx.$style.groupUsers) }, [(openBlock(true), createElementBlock(Fragment, null, renderList(groupUsers$1, (user) => {
							return openBlock(), createBlock(unref(ElDropdownItem), {
								key: user.id,
								"data-test-id": `user-stack-info-${user.id}`,
								class: normalizeClass(_ctx.$style.userInfoContainer)
							}, {
								default: withCtx(() => [createVNode(unref(N8nUserInfo_default), mergeProps({ ref_for: true }, user, { "is-current-user": user.email === props.currentUserEmail }), null, 16, ["is-current-user"])]),
								_: 2
							}, 1032, ["data-test-id", "class"]);
						}), 128))], 2)], 2)]);
					}), 128))]),
					_: 1
				})]),
				default: withCtx(() => [createBaseVNode("div", {
					class: normalizeClass(_ctx.$style.avatars),
					"data-test-id": "user-stack-avatars"
				}, [(openBlock(true), createElementBlock(Fragment, null, renderList(flatUserList.value.slice(0, visibleAvatarCount.value), (user) => {
					return openBlock(), createBlock(unref(N8nAvatar_default), {
						key: user.id,
						"first-name": user.firstName,
						"last-name": user.lastName,
						class: normalizeClass(_ctx.$style.avatar),
						"data-test-id": `user-stack-avatar-${user.id}`,
						size: "small"
					}, null, 8, [
						"first-name",
						"last-name",
						"class",
						"data-test-id"
					]);
				}), 128)), hiddenUsersCount.value > 0 ? (openBlock(), createElementBlock("div", {
					key: 0,
					class: normalizeClass(_ctx.$style.hiddenBadge)
				}, "+" + toDisplayString(hiddenUsersCount.value), 3)) : createCommentVNode("", true)], 2)]),
				_: 1
			}, 8, ["trigger", "max-height"])]);
		};
	}
});
var UserStack_vue_vue_type_style_index_0_lang_module_default = {
	avatars: "_avatars_107lo_123",
	avatar: "_avatar_107lo_123",
	hiddenBadge: "_hiddenBadge_107lo_133",
	groupContainer: "_groupContainer_107lo_148",
	groupName: "_groupName_107lo_156",
	groupUsers: "_groupUsers_107lo_164",
	userInfoContainer: "_userInfoContainer_107lo_170"
};
var N8nUserStack_default = /* @__PURE__ */ __plugin_vue_export_helper_default(UserStack_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": UserStack_vue_vue_type_style_index_0_lang_module_default }]]);
var UserSelect_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "UserSelect",
	props: {
		users: { default: () => [] },
		modelValue: { default: "" },
		ignoreIds: { default: () => [] },
		currentUserId: { default: "" },
		placeholder: {},
		size: {}
	},
	emits: ["blur", "focus"],
	setup(__props, { emit: __emit }) {
		const props = __props;
		const emit = __emit;
		const { t: t$1 } = useI18n();
		const filter = ref("");
		const filteredUsers = computed(() => props.users.filter((user) => {
			if (props.ignoreIds.includes(user.id)) return false;
			if (user.fullName && user.email) {
				if (user.fullName.toLowerCase().includes(filter.value.toLowerCase())) return true;
			}
			return user.email?.includes(filter.value) ?? false;
		}));
		const sortedUsers = computed(() => [...filteredUsers.value].sort((a$1, b$2) => {
			if (a$1.lastName && b$2.lastName && a$1.lastName !== b$2.lastName) return a$1.lastName > b$2.lastName ? 1 : -1;
			if (a$1.firstName && b$2.firstName && a$1.firstName !== b$2.firstName) return a$1.firstName > b$2.firstName ? 1 : -1;
			if (!a$1.email || !b$2.email) throw new Error("Expected all users to have email");
			return a$1.email > b$2.email ? 1 : -1;
		}));
		const setFilter = (value = "") => {
			filter.value = value;
		};
		const onBlur = () => emit("blur");
		const onFocus = () => emit("focus");
		const getLabel = (user) => (!user.fullName ? user.email : `${user.fullName} (${user.email})`) ?? "";
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(N8nSelect_default), mergeProps({ "data-test-id": "user-select-trigger" }, _ctx.$attrs, {
				"model-value": _ctx.modelValue,
				filterable: true,
				"filter-method": setFilter,
				placeholder: _ctx.placeholder || unref(t$1)("nds.userSelect.selectUser"),
				"default-first-option": true,
				teleported: "",
				"popper-class": _ctx.$style.limitPopperWidth,
				"no-data-text": unref(t$1)("nds.userSelect.noMatchingUsers"),
				size: _ctx.size,
				onBlur,
				onFocus
			}), createSlots({
				default: withCtx(() => [(openBlock(true), createElementBlock(Fragment, null, renderList(sortedUsers.value, (user) => {
					return openBlock(), createBlock(unref(N8nOption_default), {
						id: `user-select-option-id-${user.id}`,
						key: user.id,
						value: user.id,
						class: normalizeClass(_ctx.$style.itemContainer),
						label: getLabel(user),
						disabled: user.disabled
					}, {
						default: withCtx(() => [createVNode(unref(N8nUserInfo_default), mergeProps({ ref_for: true }, user, { "is-current-user": _ctx.currentUserId === user.id }), null, 16, ["is-current-user"])]),
						_: 2
					}, 1032, [
						"id",
						"value",
						"class",
						"label",
						"disabled"
					]);
				}), 128))]),
				_: 2
			}, [_ctx.$slots.prefix ? {
				name: "prefix",
				fn: withCtx(() => [renderSlot(_ctx.$slots, "prefix")]),
				key: "0"
			} : void 0]), 1040, [
				"model-value",
				"placeholder",
				"popper-class",
				"no-data-text",
				"size"
			]);
		};
	}
});
var UserSelect_vue_vue_type_style_index_0_lang_module_default = {
	itemContainer: "_itemContainer_10yj8_123",
	limitPopperWidth: "_limitPopperWidth_10yj8_128"
};
var N8nUserSelect_default = /* @__PURE__ */ __plugin_vue_export_helper_default(UserSelect_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": UserSelect_vue_vue_type_style_index_0_lang_module_default }]]);
var _hoisted_1$8 = ["data-test-id"];
var UsersList_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "UsersList",
	props: {
		users: { default: () => [] },
		readonly: {
			type: Boolean,
			default: false
		},
		currentUserId: { default: "" },
		actions: { default: () => [] },
		isSamlLoginEnabled: {
			type: Boolean,
			default: false
		}
	},
	emits: ["action"],
	setup(__props, { emit: __emit }) {
		const props = __props;
		const { t: t$1 } = useI18n();
		const sortedUsers = computed(() => [...props.users].sort((a$1, b$2) => {
			if (!a$1.email || !b$2.email) throw new Error("Expected all users to have email");
			if (a$1.isPendingUser && b$2.isPendingUser) return a$1.email > b$2.email ? 1 : -1;
			if (a$1.isPendingUser) return -1;
			if (b$2.isPendingUser) return 1;
			if (a$1.isOwner) return -1;
			if (b$2.isOwner) return 1;
			if (a$1.lastName && b$2.lastName && a$1.firstName && b$2.firstName) {
				if (a$1.lastName !== b$2.lastName) return a$1.lastName > b$2.lastName ? 1 : -1;
				if (a$1.firstName !== b$2.firstName) return a$1.firstName > b$2.firstName ? 1 : -1;
			}
			return a$1.email > b$2.email ? 1 : -1;
		}));
		const defaultGuard = () => true;
		const getActions = (user) => {
			if (user.isOwner) return [];
			return props.actions.filter((action) => (action.guard ?? defaultGuard)(user));
		};
		const emit = __emit;
		const onUserAction = (user, action) => emit("action", {
			action,
			userId: user.id
		});
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", null, [(openBlock(true), createElementBlock(Fragment, null, renderList(sortedUsers.value, (user, i$1) => {
				return openBlock(), createElementBlock("div", {
					key: user.id,
					class: normalizeClass(i$1 === sortedUsers.value.length - 1 ? _ctx.$style.itemContainer : _ctx.$style.itemWithBorder),
					"data-test-id": `user-list-item-${user.email}`
				}, [createVNode(unref(N8nUserInfo_default), mergeProps({ ref_for: true }, user, {
					"is-current-user": _ctx.currentUserId === user.id,
					"is-saml-login-enabled": _ctx.isSamlLoginEnabled
				}), null, 16, ["is-current-user", "is-saml-login-enabled"]), createBaseVNode("div", { class: normalizeClass(_ctx.$style.badgeContainer) }, [
					user.isOwner ? (openBlock(), createBlock(unref(N8nBadge_default), {
						key: 0,
						theme: "tertiary",
						bold: ""
					}, {
						default: withCtx(() => [createTextVNode(toDisplayString(unref(t$1)("nds.auth.roles.owner")), 1)]),
						_: 1
					})) : createCommentVNode("", true),
					!user.isOwner && !_ctx.readonly ? renderSlot(_ctx.$slots, "actions", {
						key: 1,
						user
					}) : createCommentVNode("", true),
					!user.isOwner && user.signInType !== "ldap" && !_ctx.readonly && getActions(user).length > 0 && _ctx.actions.length > 0 ? (openBlock(), createBlock(unref(N8nActionToggle_default), {
						key: 2,
						placement: "bottom",
						actions: getActions(user),
						theme: "dark",
						onAction: (action) => onUserAction(user, action)
					}, null, 8, ["actions", "onAction"])) : createCommentVNode("", true)
				], 2)], 10, _hoisted_1$8);
			}), 128))]);
		};
	}
});
var UsersList_vue_vue_type_style_index_0_lang_module_default = {
	itemContainer: "_itemContainer_hecoa_123",
	itemWithBorder: "_itemWithBorder_hecoa_131 _itemContainer_hecoa_123",
	badgeContainer: "_badgeContainer_hecoa_136"
};
var N8nUsersList_default = /* @__PURE__ */ __plugin_vue_export_helper_default(UsersList_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": UsersList_vue_vue_type_style_index_0_lang_module_default }]]);
var cache = /* @__PURE__ */ new Map();
function isEmojiSupported(unicode) {
	if (cache.has(unicode)) return cache.get(unicode);
	var supported = isSupported(unicode);
	cache.set(unicode, supported);
	return supported;
}
var isSupported = (function() {
	var ctx = null;
	try {
		ctx = document.createElement("canvas").getContext("2d");
	} catch (_a) {}
	if (!ctx) return function() {
		return false;
	};
	var CANVAS_HEIGHT = 25;
	var CANVAS_WIDTH = 20;
	ctx.font = Math.floor(CANVAS_HEIGHT / 2) + "px Arial, Sans-Serif";
	ctx.textBaseline = "top";
	ctx.canvas.width = CANVAS_WIDTH * 2;
	ctx.canvas.height = CANVAS_HEIGHT;
	return function(unicode) {
		ctx.clearRect(0, 0, CANVAS_WIDTH * 2, CANVAS_HEIGHT);
		ctx.fillStyle = "#FF0000";
		ctx.fillText(unicode, 0, 22);
		ctx.fillStyle = "#0000FF";
		ctx.fillText(unicode, CANVAS_WIDTH, 22);
		var a$1 = ctx.getImageData(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT).data;
		var count$3 = a$1.length;
		var i$1 = 0;
		for (; i$1 < count$3 && !a$1[i$1 + 3]; i$1 += 4);
		if (i$1 >= count$3) return false;
		var x$2 = CANVAS_WIDTH + i$1 / 4 % CANVAS_WIDTH;
		var y = Math.floor(i$1 / 4 / CANVAS_WIDTH);
		var b$2 = ctx.getImageData(x$2, y, 1, 1).data;
		if (a$1[i$1] !== b$2[0] || a$1[i$1 + 2] !== b$2[2]) return false;
		if (ctx.measureText(unicode).width >= CANVAS_WIDTH) return false;
		return true;
	};
})();
const ALL_ICON_PICKER_ICONS = [
	"folder-plus",
	"share",
	"user-check",
	"check-check",
	"circle",
	"eye-off",
	"folder",
	"circle-minus",
	"contrast",
	"refresh-cw",
	"vault",
	"chevrons-left",
	"archive",
	"arrow-left",
	"arrow-right",
	"arrow-up",
	"arrow-down",
	"at-sign",
	"ban",
	"scale",
	"menu",
	"zap",
	"book",
	"package-open",
	"bug",
	"brain",
	"calculator",
	"calendar",
	"chart-column-decreasing",
	"check",
	"circle-check",
	"square-check",
	"chevron-left",
	"chevron-right",
	"chevron-down",
	"chevron-up",
	"code",
	"git-branch",
	"cog",
	"message-circle",
	"message-square",
	"messages-square",
	"clipboard-list",
	"clock",
	"copy",
	"cloud",
	"cloud-download",
	"files",
	"box",
	"scissors",
	"database",
	"circle-dot",
	"grip-lines-vertical",
	"grip-vertical",
	"square-pen",
	"ellipsis",
	"ellipsis-vertical",
	"mail",
	"equal",
	"eye",
	"triangle-alert",
	"maximize",
	"maximize-2",
	"mcp",
	"external-link",
	"arrow-left-right",
	"file",
	"file-text",
	"file-archive",
	"file-code",
	"file-down",
	"file-output",
	"file-input",
	"file-text",
	"funnel",
	"fingerprint",
	"flask-conical",
	"folder-open",
	"case-upper",
	"gift",
	"globe",
	"earth",
	"graduation-cap",
	"hand-coins",
	"scissors",
	"handshake",
	"arrow-left",
	"hash",
	"hard-drive",
	"history",
	"house",
	"hourglass",
	"image",
	"inbox",
	"info",
	"key-round",
	"languages",
	"layers",
	"link",
	"list",
	"lightbulb",
	"lock",
	"milestone",
	"mouse-pointer",
	"network",
	"palette",
	"pause",
	"circle-pause",
	"pen",
	"pencil",
	"play",
	"circle-play",
	"plug",
	"plus",
	"circle-plus",
	"square-plus",
	"waypoints",
	"circle-help",
	"circle-help",
	"redo-2",
	"remove-formatting",
	"bot",
	"rss",
	"save",
	"satellite-dish",
	"search",
	"zoom-out",
	"zoom-in",
	"server",
	"pocket-knife",
	"smile",
	"log-in",
	"log-out",
	"sliders-horizontal",
	"sticky-note",
	"square",
	"align-right",
	"sun",
	"refresh-cw",
	"table",
	"tags",
	"list-checks",
	"terminal",
	"grid-2x2",
	"pin",
	"thumbs-down",
	"thumbs-up",
	"x",
	"circle-x",
	"wrench",
	"trash-2",
	"undo-2",
	"unlink",
	"user",
	"circle-user-round",
	"user-round",
	"users",
	"video",
	"tree-pine",
	"user-lock",
	"gem",
	"hard-drive-download",
	"power",
	"send",
	"bell",
	"variable",
	"pop-out",
	"triangle",
	"status-completed",
	"status-waiting",
	"status-error",
	"status-canceled",
	"status-new",
	"status-unknown",
	"status-warning",
	"vector-square",
	"schema",
	"json",
	"binary",
	"text",
	"toolbox",
	"spinner"
];
var _hoisted_1$7 = ["aria-expanded"];
var _hoisted_2$4 = ["onClick"];
var IconPicker_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	name: "N8nIconPicker",
	__name: "IconPicker",
	props: /* @__PURE__ */ mergeModels({
		buttonTooltip: {},
		buttonSize: { default: "large" }
	}, {
		"modelValue": { default: {
			type: "icon",
			value: "smile"
		} },
		"modelModifiers": {}
	}),
	emits: ["update:modelValue"],
	setup(__props) {
		const emojiRanges = [
			[128512, 128591],
			[127744, 128511],
			[128640, 128767],
			[9728, 9983],
			[9984, 10175],
			[129280, 129535],
			[127462, 127487],
			[128e3, 128255]
		];
		const { t: t$1 } = useI18n();
		const props = __props;
		const model = useModel(__props, "modelValue");
		const emojis = computed(() => {
			const emojisArray = [];
			emojiRanges.forEach(([start, end$1]) => {
				for (let i$1 = start; i$1 <= end$1; i$1++) {
					const emoji$1 = String.fromCodePoint(i$1);
					if (isEmojiSupported(emoji$1)) emojisArray.push(emoji$1);
				}
			});
			return emojisArray;
		});
		const popupVisible = ref(false);
		const tabs$2 = [{
			value: "icons",
			label: t$1("iconPicker.tabs.icons")
		}, {
			value: "emojis",
			label: t$1("iconPicker.tabs.emojis")
		}];
		const selectedTab = ref(tabs$2[0].value);
		const container$18 = ref();
		onClickOutside(container$18, () => {
			popupVisible.value = false;
		});
		const selectIcon = (value) => {
			model.value = value;
			popupVisible.value = false;
		};
		const togglePopup = () => {
			popupVisible.value = !popupVisible.value;
			if (popupVisible.value) selectedTab.value = tabs$2[0].value;
		};
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", {
				ref_key: "container",
				ref: container$18,
				class: normalizeClass(_ctx.$style.container),
				"aria-expanded": popupVisible.value,
				role: "button",
				"aria-haspopup": "true"
			}, [createBaseVNode("div", { class: normalizeClass(_ctx.$style["icon-picker-button"]) }, [createVNode(unref(N8nTooltip_default), {
				placement: "right",
				"data-test-id": "icon-picker-tooltip"
			}, {
				content: withCtx(() => [createTextVNode(toDisplayString(props.buttonTooltip ?? unref(t$1)("iconPicker.button.defaultToolTip")), 1)]),
				default: withCtx(() => [model.value.type === "icon" ? (openBlock(), createBlock(unref(N8nIconButton_default), {
					key: 0,
					class: normalizeClass(_ctx.$style["icon-button"]),
					icon: model.value.value,
					size: _ctx.buttonSize,
					square: true,
					type: "tertiary",
					"data-test-id": "icon-picker-button",
					onClick: togglePopup
				}, null, 8, [
					"class",
					"icon",
					"size"
				])) : model.value.type === "emoji" ? (openBlock(), createBlock(unref(N8nButton_default), {
					key: 1,
					class: normalizeClass(_ctx.$style["emoji-button"]),
					size: _ctx.buttonSize,
					square: true,
					type: "tertiary",
					"data-test-id": "icon-picker-button",
					onClick: togglePopup
				}, {
					default: withCtx(() => [createTextVNode(toDisplayString(model.value.value), 1)]),
					_: 1
				}, 8, ["class", "size"])) : createCommentVNode("", true)]),
				_: 1
			})], 2), popupVisible.value ? (openBlock(), createElementBlock("div", {
				key: 0,
				class: normalizeClass(_ctx.$style.popup),
				"data-test-id": "icon-picker-popup"
			}, [
				createBaseVNode("div", { class: normalizeClass(_ctx.$style.tabs) }, [createVNode(unref(N8nTabs_default), {
					modelValue: selectedTab.value,
					"onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => selectedTab.value = $event),
					options: tabs$2,
					"data-test-id": "icon-picker-tabs"
				}, null, 8, ["modelValue"])], 2),
				selectedTab.value === "icons" ? (openBlock(), createElementBlock("div", {
					key: 0,
					class: normalizeClass(_ctx.$style.content)
				}, [(openBlock(true), createElementBlock(Fragment, null, renderList(unref(ALL_ICON_PICKER_ICONS), (icon$11) => {
					return openBlock(), createBlock(unref(N8nIcon_default), {
						key: icon$11,
						icon: icon$11,
						class: normalizeClass(_ctx.$style.icon),
						size: 24,
						"data-test-id": "icon-picker-icon",
						onClick: ($event) => selectIcon({
							type: "icon",
							value: icon$11
						})
					}, null, 8, [
						"icon",
						"class",
						"onClick"
					]);
				}), 128))], 2)) : createCommentVNode("", true),
				selectedTab.value === "emojis" ? (openBlock(), createElementBlock("div", {
					key: 1,
					class: normalizeClass(_ctx.$style.content)
				}, [(openBlock(true), createElementBlock(Fragment, null, renderList(emojis.value, (emoji$1) => {
					return openBlock(), createElementBlock("span", {
						key: emoji$1,
						class: normalizeClass(_ctx.$style.emoji),
						"data-test-id": "icon-picker-emoji",
						onClick: ($event) => selectIcon({
							type: "emoji",
							value: emoji$1
						})
					}, toDisplayString(emoji$1), 11, _hoisted_2$4);
				}), 128))], 2)) : createCommentVNode("", true)
			], 2)) : createCommentVNode("", true)], 10, _hoisted_1$7);
		};
	}
});
const container$1 = "_container_rpep1_123";
const popup = "_popup_rpep1_131";
const tabs = "_tabs_rpep1_144";
const content$1 = "_content_rpep1_148";
const icon$1 = "_icon_rpep1_154";
const emoji = "_emoji_rpep1_127";
var IconPicker_vue_vue_type_style_index_0_lang_module_default = {
	container: container$1,
	"emoji-button": "_emoji-button_rpep1_127",
	popup,
	tabs,
	content: content$1,
	icon: icon$1,
	emoji
};
var N8nIconPicker_default = /* @__PURE__ */ __plugin_vue_export_helper_default(IconPicker_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": IconPicker_vue_vue_type_style_index_0_lang_module_default }]]);
var _hoisted_1$6 = { "data-test-id": "hidden-items-tooltip" };
var _hoisted_2$3 = [
	"title",
	"data-resourceid",
	"onClick",
	"onMouseenter",
	"onMouseup"
];
var Breadcrumbs_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	name: "N8nBreadcrumbs",
	__name: "Breadcrumbs",
	props: {
		items: {},
		hiddenItems: { default: () => new Array() },
		theme: { default: "medium" },
		showBorder: {
			type: Boolean,
			default: false
		},
		loadingSkeletonRows: { default: 3 },
		separator: { default: "/" },
		highlightLastItem: {
			type: Boolean,
			default: true
		},
		hiddenItemsTrigger: { default: "click" },
		pathTruncated: {
			type: Boolean,
			default: false
		},
		dragActive: {
			type: Boolean,
			default: false
		}
	},
	emits: [
		"tooltipOpened",
		"tooltipClosed",
		"hiddenItemsLoadingError",
		"itemSelected",
		"itemHover",
		"itemDrop"
	],
	setup(__props, { emit: __emit }) {
		const emit = __emit;
		const props = __props;
		const loadedHiddenItems = ref([]);
		const isLoadingHiddenItems = ref(false);
		const currentPromise = ref(null);
		const hasHiddenItems = computed(() => {
			return Array.isArray(props.hiddenItems) ? props.hiddenItems.length > 0 : props.hiddenItems !== void 0;
		});
		const showEllipsis = computed(() => {
			return props.items.length && (hasHiddenItems.value || props.pathTruncated);
		});
		const dropdownDisabled = computed(() => {
			return props.pathTruncated && !hasHiddenItems.value;
		});
		const hiddenItemActions = computed(() => {
			return loadedHiddenItems.value.map((item$4) => ({
				value: item$4.id,
				label: item$4.label,
				disabled: false
			}));
		});
		const getHiddenItems = async () => {
			if (loadedHiddenItems.value.length > 0 && props.hiddenItems === currentPromise.value) return;
			if (Array.isArray(props.hiddenItems)) {
				loadedHiddenItems.value = props.hiddenItems;
				return;
			}
			isLoadingHiddenItems.value = true;
			try {
				currentPromise.value = props.hiddenItems;
				loadedHiddenItems.value = await props.hiddenItems;
			} catch (error$1) {
				loadedHiddenItems.value = [];
				emit("hiddenItemsLoadingError", error$1);
			} finally {
				isLoadingHiddenItems.value = false;
			}
		};
		watch(() => props.hiddenItems, (_newValue) => {
			getHiddenItems();
		});
		const onHiddenMenuVisibleChange = async (visible$1) => {
			if (visible$1) {
				emit("tooltipOpened");
				await getHiddenItems();
			} else emit("tooltipClosed");
		};
		const emitItemSelected = (id$1) => {
			const item$4 = [...props.items, ...loadedHiddenItems.value].find((i$1) => i$1.id === id$1);
			if (!item$4) return;
			emit("itemSelected", item$4);
		};
		const emitItemHover = (id$1) => {
			const item$4 = [...props.items, ...loadedHiddenItems.value].find((i$1) => i$1.id === id$1);
			if (!item$4) return;
			emit("itemHover", item$4);
		};
		const onHiddenItemMouseUp = (item$4) => {
			const pathItem = [...props.items, ...loadedHiddenItems.value].find((i$1) => i$1.id === item$4.value);
			if (!pathItem || !props.dragActive) return;
			emit("itemDrop", pathItem);
		};
		const onItemMouseUp = (item$4) => {
			if (!props.dragActive) return;
			emit("itemDrop", item$4);
		};
		const handleTooltipShow = async () => {
			emit("tooltipOpened");
			await getHiddenItems();
		};
		const handleTooltipClose = () => {
			emit("tooltipClosed");
		};
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", { class: normalizeClass({
				[_ctx.$style.container]: true,
				[_ctx.$style.border]: props.showBorder,
				[_ctx.$style[props.theme]]: true,
				["n8n-breadcrumbs"]: true
			}) }, [
				renderSlot(_ctx.$slots, "prepend"),
				createBaseVNode("ul", { class: normalizeClass(_ctx.$style.list) }, [
					_ctx.$slots.prepend && _ctx.items.length ? (openBlock(), createElementBlock("li", {
						key: 0,
						class: normalizeClass(_ctx.$style.separator)
					}, toDisplayString(_ctx.separator), 3)) : createCommentVNode("", true),
					showEllipsis.value ? (openBlock(), createElementBlock("li", {
						key: 1,
						class: normalizeClass({
							[_ctx.$style.ellipsis]: true,
							[_ctx.$style.disabled]: dropdownDisabled.value
						}),
						"data-test-id": "ellipsis"
					}, [props.theme !== "small" ? (openBlock(), createElementBlock("div", {
						key: 0,
						class: normalizeClass(_ctx.$style["hidden-items-menu"])
					}, [createVNode(unref(N8nActionToggle_default), {
						actions: hiddenItemActions.value,
						loading: isLoadingHiddenItems.value,
						"loading-row-count": _ctx.loadingSkeletonRows,
						disabled: dropdownDisabled.value,
						class: normalizeClass(_ctx.$style["action-toggle"]),
						"popper-class": `${_ctx.$style["hidden-items-menu-popper"]} ${_ctx.dragActive ? _ctx.$style.dragging : ""}`,
						trigger: _ctx.hiddenItemsTrigger,
						theme: "dark",
						placement: "bottom",
						size: "small",
						"icon-orientation": "horizontal",
						"data-test-id": "hidden-items-menu",
						onVisibleChange: onHiddenMenuVisibleChange,
						onAction: emitItemSelected,
						onItemMouseup: onHiddenItemMouseUp
					}, {
						default: withCtx(() => [createVNode(unref(N8nText_default), {
							bold: true,
							class: normalizeClass(_ctx.$style.dots)
						}, {
							default: withCtx(() => _cache[0] || (_cache[0] = [createTextVNode("...")])),
							_: 1
						}, 8, ["class"])]),
						_: 1
					}, 8, [
						"actions",
						"loading",
						"loading-row-count",
						"disabled",
						"class",
						"popper-class",
						"trigger"
					])], 2)) : (openBlock(), createBlock(unref(N8nTooltip_default), {
						key: 1,
						"popper-class": _ctx.$style.tooltip,
						disabled: dropdownDisabled.value,
						trigger: _ctx.hiddenItemsTrigger,
						placement: "bottom",
						onBeforeShow: handleTooltipShow,
						onHide: handleTooltipClose
					}, {
						content: withCtx(() => [isLoadingHiddenItems.value ? (openBlock(), createElementBlock("div", {
							key: 0,
							class: normalizeClass(_ctx.$style["tooltip-loading"])
						}, [createVNode(unref(N8nLoading_default), {
							rows: 1,
							loading: isLoadingHiddenItems.value,
							animated: "",
							variant: "p",
							"shrink-last": false
						}, null, 8, ["loading"])], 2)) : (openBlock(), createElementBlock("div", {
							key: 1,
							class: normalizeClass(_ctx.$style.tooltipContent)
						}, [createBaseVNode("div", _hoisted_1$6, [createVNode(unref(N8nText_default), null, {
							default: withCtx(() => [createTextVNode(toDisplayString(loadedHiddenItems.value.map((item$4) => item$4.label).join(" / ")), 1)]),
							_: 1
						})])], 2))]),
						default: withCtx(() => [createBaseVNode("span", { class: normalizeClass(_ctx.$style["tooltip-ellipsis"]) }, "...", 2)]),
						_: 1
					}, 8, [
						"popper-class",
						"disabled",
						"trigger"
					]))], 2)) : createCommentVNode("", true),
					showEllipsis.value ? (openBlock(), createElementBlock("li", {
						key: 2,
						class: normalizeClass(_ctx.$style.separator)
					}, toDisplayString(_ctx.separator), 3)) : createCommentVNode("", true),
					(openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.items, (item$4, index) => {
						return openBlock(), createElementBlock(Fragment, { key: item$4.id }, [createBaseVNode("li", {
							class: normalizeClass({
								[_ctx.$style.item]: true,
								[_ctx.$style.current]: props.highlightLastItem && index === _ctx.items.length - 1,
								[_ctx.$style.dragging]: props.dragActive
							}),
							title: item$4.label,
							"data-resourceid": item$4.id,
							"data-test-id": "breadcrumbs-item",
							"data-target": "folder-breadcrumb-item",
							onClick: withModifiers(($event) => emitItemSelected(item$4.id), ["prevent"]),
							onMouseenter: ($event) => emitItemHover(item$4.id),
							onMouseup: ($event) => onItemMouseUp(item$4)
						}, [item$4.href ? (openBlock(), createBlock(unref(N8nLink_default), {
							key: 0,
							href: item$4.href,
							theme: "text"
						}, {
							default: withCtx(() => [createTextVNode(toDisplayString(item$4.label), 1)]),
							_: 2
						}, 1032, ["href"])) : (openBlock(), createBlock(unref(N8nText_default), { key: 1 }, {
							default: withCtx(() => [createTextVNode(toDisplayString(item$4.label), 1)]),
							_: 2
						}, 1024))], 42, _hoisted_2$3), index !== _ctx.items.length - 1 ? (openBlock(), createElementBlock("li", {
							key: 0,
							class: normalizeClass(_ctx.$style.separator)
						}, toDisplayString(_ctx.separator), 3)) : createCommentVNode("", true)], 64);
					}), 128))
				], 2),
				renderSlot(_ctx.$slots, "append")
			], 2);
		};
	}
});
const container = "_container_11cz9_123";
const small$2 = "_small_11cz9_127";
const border = "_border_11cz9_131";
const list = "_list_11cz9_136";
const item$2 = "_item_11cz9_142";
const dragging$1 = "_dragging_11cz9_146";
const current = "_current_11cz9_162";
const ellipsis = "_ellipsis_11cz9_166";
const dots = "_dots_11cz9_166";
const disabled$1 = "_disabled_11cz9_172";
const tooltip = "_tooltip_11cz9_167";
const separator = "_separator_11cz9_257";
const medium$2 = "_medium_11cz9_262";
var Breadcrumbs_vue_vue_type_style_index_0_lang_module_default = {
	container,
	small: small$2,
	border,
	list,
	item: item$2,
	dragging: dragging$1,
	current,
	ellipsis,
	dots,
	"tooltip-ellipsis": "_tooltip-ellipsis_11cz9_167",
	disabled: disabled$1,
	"hidden-items-menu": "_hidden-items-menu_11cz9_184",
	"hidden-items-menu-popper": "_hidden-items-menu-popper_11cz9_189",
	"tooltip-loading": "_tooltip-loading_11cz9_205",
	tooltip,
	separator,
	medium: medium$2
};
var N8nBreadcrumbs_default = /* @__PURE__ */ __plugin_vue_export_helper_default(Breadcrumbs_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": Breadcrumbs_vue_vue_type_style_index_0_lang_module_default }]]);
/**
* table-core
*
* Copyright (c) TanStack
*
* This source code is licensed under the MIT license found in the
* LICENSE.md file in the root directory of this source tree.
*
* @license MIT
*/
function createColumnHelper() {
	return {
		accessor: (accessor, column$1) => {
			return typeof accessor === "function" ? {
				...column$1,
				accessorFn: accessor
			} : {
				...column$1,
				accessorKey: accessor
			};
		},
		display: (column$1) => column$1,
		group: (column$1) => column$1
	};
}
function functionalUpdate(updater, input$4) {
	return typeof updater === "function" ? updater(input$4) : updater;
}
function makeStateUpdater(key$2, instance) {
	return (updater) => {
		instance.setState((old) => {
			return {
				...old,
				[key$2]: functionalUpdate(updater, old[key$2])
			};
		});
	};
}
function isFunction(d) {
	return d instanceof Function;
}
function isNumberArray(d) {
	return Array.isArray(d) && d.every((val) => typeof val === "number");
}
function flattenBy(arr, getChildren) {
	const flat$1 = [];
	const recurse = (subArr) => {
		subArr.forEach((item$4) => {
			flat$1.push(item$4);
			const children = getChildren(item$4);
			if (children != null && children.length) recurse(children);
		});
	};
	recurse(arr);
	return flat$1;
}
function memo(getDeps, fn$1, opts) {
	let deps = [];
	let result;
	return (depArgs) => {
		let depTime;
		if (opts.key && opts.debug) depTime = Date.now();
		const newDeps = getDeps(depArgs);
		if (!(newDeps.length !== deps.length || newDeps.some((dep, index) => deps[index] !== dep))) return result;
		deps = newDeps;
		let resultTime;
		if (opts.key && opts.debug) resultTime = Date.now();
		result = fn$1(...newDeps);
		opts == null || opts.onChange == null || opts.onChange(result);
		if (opts.key && opts.debug) {
			if (opts != null && opts.debug()) {
				const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;
				const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;
				const resultFpsPercentage = resultEndTime / 16;
				const pad = (str, num$2) => {
					str = String(str);
					while (str.length < num$2) str = " " + str;
					return str;
				};
				console.info(`%c ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`, `
            font-size: .6rem;
            font-weight: bold;
            color: hsl(${Math.max(0, Math.min(120 - 120 * resultFpsPercentage, 120))}deg 100% 31%);`, opts == null ? void 0 : opts.key);
			}
		}
		return result;
	};
}
function getMemoOptions(tableOptions, debugLevel, key$2, onChange) {
	return {
		debug: () => {
			var _tableOptions$debugAl;
			return (_tableOptions$debugAl = tableOptions == null ? void 0 : tableOptions.debugAll) != null ? _tableOptions$debugAl : tableOptions[debugLevel];
		},
		key: false,
		onChange
	};
}
function createCell(table, row, column$1, columnId) {
	const getRenderValue = () => {
		var _cell$getValue;
		return (_cell$getValue = cell.getValue()) != null ? _cell$getValue : table.options.renderFallbackValue;
	};
	const cell = {
		id: `${row.id}_${column$1.id}`,
		row,
		column: column$1,
		getValue: () => row.getValue(columnId),
		renderValue: getRenderValue,
		getContext: memo(() => [
			table,
			column$1,
			row,
			cell
		], (table$1, column$2, row$1, cell$1) => ({
			table: table$1,
			column: column$2,
			row: row$1,
			cell: cell$1,
			getValue: cell$1.getValue,
			renderValue: cell$1.renderValue
		}), getMemoOptions(table.options, "debugCells", "cell.getContext"))
	};
	table._features.forEach((feature) => {
		feature.createCell == null || feature.createCell(cell, column$1, row, table);
	}, {});
	return cell;
}
function createColumn(table, columnDef, depth, parent) {
	var _ref, _resolvedColumnDef$id;
	const resolvedColumnDef = {
		...table._getDefaultColumnDef(),
		...columnDef
	};
	const accessorKey = resolvedColumnDef.accessorKey;
	let id$1 = (_ref = (_resolvedColumnDef$id = resolvedColumnDef.id) != null ? _resolvedColumnDef$id : accessorKey ? typeof String.prototype.replaceAll === "function" ? accessorKey.replaceAll(".", "_") : accessorKey.replace(/\./g, "_") : void 0) != null ? _ref : typeof resolvedColumnDef.header === "string" ? resolvedColumnDef.header : void 0;
	let accessorFn;
	if (resolvedColumnDef.accessorFn) accessorFn = resolvedColumnDef.accessorFn;
	else if (accessorKey) if (accessorKey.includes(".")) accessorFn = (originalRow) => {
		let result = originalRow;
		for (const key$2 of accessorKey.split(".")) {
			var _result;
			result = (_result = result) == null ? void 0 : _result[key$2];
		}
		return result;
	};
	else accessorFn = (originalRow) => originalRow[resolvedColumnDef.accessorKey];
	if (!id$1) throw new Error();
	let column$1 = {
		id: `${String(id$1)}`,
		accessorFn,
		parent,
		depth,
		columnDef: resolvedColumnDef,
		columns: [],
		getFlatColumns: memo(() => [true], () => {
			var _column$columns;
			return [column$1, ...(_column$columns = column$1.columns) == null ? void 0 : _column$columns.flatMap((d) => d.getFlatColumns())];
		}, getMemoOptions(table.options, "debugColumns", "column.getFlatColumns")),
		getLeafColumns: memo(() => [table._getOrderColumnsFn()], (orderColumns$1) => {
			var _column$columns2;
			if ((_column$columns2 = column$1.columns) != null && _column$columns2.length) return orderColumns$1(column$1.columns.flatMap((column$2) => column$2.getLeafColumns()));
			return [column$1];
		}, getMemoOptions(table.options, "debugColumns", "column.getLeafColumns"))
	};
	for (const feature of table._features) feature.createColumn == null || feature.createColumn(column$1, table);
	return column$1;
}
var debug = "debugHeaders";
function createHeader(table, column$1, options$1) {
	var _options$id;
	let header$5 = {
		id: (_options$id = options$1.id) != null ? _options$id : column$1.id,
		column: column$1,
		index: options$1.index,
		isPlaceholder: !!options$1.isPlaceholder,
		placeholderId: options$1.placeholderId,
		depth: options$1.depth,
		subHeaders: [],
		colSpan: 0,
		rowSpan: 0,
		headerGroup: null,
		getLeafHeaders: () => {
			const leafHeaders = [];
			const recurseHeader = (h$2) => {
				if (h$2.subHeaders && h$2.subHeaders.length) h$2.subHeaders.map(recurseHeader);
				leafHeaders.push(h$2);
			};
			recurseHeader(header$5);
			return leafHeaders;
		},
		getContext: () => ({
			table,
			header: header$5,
			column: column$1
		})
	};
	table._features.forEach((feature) => {
		feature.createHeader == null || feature.createHeader(header$5, table);
	});
	return header$5;
}
var Headers$1 = { createTable: (table) => {
	table.getHeaderGroups = memo(() => [
		table.getAllColumns(),
		table.getVisibleLeafColumns(),
		table.getState().columnPinning.left,
		table.getState().columnPinning.right
	], (allColumns, leafColumns, left$1, right$1) => {
		var _left$map$filter, _right$map$filter;
		const leftColumns = (_left$map$filter = left$1 == null ? void 0 : left$1.map((columnId) => leafColumns.find((d) => d.id === columnId)).filter(Boolean)) != null ? _left$map$filter : [];
		const rightColumns = (_right$map$filter = right$1 == null ? void 0 : right$1.map((columnId) => leafColumns.find((d) => d.id === columnId)).filter(Boolean)) != null ? _right$map$filter : [];
		const centerColumns = leafColumns.filter((column$1) => !(left$1 != null && left$1.includes(column$1.id)) && !(right$1 != null && right$1.includes(column$1.id)));
		return buildHeaderGroups(allColumns, [
			...leftColumns,
			...centerColumns,
			...rightColumns
		], table);
	}, getMemoOptions(table.options, debug, "getHeaderGroups"));
	table.getCenterHeaderGroups = memo(() => [
		table.getAllColumns(),
		table.getVisibleLeafColumns(),
		table.getState().columnPinning.left,
		table.getState().columnPinning.right
	], (allColumns, leafColumns, left$1, right$1) => {
		leafColumns = leafColumns.filter((column$1) => !(left$1 != null && left$1.includes(column$1.id)) && !(right$1 != null && right$1.includes(column$1.id)));
		return buildHeaderGroups(allColumns, leafColumns, table, "center");
	}, getMemoOptions(table.options, debug, "getCenterHeaderGroups"));
	table.getLeftHeaderGroups = memo(() => [
		table.getAllColumns(),
		table.getVisibleLeafColumns(),
		table.getState().columnPinning.left
	], (allColumns, leafColumns, left$1) => {
		var _left$map$filter2;
		return buildHeaderGroups(allColumns, (_left$map$filter2 = left$1 == null ? void 0 : left$1.map((columnId) => leafColumns.find((d) => d.id === columnId)).filter(Boolean)) != null ? _left$map$filter2 : [], table, "left");
	}, getMemoOptions(table.options, debug, "getLeftHeaderGroups"));
	table.getRightHeaderGroups = memo(() => [
		table.getAllColumns(),
		table.getVisibleLeafColumns(),
		table.getState().columnPinning.right
	], (allColumns, leafColumns, right$1) => {
		var _right$map$filter2;
		return buildHeaderGroups(allColumns, (_right$map$filter2 = right$1 == null ? void 0 : right$1.map((columnId) => leafColumns.find((d) => d.id === columnId)).filter(Boolean)) != null ? _right$map$filter2 : [], table, "right");
	}, getMemoOptions(table.options, debug, "getRightHeaderGroups"));
	table.getFooterGroups = memo(() => [table.getHeaderGroups()], (headerGroups) => {
		return [...headerGroups].reverse();
	}, getMemoOptions(table.options, debug, "getFooterGroups"));
	table.getLeftFooterGroups = memo(() => [table.getLeftHeaderGroups()], (headerGroups) => {
		return [...headerGroups].reverse();
	}, getMemoOptions(table.options, debug, "getLeftFooterGroups"));
	table.getCenterFooterGroups = memo(() => [table.getCenterHeaderGroups()], (headerGroups) => {
		return [...headerGroups].reverse();
	}, getMemoOptions(table.options, debug, "getCenterFooterGroups"));
	table.getRightFooterGroups = memo(() => [table.getRightHeaderGroups()], (headerGroups) => {
		return [...headerGroups].reverse();
	}, getMemoOptions(table.options, debug, "getRightFooterGroups"));
	table.getFlatHeaders = memo(() => [table.getHeaderGroups()], (headerGroups) => {
		return headerGroups.map((headerGroup) => {
			return headerGroup.headers;
		}).flat();
	}, getMemoOptions(table.options, debug, "getFlatHeaders"));
	table.getLeftFlatHeaders = memo(() => [table.getLeftHeaderGroups()], (left$1) => {
		return left$1.map((headerGroup) => {
			return headerGroup.headers;
		}).flat();
	}, getMemoOptions(table.options, debug, "getLeftFlatHeaders"));
	table.getCenterFlatHeaders = memo(() => [table.getCenterHeaderGroups()], (left$1) => {
		return left$1.map((headerGroup) => {
			return headerGroup.headers;
		}).flat();
	}, getMemoOptions(table.options, debug, "getCenterFlatHeaders"));
	table.getRightFlatHeaders = memo(() => [table.getRightHeaderGroups()], (left$1) => {
		return left$1.map((headerGroup) => {
			return headerGroup.headers;
		}).flat();
	}, getMemoOptions(table.options, debug, "getRightFlatHeaders"));
	table.getCenterLeafHeaders = memo(() => [table.getCenterFlatHeaders()], (flatHeaders) => {
		return flatHeaders.filter((header$5) => {
			var _header$subHeaders;
			return !((_header$subHeaders = header$5.subHeaders) != null && _header$subHeaders.length);
		});
	}, getMemoOptions(table.options, debug, "getCenterLeafHeaders"));
	table.getLeftLeafHeaders = memo(() => [table.getLeftFlatHeaders()], (flatHeaders) => {
		return flatHeaders.filter((header$5) => {
			var _header$subHeaders2;
			return !((_header$subHeaders2 = header$5.subHeaders) != null && _header$subHeaders2.length);
		});
	}, getMemoOptions(table.options, debug, "getLeftLeafHeaders"));
	table.getRightLeafHeaders = memo(() => [table.getRightFlatHeaders()], (flatHeaders) => {
		return flatHeaders.filter((header$5) => {
			var _header$subHeaders3;
			return !((_header$subHeaders3 = header$5.subHeaders) != null && _header$subHeaders3.length);
		});
	}, getMemoOptions(table.options, debug, "getRightLeafHeaders"));
	table.getLeafHeaders = memo(() => [
		table.getLeftHeaderGroups(),
		table.getCenterHeaderGroups(),
		table.getRightHeaderGroups()
	], (left$1, center, right$1) => {
		var _left$0$headers, _left$, _center$0$headers, _center$, _right$0$headers, _right$;
		return [
			...(_left$0$headers = (_left$ = left$1[0]) == null ? void 0 : _left$.headers) != null ? _left$0$headers : [],
			...(_center$0$headers = (_center$ = center[0]) == null ? void 0 : _center$.headers) != null ? _center$0$headers : [],
			...(_right$0$headers = (_right$ = right$1[0]) == null ? void 0 : _right$.headers) != null ? _right$0$headers : []
		].map((header$5) => {
			return header$5.getLeafHeaders();
		}).flat();
	}, getMemoOptions(table.options, debug, "getLeafHeaders"));
} };
function buildHeaderGroups(allColumns, columnsToGroup, table, headerFamily) {
	var _headerGroups$0$heade, _headerGroups$;
	let maxDepth = 0;
	const findMaxDepth = function(columns, depth) {
		if (depth === void 0) depth = 1;
		maxDepth = Math.max(maxDepth, depth);
		columns.filter((column$1) => column$1.getIsVisible()).forEach((column$1) => {
			var _column$columns;
			if ((_column$columns = column$1.columns) != null && _column$columns.length) findMaxDepth(column$1.columns, depth + 1);
		}, 0);
	};
	findMaxDepth(allColumns);
	let headerGroups = [];
	const createHeaderGroup = (headersToGroup, depth) => {
		const headerGroup = {
			depth,
			id: [headerFamily, `${depth}`].filter(Boolean).join("_"),
			headers: []
		};
		const pendingParentHeaders = [];
		headersToGroup.forEach((headerToGroup) => {
			const latestPendingParentHeader = [...pendingParentHeaders].reverse()[0];
			const isLeafHeader = headerToGroup.column.depth === headerGroup.depth;
			let column$1;
			let isPlaceholder = false;
			if (isLeafHeader && headerToGroup.column.parent) column$1 = headerToGroup.column.parent;
			else {
				column$1 = headerToGroup.column;
				isPlaceholder = true;
			}
			if (latestPendingParentHeader && (latestPendingParentHeader == null ? void 0 : latestPendingParentHeader.column) === column$1) latestPendingParentHeader.subHeaders.push(headerToGroup);
			else {
				const header$5 = createHeader(table, column$1, {
					id: [
						headerFamily,
						depth,
						column$1.id,
						headerToGroup == null ? void 0 : headerToGroup.id
					].filter(Boolean).join("_"),
					isPlaceholder,
					placeholderId: isPlaceholder ? `${pendingParentHeaders.filter((d) => d.column === column$1).length}` : void 0,
					depth,
					index: pendingParentHeaders.length
				});
				header$5.subHeaders.push(headerToGroup);
				pendingParentHeaders.push(header$5);
			}
			headerGroup.headers.push(headerToGroup);
			headerToGroup.headerGroup = headerGroup;
		});
		headerGroups.push(headerGroup);
		if (depth > 0) createHeaderGroup(pendingParentHeaders, depth - 1);
	};
	createHeaderGroup(columnsToGroup.map((column$1, index) => createHeader(table, column$1, {
		depth: maxDepth,
		index
	})), maxDepth - 1);
	headerGroups.reverse();
	const recurseHeadersForSpans = (headers) => {
		return headers.filter((header$5) => header$5.column.getIsVisible()).map((header$5) => {
			let colSpan = 0;
			let rowSpan = 0;
			let childRowSpans = [0];
			if (header$5.subHeaders && header$5.subHeaders.length) {
				childRowSpans = [];
				recurseHeadersForSpans(header$5.subHeaders).forEach((_ref) => {
					let { colSpan: childColSpan, rowSpan: childRowSpan } = _ref;
					colSpan += childColSpan;
					childRowSpans.push(childRowSpan);
				});
			} else colSpan = 1;
			const minChildRowSpan = Math.min(...childRowSpans);
			rowSpan = rowSpan + minChildRowSpan;
			header$5.colSpan = colSpan;
			header$5.rowSpan = rowSpan;
			return {
				colSpan,
				rowSpan
			};
		});
	};
	recurseHeadersForSpans((_headerGroups$0$heade = (_headerGroups$ = headerGroups[0]) == null ? void 0 : _headerGroups$.headers) != null ? _headerGroups$0$heade : []);
	return headerGroups;
}
var createRow = (table, id$1, original, rowIndex, depth, subRows, parentId) => {
	let row = {
		id: id$1,
		index: rowIndex,
		original,
		depth,
		parentId,
		_valuesCache: {},
		_uniqueValuesCache: {},
		getValue: (columnId) => {
			if (row._valuesCache.hasOwnProperty(columnId)) return row._valuesCache[columnId];
			const column$1 = table.getColumn(columnId);
			if (!(column$1 != null && column$1.accessorFn)) return;
			row._valuesCache[columnId] = column$1.accessorFn(row.original, rowIndex);
			return row._valuesCache[columnId];
		},
		getUniqueValues: (columnId) => {
			if (row._uniqueValuesCache.hasOwnProperty(columnId)) return row._uniqueValuesCache[columnId];
			const column$1 = table.getColumn(columnId);
			if (!(column$1 != null && column$1.accessorFn)) return;
			if (!column$1.columnDef.getUniqueValues) {
				row._uniqueValuesCache[columnId] = [row.getValue(columnId)];
				return row._uniqueValuesCache[columnId];
			}
			row._uniqueValuesCache[columnId] = column$1.columnDef.getUniqueValues(row.original, rowIndex);
			return row._uniqueValuesCache[columnId];
		},
		renderValue: (columnId) => {
			var _row$getValue;
			return (_row$getValue = row.getValue(columnId)) != null ? _row$getValue : table.options.renderFallbackValue;
		},
		subRows: subRows != null ? subRows : [],
		getLeafRows: () => flattenBy(row.subRows, (d) => d.subRows),
		getParentRow: () => row.parentId ? table.getRow(row.parentId, true) : void 0,
		getParentRows: () => {
			let parentRows = [];
			let currentRow = row;
			while (true) {
				const parentRow = currentRow.getParentRow();
				if (!parentRow) break;
				parentRows.push(parentRow);
				currentRow = parentRow;
			}
			return parentRows.reverse();
		},
		getAllCells: memo(() => [table.getAllLeafColumns()], (leafColumns) => {
			return leafColumns.map((column$1) => {
				return createCell(table, row, column$1, column$1.id);
			});
		}, getMemoOptions(table.options, "debugRows", "getAllCells")),
		_getAllCellsByColumnId: memo(() => [row.getAllCells()], (allCells) => {
			return allCells.reduce((acc, cell) => {
				acc[cell.column.id] = cell;
				return acc;
			}, {});
		}, getMemoOptions(table.options, "debugRows", "getAllCellsByColumnId"))
	};
	for (let i$1 = 0; i$1 < table._features.length; i$1++) {
		const feature = table._features[i$1];
		feature == null || feature.createRow == null || feature.createRow(row, table);
	}
	return row;
};
var ColumnFaceting = { createColumn: (column$1, table) => {
	column$1._getFacetedRowModel = table.options.getFacetedRowModel && table.options.getFacetedRowModel(table, column$1.id);
	column$1.getFacetedRowModel = () => {
		if (!column$1._getFacetedRowModel) return table.getPreFilteredRowModel();
		return column$1._getFacetedRowModel();
	};
	column$1._getFacetedUniqueValues = table.options.getFacetedUniqueValues && table.options.getFacetedUniqueValues(table, column$1.id);
	column$1.getFacetedUniqueValues = () => {
		if (!column$1._getFacetedUniqueValues) return /* @__PURE__ */ new Map();
		return column$1._getFacetedUniqueValues();
	};
	column$1._getFacetedMinMaxValues = table.options.getFacetedMinMaxValues && table.options.getFacetedMinMaxValues(table, column$1.id);
	column$1.getFacetedMinMaxValues = () => {
		if (!column$1._getFacetedMinMaxValues) return;
		return column$1._getFacetedMinMaxValues();
	};
} };
var includesString = (row, columnId, filterValue) => {
	var _filterValue$toString, _row$getValue;
	const search = filterValue == null || (_filterValue$toString = filterValue.toString()) == null ? void 0 : _filterValue$toString.toLowerCase();
	return Boolean((_row$getValue = row.getValue(columnId)) == null || (_row$getValue = _row$getValue.toString()) == null || (_row$getValue = _row$getValue.toLowerCase()) == null ? void 0 : _row$getValue.includes(search));
};
includesString.autoRemove = (val) => testFalsey(val);
var includesStringSensitive = (row, columnId, filterValue) => {
	var _row$getValue2;
	return Boolean((_row$getValue2 = row.getValue(columnId)) == null || (_row$getValue2 = _row$getValue2.toString()) == null ? void 0 : _row$getValue2.includes(filterValue));
};
includesStringSensitive.autoRemove = (val) => testFalsey(val);
var equalsString = (row, columnId, filterValue) => {
	var _row$getValue3;
	return ((_row$getValue3 = row.getValue(columnId)) == null || (_row$getValue3 = _row$getValue3.toString()) == null ? void 0 : _row$getValue3.toLowerCase()) === (filterValue == null ? void 0 : filterValue.toLowerCase());
};
equalsString.autoRemove = (val) => testFalsey(val);
var arrIncludes = (row, columnId, filterValue) => {
	var _row$getValue4;
	return (_row$getValue4 = row.getValue(columnId)) == null ? void 0 : _row$getValue4.includes(filterValue);
};
arrIncludes.autoRemove = (val) => testFalsey(val);
var arrIncludesAll = (row, columnId, filterValue) => {
	return !filterValue.some((val) => {
		var _row$getValue5;
		return !((_row$getValue5 = row.getValue(columnId)) != null && _row$getValue5.includes(val));
	});
};
arrIncludesAll.autoRemove = (val) => testFalsey(val) || !(val != null && val.length);
var arrIncludesSome = (row, columnId, filterValue) => {
	return filterValue.some((val) => {
		var _row$getValue6;
		return (_row$getValue6 = row.getValue(columnId)) == null ? void 0 : _row$getValue6.includes(val);
	});
};
arrIncludesSome.autoRemove = (val) => testFalsey(val) || !(val != null && val.length);
var equals = (row, columnId, filterValue) => {
	return row.getValue(columnId) === filterValue;
};
equals.autoRemove = (val) => testFalsey(val);
var weakEquals = (row, columnId, filterValue) => {
	return row.getValue(columnId) == filterValue;
};
weakEquals.autoRemove = (val) => testFalsey(val);
var inNumberRange = (row, columnId, filterValue) => {
	let [min$2, max$2] = filterValue;
	const rowValue = row.getValue(columnId);
	return rowValue >= min$2 && rowValue <= max$2;
};
inNumberRange.resolveFilterValue = (val) => {
	let [unsafeMin, unsafeMax] = val;
	let parsedMin = typeof unsafeMin !== "number" ? parseFloat(unsafeMin) : unsafeMin;
	let parsedMax = typeof unsafeMax !== "number" ? parseFloat(unsafeMax) : unsafeMax;
	let min$2 = unsafeMin === null || Number.isNaN(parsedMin) ? -Infinity : parsedMin;
	let max$2 = unsafeMax === null || Number.isNaN(parsedMax) ? Infinity : parsedMax;
	if (min$2 > max$2) {
		const temp = min$2;
		min$2 = max$2;
		max$2 = temp;
	}
	return [min$2, max$2];
};
inNumberRange.autoRemove = (val) => testFalsey(val) || testFalsey(val[0]) && testFalsey(val[1]);
var filterFns = {
	includesString,
	includesStringSensitive,
	equalsString,
	arrIncludes,
	arrIncludesAll,
	arrIncludesSome,
	equals,
	weakEquals,
	inNumberRange
};
function testFalsey(val) {
	return val === void 0 || val === null || val === "";
}
var ColumnFiltering = {
	getDefaultColumnDef: () => {
		return { filterFn: "auto" };
	},
	getInitialState: (state) => {
		return {
			columnFilters: [],
			...state
		};
	},
	getDefaultOptions: (table) => {
		return {
			onColumnFiltersChange: makeStateUpdater("columnFilters", table),
			filterFromLeafRows: false,
			maxLeafRowFilterDepth: 100
		};
	},
	createColumn: (column$1, table) => {
		column$1.getAutoFilterFn = () => {
			const firstRow = table.getCoreRowModel().flatRows[0];
			const value = firstRow == null ? void 0 : firstRow.getValue(column$1.id);
			if (typeof value === "string") return filterFns.includesString;
			if (typeof value === "number") return filterFns.inNumberRange;
			if (typeof value === "boolean") return filterFns.equals;
			if (value !== null && typeof value === "object") return filterFns.equals;
			if (Array.isArray(value)) return filterFns.arrIncludes;
			return filterFns.weakEquals;
		};
		column$1.getFilterFn = () => {
			var _table$options$filter, _table$options$filter2;
			return isFunction(column$1.columnDef.filterFn) ? column$1.columnDef.filterFn : column$1.columnDef.filterFn === "auto" ? column$1.getAutoFilterFn() : (_table$options$filter = (_table$options$filter2 = table.options.filterFns) == null ? void 0 : _table$options$filter2[column$1.columnDef.filterFn]) != null ? _table$options$filter : filterFns[column$1.columnDef.filterFn];
		};
		column$1.getCanFilter = () => {
			var _column$columnDef$ena, _table$options$enable, _table$options$enable2;
			return ((_column$columnDef$ena = column$1.columnDef.enableColumnFilter) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableColumnFilters) != null ? _table$options$enable : true) && ((_table$options$enable2 = table.options.enableFilters) != null ? _table$options$enable2 : true) && !!column$1.accessorFn;
		};
		column$1.getIsFiltered = () => column$1.getFilterIndex() > -1;
		column$1.getFilterValue = () => {
			var _table$getState$colum;
			return (_table$getState$colum = table.getState().columnFilters) == null || (_table$getState$colum = _table$getState$colum.find((d) => d.id === column$1.id)) == null ? void 0 : _table$getState$colum.value;
		};
		column$1.getFilterIndex = () => {
			var _table$getState$colum2, _table$getState$colum3;
			return (_table$getState$colum2 = (_table$getState$colum3 = table.getState().columnFilters) == null ? void 0 : _table$getState$colum3.findIndex((d) => d.id === column$1.id)) != null ? _table$getState$colum2 : -1;
		};
		column$1.setFilterValue = (value) => {
			table.setColumnFilters((old) => {
				const filterFn = column$1.getFilterFn();
				const previousFilter = old == null ? void 0 : old.find((d) => d.id === column$1.id);
				const newFilter = functionalUpdate(value, previousFilter ? previousFilter.value : void 0);
				if (shouldAutoRemoveFilter(filterFn, newFilter, column$1)) {
					var _old$filter;
					return (_old$filter = old == null ? void 0 : old.filter((d) => d.id !== column$1.id)) != null ? _old$filter : [];
				}
				const newFilterObj = {
					id: column$1.id,
					value: newFilter
				};
				if (previousFilter) {
					var _old$map;
					return (_old$map = old == null ? void 0 : old.map((d) => {
						if (d.id === column$1.id) return newFilterObj;
						return d;
					})) != null ? _old$map : [];
				}
				if (old != null && old.length) return [...old, newFilterObj];
				return [newFilterObj];
			});
		};
	},
	createRow: (row, _table) => {
		row.columnFilters = {};
		row.columnFiltersMeta = {};
	},
	createTable: (table) => {
		table.setColumnFilters = (updater) => {
			const leafColumns = table.getAllLeafColumns();
			const updateFn = (old) => {
				var _functionalUpdate;
				return (_functionalUpdate = functionalUpdate(updater, old)) == null ? void 0 : _functionalUpdate.filter((filter) => {
					const column$1 = leafColumns.find((d) => d.id === filter.id);
					if (column$1) {
						if (shouldAutoRemoveFilter(column$1.getFilterFn(), filter.value, column$1)) return false;
					}
					return true;
				});
			};
			table.options.onColumnFiltersChange == null || table.options.onColumnFiltersChange(updateFn);
		};
		table.resetColumnFilters = (defaultState) => {
			var _table$initialState$c, _table$initialState;
			table.setColumnFilters(defaultState ? [] : (_table$initialState$c = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.columnFilters) != null ? _table$initialState$c : []);
		};
		table.getPreFilteredRowModel = () => table.getCoreRowModel();
		table.getFilteredRowModel = () => {
			if (!table._getFilteredRowModel && table.options.getFilteredRowModel) table._getFilteredRowModel = table.options.getFilteredRowModel(table);
			if (table.options.manualFiltering || !table._getFilteredRowModel) return table.getPreFilteredRowModel();
			return table._getFilteredRowModel();
		};
	}
};
function shouldAutoRemoveFilter(filterFn, value, column$1) {
	return (filterFn && filterFn.autoRemove ? filterFn.autoRemove(value, column$1) : false) || typeof value === "undefined" || typeof value === "string" && !value;
}
var sum = (columnId, _leafRows, childRows) => {
	return childRows.reduce((sum$2, next$1) => {
		const nextValue = next$1.getValue(columnId);
		return sum$2 + (typeof nextValue === "number" ? nextValue : 0);
	}, 0);
};
var min = (columnId, _leafRows, childRows) => {
	let min$2;
	childRows.forEach((row) => {
		const value = row.getValue(columnId);
		if (value != null && (min$2 > value || min$2 === void 0 && value >= value)) min$2 = value;
	});
	return min$2;
};
var max = (columnId, _leafRows, childRows) => {
	let max$2;
	childRows.forEach((row) => {
		const value = row.getValue(columnId);
		if (value != null && (max$2 < value || max$2 === void 0 && value >= value)) max$2 = value;
	});
	return max$2;
};
var extent = (columnId, _leafRows, childRows) => {
	let min$2;
	let max$2;
	childRows.forEach((row) => {
		const value = row.getValue(columnId);
		if (value != null) if (min$2 === void 0) {
			if (value >= value) min$2 = max$2 = value;
		} else {
			if (min$2 > value) min$2 = value;
			if (max$2 < value) max$2 = value;
		}
	});
	return [min$2, max$2];
};
var mean = (columnId, leafRows) => {
	let count$3 = 0;
	let sum$2 = 0;
	leafRows.forEach((row) => {
		let value = row.getValue(columnId);
		if (value != null && (value = +value) >= value) ++count$3, sum$2 += value;
	});
	if (count$3) return sum$2 / count$3;
};
var median = (columnId, leafRows) => {
	if (!leafRows.length) return;
	const values = leafRows.map((row) => row.getValue(columnId));
	if (!isNumberArray(values)) return;
	if (values.length === 1) return values[0];
	const mid$1 = Math.floor(values.length / 2);
	const nums = values.sort((a$1, b$2) => a$1 - b$2);
	return values.length % 2 !== 0 ? nums[mid$1] : (nums[mid$1 - 1] + nums[mid$1]) / 2;
};
var unique = (columnId, leafRows) => {
	return Array.from(new Set(leafRows.map((d) => d.getValue(columnId))).values());
};
var uniqueCount = (columnId, leafRows) => {
	return new Set(leafRows.map((d) => d.getValue(columnId))).size;
};
var count = (_columnId, leafRows) => {
	return leafRows.length;
};
var aggregationFns = {
	sum,
	min,
	max,
	extent,
	mean,
	median,
	unique,
	uniqueCount,
	count
};
var ColumnGrouping = {
	getDefaultColumnDef: () => {
		return {
			aggregatedCell: (props) => {
				var _toString, _props$getValue;
				return (_toString = (_props$getValue = props.getValue()) == null || _props$getValue.toString == null ? void 0 : _props$getValue.toString()) != null ? _toString : null;
			},
			aggregationFn: "auto"
		};
	},
	getInitialState: (state) => {
		return {
			grouping: [],
			...state
		};
	},
	getDefaultOptions: (table) => {
		return {
			onGroupingChange: makeStateUpdater("grouping", table),
			groupedColumnMode: "reorder"
		};
	},
	createColumn: (column$1, table) => {
		column$1.toggleGrouping = () => {
			table.setGrouping((old) => {
				if (old != null && old.includes(column$1.id)) return old.filter((d) => d !== column$1.id);
				return [...old != null ? old : [], column$1.id];
			});
		};
		column$1.getCanGroup = () => {
			var _column$columnDef$ena, _table$options$enable;
			return ((_column$columnDef$ena = column$1.columnDef.enableGrouping) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableGrouping) != null ? _table$options$enable : true) && (!!column$1.accessorFn || !!column$1.columnDef.getGroupingValue);
		};
		column$1.getIsGrouped = () => {
			var _table$getState$group;
			return (_table$getState$group = table.getState().grouping) == null ? void 0 : _table$getState$group.includes(column$1.id);
		};
		column$1.getGroupedIndex = () => {
			var _table$getState$group2;
			return (_table$getState$group2 = table.getState().grouping) == null ? void 0 : _table$getState$group2.indexOf(column$1.id);
		};
		column$1.getToggleGroupingHandler = () => {
			const canGroup = column$1.getCanGroup();
			return () => {
				if (!canGroup) return;
				column$1.toggleGrouping();
			};
		};
		column$1.getAutoAggregationFn = () => {
			const firstRow = table.getCoreRowModel().flatRows[0];
			const value = firstRow == null ? void 0 : firstRow.getValue(column$1.id);
			if (typeof value === "number") return aggregationFns.sum;
			if (Object.prototype.toString.call(value) === "[object Date]") return aggregationFns.extent;
		};
		column$1.getAggregationFn = () => {
			var _table$options$aggreg, _table$options$aggreg2;
			if (!column$1) throw new Error();
			return isFunction(column$1.columnDef.aggregationFn) ? column$1.columnDef.aggregationFn : column$1.columnDef.aggregationFn === "auto" ? column$1.getAutoAggregationFn() : (_table$options$aggreg = (_table$options$aggreg2 = table.options.aggregationFns) == null ? void 0 : _table$options$aggreg2[column$1.columnDef.aggregationFn]) != null ? _table$options$aggreg : aggregationFns[column$1.columnDef.aggregationFn];
		};
	},
	createTable: (table) => {
		table.setGrouping = (updater) => table.options.onGroupingChange == null ? void 0 : table.options.onGroupingChange(updater);
		table.resetGrouping = (defaultState) => {
			var _table$initialState$g, _table$initialState;
			table.setGrouping(defaultState ? [] : (_table$initialState$g = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.grouping) != null ? _table$initialState$g : []);
		};
		table.getPreGroupedRowModel = () => table.getFilteredRowModel();
		table.getGroupedRowModel = () => {
			if (!table._getGroupedRowModel && table.options.getGroupedRowModel) table._getGroupedRowModel = table.options.getGroupedRowModel(table);
			if (table.options.manualGrouping || !table._getGroupedRowModel) return table.getPreGroupedRowModel();
			return table._getGroupedRowModel();
		};
	},
	createRow: (row, table) => {
		row.getIsGrouped = () => !!row.groupingColumnId;
		row.getGroupingValue = (columnId) => {
			if (row._groupingValuesCache.hasOwnProperty(columnId)) return row._groupingValuesCache[columnId];
			const column$1 = table.getColumn(columnId);
			if (!(column$1 != null && column$1.columnDef.getGroupingValue)) return row.getValue(columnId);
			row._groupingValuesCache[columnId] = column$1.columnDef.getGroupingValue(row.original);
			return row._groupingValuesCache[columnId];
		};
		row._groupingValuesCache = {};
	},
	createCell: (cell, column$1, row, table) => {
		cell.getIsGrouped = () => column$1.getIsGrouped() && column$1.id === row.groupingColumnId;
		cell.getIsPlaceholder = () => !cell.getIsGrouped() && column$1.getIsGrouped();
		cell.getIsAggregated = () => {
			var _row$subRows;
			return !cell.getIsGrouped() && !cell.getIsPlaceholder() && !!((_row$subRows = row.subRows) != null && _row$subRows.length);
		};
	}
};
function orderColumns(leafColumns, grouping, groupedColumnMode) {
	if (!(grouping != null && grouping.length) || !groupedColumnMode) return leafColumns;
	const nonGroupingColumns = leafColumns.filter((col) => !grouping.includes(col.id));
	if (groupedColumnMode === "remove") return nonGroupingColumns;
	return [...grouping.map((g$1) => leafColumns.find((col) => col.id === g$1)).filter(Boolean), ...nonGroupingColumns];
}
var ColumnOrdering = {
	getInitialState: (state) => {
		return {
			columnOrder: [],
			...state
		};
	},
	getDefaultOptions: (table) => {
		return { onColumnOrderChange: makeStateUpdater("columnOrder", table) };
	},
	createColumn: (column$1, table) => {
		column$1.getIndex = memo((position) => [_getVisibleLeafColumns(table, position)], (columns) => columns.findIndex((d) => d.id === column$1.id), getMemoOptions(table.options, "debugColumns", "getIndex"));
		column$1.getIsFirstColumn = (position) => {
			var _columns$;
			return ((_columns$ = _getVisibleLeafColumns(table, position)[0]) == null ? void 0 : _columns$.id) === column$1.id;
		};
		column$1.getIsLastColumn = (position) => {
			var _columns;
			const columns = _getVisibleLeafColumns(table, position);
			return ((_columns = columns[columns.length - 1]) == null ? void 0 : _columns.id) === column$1.id;
		};
	},
	createTable: (table) => {
		table.setColumnOrder = (updater) => table.options.onColumnOrderChange == null ? void 0 : table.options.onColumnOrderChange(updater);
		table.resetColumnOrder = (defaultState) => {
			var _table$initialState$c;
			table.setColumnOrder(defaultState ? [] : (_table$initialState$c = table.initialState.columnOrder) != null ? _table$initialState$c : []);
		};
		table._getOrderColumnsFn = memo(() => [
			table.getState().columnOrder,
			table.getState().grouping,
			table.options.groupedColumnMode
		], (columnOrder, grouping, groupedColumnMode) => (columns) => {
			let orderedColumns = [];
			if (!(columnOrder != null && columnOrder.length)) orderedColumns = columns;
			else {
				const columnOrderCopy = [...columnOrder];
				const columnsCopy = [...columns];
				while (columnsCopy.length && columnOrderCopy.length) {
					const targetColumnId = columnOrderCopy.shift();
					const foundIndex = columnsCopy.findIndex((d) => d.id === targetColumnId);
					if (foundIndex > -1) orderedColumns.push(columnsCopy.splice(foundIndex, 1)[0]);
				}
				orderedColumns = [...orderedColumns, ...columnsCopy];
			}
			return orderColumns(orderedColumns, grouping, groupedColumnMode);
		}, getMemoOptions(table.options, "debugTable", "_getOrderColumnsFn"));
	}
};
var getDefaultColumnPinningState = () => ({
	left: [],
	right: []
});
var ColumnPinning = {
	getInitialState: (state) => {
		return {
			columnPinning: getDefaultColumnPinningState(),
			...state
		};
	},
	getDefaultOptions: (table) => {
		return { onColumnPinningChange: makeStateUpdater("columnPinning", table) };
	},
	createColumn: (column$1, table) => {
		column$1.pin = (position) => {
			const columnIds = column$1.getLeafColumns().map((d) => d.id).filter(Boolean);
			table.setColumnPinning((old) => {
				var _old$left3, _old$right3;
				if (position === "right") {
					var _old$left, _old$right;
					return {
						left: ((_old$left = old == null ? void 0 : old.left) != null ? _old$left : []).filter((d) => !(columnIds != null && columnIds.includes(d))),
						right: [...((_old$right = old == null ? void 0 : old.right) != null ? _old$right : []).filter((d) => !(columnIds != null && columnIds.includes(d))), ...columnIds]
					};
				}
				if (position === "left") {
					var _old$left2, _old$right2;
					return {
						left: [...((_old$left2 = old == null ? void 0 : old.left) != null ? _old$left2 : []).filter((d) => !(columnIds != null && columnIds.includes(d))), ...columnIds],
						right: ((_old$right2 = old == null ? void 0 : old.right) != null ? _old$right2 : []).filter((d) => !(columnIds != null && columnIds.includes(d)))
					};
				}
				return {
					left: ((_old$left3 = old == null ? void 0 : old.left) != null ? _old$left3 : []).filter((d) => !(columnIds != null && columnIds.includes(d))),
					right: ((_old$right3 = old == null ? void 0 : old.right) != null ? _old$right3 : []).filter((d) => !(columnIds != null && columnIds.includes(d)))
				};
			});
		};
		column$1.getCanPin = () => {
			return column$1.getLeafColumns().some((d) => {
				var _d$columnDef$enablePi, _ref, _table$options$enable;
				return ((_d$columnDef$enablePi = d.columnDef.enablePinning) != null ? _d$columnDef$enablePi : true) && ((_ref = (_table$options$enable = table.options.enableColumnPinning) != null ? _table$options$enable : table.options.enablePinning) != null ? _ref : true);
			});
		};
		column$1.getIsPinned = () => {
			const leafColumnIds = column$1.getLeafColumns().map((d) => d.id);
			const { left: left$1, right: right$1 } = table.getState().columnPinning;
			const isLeft = leafColumnIds.some((d) => left$1 == null ? void 0 : left$1.includes(d));
			const isRight = leafColumnIds.some((d) => right$1 == null ? void 0 : right$1.includes(d));
			return isLeft ? "left" : isRight ? "right" : false;
		};
		column$1.getPinnedIndex = () => {
			var _table$getState$colum, _table$getState$colum2;
			const position = column$1.getIsPinned();
			return position ? (_table$getState$colum = (_table$getState$colum2 = table.getState().columnPinning) == null || (_table$getState$colum2 = _table$getState$colum2[position]) == null ? void 0 : _table$getState$colum2.indexOf(column$1.id)) != null ? _table$getState$colum : -1 : 0;
		};
	},
	createRow: (row, table) => {
		row.getCenterVisibleCells = memo(() => [
			row._getAllVisibleCells(),
			table.getState().columnPinning.left,
			table.getState().columnPinning.right
		], (allCells, left$1, right$1) => {
			const leftAndRight = [...left$1 != null ? left$1 : [], ...right$1 != null ? right$1 : []];
			return allCells.filter((d) => !leftAndRight.includes(d.column.id));
		}, getMemoOptions(table.options, "debugRows", "getCenterVisibleCells"));
		row.getLeftVisibleCells = memo(() => [row._getAllVisibleCells(), table.getState().columnPinning.left], (allCells, left$1) => {
			return (left$1 != null ? left$1 : []).map((columnId) => allCells.find((cell) => cell.column.id === columnId)).filter(Boolean).map((d) => ({
				...d,
				position: "left"
			}));
		}, getMemoOptions(table.options, "debugRows", "getLeftVisibleCells"));
		row.getRightVisibleCells = memo(() => [row._getAllVisibleCells(), table.getState().columnPinning.right], (allCells, right$1) => {
			return (right$1 != null ? right$1 : []).map((columnId) => allCells.find((cell) => cell.column.id === columnId)).filter(Boolean).map((d) => ({
				...d,
				position: "right"
			}));
		}, getMemoOptions(table.options, "debugRows", "getRightVisibleCells"));
	},
	createTable: (table) => {
		table.setColumnPinning = (updater) => table.options.onColumnPinningChange == null ? void 0 : table.options.onColumnPinningChange(updater);
		table.resetColumnPinning = (defaultState) => {
			var _table$initialState$c, _table$initialState;
			return table.setColumnPinning(defaultState ? getDefaultColumnPinningState() : (_table$initialState$c = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.columnPinning) != null ? _table$initialState$c : getDefaultColumnPinningState());
		};
		table.getIsSomeColumnsPinned = (position) => {
			var _pinningState$positio;
			const pinningState = table.getState().columnPinning;
			if (!position) {
				var _pinningState$left, _pinningState$right;
				return Boolean(((_pinningState$left = pinningState.left) == null ? void 0 : _pinningState$left.length) || ((_pinningState$right = pinningState.right) == null ? void 0 : _pinningState$right.length));
			}
			return Boolean((_pinningState$positio = pinningState[position]) == null ? void 0 : _pinningState$positio.length);
		};
		table.getLeftLeafColumns = memo(() => [table.getAllLeafColumns(), table.getState().columnPinning.left], (allColumns, left$1) => {
			return (left$1 != null ? left$1 : []).map((columnId) => allColumns.find((column$1) => column$1.id === columnId)).filter(Boolean);
		}, getMemoOptions(table.options, "debugColumns", "getLeftLeafColumns"));
		table.getRightLeafColumns = memo(() => [table.getAllLeafColumns(), table.getState().columnPinning.right], (allColumns, right$1) => {
			return (right$1 != null ? right$1 : []).map((columnId) => allColumns.find((column$1) => column$1.id === columnId)).filter(Boolean);
		}, getMemoOptions(table.options, "debugColumns", "getRightLeafColumns"));
		table.getCenterLeafColumns = memo(() => [
			table.getAllLeafColumns(),
			table.getState().columnPinning.left,
			table.getState().columnPinning.right
		], (allColumns, left$1, right$1) => {
			const leftAndRight = [...left$1 != null ? left$1 : [], ...right$1 != null ? right$1 : []];
			return allColumns.filter((d) => !leftAndRight.includes(d.id));
		}, getMemoOptions(table.options, "debugColumns", "getCenterLeafColumns"));
	}
};
var defaultColumnSizing = {
	size: 150,
	minSize: 20,
	maxSize: Number.MAX_SAFE_INTEGER
};
var getDefaultColumnSizingInfoState = () => ({
	startOffset: null,
	startSize: null,
	deltaOffset: null,
	deltaPercentage: null,
	isResizingColumn: false,
	columnSizingStart: []
});
var ColumnSizing = {
	getDefaultColumnDef: () => {
		return defaultColumnSizing;
	},
	getInitialState: (state) => {
		return {
			columnSizing: {},
			columnSizingInfo: getDefaultColumnSizingInfoState(),
			...state
		};
	},
	getDefaultOptions: (table) => {
		return {
			columnResizeMode: "onEnd",
			columnResizeDirection: "ltr",
			onColumnSizingChange: makeStateUpdater("columnSizing", table),
			onColumnSizingInfoChange: makeStateUpdater("columnSizingInfo", table)
		};
	},
	createColumn: (column$1, table) => {
		column$1.getSize = () => {
			var _column$columnDef$min, _ref, _column$columnDef$max;
			const columnSize = table.getState().columnSizing[column$1.id];
			return Math.min(Math.max((_column$columnDef$min = column$1.columnDef.minSize) != null ? _column$columnDef$min : defaultColumnSizing.minSize, (_ref = columnSize != null ? columnSize : column$1.columnDef.size) != null ? _ref : defaultColumnSizing.size), (_column$columnDef$max = column$1.columnDef.maxSize) != null ? _column$columnDef$max : defaultColumnSizing.maxSize);
		};
		column$1.getStart = memo((position) => [
			position,
			_getVisibleLeafColumns(table, position),
			table.getState().columnSizing
		], (position, columns) => columns.slice(0, column$1.getIndex(position)).reduce((sum$2, column$2) => sum$2 + column$2.getSize(), 0), getMemoOptions(table.options, "debugColumns", "getStart"));
		column$1.getAfter = memo((position) => [
			position,
			_getVisibleLeafColumns(table, position),
			table.getState().columnSizing
		], (position, columns) => columns.slice(column$1.getIndex(position) + 1).reduce((sum$2, column$2) => sum$2 + column$2.getSize(), 0), getMemoOptions(table.options, "debugColumns", "getAfter"));
		column$1.resetSize = () => {
			table.setColumnSizing((_ref2) => {
				let { [column$1.id]: _,...rest } = _ref2;
				return rest;
			});
		};
		column$1.getCanResize = () => {
			var _column$columnDef$ena, _table$options$enable;
			return ((_column$columnDef$ena = column$1.columnDef.enableResizing) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableColumnResizing) != null ? _table$options$enable : true);
		};
		column$1.getIsResizing = () => {
			return table.getState().columnSizingInfo.isResizingColumn === column$1.id;
		};
	},
	createHeader: (header$5, table) => {
		header$5.getSize = () => {
			let sum$2 = 0;
			const recurse = (header$6) => {
				if (header$6.subHeaders.length) header$6.subHeaders.forEach(recurse);
				else {
					var _header$column$getSiz;
					sum$2 += (_header$column$getSiz = header$6.column.getSize()) != null ? _header$column$getSiz : 0;
				}
			};
			recurse(header$5);
			return sum$2;
		};
		header$5.getStart = () => {
			if (header$5.index > 0) {
				const prevSiblingHeader = header$5.headerGroup.headers[header$5.index - 1];
				return prevSiblingHeader.getStart() + prevSiblingHeader.getSize();
			}
			return 0;
		};
		header$5.getResizeHandler = (_contextDocument) => {
			const column$1 = table.getColumn(header$5.column.id);
			const canResize = column$1 == null ? void 0 : column$1.getCanResize();
			return (e) => {
				if (!column$1 || !canResize) return;
				e.persist == null || e.persist();
				if (isTouchStartEvent(e)) {
					if (e.touches && e.touches.length > 1) return;
				}
				const startSize = header$5.getSize();
				const columnSizingStart = header$5 ? header$5.getLeafHeaders().map((d) => [d.column.id, d.column.getSize()]) : [[column$1.id, column$1.getSize()]];
				const clientX = isTouchStartEvent(e) ? Math.round(e.touches[0].clientX) : e.clientX;
				const newColumnSizing = {};
				const updateOffset = (eventType, clientXPos) => {
					if (typeof clientXPos !== "number") return;
					table.setColumnSizingInfo((old) => {
						var _old$startOffset, _old$startSize;
						const deltaDirection = table.options.columnResizeDirection === "rtl" ? -1 : 1;
						const deltaOffset = (clientXPos - ((_old$startOffset = old == null ? void 0 : old.startOffset) != null ? _old$startOffset : 0)) * deltaDirection;
						const deltaPercentage = Math.max(deltaOffset / ((_old$startSize = old == null ? void 0 : old.startSize) != null ? _old$startSize : 0), -.999999);
						old.columnSizingStart.forEach((_ref3) => {
							let [columnId, headerSize] = _ref3;
							newColumnSizing[columnId] = Math.round(Math.max(headerSize + headerSize * deltaPercentage, 0) * 100) / 100;
						});
						return {
							...old,
							deltaOffset,
							deltaPercentage
						};
					});
					if (table.options.columnResizeMode === "onChange" || eventType === "end") table.setColumnSizing((old) => ({
						...old,
						...newColumnSizing
					}));
				};
				const onMove = (clientXPos) => updateOffset("move", clientXPos);
				const onEnd = (clientXPos) => {
					updateOffset("end", clientXPos);
					table.setColumnSizingInfo((old) => ({
						...old,
						isResizingColumn: false,
						startOffset: null,
						startSize: null,
						deltaOffset: null,
						deltaPercentage: null,
						columnSizingStart: []
					}));
				};
				const contextDocument = _contextDocument || typeof document !== "undefined" ? document : null;
				const mouseEvents = {
					moveHandler: (e$1) => onMove(e$1.clientX),
					upHandler: (e$1) => {
						contextDocument?.removeEventListener("mousemove", mouseEvents.moveHandler);
						contextDocument?.removeEventListener("mouseup", mouseEvents.upHandler);
						onEnd(e$1.clientX);
					}
				};
				const touchEvents = {
					moveHandler: (e$1) => {
						if (e$1.cancelable) {
							e$1.preventDefault();
							e$1.stopPropagation();
						}
						onMove(e$1.touches[0].clientX);
						return false;
					},
					upHandler: (e$1) => {
						var _e$touches$;
						contextDocument?.removeEventListener("touchmove", touchEvents.moveHandler);
						contextDocument?.removeEventListener("touchend", touchEvents.upHandler);
						if (e$1.cancelable) {
							e$1.preventDefault();
							e$1.stopPropagation();
						}
						onEnd((_e$touches$ = e$1.touches[0]) == null ? void 0 : _e$touches$.clientX);
					}
				};
				const passiveIfSupported = passiveEventSupported() ? { passive: false } : false;
				if (isTouchStartEvent(e)) {
					contextDocument?.addEventListener("touchmove", touchEvents.moveHandler, passiveIfSupported);
					contextDocument?.addEventListener("touchend", touchEvents.upHandler, passiveIfSupported);
				} else {
					contextDocument?.addEventListener("mousemove", mouseEvents.moveHandler, passiveIfSupported);
					contextDocument?.addEventListener("mouseup", mouseEvents.upHandler, passiveIfSupported);
				}
				table.setColumnSizingInfo((old) => ({
					...old,
					startOffset: clientX,
					startSize,
					deltaOffset: 0,
					deltaPercentage: 0,
					columnSizingStart,
					isResizingColumn: column$1.id
				}));
			};
		};
	},
	createTable: (table) => {
		table.setColumnSizing = (updater) => table.options.onColumnSizingChange == null ? void 0 : table.options.onColumnSizingChange(updater);
		table.setColumnSizingInfo = (updater) => table.options.onColumnSizingInfoChange == null ? void 0 : table.options.onColumnSizingInfoChange(updater);
		table.resetColumnSizing = (defaultState) => {
			var _table$initialState$c;
			table.setColumnSizing(defaultState ? {} : (_table$initialState$c = table.initialState.columnSizing) != null ? _table$initialState$c : {});
		};
		table.resetHeaderSizeInfo = (defaultState) => {
			var _table$initialState$c2;
			table.setColumnSizingInfo(defaultState ? getDefaultColumnSizingInfoState() : (_table$initialState$c2 = table.initialState.columnSizingInfo) != null ? _table$initialState$c2 : getDefaultColumnSizingInfoState());
		};
		table.getTotalSize = () => {
			var _table$getHeaderGroup, _table$getHeaderGroup2;
			return (_table$getHeaderGroup = (_table$getHeaderGroup2 = table.getHeaderGroups()[0]) == null ? void 0 : _table$getHeaderGroup2.headers.reduce((sum$2, header$5) => {
				return sum$2 + header$5.getSize();
			}, 0)) != null ? _table$getHeaderGroup : 0;
		};
		table.getLeftTotalSize = () => {
			var _table$getLeftHeaderG, _table$getLeftHeaderG2;
			return (_table$getLeftHeaderG = (_table$getLeftHeaderG2 = table.getLeftHeaderGroups()[0]) == null ? void 0 : _table$getLeftHeaderG2.headers.reduce((sum$2, header$5) => {
				return sum$2 + header$5.getSize();
			}, 0)) != null ? _table$getLeftHeaderG : 0;
		};
		table.getCenterTotalSize = () => {
			var _table$getCenterHeade, _table$getCenterHeade2;
			return (_table$getCenterHeade = (_table$getCenterHeade2 = table.getCenterHeaderGroups()[0]) == null ? void 0 : _table$getCenterHeade2.headers.reduce((sum$2, header$5) => {
				return sum$2 + header$5.getSize();
			}, 0)) != null ? _table$getCenterHeade : 0;
		};
		table.getRightTotalSize = () => {
			var _table$getRightHeader, _table$getRightHeader2;
			return (_table$getRightHeader = (_table$getRightHeader2 = table.getRightHeaderGroups()[0]) == null ? void 0 : _table$getRightHeader2.headers.reduce((sum$2, header$5) => {
				return sum$2 + header$5.getSize();
			}, 0)) != null ? _table$getRightHeader : 0;
		};
	}
};
var passiveSupported = null;
function passiveEventSupported() {
	if (typeof passiveSupported === "boolean") return passiveSupported;
	let supported = false;
	try {
		const options$1 = { get passive() {
			supported = true;
			return false;
		} };
		const noop$1 = () => {};
		window.addEventListener("test", noop$1, options$1);
		window.removeEventListener("test", noop$1);
	} catch (err) {
		supported = false;
	}
	passiveSupported = supported;
	return passiveSupported;
}
function isTouchStartEvent(e) {
	return e.type === "touchstart";
}
var ColumnVisibility = {
	getInitialState: (state) => {
		return {
			columnVisibility: {},
			...state
		};
	},
	getDefaultOptions: (table) => {
		return { onColumnVisibilityChange: makeStateUpdater("columnVisibility", table) };
	},
	createColumn: (column$1, table) => {
		column$1.toggleVisibility = (value) => {
			if (column$1.getCanHide()) table.setColumnVisibility((old) => ({
				...old,
				[column$1.id]: value != null ? value : !column$1.getIsVisible()
			}));
		};
		column$1.getIsVisible = () => {
			var _ref, _table$getState$colum;
			const childColumns = column$1.columns;
			return (_ref = childColumns.length ? childColumns.some((c$2) => c$2.getIsVisible()) : (_table$getState$colum = table.getState().columnVisibility) == null ? void 0 : _table$getState$colum[column$1.id]) != null ? _ref : true;
		};
		column$1.getCanHide = () => {
			var _column$columnDef$ena, _table$options$enable;
			return ((_column$columnDef$ena = column$1.columnDef.enableHiding) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableHiding) != null ? _table$options$enable : true);
		};
		column$1.getToggleVisibilityHandler = () => {
			return (e) => {
				column$1.toggleVisibility == null || column$1.toggleVisibility(e.target.checked);
			};
		};
	},
	createRow: (row, table) => {
		row._getAllVisibleCells = memo(() => [row.getAllCells(), table.getState().columnVisibility], (cells) => {
			return cells.filter((cell) => cell.column.getIsVisible());
		}, getMemoOptions(table.options, "debugRows", "_getAllVisibleCells"));
		row.getVisibleCells = memo(() => [
			row.getLeftVisibleCells(),
			row.getCenterVisibleCells(),
			row.getRightVisibleCells()
		], (left$1, center, right$1) => [
			...left$1,
			...center,
			...right$1
		], getMemoOptions(table.options, "debugRows", "getVisibleCells"));
	},
	createTable: (table) => {
		const makeVisibleColumnsMethod = (key$2, getColumns) => {
			return memo(() => [getColumns(), getColumns().filter((d) => d.getIsVisible()).map((d) => d.id).join("_")], (columns) => {
				return columns.filter((d) => d.getIsVisible == null ? void 0 : d.getIsVisible());
			}, getMemoOptions(table.options, "debugColumns", key$2));
		};
		table.getVisibleFlatColumns = makeVisibleColumnsMethod("getVisibleFlatColumns", () => table.getAllFlatColumns());
		table.getVisibleLeafColumns = makeVisibleColumnsMethod("getVisibleLeafColumns", () => table.getAllLeafColumns());
		table.getLeftVisibleLeafColumns = makeVisibleColumnsMethod("getLeftVisibleLeafColumns", () => table.getLeftLeafColumns());
		table.getRightVisibleLeafColumns = makeVisibleColumnsMethod("getRightVisibleLeafColumns", () => table.getRightLeafColumns());
		table.getCenterVisibleLeafColumns = makeVisibleColumnsMethod("getCenterVisibleLeafColumns", () => table.getCenterLeafColumns());
		table.setColumnVisibility = (updater) => table.options.onColumnVisibilityChange == null ? void 0 : table.options.onColumnVisibilityChange(updater);
		table.resetColumnVisibility = (defaultState) => {
			var _table$initialState$c;
			table.setColumnVisibility(defaultState ? {} : (_table$initialState$c = table.initialState.columnVisibility) != null ? _table$initialState$c : {});
		};
		table.toggleAllColumnsVisible = (value) => {
			var _value;
			value = (_value = value) != null ? _value : !table.getIsAllColumnsVisible();
			table.setColumnVisibility(table.getAllLeafColumns().reduce((obj, column$1) => ({
				...obj,
				[column$1.id]: !value ? !(column$1.getCanHide != null && column$1.getCanHide()) : value
			}), {}));
		};
		table.getIsAllColumnsVisible = () => !table.getAllLeafColumns().some((column$1) => !(column$1.getIsVisible != null && column$1.getIsVisible()));
		table.getIsSomeColumnsVisible = () => table.getAllLeafColumns().some((column$1) => column$1.getIsVisible == null ? void 0 : column$1.getIsVisible());
		table.getToggleAllColumnsVisibilityHandler = () => {
			return (e) => {
				var _target;
				table.toggleAllColumnsVisible((_target = e.target) == null ? void 0 : _target.checked);
			};
		};
	}
};
function _getVisibleLeafColumns(table, position) {
	return !position ? table.getVisibleLeafColumns() : position === "center" ? table.getCenterVisibleLeafColumns() : position === "left" ? table.getLeftVisibleLeafColumns() : table.getRightVisibleLeafColumns();
}
var GlobalFaceting = { createTable: (table) => {
	table._getGlobalFacetedRowModel = table.options.getFacetedRowModel && table.options.getFacetedRowModel(table, "__global__");
	table.getGlobalFacetedRowModel = () => {
		if (table.options.manualFiltering || !table._getGlobalFacetedRowModel) return table.getPreFilteredRowModel();
		return table._getGlobalFacetedRowModel();
	};
	table._getGlobalFacetedUniqueValues = table.options.getFacetedUniqueValues && table.options.getFacetedUniqueValues(table, "__global__");
	table.getGlobalFacetedUniqueValues = () => {
		if (!table._getGlobalFacetedUniqueValues) return /* @__PURE__ */ new Map();
		return table._getGlobalFacetedUniqueValues();
	};
	table._getGlobalFacetedMinMaxValues = table.options.getFacetedMinMaxValues && table.options.getFacetedMinMaxValues(table, "__global__");
	table.getGlobalFacetedMinMaxValues = () => {
		if (!table._getGlobalFacetedMinMaxValues) return;
		return table._getGlobalFacetedMinMaxValues();
	};
} };
var GlobalFiltering = {
	getInitialState: (state) => {
		return {
			globalFilter: void 0,
			...state
		};
	},
	getDefaultOptions: (table) => {
		return {
			onGlobalFilterChange: makeStateUpdater("globalFilter", table),
			globalFilterFn: "auto",
			getColumnCanGlobalFilter: (column$1) => {
				var _table$getCoreRowMode;
				const value = (_table$getCoreRowMode = table.getCoreRowModel().flatRows[0]) == null || (_table$getCoreRowMode = _table$getCoreRowMode._getAllCellsByColumnId()[column$1.id]) == null ? void 0 : _table$getCoreRowMode.getValue();
				return typeof value === "string" || typeof value === "number";
			}
		};
	},
	createColumn: (column$1, table) => {
		column$1.getCanGlobalFilter = () => {
			var _column$columnDef$ena, _table$options$enable, _table$options$enable2, _table$options$getCol;
			return ((_column$columnDef$ena = column$1.columnDef.enableGlobalFilter) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableGlobalFilter) != null ? _table$options$enable : true) && ((_table$options$enable2 = table.options.enableFilters) != null ? _table$options$enable2 : true) && ((_table$options$getCol = table.options.getColumnCanGlobalFilter == null ? void 0 : table.options.getColumnCanGlobalFilter(column$1)) != null ? _table$options$getCol : true) && !!column$1.accessorFn;
		};
	},
	createTable: (table) => {
		table.getGlobalAutoFilterFn = () => {
			return filterFns.includesString;
		};
		table.getGlobalFilterFn = () => {
			var _table$options$filter, _table$options$filter2;
			const { globalFilterFn } = table.options;
			return isFunction(globalFilterFn) ? globalFilterFn : globalFilterFn === "auto" ? table.getGlobalAutoFilterFn() : (_table$options$filter = (_table$options$filter2 = table.options.filterFns) == null ? void 0 : _table$options$filter2[globalFilterFn]) != null ? _table$options$filter : filterFns[globalFilterFn];
		};
		table.setGlobalFilter = (updater) => {
			table.options.onGlobalFilterChange == null || table.options.onGlobalFilterChange(updater);
		};
		table.resetGlobalFilter = (defaultState) => {
			table.setGlobalFilter(defaultState ? void 0 : table.initialState.globalFilter);
		};
	}
};
var RowExpanding = {
	getInitialState: (state) => {
		return {
			expanded: {},
			...state
		};
	},
	getDefaultOptions: (table) => {
		return {
			onExpandedChange: makeStateUpdater("expanded", table),
			paginateExpandedRows: true
		};
	},
	createTable: (table) => {
		let registered$1 = false;
		let queued = false;
		table._autoResetExpanded = () => {
			var _ref, _table$options$autoRe;
			if (!registered$1) {
				table._queue(() => {
					registered$1 = true;
				});
				return;
			}
			if ((_ref = (_table$options$autoRe = table.options.autoResetAll) != null ? _table$options$autoRe : table.options.autoResetExpanded) != null ? _ref : !table.options.manualExpanding) {
				if (queued) return;
				queued = true;
				table._queue(() => {
					table.resetExpanded();
					queued = false;
				});
			}
		};
		table.setExpanded = (updater) => table.options.onExpandedChange == null ? void 0 : table.options.onExpandedChange(updater);
		table.toggleAllRowsExpanded = (expanded$2) => {
			if (expanded$2 != null ? expanded$2 : !table.getIsAllRowsExpanded()) table.setExpanded(true);
			else table.setExpanded({});
		};
		table.resetExpanded = (defaultState) => {
			var _table$initialState$e, _table$initialState;
			table.setExpanded(defaultState ? {} : (_table$initialState$e = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.expanded) != null ? _table$initialState$e : {});
		};
		table.getCanSomeRowsExpand = () => {
			return table.getPrePaginationRowModel().flatRows.some((row) => row.getCanExpand());
		};
		table.getToggleAllRowsExpandedHandler = () => {
			return (e) => {
				e.persist == null || e.persist();
				table.toggleAllRowsExpanded();
			};
		};
		table.getIsSomeRowsExpanded = () => {
			const expanded$2 = table.getState().expanded;
			return expanded$2 === true || Object.values(expanded$2).some(Boolean);
		};
		table.getIsAllRowsExpanded = () => {
			const expanded$2 = table.getState().expanded;
			if (typeof expanded$2 === "boolean") return expanded$2 === true;
			if (!Object.keys(expanded$2).length) return false;
			if (table.getRowModel().flatRows.some((row) => !row.getIsExpanded())) return false;
			return true;
		};
		table.getExpandedDepth = () => {
			let maxDepth = 0;
			(table.getState().expanded === true ? Object.keys(table.getRowModel().rowsById) : Object.keys(table.getState().expanded)).forEach((id$1) => {
				const splitId = id$1.split(".");
				maxDepth = Math.max(maxDepth, splitId.length);
			});
			return maxDepth;
		};
		table.getPreExpandedRowModel = () => table.getSortedRowModel();
		table.getExpandedRowModel = () => {
			if (!table._getExpandedRowModel && table.options.getExpandedRowModel) table._getExpandedRowModel = table.options.getExpandedRowModel(table);
			if (table.options.manualExpanding || !table._getExpandedRowModel) return table.getPreExpandedRowModel();
			return table._getExpandedRowModel();
		};
	},
	createRow: (row, table) => {
		row.toggleExpanded = (expanded$2) => {
			table.setExpanded((old) => {
				var _expanded;
				const exists = old === true ? true : !!(old != null && old[row.id]);
				let oldExpanded = {};
				if (old === true) Object.keys(table.getRowModel().rowsById).forEach((rowId) => {
					oldExpanded[rowId] = true;
				});
				else oldExpanded = old;
				expanded$2 = (_expanded = expanded$2) != null ? _expanded : !exists;
				if (!exists && expanded$2) return {
					...oldExpanded,
					[row.id]: true
				};
				if (exists && !expanded$2) {
					const { [row.id]: _,...rest } = oldExpanded;
					return rest;
				}
				return old;
			});
		};
		row.getIsExpanded = () => {
			var _table$options$getIsR;
			const expanded$2 = table.getState().expanded;
			return !!((_table$options$getIsR = table.options.getIsRowExpanded == null ? void 0 : table.options.getIsRowExpanded(row)) != null ? _table$options$getIsR : expanded$2 === true || (expanded$2 == null ? void 0 : expanded$2[row.id]));
		};
		row.getCanExpand = () => {
			var _table$options$getRow, _table$options$enable, _row$subRows;
			return (_table$options$getRow = table.options.getRowCanExpand == null ? void 0 : table.options.getRowCanExpand(row)) != null ? _table$options$getRow : ((_table$options$enable = table.options.enableExpanding) != null ? _table$options$enable : true) && !!((_row$subRows = row.subRows) != null && _row$subRows.length);
		};
		row.getIsAllParentsExpanded = () => {
			let isFullyExpanded = true;
			let currentRow = row;
			while (isFullyExpanded && currentRow.parentId) {
				currentRow = table.getRow(currentRow.parentId, true);
				isFullyExpanded = currentRow.getIsExpanded();
			}
			return isFullyExpanded;
		};
		row.getToggleExpandedHandler = () => {
			const canExpand = row.getCanExpand();
			return () => {
				if (!canExpand) return;
				row.toggleExpanded();
			};
		};
	}
};
var defaultPageIndex = 0;
var defaultPageSize = 10;
var getDefaultPaginationState = () => ({
	pageIndex: defaultPageIndex,
	pageSize: defaultPageSize
});
var RowPagination = {
	getInitialState: (state) => {
		return {
			...state,
			pagination: {
				...getDefaultPaginationState(),
				...state == null ? void 0 : state.pagination
			}
		};
	},
	getDefaultOptions: (table) => {
		return { onPaginationChange: makeStateUpdater("pagination", table) };
	},
	createTable: (table) => {
		let registered$1 = false;
		let queued = false;
		table._autoResetPageIndex = () => {
			var _ref, _table$options$autoRe;
			if (!registered$1) {
				table._queue(() => {
					registered$1 = true;
				});
				return;
			}
			if ((_ref = (_table$options$autoRe = table.options.autoResetAll) != null ? _table$options$autoRe : table.options.autoResetPageIndex) != null ? _ref : !table.options.manualPagination) {
				if (queued) return;
				queued = true;
				table._queue(() => {
					table.resetPageIndex();
					queued = false;
				});
			}
		};
		table.setPagination = (updater) => {
			const safeUpdater = (old) => {
				return functionalUpdate(updater, old);
			};
			return table.options.onPaginationChange == null ? void 0 : table.options.onPaginationChange(safeUpdater);
		};
		table.resetPagination = (defaultState) => {
			var _table$initialState$p;
			table.setPagination(defaultState ? getDefaultPaginationState() : (_table$initialState$p = table.initialState.pagination) != null ? _table$initialState$p : getDefaultPaginationState());
		};
		table.setPageIndex = (updater) => {
			table.setPagination((old) => {
				let pageIndex = functionalUpdate(updater, old.pageIndex);
				const maxPageIndex = typeof table.options.pageCount === "undefined" || table.options.pageCount === -1 ? Number.MAX_SAFE_INTEGER : table.options.pageCount - 1;
				pageIndex = Math.max(0, Math.min(pageIndex, maxPageIndex));
				return {
					...old,
					pageIndex
				};
			});
		};
		table.resetPageIndex = (defaultState) => {
			var _table$initialState$p2, _table$initialState;
			table.setPageIndex(defaultState ? defaultPageIndex : (_table$initialState$p2 = (_table$initialState = table.initialState) == null || (_table$initialState = _table$initialState.pagination) == null ? void 0 : _table$initialState.pageIndex) != null ? _table$initialState$p2 : defaultPageIndex);
		};
		table.resetPageSize = (defaultState) => {
			var _table$initialState$p3, _table$initialState2;
			table.setPageSize(defaultState ? defaultPageSize : (_table$initialState$p3 = (_table$initialState2 = table.initialState) == null || (_table$initialState2 = _table$initialState2.pagination) == null ? void 0 : _table$initialState2.pageSize) != null ? _table$initialState$p3 : defaultPageSize);
		};
		table.setPageSize = (updater) => {
			table.setPagination((old) => {
				const pageSize = Math.max(1, functionalUpdate(updater, old.pageSize));
				const topRowIndex = old.pageSize * old.pageIndex;
				const pageIndex = Math.floor(topRowIndex / pageSize);
				return {
					...old,
					pageIndex,
					pageSize
				};
			});
		};
		table.setPageCount = (updater) => table.setPagination((old) => {
			var _table$options$pageCo;
			let newPageCount = functionalUpdate(updater, (_table$options$pageCo = table.options.pageCount) != null ? _table$options$pageCo : -1);
			if (typeof newPageCount === "number") newPageCount = Math.max(-1, newPageCount);
			return {
				...old,
				pageCount: newPageCount
			};
		});
		table.getPageOptions = memo(() => [table.getPageCount()], (pageCount) => {
			let pageOptions = [];
			if (pageCount && pageCount > 0) pageOptions = [...new Array(pageCount)].fill(null).map((_, i$1) => i$1);
			return pageOptions;
		}, getMemoOptions(table.options, "debugTable", "getPageOptions"));
		table.getCanPreviousPage = () => table.getState().pagination.pageIndex > 0;
		table.getCanNextPage = () => {
			const { pageIndex } = table.getState().pagination;
			const pageCount = table.getPageCount();
			if (pageCount === -1) return true;
			if (pageCount === 0) return false;
			return pageIndex < pageCount - 1;
		};
		table.previousPage = () => {
			return table.setPageIndex((old) => old - 1);
		};
		table.nextPage = () => {
			return table.setPageIndex((old) => {
				return old + 1;
			});
		};
		table.firstPage = () => {
			return table.setPageIndex(0);
		};
		table.lastPage = () => {
			return table.setPageIndex(table.getPageCount() - 1);
		};
		table.getPrePaginationRowModel = () => table.getExpandedRowModel();
		table.getPaginationRowModel = () => {
			if (!table._getPaginationRowModel && table.options.getPaginationRowModel) table._getPaginationRowModel = table.options.getPaginationRowModel(table);
			if (table.options.manualPagination || !table._getPaginationRowModel) return table.getPrePaginationRowModel();
			return table._getPaginationRowModel();
		};
		table.getPageCount = () => {
			var _table$options$pageCo2;
			return (_table$options$pageCo2 = table.options.pageCount) != null ? _table$options$pageCo2 : Math.ceil(table.getRowCount() / table.getState().pagination.pageSize);
		};
		table.getRowCount = () => {
			var _table$options$rowCou;
			return (_table$options$rowCou = table.options.rowCount) != null ? _table$options$rowCou : table.getPrePaginationRowModel().rows.length;
		};
	}
};
var getDefaultRowPinningState = () => ({
	top: [],
	bottom: []
});
var RowPinning = {
	getInitialState: (state) => {
		return {
			rowPinning: getDefaultRowPinningState(),
			...state
		};
	},
	getDefaultOptions: (table) => {
		return { onRowPinningChange: makeStateUpdater("rowPinning", table) };
	},
	createRow: (row, table) => {
		row.pin = (position, includeLeafRows, includeParentRows) => {
			const leafRowIds = includeLeafRows ? row.getLeafRows().map((_ref) => {
				let { id: id$1 } = _ref;
				return id$1;
			}) : [];
			const parentRowIds = includeParentRows ? row.getParentRows().map((_ref2) => {
				let { id: id$1 } = _ref2;
				return id$1;
			}) : [];
			const rowIds = new Set([
				...parentRowIds,
				row.id,
				...leafRowIds
			]);
			table.setRowPinning((old) => {
				var _old$top3, _old$bottom3;
				if (position === "bottom") {
					var _old$top, _old$bottom;
					return {
						top: ((_old$top = old == null ? void 0 : old.top) != null ? _old$top : []).filter((d) => !(rowIds != null && rowIds.has(d))),
						bottom: [...((_old$bottom = old == null ? void 0 : old.bottom) != null ? _old$bottom : []).filter((d) => !(rowIds != null && rowIds.has(d))), ...Array.from(rowIds)]
					};
				}
				if (position === "top") {
					var _old$top2, _old$bottom2;
					return {
						top: [...((_old$top2 = old == null ? void 0 : old.top) != null ? _old$top2 : []).filter((d) => !(rowIds != null && rowIds.has(d))), ...Array.from(rowIds)],
						bottom: ((_old$bottom2 = old == null ? void 0 : old.bottom) != null ? _old$bottom2 : []).filter((d) => !(rowIds != null && rowIds.has(d)))
					};
				}
				return {
					top: ((_old$top3 = old == null ? void 0 : old.top) != null ? _old$top3 : []).filter((d) => !(rowIds != null && rowIds.has(d))),
					bottom: ((_old$bottom3 = old == null ? void 0 : old.bottom) != null ? _old$bottom3 : []).filter((d) => !(rowIds != null && rowIds.has(d)))
				};
			});
		};
		row.getCanPin = () => {
			var _ref3;
			const { enableRowPinning, enablePinning } = table.options;
			if (typeof enableRowPinning === "function") return enableRowPinning(row);
			return (_ref3 = enableRowPinning != null ? enableRowPinning : enablePinning) != null ? _ref3 : true;
		};
		row.getIsPinned = () => {
			const rowIds = [row.id];
			const { top: top$3, bottom: bottom$2 } = table.getState().rowPinning;
			const isTop = rowIds.some((d) => top$3 == null ? void 0 : top$3.includes(d));
			const isBottom = rowIds.some((d) => bottom$2 == null ? void 0 : bottom$2.includes(d));
			return isTop ? "top" : isBottom ? "bottom" : false;
		};
		row.getPinnedIndex = () => {
			var _ref4, _visiblePinnedRowIds$;
			const position = row.getIsPinned();
			if (!position) return -1;
			const visiblePinnedRowIds = (_ref4 = position === "top" ? table.getTopRows() : table.getBottomRows()) == null ? void 0 : _ref4.map((_ref5) => {
				let { id: id$1 } = _ref5;
				return id$1;
			});
			return (_visiblePinnedRowIds$ = visiblePinnedRowIds == null ? void 0 : visiblePinnedRowIds.indexOf(row.id)) != null ? _visiblePinnedRowIds$ : -1;
		};
	},
	createTable: (table) => {
		table.setRowPinning = (updater) => table.options.onRowPinningChange == null ? void 0 : table.options.onRowPinningChange(updater);
		table.resetRowPinning = (defaultState) => {
			var _table$initialState$r, _table$initialState;
			return table.setRowPinning(defaultState ? getDefaultRowPinningState() : (_table$initialState$r = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.rowPinning) != null ? _table$initialState$r : getDefaultRowPinningState());
		};
		table.getIsSomeRowsPinned = (position) => {
			var _pinningState$positio;
			const pinningState = table.getState().rowPinning;
			if (!position) {
				var _pinningState$top, _pinningState$bottom;
				return Boolean(((_pinningState$top = pinningState.top) == null ? void 0 : _pinningState$top.length) || ((_pinningState$bottom = pinningState.bottom) == null ? void 0 : _pinningState$bottom.length));
			}
			return Boolean((_pinningState$positio = pinningState[position]) == null ? void 0 : _pinningState$positio.length);
		};
		table._getPinnedRows = (visibleRows, pinnedRowIds, position) => {
			var _table$options$keepPi;
			return (((_table$options$keepPi = table.options.keepPinnedRows) != null ? _table$options$keepPi : true) ? (pinnedRowIds != null ? pinnedRowIds : []).map((rowId) => {
				const row = table.getRow(rowId, true);
				return row.getIsAllParentsExpanded() ? row : null;
			}) : (pinnedRowIds != null ? pinnedRowIds : []).map((rowId) => visibleRows.find((row) => row.id === rowId))).filter(Boolean).map((d) => ({
				...d,
				position
			}));
		};
		table.getTopRows = memo(() => [table.getRowModel().rows, table.getState().rowPinning.top], (allRows, topPinnedRowIds) => table._getPinnedRows(allRows, topPinnedRowIds, "top"), getMemoOptions(table.options, "debugRows", "getTopRows"));
		table.getBottomRows = memo(() => [table.getRowModel().rows, table.getState().rowPinning.bottom], (allRows, bottomPinnedRowIds) => table._getPinnedRows(allRows, bottomPinnedRowIds, "bottom"), getMemoOptions(table.options, "debugRows", "getBottomRows"));
		table.getCenterRows = memo(() => [
			table.getRowModel().rows,
			table.getState().rowPinning.top,
			table.getState().rowPinning.bottom
		], (allRows, top$3, bottom$2) => {
			const topAndBottom = new Set([...top$3 != null ? top$3 : [], ...bottom$2 != null ? bottom$2 : []]);
			return allRows.filter((d) => !topAndBottom.has(d.id));
		}, getMemoOptions(table.options, "debugRows", "getCenterRows"));
	}
};
var RowSelection = {
	getInitialState: (state) => {
		return {
			rowSelection: {},
			...state
		};
	},
	getDefaultOptions: (table) => {
		return {
			onRowSelectionChange: makeStateUpdater("rowSelection", table),
			enableRowSelection: true,
			enableMultiRowSelection: true,
			enableSubRowSelection: true
		};
	},
	createTable: (table) => {
		table.setRowSelection = (updater) => table.options.onRowSelectionChange == null ? void 0 : table.options.onRowSelectionChange(updater);
		table.resetRowSelection = (defaultState) => {
			var _table$initialState$r;
			return table.setRowSelection(defaultState ? {} : (_table$initialState$r = table.initialState.rowSelection) != null ? _table$initialState$r : {});
		};
		table.toggleAllRowsSelected = (value) => {
			table.setRowSelection((old) => {
				value = typeof value !== "undefined" ? value : !table.getIsAllRowsSelected();
				const rowSelection = { ...old };
				const preGroupedFlatRows = table.getPreGroupedRowModel().flatRows;
				if (value) preGroupedFlatRows.forEach((row) => {
					if (!row.getCanSelect()) return;
					rowSelection[row.id] = true;
				});
				else preGroupedFlatRows.forEach((row) => {
					delete rowSelection[row.id];
				});
				return rowSelection;
			});
		};
		table.toggleAllPageRowsSelected = (value) => table.setRowSelection((old) => {
			const resolvedValue = typeof value !== "undefined" ? value : !table.getIsAllPageRowsSelected();
			const rowSelection = { ...old };
			table.getRowModel().rows.forEach((row) => {
				mutateRowIsSelected(rowSelection, row.id, resolvedValue, true, table);
			});
			return rowSelection;
		});
		table.getPreSelectedRowModel = () => table.getCoreRowModel();
		table.getSelectedRowModel = memo(() => [table.getState().rowSelection, table.getCoreRowModel()], (rowSelection, rowModel) => {
			if (!Object.keys(rowSelection).length) return {
				rows: [],
				flatRows: [],
				rowsById: {}
			};
			return selectRowsFn(table, rowModel);
		}, getMemoOptions(table.options, "debugTable", "getSelectedRowModel"));
		table.getFilteredSelectedRowModel = memo(() => [table.getState().rowSelection, table.getFilteredRowModel()], (rowSelection, rowModel) => {
			if (!Object.keys(rowSelection).length) return {
				rows: [],
				flatRows: [],
				rowsById: {}
			};
			return selectRowsFn(table, rowModel);
		}, getMemoOptions(table.options, "debugTable", "getFilteredSelectedRowModel"));
		table.getGroupedSelectedRowModel = memo(() => [table.getState().rowSelection, table.getSortedRowModel()], (rowSelection, rowModel) => {
			if (!Object.keys(rowSelection).length) return {
				rows: [],
				flatRows: [],
				rowsById: {}
			};
			return selectRowsFn(table, rowModel);
		}, getMemoOptions(table.options, "debugTable", "getGroupedSelectedRowModel"));
		table.getIsAllRowsSelected = () => {
			const preGroupedFlatRows = table.getFilteredRowModel().flatRows;
			const { rowSelection } = table.getState();
			let isAllRowsSelected = Boolean(preGroupedFlatRows.length && Object.keys(rowSelection).length);
			if (isAllRowsSelected) {
				if (preGroupedFlatRows.some((row) => row.getCanSelect() && !rowSelection[row.id])) isAllRowsSelected = false;
			}
			return isAllRowsSelected;
		};
		table.getIsAllPageRowsSelected = () => {
			const paginationFlatRows = table.getPaginationRowModel().flatRows.filter((row) => row.getCanSelect());
			const { rowSelection } = table.getState();
			let isAllPageRowsSelected = !!paginationFlatRows.length;
			if (isAllPageRowsSelected && paginationFlatRows.some((row) => !rowSelection[row.id])) isAllPageRowsSelected = false;
			return isAllPageRowsSelected;
		};
		table.getIsSomeRowsSelected = () => {
			var _table$getState$rowSe;
			const totalSelected = Object.keys((_table$getState$rowSe = table.getState().rowSelection) != null ? _table$getState$rowSe : {}).length;
			return totalSelected > 0 && totalSelected < table.getFilteredRowModel().flatRows.length;
		};
		table.getIsSomePageRowsSelected = () => {
			const paginationFlatRows = table.getPaginationRowModel().flatRows;
			return table.getIsAllPageRowsSelected() ? false : paginationFlatRows.filter((row) => row.getCanSelect()).some((d) => d.getIsSelected() || d.getIsSomeSelected());
		};
		table.getToggleAllRowsSelectedHandler = () => {
			return (e) => {
				table.toggleAllRowsSelected(e.target.checked);
			};
		};
		table.getToggleAllPageRowsSelectedHandler = () => {
			return (e) => {
				table.toggleAllPageRowsSelected(e.target.checked);
			};
		};
	},
	createRow: (row, table) => {
		row.toggleSelected = (value, opts) => {
			const isSelected = row.getIsSelected();
			table.setRowSelection((old) => {
				var _opts$selectChildren;
				value = typeof value !== "undefined" ? value : !isSelected;
				if (row.getCanSelect() && isSelected === value) return old;
				const selectedRowIds = { ...old };
				mutateRowIsSelected(selectedRowIds, row.id, value, (_opts$selectChildren = opts == null ? void 0 : opts.selectChildren) != null ? _opts$selectChildren : true, table);
				return selectedRowIds;
			});
		};
		row.getIsSelected = () => {
			const { rowSelection } = table.getState();
			return isRowSelected(row, rowSelection);
		};
		row.getIsSomeSelected = () => {
			const { rowSelection } = table.getState();
			return isSubRowSelected(row, rowSelection) === "some";
		};
		row.getIsAllSubRowsSelected = () => {
			const { rowSelection } = table.getState();
			return isSubRowSelected(row, rowSelection) === "all";
		};
		row.getCanSelect = () => {
			var _table$options$enable;
			if (typeof table.options.enableRowSelection === "function") return table.options.enableRowSelection(row);
			return (_table$options$enable = table.options.enableRowSelection) != null ? _table$options$enable : true;
		};
		row.getCanSelectSubRows = () => {
			var _table$options$enable2;
			if (typeof table.options.enableSubRowSelection === "function") return table.options.enableSubRowSelection(row);
			return (_table$options$enable2 = table.options.enableSubRowSelection) != null ? _table$options$enable2 : true;
		};
		row.getCanMultiSelect = () => {
			var _table$options$enable3;
			if (typeof table.options.enableMultiRowSelection === "function") return table.options.enableMultiRowSelection(row);
			return (_table$options$enable3 = table.options.enableMultiRowSelection) != null ? _table$options$enable3 : true;
		};
		row.getToggleSelectedHandler = () => {
			const canSelect = row.getCanSelect();
			return (e) => {
				var _target;
				if (!canSelect) return;
				row.toggleSelected((_target = e.target) == null ? void 0 : _target.checked);
			};
		};
	}
};
var mutateRowIsSelected = (selectedRowIds, id$1, value, includeChildren, table) => {
	var _row$subRows;
	const row = table.getRow(id$1, true);
	if (value) {
		if (!row.getCanMultiSelect()) Object.keys(selectedRowIds).forEach((key$2) => delete selectedRowIds[key$2]);
		if (row.getCanSelect()) selectedRowIds[id$1] = true;
	} else delete selectedRowIds[id$1];
	if (includeChildren && (_row$subRows = row.subRows) != null && _row$subRows.length && row.getCanSelectSubRows()) row.subRows.forEach((row$1) => mutateRowIsSelected(selectedRowIds, row$1.id, value, includeChildren, table));
};
function selectRowsFn(table, rowModel) {
	const rowSelection = table.getState().rowSelection;
	const newSelectedFlatRows = [];
	const newSelectedRowsById = {};
	const recurseRows = function(rows, depth) {
		return rows.map((row) => {
			var _row$subRows2;
			const isSelected = isRowSelected(row, rowSelection);
			if (isSelected) {
				newSelectedFlatRows.push(row);
				newSelectedRowsById[row.id] = row;
			}
			if ((_row$subRows2 = row.subRows) != null && _row$subRows2.length) row = {
				...row,
				subRows: recurseRows(row.subRows)
			};
			if (isSelected) return row;
		}).filter(Boolean);
	};
	return {
		rows: recurseRows(rowModel.rows),
		flatRows: newSelectedFlatRows,
		rowsById: newSelectedRowsById
	};
}
function isRowSelected(row, selection) {
	var _selection$row$id;
	return (_selection$row$id = selection[row.id]) != null ? _selection$row$id : false;
}
function isSubRowSelected(row, selection, table) {
	var _row$subRows3;
	if (!((_row$subRows3 = row.subRows) != null && _row$subRows3.length)) return false;
	let allChildrenSelected = true;
	let someSelected = false;
	row.subRows.forEach((subRow) => {
		if (someSelected && !allChildrenSelected) return;
		if (subRow.getCanSelect()) if (isRowSelected(subRow, selection)) someSelected = true;
		else allChildrenSelected = false;
		if (subRow.subRows && subRow.subRows.length) {
			const subRowChildrenSelected = isSubRowSelected(subRow, selection);
			if (subRowChildrenSelected === "all") someSelected = true;
			else if (subRowChildrenSelected === "some") {
				someSelected = true;
				allChildrenSelected = false;
			} else allChildrenSelected = false;
		}
	});
	return allChildrenSelected ? "all" : someSelected ? "some" : false;
}
var reSplitAlphaNumeric = /([0-9]+)/gm;
var alphanumeric = (rowA, rowB, columnId) => {
	return compareAlphanumeric(toString(rowA.getValue(columnId)).toLowerCase(), toString(rowB.getValue(columnId)).toLowerCase());
};
var alphanumericCaseSensitive = (rowA, rowB, columnId) => {
	return compareAlphanumeric(toString(rowA.getValue(columnId)), toString(rowB.getValue(columnId)));
};
var text$1 = (rowA, rowB, columnId) => {
	return compareBasic(toString(rowA.getValue(columnId)).toLowerCase(), toString(rowB.getValue(columnId)).toLowerCase());
};
var textCaseSensitive = (rowA, rowB, columnId) => {
	return compareBasic(toString(rowA.getValue(columnId)), toString(rowB.getValue(columnId)));
};
var datetime = (rowA, rowB, columnId) => {
	const a$1 = rowA.getValue(columnId);
	const b$2 = rowB.getValue(columnId);
	return a$1 > b$2 ? 1 : a$1 < b$2 ? -1 : 0;
};
var basic = (rowA, rowB, columnId) => {
	return compareBasic(rowA.getValue(columnId), rowB.getValue(columnId));
};
function compareBasic(a$1, b$2) {
	return a$1 === b$2 ? 0 : a$1 > b$2 ? 1 : -1;
}
function toString(a$1) {
	if (typeof a$1 === "number") {
		if (isNaN(a$1) || a$1 === Infinity || a$1 === -Infinity) return "";
		return String(a$1);
	}
	if (typeof a$1 === "string") return a$1;
	return "";
}
function compareAlphanumeric(aStr, bStr) {
	const a$1 = aStr.split(reSplitAlphaNumeric).filter(Boolean);
	const b$2 = bStr.split(reSplitAlphaNumeric).filter(Boolean);
	while (a$1.length && b$2.length) {
		const aa = a$1.shift();
		const bb = b$2.shift();
		const an$1 = parseInt(aa, 10);
		const bn = parseInt(bb, 10);
		const combo = [an$1, bn].sort();
		if (isNaN(combo[0])) {
			if (aa > bb) return 1;
			if (bb > aa) return -1;
			continue;
		}
		if (isNaN(combo[1])) return isNaN(an$1) ? -1 : 1;
		if (an$1 > bn) return 1;
		if (bn > an$1) return -1;
	}
	return a$1.length - b$2.length;
}
var sortingFns = {
	alphanumeric,
	alphanumericCaseSensitive,
	text: text$1,
	textCaseSensitive,
	datetime,
	basic
};
var builtInFeatures = [
	Headers$1,
	ColumnVisibility,
	ColumnOrdering,
	ColumnPinning,
	ColumnFaceting,
	ColumnFiltering,
	GlobalFaceting,
	GlobalFiltering,
	{
		getInitialState: (state) => {
			return {
				sorting: [],
				...state
			};
		},
		getDefaultColumnDef: () => {
			return {
				sortingFn: "auto",
				sortUndefined: 1
			};
		},
		getDefaultOptions: (table) => {
			return {
				onSortingChange: makeStateUpdater("sorting", table),
				isMultiSortEvent: (e) => {
					return e.shiftKey;
				}
			};
		},
		createColumn: (column$1, table) => {
			column$1.getAutoSortingFn = () => {
				const firstRows = table.getFilteredRowModel().flatRows.slice(10);
				let isString$3 = false;
				for (const row of firstRows) {
					const value = row == null ? void 0 : row.getValue(column$1.id);
					if (Object.prototype.toString.call(value) === "[object Date]") return sortingFns.datetime;
					if (typeof value === "string") {
						isString$3 = true;
						if (value.split(reSplitAlphaNumeric).length > 1) return sortingFns.alphanumeric;
					}
				}
				if (isString$3) return sortingFns.text;
				return sortingFns.basic;
			};
			column$1.getAutoSortDir = () => {
				const firstRow = table.getFilteredRowModel().flatRows[0];
				if (typeof (firstRow == null ? void 0 : firstRow.getValue(column$1.id)) === "string") return "asc";
				return "desc";
			};
			column$1.getSortingFn = () => {
				var _table$options$sortin, _table$options$sortin2;
				if (!column$1) throw new Error();
				return isFunction(column$1.columnDef.sortingFn) ? column$1.columnDef.sortingFn : column$1.columnDef.sortingFn === "auto" ? column$1.getAutoSortingFn() : (_table$options$sortin = (_table$options$sortin2 = table.options.sortingFns) == null ? void 0 : _table$options$sortin2[column$1.columnDef.sortingFn]) != null ? _table$options$sortin : sortingFns[column$1.columnDef.sortingFn];
			};
			column$1.toggleSorting = (desc, multi) => {
				const nextSortingOrder = column$1.getNextSortingOrder();
				const hasManualValue = typeof desc !== "undefined" && desc !== null;
				table.setSorting((old) => {
					const existingSorting = old == null ? void 0 : old.find((d) => d.id === column$1.id);
					const existingIndex = old == null ? void 0 : old.findIndex((d) => d.id === column$1.id);
					let newSorting = [];
					let sortAction;
					let nextDesc = hasManualValue ? desc : nextSortingOrder === "desc";
					if (old != null && old.length && column$1.getCanMultiSort() && multi) if (existingSorting) sortAction = "toggle";
					else sortAction = "add";
					else if (old != null && old.length && existingIndex !== old.length - 1) sortAction = "replace";
					else if (existingSorting) sortAction = "toggle";
					else sortAction = "replace";
					if (sortAction === "toggle") {
						if (!hasManualValue) {
							if (!nextSortingOrder) sortAction = "remove";
						}
					}
					if (sortAction === "add") {
						var _table$options$maxMul;
						newSorting = [...old, {
							id: column$1.id,
							desc: nextDesc
						}];
						newSorting.splice(0, newSorting.length - ((_table$options$maxMul = table.options.maxMultiSortColCount) != null ? _table$options$maxMul : Number.MAX_SAFE_INTEGER));
					} else if (sortAction === "toggle") newSorting = old.map((d) => {
						if (d.id === column$1.id) return {
							...d,
							desc: nextDesc
						};
						return d;
					});
					else if (sortAction === "remove") newSorting = old.filter((d) => d.id !== column$1.id);
					else newSorting = [{
						id: column$1.id,
						desc: nextDesc
					}];
					return newSorting;
				});
			};
			column$1.getFirstSortDir = () => {
				var _ref, _column$columnDef$sor;
				return ((_ref = (_column$columnDef$sor = column$1.columnDef.sortDescFirst) != null ? _column$columnDef$sor : table.options.sortDescFirst) != null ? _ref : column$1.getAutoSortDir() === "desc") ? "desc" : "asc";
			};
			column$1.getNextSortingOrder = (multi) => {
				var _table$options$enable, _table$options$enable2;
				const firstSortDirection = column$1.getFirstSortDir();
				const isSorted = column$1.getIsSorted();
				if (!isSorted) return firstSortDirection;
				if (isSorted !== firstSortDirection && ((_table$options$enable = table.options.enableSortingRemoval) != null ? _table$options$enable : true) && (multi ? (_table$options$enable2 = table.options.enableMultiRemove) != null ? _table$options$enable2 : true : true)) return false;
				return isSorted === "desc" ? "asc" : "desc";
			};
			column$1.getCanSort = () => {
				var _column$columnDef$ena, _table$options$enable3;
				return ((_column$columnDef$ena = column$1.columnDef.enableSorting) != null ? _column$columnDef$ena : true) && ((_table$options$enable3 = table.options.enableSorting) != null ? _table$options$enable3 : true) && !!column$1.accessorFn;
			};
			column$1.getCanMultiSort = () => {
				var _ref2, _column$columnDef$ena2;
				return (_ref2 = (_column$columnDef$ena2 = column$1.columnDef.enableMultiSort) != null ? _column$columnDef$ena2 : table.options.enableMultiSort) != null ? _ref2 : !!column$1.accessorFn;
			};
			column$1.getIsSorted = () => {
				var _table$getState$sorti;
				const columnSort = (_table$getState$sorti = table.getState().sorting) == null ? void 0 : _table$getState$sorti.find((d) => d.id === column$1.id);
				return !columnSort ? false : columnSort.desc ? "desc" : "asc";
			};
			column$1.getSortIndex = () => {
				var _table$getState$sorti2, _table$getState$sorti3;
				return (_table$getState$sorti2 = (_table$getState$sorti3 = table.getState().sorting) == null ? void 0 : _table$getState$sorti3.findIndex((d) => d.id === column$1.id)) != null ? _table$getState$sorti2 : -1;
			};
			column$1.clearSorting = () => {
				table.setSorting((old) => old != null && old.length ? old.filter((d) => d.id !== column$1.id) : []);
			};
			column$1.getToggleSortingHandler = () => {
				const canSort = column$1.getCanSort();
				return (e) => {
					if (!canSort) return;
					e.persist == null || e.persist();
					column$1.toggleSorting == null || column$1.toggleSorting(void 0, column$1.getCanMultiSort() ? table.options.isMultiSortEvent == null ? void 0 : table.options.isMultiSortEvent(e) : false);
				};
			};
		},
		createTable: (table) => {
			table.setSorting = (updater) => table.options.onSortingChange == null ? void 0 : table.options.onSortingChange(updater);
			table.resetSorting = (defaultState) => {
				var _table$initialState$s, _table$initialState;
				table.setSorting(defaultState ? [] : (_table$initialState$s = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.sorting) != null ? _table$initialState$s : []);
			};
			table.getPreSortedRowModel = () => table.getGroupedRowModel();
			table.getSortedRowModel = () => {
				if (!table._getSortedRowModel && table.options.getSortedRowModel) table._getSortedRowModel = table.options.getSortedRowModel(table);
				if (table.options.manualSorting || !table._getSortedRowModel) return table.getPreSortedRowModel();
				return table._getSortedRowModel();
			};
		}
	},
	ColumnGrouping,
	RowExpanding,
	RowPagination,
	RowPinning,
	RowSelection,
	ColumnSizing
];
function createTable(options$1) {
	var _options$_features, _options$initialState;
	const _features = [...builtInFeatures, ...(_options$_features = options$1._features) != null ? _options$_features : []];
	let table = { _features };
	const defaultOptions$1 = table._features.reduce((obj, feature) => {
		return Object.assign(obj, feature.getDefaultOptions == null ? void 0 : feature.getDefaultOptions(table));
	}, {});
	const mergeOptions = (options$2) => {
		if (table.options.mergeOptions) return table.options.mergeOptions(defaultOptions$1, options$2);
		return {
			...defaultOptions$1,
			...options$2
		};
	};
	let initialState = { ...(_options$initialState = options$1.initialState) != null ? _options$initialState : {} };
	table._features.forEach((feature) => {
		var _feature$getInitialSt;
		initialState = (_feature$getInitialSt = feature.getInitialState == null ? void 0 : feature.getInitialState(initialState)) != null ? _feature$getInitialSt : initialState;
	});
	const queued = [];
	let queuedTimeout = false;
	const coreInstance = {
		_features,
		options: {
			...defaultOptions$1,
			...options$1
		},
		initialState,
		_queue: (cb) => {
			queued.push(cb);
			if (!queuedTimeout) {
				queuedTimeout = true;
				Promise.resolve().then(() => {
					while (queued.length) queued.shift()();
					queuedTimeout = false;
				}).catch((error$1) => setTimeout(() => {
					throw error$1;
				}));
			}
		},
		reset: () => {
			table.setState(table.initialState);
		},
		setOptions: (updater) => {
			table.options = mergeOptions(functionalUpdate(updater, table.options));
		},
		getState: () => {
			return table.options.state;
		},
		setState: (updater) => {
			table.options.onStateChange == null || table.options.onStateChange(updater);
		},
		_getRowId: (row, index, parent) => {
			var _table$options$getRow;
			return (_table$options$getRow = table.options.getRowId == null ? void 0 : table.options.getRowId(row, index, parent)) != null ? _table$options$getRow : `${parent ? [parent.id, index].join(".") : index}`;
		},
		getCoreRowModel: () => {
			if (!table._getCoreRowModel) table._getCoreRowModel = table.options.getCoreRowModel(table);
			return table._getCoreRowModel();
		},
		getRowModel: () => {
			return table.getPaginationRowModel();
		},
		getRow: (id$1, searchAll) => {
			let row = (searchAll ? table.getPrePaginationRowModel() : table.getRowModel()).rowsById[id$1];
			if (!row) {
				row = table.getCoreRowModel().rowsById[id$1];
				if (!row) throw new Error();
			}
			return row;
		},
		_getDefaultColumnDef: memo(() => [table.options.defaultColumn], (defaultColumn) => {
			var _defaultColumn;
			defaultColumn = (_defaultColumn = defaultColumn) != null ? _defaultColumn : {};
			return {
				header: (props) => {
					const resolvedColumnDef = props.header.column.columnDef;
					if (resolvedColumnDef.accessorKey) return resolvedColumnDef.accessorKey;
					if (resolvedColumnDef.accessorFn) return resolvedColumnDef.id;
					return null;
				},
				cell: (props) => {
					var _props$renderValue$to, _props$renderValue;
					return (_props$renderValue$to = (_props$renderValue = props.renderValue()) == null || _props$renderValue.toString == null ? void 0 : _props$renderValue.toString()) != null ? _props$renderValue$to : null;
				},
				...table._features.reduce((obj, feature) => {
					return Object.assign(obj, feature.getDefaultColumnDef == null ? void 0 : feature.getDefaultColumnDef());
				}, {}),
				...defaultColumn
			};
		}, getMemoOptions(options$1, "debugColumns", "_getDefaultColumnDef")),
		_getColumnDefs: () => table.options.columns,
		getAllColumns: memo(() => [table._getColumnDefs()], (columnDefs) => {
			const recurseColumns = function(columnDefs$1, parent, depth) {
				if (depth === void 0) depth = 0;
				return columnDefs$1.map((columnDef) => {
					const column$1 = createColumn(table, columnDef, depth, parent);
					const groupingColumnDef = columnDef;
					column$1.columns = groupingColumnDef.columns ? recurseColumns(groupingColumnDef.columns, column$1, depth + 1) : [];
					return column$1;
				});
			};
			return recurseColumns(columnDefs);
		}, getMemoOptions(options$1, "debugColumns", "getAllColumns")),
		getAllFlatColumns: memo(() => [table.getAllColumns()], (allColumns) => {
			return allColumns.flatMap((column$1) => {
				return column$1.getFlatColumns();
			});
		}, getMemoOptions(options$1, "debugColumns", "getAllFlatColumns")),
		_getAllFlatColumnsById: memo(() => [table.getAllFlatColumns()], (flatColumns) => {
			return flatColumns.reduce((acc, column$1) => {
				acc[column$1.id] = column$1;
				return acc;
			}, {});
		}, getMemoOptions(options$1, "debugColumns", "getAllFlatColumnsById")),
		getAllLeafColumns: memo(() => [table.getAllColumns(), table._getOrderColumnsFn()], (allColumns, orderColumns$1) => {
			return orderColumns$1(allColumns.flatMap((column$1) => column$1.getLeafColumns()));
		}, getMemoOptions(options$1, "debugColumns", "getAllLeafColumns")),
		getColumn: (columnId) => {
			return table._getAllFlatColumnsById()[columnId];
		}
	};
	Object.assign(table, coreInstance);
	for (let index = 0; index < table._features.length; index++) {
		const feature = table._features[index];
		feature == null || feature.createTable == null || feature.createTable(table);
	}
	return table;
}
function getCoreRowModel() {
	return (table) => memo(() => [table.options.data], (data) => {
		const rowModel = {
			rows: [],
			flatRows: [],
			rowsById: {}
		};
		const accessRows = function(originalRows, depth, parentRow) {
			if (depth === void 0) depth = 0;
			const rows = [];
			for (let i$1 = 0; i$1 < originalRows.length; i$1++) {
				const row = createRow(table, table._getRowId(originalRows[i$1], i$1, parentRow), originalRows[i$1], i$1, depth, void 0, parentRow == null ? void 0 : parentRow.id);
				rowModel.flatRows.push(row);
				rowModel.rowsById[row.id] = row;
				rows.push(row);
				if (table.options.getSubRows) {
					var _row$originalSubRows;
					row.originalSubRows = table.options.getSubRows(originalRows[i$1], i$1);
					if ((_row$originalSubRows = row.originalSubRows) != null && _row$originalSubRows.length) row.subRows = accessRows(row.originalSubRows, depth + 1, row);
				}
			}
			return rows;
		};
		rowModel.rows = accessRows(data);
		return rowModel;
	}, getMemoOptions(table.options, "debugTable", "getRowModel", () => table._autoResetPageIndex()));
}
function trueFn() {
	return true;
}
var $PROXY = Symbol("merge-proxy");
var propTraps = {
	get(_, property$1, receiver) {
		if (property$1 === $PROXY) return receiver;
		return _.get(property$1);
	},
	has(_, property$1) {
		return _.has(property$1);
	},
	set: trueFn,
	deleteProperty: trueFn,
	getOwnPropertyDescriptor(_, property$1) {
		return {
			configurable: true,
			enumerable: true,
			get() {
				return _.get(property$1);
			},
			set: trueFn,
			deleteProperty: trueFn
		};
	},
	ownKeys(_) {
		return _.keys();
	}
};
function resolveSource(s) {
	return "value" in s ? s.value : s;
}
function mergeProxy() {
	for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) sources[_key] = arguments[_key];
	return new Proxy({
		get(property$1) {
			for (let i$1 = sources.length - 1; i$1 >= 0; i$1--) {
				const v$1 = resolveSource(sources[i$1])[property$1];
				if (v$1 !== void 0) return v$1;
			}
		},
		has(property$1) {
			for (let i$1 = sources.length - 1; i$1 >= 0; i$1--) if (property$1 in resolveSource(sources[i$1])) return true;
			return false;
		},
		keys() {
			const keys$1 = [];
			for (let i$1 = 0; i$1 < sources.length; i$1++) keys$1.push(...Object.keys(resolveSource(sources[i$1])));
			return [...Array.from(new Set(keys$1))];
		}
	}, propTraps);
}
var FlexRender = defineComponent({
	props: ["render", "props"],
	setup: (props) => {
		return () => {
			if (typeof props.render === "function" || typeof props.render === "object") return h(props.render, props.props);
			return props.render;
		};
	}
});
function getOptionsWithReactiveData(options$1) {
	return mergeProxy(options$1, { data: unref(options$1.data) });
}
function useVueTable(initialOptions) {
	const IS_REACTIVE = isRef(initialOptions.data);
	const table = createTable(mergeProxy({
		state: {},
		onStateChange: () => {},
		renderFallbackValue: null,
		mergeOptions(defaultOptions$1, options$1) {
			return IS_REACTIVE ? {
				...defaultOptions$1,
				...options$1
			} : mergeProxy(defaultOptions$1, options$1);
		}
	}, IS_REACTIVE ? getOptionsWithReactiveData(initialOptions) : initialOptions));
	if (IS_REACTIVE) {
		const dataRef = shallowRef(initialOptions.data);
		watch(dataRef, () => {
			table.setState((prev) => ({
				...prev,
				data: dataRef.value
			}));
		}, { immediate: true });
	}
	const state = ref(table.initialState);
	watchEffect(() => {
		table.setOptions((prev) => {
			var _initialOptions$state;
			const stateProxy = new Proxy({}, { get: (_, prop$1) => state.value[prop$1] });
			return mergeProxy(prev, IS_REACTIVE ? getOptionsWithReactiveData(initialOptions) : initialOptions, {
				state: mergeProxy(stateProxy, (_initialOptions$state = initialOptions.state) != null ? _initialOptions$state : {}),
				onStateChange: (updater) => {
					if (updater instanceof Function) state.value = updater(state.value);
					else state.value = updater;
					initialOptions.onStateChange == null || initialOptions.onStateChange(updater);
				}
			});
		});
	});
	return table;
}
var import_get = /* @__PURE__ */ __toESM(require_get());
var _hoisted_1$5 = { class: "n8n-data-table-server-wrapper" };
var _hoisted_2$2 = { class: "table-scroll" };
var _hoisted_3$1 = ["onMousedown"];
var _hoisted_4$1 = [
	"onMousedown",
	"onTouchstart",
	"onDblclick"
];
var _hoisted_5 = { key: 0 };
var _hoisted_6 = ["colspan"];
var _hoisted_7 = { key: 0 };
var _hoisted_8 = ["colspan"];
var _hoisted_9 = ["onClick"];
var _hoisted_10 = {
	key: 0,
	class: "table-pagination",
	"data-test-id": "pagination"
};
var _hoisted_11 = { class: "table-pagination__sizes" };
var N8nDataTableServer_default = /* @__PURE__ */ __plugin_vue_export_helper_default(/* @__PURE__ */ defineComponent({
	__name: "N8nDataTableServer",
	props: /* @__PURE__ */ mergeModels({
		items: {},
		headers: {},
		itemsLength: {},
		loading: { type: Boolean },
		multiSort: { type: Boolean },
		showSelect: { type: Boolean },
		itemValue: {
			type: [Function, String],
			default: "id"
		},
		returnObject: { type: Boolean },
		itemSelectable: {
			type: [Boolean, Function],
			default: void 0
		},
		pageSizes: { default: () => [
			10,
			25,
			50,
			100
		] },
		rowProps: {
			type: [Object, Function],
			default: void 0
		}
	}, {
		"page": { default: 0 },
		"pageModifiers": {},
		"items-per-page": { default: 10 },
		"items-per-pageModifiers": {},
		"sort-by": {
			default: [],
			required: false
		},
		"sort-byModifiers": {},
		"selection": {},
		"selectionModifiers": {}
	}),
	emits: /* @__PURE__ */ mergeModels(["update:options", "click:row"], [
		"update:page",
		"update:items-per-page",
		"update:sort-by",
		"update:selection"
	]),
	setup(__props, { emit: __emit }) {
		const props = __props;
		const slots = useSlots();
		const emit = __emit;
		const data = shallowRef(props.items.concat());
		watch(() => props.items, () => {
			data.value = props.items.concat();
		}, { deep: true });
		function itemKeySlot(info$3) {
			const slotName = `item.${info$3.column.id}`;
			return slots[slotName] ? slots[slotName]({
				item: info$3.row.original,
				value: info$3.getValue()
			}) : info$3.getValue();
		}
		function isValueAccessor(column$1) {
			return !!column$1.value;
		}
		function getHeaderTitle(column$1) {
			const value = typeof column$1.value === "function" ? "" : column$1.value;
			return column$1.title ?? column$1.key ?? value;
		}
		function isAccessorColumn(column$1) {
			return typeof column$1.value === "function";
		}
		const getColumnMeta = (column$1) => {
			return column$1.columnDef.meta ?? { cellProps: { align: "start" } };
		};
		function getRowProps(row, index) {
			if (typeof props.rowProps === "function") return props.rowProps(row, index);
			return props.rowProps;
		}
		const MIN_COLUMN_WIDTH = 75;
		function getValueAccessor(column$1) {
			if (isAccessorColumn(column$1)) return columnHelper.accessor(column$1.value, {
				id: column$1.key,
				cell: itemKeySlot,
				header: () => getHeaderTitle(column$1),
				enableSorting: !column$1.disableSort,
				enableResizing: column$1.resize ?? true,
				minSize: column$1.minWidth ?? MIN_COLUMN_WIDTH,
				size: column$1.width,
				meta: { cellProps: { align: column$1.align ?? "start" } }
			});
			else return columnHelper.accessor(column$1.value, {
				id: column$1.key ?? column$1.value,
				cell: itemKeySlot,
				header: () => getHeaderTitle(column$1),
				enableSorting: !column$1.disableSort,
				enableResizing: column$1.resize ?? true,
				minSize: column$1.minWidth ?? MIN_COLUMN_WIDTH,
				size: column$1.width,
				meta: { cellProps: { align: column$1.align ?? "start" } }
			});
		}
		function mapHeaders(columns) {
			return columns.map((column$1, index) => {
				if (isValueAccessor(column$1)) return getValueAccessor(column$1);
				if (column$1.key) {
					const accessor = column$1.key;
					return columnHelper.accessor(column$1.key, {
						id: accessor,
						cell: itemKeySlot,
						header: () => getHeaderTitle(column$1),
						enableSorting: !column$1.disableSort,
						enableResizing: column$1.resize ?? true,
						minSize: column$1.minWidth ?? MIN_COLUMN_WIDTH,
						size: column$1.width,
						meta: { cellProps: { align: column$1.align ?? "start" } }
					});
				}
				return columnHelper.display({
					id: `display_column_${index}`,
					header: () => getHeaderTitle(column$1),
					size: column$1.width,
					meta: { cellProps: { align: column$1.align ?? "start" } }
				});
			});
		}
		const columnsDefinition = computed(() => {
			return [...props.showSelect ? [selectColumn] : [], ...mapHeaders(props.headers)];
		});
		const page = useModel(__props, "page");
		watch(page, () => table.setPageIndex(page.value));
		const itemsPerPage = useModel(__props, "items-per-page");
		watch(itemsPerPage, () => table.setPageSize(itemsPerPage.value));
		const pagination = computed({
			get() {
				return {
					pageIndex: page.value,
					pageSize: itemsPerPage.value
				};
			},
			set(newValue) {
				page.value = newValue.pageIndex;
				itemsPerPage.value = newValue.pageSize;
			}
		});
		const showPagination = computed(() => props.itemsLength > Math.min(...props.pageSizes));
		const sortBy = useModel(__props, "sort-by");
		function handleSortingChange(updaterOrValue) {
			const newValue = typeof updaterOrValue === "function" ? updaterOrValue(sortBy.value) : updaterOrValue;
			sortBy.value = newValue;
			emit("update:options", {
				page: page.value,
				itemsPerPage: itemsPerPage.value,
				sortBy: newValue
			});
		}
		const selectColumn = {
			id: "data-table-select",
			enableResizing: false,
			size: 38,
			enablePinning: true,
			header: ({ table: table$1 }) => {
				const checkboxRef = ref();
				return h(ElCheckbox, {
					ref: checkboxRef,
					modelValue: table$1.getIsAllRowsSelected(),
					indeterminate: table$1.getIsSomeRowsSelected(),
					onChange: () => {
						const input$4 = checkboxRef.value?.$el.getElementsByTagName("input")[0];
						if (!input$4) return;
						table$1.getToggleAllRowsSelectedHandler()?.({ target: input$4 });
					}
				});
			},
			cell: ({ row }) => {
				const checkboxRef = ref();
				return h(ElCheckbox, {
					ref: checkboxRef,
					modelValue: row.getIsSelected(),
					disabled: !row.getCanSelect(),
					onChange: () => {
						const input$4 = checkboxRef.value?.$el.getElementsByTagName("input")[0];
						if (!input$4) return;
						row.getToggleSelectedHandler()?.({ target: input$4 });
					}
				});
			},
			meta: { cellProps: { align: "start" } }
		};
		function getRowId(originalRow, index, parent) {
			if (typeof props.itemValue === "function") return props.itemValue(originalRow, index, parent);
			return String((0, import_get.default)(originalRow, props.itemValue));
		}
		function handleRowSelectionChange(updaterOrValue) {
			if (typeof updaterOrValue === "function") rowSelection.value = updaterOrValue(rowSelection.value);
			else rowSelection.value = updaterOrValue;
			if (props.returnObject) selection.value = Object.keys(rowSelection.value).map((id$1) => table.getRow(id$1).original);
			else selection.value = Object.keys(rowSelection.value);
		}
		const selection = useModel(__props, "selection");
		const rowSelection = ref((selection.value ?? []).reduce((acc, item$4, index) => {
			const key$2 = typeof item$4 === "string" ? item$4 : getRowId(item$4, index);
			acc[key$2] = true;
			return acc;
		}, {}));
		const emitUpdateOptions = useThrottleFn((payload) => emit("update:options", payload), 100);
		function handlePageSizeChange(newPageSize) {
			const maxPage = Math.max(0, Math.ceil(props.itemsLength / newPageSize) - 1);
			page.value = Math.min(page.value, maxPage);
			itemsPerPage.value = newPageSize;
		}
		const columnHelper = createColumnHelper();
		const table = useVueTable({
			data,
			columns: columnsDefinition.value,
			get rowCount() {
				return props.itemsLength;
			},
			state: {
				get sorting() {
					return sortBy.value;
				},
				get pagination() {
					return pagination.value;
				},
				get rowSelection() {
					return rowSelection.value;
				}
			},
			getCoreRowModel: getCoreRowModel(),
			onSortingChange: handleSortingChange,
			onPaginationChange(updaterOrValue) {
				const newValue = typeof updaterOrValue === "function" ? updaterOrValue(pagination.value) : updaterOrValue;
				emitUpdateOptions({
					page: newValue.pageIndex,
					itemsPerPage: newValue.pageSize,
					sortBy: sortBy.value
				});
			},
			manualSorting: true,
			enableMultiSort: props.multiSort,
			manualPagination: true,
			columnResizeMode: "onChange",
			columnResizeDirection: "ltr",
			getRowId,
			enableRowSelection: (row) => {
				if (typeof props.itemSelectable === "undefined") return true;
				if (typeof props.itemSelectable === "boolean") return props.itemSelectable;
				if (typeof props.itemSelectable === "function") return props.itemSelectable(row.original);
				return Boolean((0, import_get.default)(row.original, props.itemSelectable));
			},
			onRowSelectionChange: handleRowSelectionChange
		});
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", null, [createBaseVNode("div", _hoisted_1$5, [createBaseVNode("div", _hoisted_2$2, [createBaseVNode("table", {
				class: normalizeClass(["n8n-data-table-server", { "table--loading": _ctx.loading }]),
				style: normalizeStyle({
					width: `${unref(table).getCenterTotalSize()}px`,
					borderSpacing: 0,
					minWidth: "100%",
					tableLayout: "fixed"
				})
			}, [createBaseVNode("thead", {
				style: {
					position: "sticky",
					top: 0,
					zIndex: 2
				},
				class: normalizeClass({ loading: _ctx.loading })
			}, [(openBlock(true), createElementBlock(Fragment, null, renderList(unref(table).getHeaderGroups(), (headerGroup) => {
				return openBlock(), createElementBlock("tr", { key: headerGroup.id }, [(openBlock(true), createElementBlock(Fragment, null, renderList(headerGroup.headers, (header$5) => {
					return openBlock(), createElementBlock("th", {
						key: header$5.id,
						style: normalizeStyle({
							cursor: header$5.column.getCanSort() ? "pointer" : void 0,
							width: `${header$5.getSize()}px`
						}),
						class: normalizeClass({ [`cell-align--${getColumnMeta(header$5.column).cellProps.align}`]: true }),
						onMousedown: ($event) => header$5.column.getToggleSortingHandler()?.($event)
					}, [
						!header$5.isPlaceholder ? (openBlock(), createBlock(unref(FlexRender), {
							key: 0,
							render: header$5.column.columnDef.header,
							props: header$5.getContext()
						}, null, 8, ["render", "props"])) : createCommentVNode("", true),
						header$5.column.getCanSort() ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [createTextVNode(toDisplayString({
							asc: "",
							desc: ""
						}[header$5.column.getIsSorted()]), 1)], 64)) : createCommentVNode("", true),
						header$5.column.getCanResize() ? (openBlock(), createElementBlock("div", {
							key: 2,
							class: normalizeClass({
								resizer: true,
								["is-resizing"]: header$5.column.getIsResizing()
							}),
							onMousedown: withModifiers(($event) => header$5.getResizeHandler()?.($event), ["stop"]),
							onTouchstart: ($event) => header$5.getResizeHandler()?.($event),
							onDblclick: ($event) => header$5.column.resetSize()
						}, null, 42, _hoisted_4$1)) : createCommentVNode("", true)
					], 46, _hoisted_3$1);
				}), 128))]);
			}), 128)), _ctx.loading ? (openBlock(), createElementBlock("tr", _hoisted_5, [createBaseVNode("th", {
				colspan: unref(table).getVisibleFlatColumns().length,
				class: "loading-row"
			}, _cache[2] || (_cache[2] = [createBaseVNode("div", { class: "progress-bar" }, [createBaseVNode("div", { class: "progress-bar-value" })], -1)]), 8, _hoisted_6)])) : createCommentVNode("", true)], 2), createBaseVNode("tbody", null, [unref(slots).cover ? (openBlock(), createElementBlock("tr", _hoisted_7, [createBaseVNode("td", {
				class: "cover",
				colspan: unref(table).getVisibleFlatColumns().length
			}, [renderSlot(_ctx.$slots, "cover", {}, void 0, true)], 8, _hoisted_8)])) : createCommentVNode("", true), _ctx.loading && !unref(table).getRowModel().rows.length ? (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(itemsPerPage.value, (item$4) => {
				return openBlock(), createElementBlock("tr", { key: item$4 }, [(openBlock(true), createElementBlock(Fragment, null, renderList(unref(table).getVisibleFlatColumns(), (coll) => {
					return openBlock(), createElementBlock("td", {
						key: coll.id,
						class: "el-skeleton is-animated"
					}, [createVNode(unref(ElSkeletonItem))]);
				}), 128))]);
			}), 128)) : unref(table).getRowModel().rows.length ? (openBlock(true), createElementBlock(Fragment, { key: 2 }, renderList(unref(table).getRowModel().rows, (row) => {
				return renderSlot(_ctx.$slots, "item", mergeProps({
					key: row.id,
					ref_for: true
				}, {
					item: row.original,
					cells: row.getVisibleCells()
				}), () => [createBaseVNode("tr", mergeProps({ ref_for: true }, getRowProps(row.original, row.index), { onClick: ($event) => emit("click:row", $event, { item: row.original }) }), [(openBlock(true), createElementBlock(Fragment, null, renderList(row.getVisibleCells(), (cell) => {
					return openBlock(), createElementBlock("td", {
						key: cell.id,
						class: normalizeClass({ [`cell-align--${getColumnMeta(cell.column).cellProps.align}`]: Boolean(getColumnMeta(cell.column).cellProps.align) })
					}, [createVNode(unref(FlexRender), {
						render: cell.column.columnDef.cell,
						props: cell.getContext()
					}, null, 8, ["render", "props"])], 2);
				}), 128))], 16, _hoisted_9)], true);
			}), 128)) : createCommentVNode("", true)])], 6)])]), showPagination.value ? (openBlock(), createElementBlock("div", _hoisted_10, [createVNode(unref(N8nPagination_default), {
				"current-page": page.value + 1,
				"page-size": itemsPerPage.value,
				"page-sizes": _ctx.pageSizes,
				layout: "prev, pager, next",
				total: _ctx.itemsLength,
				"onUpdate:currentPage": _cache[0] || (_cache[0] = ($event) => page.value = $event - 1)
			}, null, 8, [
				"current-page",
				"page-size",
				"page-sizes",
				"total"
			]), createBaseVNode("div", _hoisted_11, [_cache[3] || (_cache[3] = createBaseVNode("div", { class: "table-pagination__sizes__label" }, "Page size", -1)), createVNode(unref(ElSelect), {
				modelValue: itemsPerPage.value,
				"onUpdate:modelValue": [_cache[1] || (_cache[1] = ($event) => itemsPerPage.value = $event), handlePageSizeChange],
				modelModifiers: { number: true },
				class: "table-pagination__sizes__select",
				size: "small",
				teleported: false
			}, {
				default: withCtx(() => [(openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.pageSizes, (item$4) => {
					return openBlock(), createBlock(unref(ElOption), {
						key: item$4,
						label: item$4,
						value: item$4
					}, null, 8, ["label", "value"]);
				}), 128))]),
				_: 1
			}, 8, ["modelValue"])])])) : createCommentVNode("", true)]);
		};
	}
}), [["__scopeId", "data-v-17c481e9"]]);
var _hoisted_1$4 = {
	key: 0,
	style: {
		display: "flex",
		flexDirection: "column",
		gap: 2
	},
	"data-testid": "visible-columns-section"
};
var _hoisted_2$1 = [
	"data-column-key",
	"onDragstart",
	"onDragover",
	"onDrop"
];
var _hoisted_3 = {
	key: 1,
	style: {
		display: "flex",
		flexDirection: "column",
		gap: 2
	},
	"data-testid": "hidden-columns-section"
};
var _hoisted_4 = ["data-column-key"];
var TableHeaderControlsButton_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "TableHeaderControlsButton",
	props: {
		columns: {},
		buttonSize: {},
		iconSize: {}
	},
	emits: ["update:columnVisibility", "update:columnOrder"],
	setup(__props, { emit: __emit }) {
		const props = __props;
		const visibleColumns = computed(() => props.columns.filter((column$1) => !column$1.disabled && column$1.visible));
		const hiddenColumns = computed(() => props.columns.filter((column$1) => !column$1.disabled && !column$1.visible));
		const { t: t$1 } = useI18n();
		const draggedItem = ref(null);
		const dragOverItem = ref(null);
		const emit = __emit;
		const resetDragState = () => {
			draggedItem.value = null;
			dragOverItem.value = null;
		};
		const handleDragStart = (event, columnKey) => {
			if (!event.dataTransfer) return;
			draggedItem.value = columnKey;
			event.dataTransfer.effectAllowed = "move";
			event.dataTransfer.setData("text/plain", columnKey);
		};
		const handleDragOver = (event, columnKey) => {
			event.preventDefault();
			if (!event.dataTransfer) return;
			event.dataTransfer.dropEffect = "move";
			dragOverItem.value = columnKey;
		};
		const handleDragLeave = () => {
			dragOverItem.value = null;
		};
		const handleDrop = (event, targetColumnKey) => {
			event.preventDefault();
			const draggedColumnKey = draggedItem.value;
			if (!draggedColumnKey || draggedColumnKey === targetColumnKey) {
				resetDragState();
				return;
			}
			const allColumnKeys = props.columns.map((col) => col.key);
			const draggedIndex = allColumnKeys.indexOf(draggedColumnKey);
			if (draggedIndex === -1) {
				resetDragState();
				return;
			}
			let newOrder;
			if (targetColumnKey === "END") {
				newOrder = [...allColumnKeys];
				newOrder.splice(draggedIndex, 1);
				newOrder.push(draggedColumnKey);
			} else {
				const targetIndex = allColumnKeys.indexOf(targetColumnKey);
				if (targetIndex === -1) {
					resetDragState();
					return;
				}
				newOrder = [...allColumnKeys];
				newOrder.splice(draggedIndex, 1);
				let insertIndex = targetIndex;
				if (draggedIndex <= targetIndex) insertIndex = targetIndex - 1;
				newOrder.splice(insertIndex, 0, draggedColumnKey);
			}
			emit("update:columnOrder", newOrder);
			resetDragState();
		};
		const handleDragEnd = () => {
			resetDragState();
		};
		return (_ctx, _cache) => {
			return openBlock(), createBlock(N8nPopoverReka_default$1, {
				class: normalizeClass(_ctx.$style.container),
				width: "260px",
				"max-height": "300px",
				"scroll-type": "auto"
			}, {
				trigger: withCtx(() => [createVNode(unref(N8nButton_default), {
					icon: "sliders-horizontal",
					type: "secondary",
					"icon-size": _ctx.iconSize,
					size: _ctx.buttonSize
				}, {
					default: withCtx(() => [createTextVNode(toDisplayString(unref(t$1)("tableControlsButton.display")), 1)]),
					_: 1
				}, 8, ["icon-size", "size"])]),
				content: withCtx(() => [createBaseVNode("div", { class: normalizeClass(_ctx.$style.contentContainer) }, [visibleColumns.value.length ? (openBlock(), createElementBlock("div", _hoisted_1$4, [
					createBaseVNode("h5", { class: normalizeClass(_ctx.$style.header) }, toDisplayString(unref(t$1)("tableControlsButton.shown")), 3),
					(openBlock(true), createElementBlock(Fragment, null, renderList(visibleColumns.value, (column$1) => {
						return openBlock(), createElementBlock("div", {
							key: column$1.key,
							class: normalizeClass(_ctx.$style.columnWrapper)
						}, [dragOverItem.value === column$1.key ? (openBlock(), createElementBlock("div", {
							key: 0,
							class: normalizeClass(_ctx.$style.dropIndicator),
							"data-testid": "drop-indicator"
						}, null, 2)) : createCommentVNode("", true), createBaseVNode("fieldset", {
							class: normalizeClass([
								_ctx.$style.column,
								_ctx.$style.draggable,
								{ [_ctx.$style.dragging]: draggedItem.value === column$1.key }
							]),
							draggable: "true",
							"data-testid": "visible-column",
							"data-column-key": column$1.key,
							onDragstart: (event) => handleDragStart(event, column$1.key),
							onDragover: (event) => handleDragOver(event, column$1.key),
							onDragleave: handleDragLeave,
							onDrop: (event) => handleDrop(event, column$1.key),
							onDragend: handleDragEnd
						}, [
							createVNode(unref(N8nIcon_default), {
								icon: "grip-vertical",
								class: normalizeClass(_ctx.$style.grip)
							}, null, 8, ["class"]),
							createBaseVNode("label", null, toDisplayString(column$1.label), 1),
							createVNode(unref(N8nIcon_default), {
								class: normalizeClass(_ctx.$style.visibilityToggle),
								icon: "eye",
								"data-testid": "visibility-toggle-visible",
								onClick: () => emit("update:columnVisibility", column$1.key, false)
							}, null, 8, ["class", "onClick"])
						], 42, _hoisted_2$1)], 2);
					}), 128)),
					createBaseVNode("div", {
						class: normalizeClass(_ctx.$style.endDropZone),
						"data-testid": "end-drop-zone",
						onDragover: _cache[0] || (_cache[0] = (event) => handleDragOver(event, "END")),
						onDragleave: handleDragLeave,
						onDrop: _cache[1] || (_cache[1] = (event) => handleDrop(event, "END"))
					}, [dragOverItem.value === "END" ? (openBlock(), createElementBlock("div", {
						key: 0,
						class: normalizeClass(_ctx.$style.dropIndicator),
						"data-testid": "drop-indicator"
					}, null, 2)) : createCommentVNode("", true)], 34)
				])) : createCommentVNode("", true), hiddenColumns.value.length ? (openBlock(), createElementBlock("div", _hoisted_3, [createBaseVNode("h4", { class: normalizeClass(_ctx.$style.header) }, toDisplayString(unref(t$1)("tableControlsButton.hidden")), 3), (openBlock(true), createElementBlock(Fragment, null, renderList(hiddenColumns.value, (column$1) => {
					return openBlock(), createElementBlock("fieldset", {
						key: column$1.key,
						class: normalizeClass([_ctx.$style.column, _ctx.$style.hidden]),
						"data-testid": "hidden-column",
						"data-column-key": column$1.key
					}, [
						createVNode(unref(N8nIcon_default), {
							icon: "grip-vertical",
							class: normalizeClass([_ctx.$style.grip, _ctx.$style.hidden])
						}, null, 8, ["class"]),
						createBaseVNode("label", null, toDisplayString(column$1.label), 1),
						createVNode(unref(N8nIcon_default), {
							class: normalizeClass(_ctx.$style.visibilityToggle),
							icon: "eye-off",
							"data-testid": "visibility-toggle-hidden",
							onClick: () => emit("update:columnVisibility", column$1.key, true)
						}, null, 8, ["class", "onClick"])
					], 10, _hoisted_4);
				}), 128))])) : createCommentVNode("", true)], 2)]),
				_: 1
			}, 8, ["class"]);
		};
	}
});
var TableHeaderControlsButton_vue_vue_type_style_index_0_lang_module_default = {
	header: "_header_1qhw6_123",
	grip: "_grip_1qhw6_129",
	hidden: "_hidden_1qhw6_133",
	contentContainer: "_contentContainer_1qhw6_137",
	column: "_column_1qhw6_141",
	draggable: "_draggable_1qhw6_153",
	dragging: "_dragging_1qhw6_161",
	columnWrapper: "_columnWrapper_1qhw6_166",
	dropIndicator: "_dropIndicator_1qhw6_170",
	endDropZone: "_endDropZone_1qhw6_181",
	visibilityToggle: "_visibilityToggle_1qhw6_194"
};
var TableHeaderControlsButton_default = /* @__PURE__ */ __plugin_vue_export_helper_default(TableHeaderControlsButton_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": TableHeaderControlsButton_vue_vue_type_style_index_0_lang_module_default }]]);
var InlineTextEdit_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "InlineTextEdit",
	props: {
		modelValue: {},
		readOnly: {
			type: Boolean,
			default: false
		},
		maxLength: { default: 100 },
		maxWidth: { default: 200 },
		minWidth: { default: 64 },
		placeholder: { default: "Enter text..." },
		disabled: { type: Boolean }
	},
	emits: ["update:model-value"],
	setup(__props, { expose: __expose, emit: __emit }) {
		const props = __props;
		const emit = __emit;
		const editableRoot = useTemplateRef("editableRoot");
		const measureSpan$1 = useTemplateRef("measureSpan");
		const editingValue = ref(props.modelValue);
		const displayContent = computed(() => editingValue.value || props.placeholder);
		watchEffect(() => {
			editingValue.value = props.modelValue;
		});
		const { width: measuredWidth } = useElementSize(measureSpan$1);
		const inputWidth = computed(() => Math.max(props.minWidth, Math.min(measuredWidth.value + 1, props.maxWidth)));
		const computedInlineStyles = computed(() => ({
			width: `${inputWidth.value}px`,
			maxWidth: `${props.maxWidth}px`,
			zIndex: 1
		}));
		function forceFocus() {
			if (editableRoot.value && !props.readOnly && !props.disabled) editableRoot.value.edit();
		}
		function forceCancel() {
			if (editableRoot.value) {
				editingValue.value = props.modelValue;
				editableRoot.value.cancel();
			}
		}
		function onSubmit() {
			const trimmed = editingValue.value.trim();
			if (!trimmed) {
				editingValue.value = props.modelValue;
				return;
			}
			if (trimmed !== props.modelValue) emit("update:model-value", trimmed);
		}
		function onInput(value) {
			editingValue.value = value;
		}
		function onStateChange(state) {
			if (state === "cancel") editingValue.value = props.modelValue;
		}
		__expose({
			forceFocus,
			forceCancel
		});
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(EditableRoot_default), {
				ref_key: "editableRoot",
				ref: editableRoot,
				placeholder: _ctx.placeholder,
				"model-value": editingValue.value,
				"submit-mode": "both",
				class: normalizeClass(_ctx.$style.inlineRenameRoot),
				title: props.modelValue,
				disabled: _ctx.disabled,
				"max-length": _ctx.maxLength,
				readonly: _ctx.readOnly,
				"select-on-focus": "",
				"auto-resize": "",
				onClick: forceFocus,
				onSubmit,
				"onUpdate:modelValue": onInput,
				"onUpdate:state": onStateChange
			}, {
				default: withCtx(() => [createVNode(unref(EditableArea_default), {
					style: normalizeStyle(computedInlineStyles.value),
					class: normalizeClass(_ctx.$style.inlineRenameArea),
					"data-test-id": "inline-editable-area"
				}, {
					default: withCtx(() => [
						createBaseVNode("span", {
							ref_key: "measureSpan",
							ref: measureSpan$1,
							class: normalizeClass(_ctx.$style.measureSpan)
						}, toDisplayString(displayContent.value), 3),
						createVNode(unref(EditablePreview_default), {
							"data-test-id": "inline-edit-preview",
							class: normalizeClass(_ctx.$style.inlineRenamePreview),
							style: normalizeStyle(computedInlineStyles.value)
						}, null, 8, ["class", "style"]),
						createVNode(unref(EditableInput_default), {
							ref: "input",
							class: normalizeClass(_ctx.$style.inlineRenameInput),
							"data-test-id": "inline-edit-input",
							style: normalizeStyle(computedInlineStyles.value),
							onInput: _cache[0] || (_cache[0] = ($event) => onInput($event.target.value))
						}, null, 8, ["class", "style"])
					]),
					_: 1
				}, 8, ["style", "class"])]),
				_: 1
			}, 8, [
				"placeholder",
				"model-value",
				"class",
				"title",
				"disabled",
				"max-length",
				"readonly"
			]);
		};
	}
});
var InlineTextEdit_vue_vue_type_style_index_0_lang_module_default = {
	inlineRenameArea: "_inlineRenameArea_1h0oi_123",
	inlineRenamePreview: "_inlineRenamePreview_1h0oi_159",
	measureSpan: "_measureSpan_1h0oi_168"
};
var N8nInlineTextEdit_default = /* @__PURE__ */ __plugin_vue_export_helper_default(InlineTextEdit_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": InlineTextEdit_vue_vue_type_style_index_0_lang_module_default }]]);
var N8nScrollArea_default = N8nScrollArea_default$1;
var _hoisted_1$3 = { key: 0 };
var DateRangePickerField_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "DateRangePickerField",
	setup(__props) {
		function hasTime$1(segments) {
			return [...segments.start, ...segments.end].some((segment) => [
				"hour",
				"minute",
				"second",
				"dayPeriod"
			].includes(segment.part));
		}
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(DateRangePickerField_default$1), { "as-child": "" }, {
				default: withCtx(({ segments }) => [hasTime$1(segments) ? (openBlock(), createElementBlock("div", _hoisted_1$3, [
					createVNode(unref(N8nText_default), {
						bold: "",
						color: "text-light",
						tag: "div",
						class: "mb-3xs"
					}, {
						default: withCtx(() => _cache[0] || (_cache[0] = [createTextVNode("Start")])),
						_: 1
					}),
					createBaseVNode("div", { class: normalizeClass([_ctx.$style.Inline, "mb-xs"]) }, [(openBlock(true), createElementBlock(Fragment, null, renderList(segments.start, (item$4) => {
						return openBlock(), createElementBlock(Fragment, { key: item$4.part }, [item$4.part === "literal" ? (openBlock(), createBlock(unref(DateRangePickerInput_default), {
							key: 0,
							part: item$4.part,
							class: "DateFieldLiteral",
							type: "start"
						}, {
							default: withCtx(() => [createTextVNode(toDisplayString(item$4.value), 1)]),
							_: 2
						}, 1032, ["part"])) : (openBlock(), createBlock(unref(DateRangePickerInput_default), {
							key: 1,
							part: item$4.part,
							class: normalizeClass(_ctx.$style.DateFieldSegment),
							type: "start"
						}, {
							default: withCtx(() => [createTextVNode(toDisplayString(item$4.value), 1)]),
							_: 2
						}, 1032, ["part", "class"]))], 64);
					}), 128))], 2),
					createVNode(unref(N8nText_default), {
						bold: "",
						color: "text-light",
						tag: "div",
						class: "mb-3xs"
					}, {
						default: withCtx(() => _cache[1] || (_cache[1] = [createTextVNode("End")])),
						_: 1
					}),
					createBaseVNode("div", { class: normalizeClass(_ctx.$style.Inline) }, [(openBlock(true), createElementBlock(Fragment, null, renderList(segments.end, (item$4) => {
						return openBlock(), createElementBlock(Fragment, { key: item$4.part }, [item$4.part === "literal" ? (openBlock(), createBlock(unref(DateRangePickerInput_default), {
							key: 0,
							part: item$4.part,
							class: normalizeClass(_ctx.$style.DateFieldLiteral),
							type: "end"
						}, {
							default: withCtx(() => [createTextVNode(toDisplayString(item$4.value), 1)]),
							_: 2
						}, 1032, ["part", "class"])) : (openBlock(), createBlock(unref(DateRangePickerInput_default), {
							key: 1,
							part: item$4.part,
							class: normalizeClass(_ctx.$style.DateFieldSegment),
							type: "end"
						}, {
							default: withCtx(() => [createTextVNode(toDisplayString(item$4.value), 1)]),
							_: 2
						}, 1032, ["part", "class"]))], 64);
					}), 128))], 2)
				])) : (openBlock(), createElementBlock("div", {
					key: 1,
					class: normalizeClass(_ctx.$style.Inline)
				}, [
					(openBlock(true), createElementBlock(Fragment, null, renderList(segments.start, (item$4) => {
						return openBlock(), createElementBlock(Fragment, { key: item$4.part }, [item$4.part === "literal" ? (openBlock(), createBlock(unref(DateRangePickerInput_default), {
							key: 0,
							part: item$4.part,
							class: "DateFieldLiteral",
							type: "start"
						}, {
							default: withCtx(() => [createTextVNode(toDisplayString(item$4.value), 1)]),
							_: 2
						}, 1032, ["part"])) : (openBlock(), createBlock(unref(DateRangePickerInput_default), {
							key: 1,
							part: item$4.part,
							class: normalizeClass(_ctx.$style.DateFieldSegment),
							type: "start"
						}, {
							default: withCtx(() => [createTextVNode(toDisplayString(item$4.value), 1)]),
							_: 2
						}, 1032, ["part", "class"]))], 64);
					}), 128)),
					_cache[2] || (_cache[2] = createTextVNode(" - ")),
					(openBlock(true), createElementBlock(Fragment, null, renderList(segments.end, (item$4) => {
						return openBlock(), createElementBlock(Fragment, { key: item$4.part }, [item$4.part === "literal" ? (openBlock(), createBlock(unref(DateRangePickerInput_default), {
							key: 0,
							part: item$4.part,
							class: normalizeClass(_ctx.$style.DateFieldLiteral),
							type: "end"
						}, {
							default: withCtx(() => [createTextVNode(toDisplayString(item$4.value), 1)]),
							_: 2
						}, 1032, ["part", "class"])) : (openBlock(), createBlock(unref(DateRangePickerInput_default), {
							key: 1,
							part: item$4.part,
							class: normalizeClass(_ctx.$style.DateFieldSegment),
							type: "end"
						}, {
							default: withCtx(() => [createTextVNode(toDisplayString(item$4.value), 1)]),
							_: 2
						}, 1032, ["part", "class"]))], 64);
					}), 128))
				], 2))]),
				_: 1
			});
		};
	}
});
var DateRangePickerField_vue_vue_type_style_index_0_lang_module_default = {
	DateFieldSegment: "_DateFieldSegment_1xoaw_2",
	Inline: "_Inline_1xoaw_7"
};
var DateRangePickerField_default = /* @__PURE__ */ __plugin_vue_export_helper_default(DateRangePickerField_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": DateRangePickerField_vue_vue_type_style_index_0_lang_module_default }]]);
var DateRangePicker_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "DateRangePicker",
	props: {
		defaultValue: {},
		defaultPlaceholder: {},
		placeholder: {},
		modelValue: {},
		hourCycle: { default: 24 },
		step: {},
		granularity: {},
		hideTimeZone: { type: Boolean },
		maxValue: {},
		minValue: {},
		locale: {},
		disabled: { type: Boolean },
		readonly: { type: Boolean },
		isDateUnavailable: {},
		id: {},
		dir: {},
		asChild: { type: Boolean },
		as: {},
		name: {},
		required: { type: Boolean },
		defaultOpen: { type: Boolean },
		open: { type: Boolean },
		modal: { type: Boolean },
		isDateDisabled: {},
		pagedNavigation: { type: Boolean },
		weekStartsOn: { default: 1 },
		weekdayFormat: { default: "short" },
		fixedWeeks: {
			type: Boolean,
			default: true
		},
		numberOfMonths: {},
		preventDeselect: { type: Boolean },
		isDateHighlightable: {},
		allowNonContiguousRanges: { type: Boolean },
		fixedDate: {},
		maximumDays: {},
		closeOnSelect: { type: Boolean },
		hideInputs: { type: Boolean }
	},
	emits: [
		"update:modelValue",
		"update:placeholder",
		"update:startValue",
		"update:open"
	],
	setup(__props, { emit: __emit }) {
		const props = __props;
		const emit = __emit;
		const forwarded = useForwardPropsEmits(props, emit);
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(DateRangePickerRoot_default), normalizeProps(guardReactiveProps(unref(forwarded))), {
				default: withCtx(() => [createVNode(unref(DateRangePickerTrigger_default), { "as-child": "" }, {
					default: withCtx(() => [renderSlot(_ctx.$slots, "trigger", {}, () => [createVNode(unref(N8nIconButton_default), {
						icon: "calendar",
						type: "secondary",
						"aria-label": "Open calendar"
					})])]),
					_: 3
				}), createVNode(unref(DateRangePickerContent_default), {
					align: "start",
					"side-offset": 5,
					class: normalizeClass(_ctx.$style.PopoverContent)
				}, {
					default: withCtx(() => [createVNode(unref(DateRangePickerCalendar_default), { class: normalizeClass(_ctx.$style.Calendar) }, {
						default: withCtx(({ weekDays, grid: grid$1 }) => [!!_ctx.$slots.presets ? (openBlock(), createElementBlock("div", {
							key: 0,
							class: normalizeClass(_ctx.$style.Presets)
						}, [renderSlot(_ctx.$slots, "presets")], 2)) : createCommentVNode("", true), createBaseVNode("div", null, [createBaseVNode("div", { class: normalizeClass(_ctx.$style.CalendarWrapper) }, [createVNode(unref(DateRangePickerHeader_default), { class: normalizeClass(_ctx.$style.CalendarHeader) }, {
							default: withCtx(() => [
								createVNode(unref(DateRangePickerPrev_default), { "as-child": "" }, {
									default: withCtx(() => [createVNode(unref(N8nIconButton_default), {
										icon: "chevron-left",
										type: "secondary"
									})]),
									_: 1
								}),
								createVNode(unref(DateRangePickerHeading_default), { class: normalizeClass(_ctx.$style.CalendarHeading) }, null, 8, ["class"]),
								createVNode(unref(DateRangePickerNext_default), { "as-child": "" }, {
									default: withCtx(() => [createVNode(unref(N8nIconButton_default), {
										icon: "chevron-right",
										type: "secondary"
									})]),
									_: 1
								})
							]),
							_: 1
						}, 8, ["class"]), (openBlock(true), createElementBlock(Fragment, null, renderList(grid$1, (month) => {
							return openBlock(), createBlock(unref(DateRangePickerGrid_default), {
								key: month.value.toString(),
								class: normalizeClass(_ctx.$style.CalendarGrid)
							}, {
								default: withCtx(() => [createVNode(unref(DateRangePickerGridHead_default), null, {
									default: withCtx(() => [createVNode(unref(DateRangePickerGridRow_default), { class: normalizeClass(_ctx.$style.CalendarGridRow) }, {
										default: withCtx(() => [(openBlock(true), createElementBlock(Fragment, null, renderList(weekDays, (day) => {
											return openBlock(), createBlock(unref(DateRangePickerHeadCell_default), {
												key: day,
												class: normalizeClass(_ctx.$style.CalendarHeadCell)
											}, {
												default: withCtx(() => [createTextVNode(toDisplayString(day), 1)]),
												_: 2
											}, 1032, ["class"]);
										}), 128))]),
										_: 2
									}, 1032, ["class"])]),
									_: 2
								}, 1024), createVNode(unref(DateRangePickerGridBody_default), null, {
									default: withCtx(() => [(openBlock(true), createElementBlock(Fragment, null, renderList(month.rows, (weekDates, index) => {
										return openBlock(), createBlock(unref(DateRangePickerGridRow_default), {
											key: `weekDate-${index}`,
											class: normalizeClass(_ctx.$style.CalendarGridRow)
										}, {
											default: withCtx(() => [(openBlock(true), createElementBlock(Fragment, null, renderList(weekDates, (weekDate) => {
												return openBlock(), createBlock(unref(DateRangePickerCell_default), {
													key: weekDate.toString(),
													date: weekDate,
													class: normalizeClass(_ctx.$style.CalendarCell)
												}, {
													default: withCtx(() => [createVNode(unref(DateRangePickerCellTrigger_default), {
														day: weekDate,
														month: month.value,
														class: normalizeClass(_ctx.$style.CalendarCellTrigger)
													}, null, 8, [
														"day",
														"month",
														"class"
													])]),
													_: 2
												}, 1032, ["date", "class"]);
											}), 128))]),
											_: 2
										}, 1032, ["class"]);
									}), 128))]),
									_: 2
								}, 1024)]),
								_: 2
							}, 1032, ["class"]);
						}), 128))], 2), !_ctx.hideInputs ? (openBlock(), createElementBlock("div", {
							key: 0,
							class: normalizeClass(_ctx.$style.DateFieldWrapper)
						}, [
							createVNode(DateRangePickerField_default, { class: normalizeClass(_ctx.$style.DateField) }, null, 8, ["class"]),
							createBaseVNode("div", { class: normalizeClass(_ctx.$style.DateFieldError) }, "Outside of allowed range", 2),
							createVNode(Button_default, {
								type: "secondary",
								block: "",
								class: "mt-2xs",
								onClick: _cache[0] || (_cache[0] = ($event) => emit("update:open", false))
							}, {
								default: withCtx(() => _cache[1] || (_cache[1] = [createTextVNode(" Apply ")])),
								_: 1
							})
						], 2)) : createCommentVNode("", true)])]),
						_: 3
					}, 8, ["class"])]),
					_: 3
				}, 8, ["class"])]),
				_: 3
			}, 16);
		};
	}
});
var DateRangePicker_vue_vue_type_style_index_0_lang_module_default = {
	DateFieldWrapper: "_DateFieldWrapper_1ptt0_2",
	DateField: "_DateField_1ptt0_2",
	DateFieldError: "_DateFieldError_1ptt0_7",
	DateFieldSegment: "_DateFieldSegment_1ptt0_19",
	Calendar: "_Calendar_1ptt0_24",
	CalendarHeader: "_CalendarHeader_1ptt0_28",
	CalendarWrapper: "_CalendarWrapper_1ptt0_34",
	CalendarGrid: "_CalendarGrid_1ptt0_38",
	CalendarGridRow: "_CalendarGridRow_1ptt0_45",
	CalendarHeadCell: "_CalendarHeadCell_1ptt0_52",
	CalendarCell: "_CalendarCell_1ptt0_59",
	CalendarCellTrigger: "_CalendarCellTrigger_1ptt0_66",
	PopoverContent: "_PopoverContent_1ptt0_149",
	slideDownAndFade: "_slideDownAndFade_1ptt0_1",
	slideLeftAndFade: "_slideLeftAndFade_1ptt0_1",
	slideUpAndFade: "_slideUpAndFade_1ptt0_1",
	slideRightAndFade: "_slideRightAndFade_1ptt0_1",
	Presets: "_Presets_1ptt0_175"
};
var DateRangePicker_default = /* @__PURE__ */ __plugin_vue_export_helper_default(DateRangePicker_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": DateRangePicker_vue_vue_type_style_index_0_lang_module_default }]]);
var _hoisted_1$2 = ["data-item-id"];
var CommandBarItem_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "CommandBarItem",
	props: {
		item: {},
		isSelected: { type: Boolean }
	},
	emits: ["select"],
	setup(__props, { emit: __emit }) {
		const props = __props;
		const emit = __emit;
		const isHovered = ref(false);
		const handleSelect = () => {
			emit("select", props.item);
		};
		const handleMouseEnter = () => {
			isHovered.value = true;
		};
		const handleMouseLeave = () => {
			isHovered.value = false;
		};
		return (_ctx, _cache) => {
			const _directive_n8n_html = resolveDirective("n8n-html");
			return openBlock(), createElementBlock("div", {
				key: _ctx.item.id,
				"data-item-id": _ctx.item.id,
				class: normalizeClass([_ctx.$style.item, { [_ctx.$style.selected]: _ctx.isSelected }]),
				onClick: withModifiers(handleSelect, ["stop"]),
				onMouseenter: handleMouseEnter,
				onMouseleave: handleMouseLeave
			}, [_ctx.item.icon ? (openBlock(), createElementBlock("div", {
				key: 0,
				class: normalizeClass(_ctx.$style.icon)
			}, [_ctx.item.icon && "html" in _ctx.item.icon ? withDirectives((openBlock(), createElementBlock("span", {
				key: 0,
				class: normalizeClass(_ctx.$style.iconHtml)
			}, null, 2)), [[_directive_n8n_html, _ctx.item.icon.html]]) : _ctx.item.icon && "component" in _ctx.item.icon ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.item.icon.component), normalizeProps(mergeProps({ key: 1 }, _ctx.item.icon.props)), null, 16)) : createCommentVNode("", true)], 2)) : createCommentVNode("", true), createBaseVNode("div", { class: normalizeClass(_ctx.$style.content) }, [createBaseVNode("div", { class: normalizeClass(_ctx.$style.title) }, [typeof _ctx.item.title === "string" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [createTextVNode(toDisplayString(_ctx.item.title), 1)], 64)) : (openBlock(), createBlock(resolveDynamicComponent(_ctx.item.title.component), normalizeProps(mergeProps({ key: 1 }, {
				..._ctx.item.title.props,
				isSelected: _ctx.isSelected,
				isHovered: isHovered.value
			})), null, 16))], 2)], 2)], 42, _hoisted_1$2);
		};
	}
});
var CommandBarItem_vue_vue_type_style_index_0_lang_module_default = {
	item: "_item_o9brn_123",
	selected: "_selected_o9brn_136",
	icon: "_icon_o9brn_140",
	iconHtml: "_iconHtml_o9brn_149",
	content: "_content_o9brn_157",
	title: "_title_o9brn_162",
	meta: "_meta_o9brn_172"
};
var CommandBarItem_default = /* @__PURE__ */ __plugin_vue_export_helper_default(CommandBarItem_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": CommandBarItem_vue_vue_type_style_index_0_lang_module_default }]]);
var _hoisted_1$1 = ["placeholder"];
var NUM_LOADING_ITEMS = 8;
var CommandBar_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	name: "N8nCommandBar",
	__name: "CommandBar",
	props: {
		placeholder: { default: "Type a command..." },
		context: { default: "" },
		items: {},
		isLoading: {
			type: Boolean,
			default: false
		},
		zIndex: { default: 1900 }
	},
	emits: ["inputChange", "navigateTo"],
	setup(__props, { emit: __emit }) {
		const props = __props;
		const emit = __emit;
		const isOpen = ref(false);
		const inputRef = ref();
		const selectedIndex = ref(-1);
		const inputValue = ref("");
		const currentParentId = ref(null);
		const currentParent = computed(() => {
			return props.items.find((item$4) => item$4.id === currentParentId.value);
		});
		const currentItems = computed(() => {
			return currentParent.value ? currentParent.value.children ?? [] : props.items;
		});
		const currentPlaceholder = computed(() => {
			return currentParent.value?.placeholder ?? props.placeholder;
		});
		const commandBarRef = ref();
		const itemsListRef = ref();
		const scrollAreaRef = ref();
		const filteredItems = computed(() => {
			let items = currentItems.value;
			if (inputValue.value) {
				const query = inputValue.value.toLowerCase();
				items = items.filter((item$4) => {
					const searchText = [typeof item$4.title === "string" ? item$4.title : "", ...item$4.keywords ?? []].filter(Boolean).join(" ").toLowerCase();
					if (item$4.matchAnySearchTerm) return query.split(" ").filter(Boolean).some((word) => searchText.includes(word));
					return searchText.includes(query);
				});
			}
			return items;
		});
		const groupedItems = computed(() => {
			const items = filteredItems.value;
			const ungrouped = [];
			const sections = {};
			items.forEach((item$4) => {
				if (item$4.section) {
					if (!sections[item$4.section]) sections[item$4.section] = [];
					sections[item$4.section].push(item$4);
				} else ungrouped.push(item$4);
			});
			return {
				ungrouped,
				sections: Object.entries(sections).map(([title$3, items$1]) => ({
					title: title$3,
					items: items$1
				}))
			};
		});
		const flattenedItems = computed(() => {
			const result = [];
			result.push(...groupedItems.value.ungrouped);
			groupedItems.value.sections.forEach((section) => {
				result.push(...section.items);
			});
			return result;
		});
		const getGlobalIndex = (item$4) => {
			return flattenedItems.value.findIndex((flatItem) => flatItem.id === item$4.id);
		};
		const scrollSelectedIntoView = () => {
			if (selectedIndex.value < 0) return;
			nextTick(async () => {
				if (selectedIndex.value === 0) {
					await scrollAreaRef.value?.scrollToTop({ smooth: true });
					return;
				} else if (selectedIndex.value === flattenedItems.value.length - 1) {
					await scrollAreaRef.value?.scrollToBottom({ smooth: true });
					return;
				}
				const selectedItem = flattenedItems.value[selectedIndex.value];
				if (!selectedItem) return;
				const selectedElement = document.querySelector(`[data-item-id="${selectedItem.id}"]`);
				if (selectedElement) selectedElement.scrollIntoView({
					behavior: "smooth",
					block: "nearest"
				});
			});
		};
		const openCommandBar = async () => {
			isOpen.value = true;
			selectedIndex.value = 0;
			inputValue.value = "";
			await nextTick();
			inputRef.value?.focus();
		};
		const closeCommandBar = () => {
			isOpen.value = false;
			selectedIndex.value = -1;
			inputValue.value = "";
			currentParentId.value = null;
		};
		const navigateToChildren = (item$4) => {
			currentParentId.value = item$4.id;
			selectedIndex.value = 0;
			inputValue.value = "";
			scrollSelectedIntoView();
			emit("navigateTo", item$4.id);
		};
		const navigateBack = () => {
			if (!currentParent.value) return;
			currentParentId.value = null;
			selectedIndex.value = 0;
			inputValue.value = "";
			emit("navigateTo", null);
		};
		const selectItem$1 = (item$4) => {
			if (item$4.children) {
				navigateToChildren(item$4);
				return;
			}
			if (item$4.handler) item$4.handler();
			closeCommandBar();
		};
		const handleKeydown = (event) => {
			if ((event.metaKey || event.ctrlKey) && event.key === "k") {
				event.preventDefault();
				openCommandBar();
				return;
			}
			if (!isOpen.value) return;
			event.stopPropagation();
			switch (event.key) {
				case "Escape":
					event.preventDefault();
					closeCommandBar();
					break;
				case "ArrowDown":
					event.preventDefault();
					selectedIndex.value = Math.min(selectedIndex.value + 1, flattenedItems.value.length - 1);
					scrollSelectedIntoView();
					break;
				case "ArrowUp":
					event.preventDefault();
					selectedIndex.value = Math.max(selectedIndex.value - 1, 0);
					scrollSelectedIntoView();
					break;
				case "ArrowLeft":
					if (!inputValue.value && currentParent.value) {
						event.preventDefault();
						navigateBack();
					}
					break;
				case "ArrowRight":
					if (selectedIndex.value >= 0 && flattenedItems.value[selectedIndex.value]) {
						const selectedItem = flattenedItems.value[selectedIndex.value];
						if (selectedItem.children) {
							event.preventDefault();
							navigateToChildren(selectedItem);
						}
					}
					break;
				case "Enter":
					event.preventDefault();
					if (selectedIndex.value >= 0 && flattenedItems.value[selectedIndex.value]) selectItem$1(flattenedItems.value[selectedIndex.value]);
					break;
			}
		};
		const handleClickOutside = (event) => {
			if (!isOpen.value) return;
			if (commandBarRef.value && !commandBarRef.value.contains(event.target)) closeCommandBar();
		};
		watch(inputValue, (newValue) => {
			emit("inputChange", newValue);
			selectedIndex.value = 0;
		});
		onMounted(() => {
			document.addEventListener("keydown", handleKeydown, { capture: true });
			document.addEventListener("click", handleClickOutside);
		});
		onUnmounted(() => {
			document.removeEventListener("keydown", handleKeydown, { capture: true });
			document.removeEventListener("click", handleClickOutside);
		});
		return (_ctx, _cache) => {
			return openBlock(), createBlock(Teleport, { to: "body" }, [createVNode(unref(FocusScope_default), { trapped: isOpen.value }, {
				default: withCtx(() => [createVNode(Transition, {
					name: "command-bar",
					appear: ""
				}, {
					default: withCtx(() => [isOpen.value ? (openBlock(), createElementBlock("div", {
						key: 0,
						ref_key: "commandBarRef",
						ref: commandBarRef,
						class: normalizeClass(_ctx.$style.commandBar),
						style: normalizeStyle({ zIndex: _ctx.zIndex }),
						"data-test-id": "command-bar"
					}, [
						_ctx.context ? (openBlock(), createElementBlock("div", {
							key: 0,
							class: normalizeClass(_ctx.$style.contextContainer)
						}, [createVNode(unref(N8nBadge_default), { size: "small" }, {
							default: withCtx(() => [createTextVNode(toDisplayString(_ctx.context), 1)]),
							_: 1
						})], 2)) : createCommentVNode("", true),
						withDirectives(createBaseVNode("input", {
							ref_key: "inputRef",
							ref: inputRef,
							"onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => inputValue.value = $event),
							placeholder: currentPlaceholder.value,
							class: normalizeClass(_ctx.$style.input),
							type: "text"
						}, null, 10, _hoisted_1$1), [[vModelText, inputValue.value]]),
						_ctx.isLoading ? (openBlock(), createElementBlock("div", {
							key: 1,
							class: normalizeClass(_ctx.$style.loadingContainer)
						}, [(openBlock(), createElementBlock(Fragment, null, renderList(NUM_LOADING_ITEMS, (i$1) => {
							return createBaseVNode("div", {
								key: i$1,
								class: normalizeClass(_ctx.$style.loadingItem)
							}, [createVNode(Loading_default$1, {
								variant: "custom",
								class: normalizeClass(_ctx.$style.loading)
							}, null, 8, ["class"])], 2);
						}), 64))], 2)) : flattenedItems.value.length > 0 ? (openBlock(), createBlock(N8nScrollArea_default$1, {
							key: 2,
							ref_key: "scrollAreaRef",
							ref: scrollAreaRef,
							"max-height": "350px",
							class: normalizeClass(_ctx.$style.scrollArea),
							"data-test-id": "command-bar-items-list"
						}, {
							default: withCtx(() => [createBaseVNode("div", {
								ref_key: "itemsListRef",
								ref: itemsListRef,
								class: normalizeClass(_ctx.$style.itemsList)
							}, [groupedItems.value.ungrouped.length > 0 ? (openBlock(), createElementBlock("div", {
								key: 0,
								class: normalizeClass(_ctx.$style.ungroupedSection)
							}, [(openBlock(true), createElementBlock(Fragment, null, renderList(groupedItems.value.ungrouped, (item$4) => {
								return openBlock(), createElementBlock("div", { key: item$4.id }, [createVNode(CommandBarItem_default, {
									item: item$4,
									"is-selected": getGlobalIndex(item$4) === selectedIndex.value,
									onSelect: selectItem$1
								}, null, 8, ["item", "is-selected"])]);
							}), 128))], 2)) : createCommentVNode("", true), (openBlock(true), createElementBlock(Fragment, null, renderList(groupedItems.value.sections, (section) => {
								return openBlock(), createElementBlock(Fragment, { key: section.title }, [createBaseVNode("div", { class: normalizeClass(_ctx.$style.sectionHeader) }, toDisplayString(section.title), 3), (openBlock(true), createElementBlock(Fragment, null, renderList(section.items, (item$4) => {
									return openBlock(), createElementBlock("div", { key: item$4.id }, [createVNode(CommandBarItem_default, {
										item: item$4,
										"is-selected": getGlobalIndex(item$4) === selectedIndex.value,
										onSelect: selectItem$1
									}, null, 8, ["item", "is-selected"])]);
								}), 128))], 64);
							}), 128))], 2)]),
							_: 1
						}, 8, ["class"])) : inputValue.value && flattenedItems.value.length === 0 ? (openBlock(), createElementBlock("div", {
							key: 3,
							class: normalizeClass(_ctx.$style.noResults)
						}, " No results found ", 2)) : createCommentVNode("", true)
					], 6)) : createCommentVNode("", true)]),
					_: 1
				})]),
				_: 1
			}, 8, ["trapped"])]);
		};
	}
});
var CommandBar_vue_vue_type_style_index_0_lang_module_default = {
	commandBar: "_commandBar_1utj1_123",
	input: "_input_1utj1_136",
	scrollArea: "_scrollArea_1utj1_153",
	itemsList: "_itemsList_1utj1_157",
	ungroupedSection: "_ungroupedSection_1utj1_163",
	sectionHeader: "_sectionHeader_1utj1_170",
	noResults: "_noResults_1utj1_177",
	contextContainer: "_contextContainer_1utj1_184",
	loadingContainer: "_loadingContainer_1utj1_188",
	loadingItem: "_loadingItem_1utj1_193"
};
var N8nCommandBar_default = /* @__PURE__ */ __plugin_vue_export_helper_default(CommandBar_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": CommandBar_vue_vue_type_style_index_0_lang_module_default }]]);
const n8nTruncate = (el$2, binding) => {
	if (binding.value !== binding.oldValue) el$2.textContent = truncate(binding.value ?? "", Number(binding.arg) || void 0);
};
var import_sanitize_html = /* @__PURE__ */ __toESM(require_sanitize_html());
var configuredSanitize = (html) => (0, import_sanitize_html.default)(html, {
	allowedTags: import_sanitize_html.default.defaults.allowedTags.concat(["img", "input"]),
	allowedAttributes: {
		...import_sanitize_html.default.defaults.allowedAttributes,
		input: [
			"type",
			"id",
			"checked"
		],
		code: ["class"],
		a: import_sanitize_html.default.defaults.allowedAttributes.a.concat(["data-*"]),
		div: ["class"]
	}
});
const n8nHtml = (el$2, binding) => {
	if (binding.value !== binding.oldValue) el$2.innerHTML = configuredSanitize(binding.value);
};
var directives_exports = /* @__PURE__ */ __export({
	n8nHtml: () => n8nHtml,
	n8nTruncate: () => n8nTruncate
});
const N8nPlugin = { install: (app) => {
	for (const [name$1, directive] of Object.entries(directives_exports)) app.directive(name$1, directive);
} };
function get(object, path, defaultValue) {
	if (typeof path === "string") path = path.split(".").map((key$2) => {
		const numKey = Number(key$2);
		return Number.isNaN(numKey) ? key$2 : numKey;
	});
	let result = object;
	for (const key$2 of path) {
		if (result === void 0 || result === null) return defaultValue;
		result = result[key$2];
	}
	return result !== void 0 ? result : defaultValue;
}
var SelectItem_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	inheritAttrs: false,
	__name: "SelectItem",
	props: {
		label: {},
		type: {},
		value: { type: [
			String,
			Number,
			Object,
			null,
			Boolean
		] },
		disabled: { type: Boolean },
		onSelect: { type: Function },
		icon: {},
		class: {},
		strokeWidth: {}
	},
	setup(__props) {
		const props = __props;
		const $style = useCssModule();
		function isAcceptable(value) {
			return value;
		}
		const leadingProps = computed(() => ({
			class: $style.itemLeading,
			strokeWidth: props.strokeWidth
		}));
		const trailingProps = computed(() => ({
			class: $style.itemTrailing,
			strokeWidth: props.strokeWidth
		}));
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(SelectItem_default$1), {
				disabled: props.disabled,
				value: isAcceptable(props.value),
				class: normalizeClass(props.class),
				onSelect: _cache[0] || (_cache[0] = ($event) => props.onSelect?.($event))
			}, {
				default: withCtx(() => [
					renderSlot(_ctx.$slots, "item-leading", {
						item: props,
						ui: leadingProps.value
					}, () => [props.icon ? (openBlock(), createBlock(Icon_default, mergeProps({
						key: 0,
						icon: props.icon
					}, leadingProps.value), null, 16, ["icon"])) : createCommentVNode("", true)]),
					createVNode(unref(SelectItemText_default), { class: normalizeClass(unref($style).itemText) }, {
						default: withCtx(() => [renderSlot(_ctx.$slots, "item-label", { item: props }, () => [createTextVNode(toDisplayString(props.label), 1)])]),
						_: 3
					}, 8, ["class"]),
					renderSlot(_ctx.$slots, "item-trailing", {
						item: props,
						ui: trailingProps.value
					}),
					createVNode(unref(SelectItemIndicator_default), { "as-child": "" }, {
						default: withCtx(() => [createVNode(Icon_default, {
							icon: "check",
							class: normalizeClass(unref($style).itemIndicator)
						}, null, 8, ["class"])]),
						_: 1
					})
				]),
				_: 3
			}, 8, [
				"disabled",
				"value",
				"class"
			]);
		};
	}
});
var SelectItem_vue_vue_type_style_index_0_lang_module_default = {
	itemLeading: "_itemLeading_1h65n_2",
	itemText: "_itemText_1h65n_6",
	itemIndicator: "_itemIndicator_1h65n_10",
	itemTrailing: "_itemTrailing_1h65n_11"
};
var SelectItem_default = /* @__PURE__ */ __plugin_vue_export_helper_default(SelectItem_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": SelectItem_vue_vue_type_style_index_0_lang_module_default }]]);
var Select_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	inheritAttrs: false,
	__name: "Select",
	props: {
		open: { type: Boolean },
		defaultOpen: { type: Boolean },
		autocomplete: {},
		disabled: { type: Boolean },
		name: {},
		required: { type: Boolean },
		id: {},
		placeholder: { default: "Select an option" },
		size: { default: "small" },
		valueKey: {},
		labelKey: {},
		items: {},
		defaultValue: {},
		modelValue: {},
		multiple: { type: Boolean },
		variant: { default: "default" },
		icon: {}
	},
	emits: ["update:open", "update:modelValue"],
	setup(__props, { expose: __expose, emit: __emit }) {
		const $style = useCssModule();
		const props = __props;
		const emit = __emit;
		useSlots();
		const rootProps = useForwardPropsEmits(reactivePick(props, "open", "defaultOpen", "disabled", "autocomplete", "required", "multiple"), emit);
		function isSelectItem(item$4) {
			return typeof item$4 === "object" && item$4 !== null;
		}
		const triggerRef$1 = useTemplateRef("trigger");
		function castToSelectItemValue(value) {
			return value;
		}
		__expose({ triggerRef: triggerRef$1 });
		const variants = {
			default: $style.default,
			ghost: $style.ghost
		};
		const variant = computed(() => variants[props.variant]);
		const sizes = {
			xsmall: $style.xsmall,
			small: $style.small,
			medium: $style.medium
		};
		const size$2 = computed(() => sizes[props.size]);
		const strokeWidths = {
			xsmall: 1,
			small: 1,
			medium: 1.5
		};
		const iconStrokeWidth = computed(() => strokeWidths[props.size]);
		const labelSizes = {
			xsmall: $style.selectLabelXsmall,
			small: $style.selectLabelSmall,
			medium: $style.selectLabelMedium
		};
		const labelSize = computed(() => labelSizes[props.size]);
		const groups = computed(() => {
			if (!props.items?.length) return [];
			return props.items.map((item$4) => {
				return isSelectItem(item$4) ? {
					...item$4,
					value: get(item$4, props.valueKey?.toString() ?? "value"),
					label: get(item$4, props.labelKey?.toString() ?? "label"),
					class: [
						$style.selectItem,
						item$4.class,
						size$2.value
					],
					strokeWidth: iconStrokeWidth.value
				} : {
					value: item$4,
					label: String(item$4),
					class: [$style.selectItem, size$2.value]
				};
			});
		});
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(SelectRoot_default), mergeProps({ name: _ctx.name }, unref(rootProps), {
				autocomplete: _ctx.autocomplete,
				disabled: _ctx.disabled,
				"default-value": castToSelectItemValue(_ctx.defaultValue),
				"model-value": castToSelectItemValue(_ctx.modelValue)
			}), {
				default: withCtx(({ open }) => [createVNode(unref(SelectTrigger_default), mergeProps({
					id: _ctx.id,
					ref: "trigger"
				}, _ctx.$attrs, {
					class: [
						unref($style).selectTrigger,
						variant.value,
						size$2.value
					],
					"aria-label": _ctx.$attrs["aria-label"] ?? _ctx.placeholder
				}), {
					default: withCtx(() => [
						_ctx.icon ? (openBlock(), createBlock(Icon_default, {
							key: 0,
							icon: _ctx.icon,
							class: normalizeClass(unref($style).selectedIcon),
							"stroke-width": iconStrokeWidth.value
						}, null, 8, [
							"icon",
							"class",
							"stroke-width"
						])) : createCommentVNode("", true),
						createVNode(unref(SelectValue_default), {
							placeholder: _ctx.placeholder,
							class: normalizeClass(unref($style).selectValue)
						}, {
							default: withCtx(() => [renderSlot(_ctx.$slots, "default", {
								modelValue: _ctx.modelValue,
								open
							})]),
							_: 2
						}, 1032, ["placeholder", "class"]),
						createVNode(Icon_default, {
							icon: "chevron-down",
							class: normalizeClass(unref($style).trailingIcon)
						}, null, 8, ["class"])
					]),
					_: 2
				}, 1040, [
					"id",
					"class",
					"aria-label"
				]), createVNode(unref(SelectPortal_default), null, {
					default: withCtx(() => [createVNode(unref(SelectContent_default), { class: normalizeClass(unref($style).selectContent) }, {
						default: withCtx(() => [
							createVNode(unref(SelectScrollUpButton_default), { class: normalizeClass(unref($style).selectScrollButton) }, {
								default: withCtx(() => [createVNode(Icon_default, { icon: "chevron-up" })]),
								_: 1
							}, 8, ["class"]),
							createVNode(unref(SelectViewport_default), { class: normalizeClass(unref($style).selectViewport) }, {
								default: withCtx(() => [createVNode(unref(SelectGroup_default), null, {
									default: withCtx(() => [(openBlock(true), createElementBlock(Fragment, null, renderList(groups.value, (item$4, index) => {
										return openBlock(), createElementBlock(Fragment, { key: `group-${index}` }, [item$4.type === "label" ? (openBlock(), createBlock(unref(SelectLabel_default), {
											key: 0,
											class: normalizeClass([unref($style).selectLabel, labelSize.value])
										}, {
											default: withCtx(() => [createTextVNode(toDisplayString(item$4.label), 1)]),
											_: 2
										}, 1032, ["class"])) : item$4.type === "separator" ? (openBlock(), createBlock(unref(SelectSeparator_default), {
											key: 1,
											class: normalizeClass(unref($style).selectSeparator),
											role: "separator"
										}, null, 8, ["class"])) : renderSlot(_ctx.$slots, "item", {
											key: 2,
											item: item$4
										}, () => [createVNode(SelectItem_default, mergeProps({ ref_for: true }, item$4), {
											"item-leading": withCtx(({ ui }) => [renderSlot(_ctx.$slots, "item-leading", {
												item: item$4,
												ui
											})]),
											"item-label": withCtx(() => [renderSlot(_ctx.$slots, "item-label", { item: item$4 })]),
											"item-trailing": withCtx(({ ui }) => [renderSlot(_ctx.$slots, "item-trailing", {
												item: item$4,
												ui
											})]),
											_: 2
										}, 1040)])], 64);
									}), 128))]),
									_: 3
								})]),
								_: 3
							}, 8, ["class"]),
							createVNode(unref(SelectScrollDownButton_default), { class: normalizeClass(unref($style).selectScrollButton) }, {
								default: withCtx(() => [createVNode(Icon_default, { icon: "chevron-down" })]),
								_: 1
							}, 8, ["class"])
						]),
						_: 3
					}, 8, ["class"])]),
					_: 3
				})]),
				_: 3
			}, 16, [
				"name",
				"autocomplete",
				"disabled",
				"default-value",
				"model-value"
			]);
		};
	}
});
const selectTrigger = "_selectTrigger_zgy2e_2";
const ghost = "_ghost_zgy2e_43";
const xsmall = "_xsmall_zgy2e_47";
const small$1 = "_small_zgy2e_53";
const medium$1 = "_medium_zgy2e_59";
const selectedIcon = "_selectedIcon_zgy2e_66";
const trailingIcon = "_trailingIcon_zgy2e_70";
const selectContent = "_selectContent_zgy2e_76";
const selectViewport = "_selectViewport_zgy2e_89";
const selectValue = "_selectValue_zgy2e_93";
const selectItem = "_selectItem_zgy2e_99";
const selectLabel = "_selectLabel_zgy2e_126";
const selectLabelMedium = "_selectLabelMedium_zgy2e_131";
const selectLabelSmall = "_selectLabelSmall_zgy2e_135";
const selectLabelXsmall = "_selectLabelXsmall_zgy2e_139";
const selectSeparator = "_selectSeparator_zgy2e_143";
const selectItemIndicator = "_selectItemIndicator_zgy2e_149";
const selectScrollButton = "_selectScrollButton_zgy2e_158";
var Select_vue_vue_type_style_index_0_lang_module_default = {
	selectTrigger,
	"default": "_default_zgy2e_39",
	ghost,
	xsmall,
	small: small$1,
	medium: medium$1,
	selectedIcon,
	trailingIcon,
	selectContent,
	selectViewport,
	selectValue,
	selectItem,
	selectLabel,
	selectLabelMedium,
	selectLabelSmall,
	selectLabelXsmall,
	selectSeparator,
	selectItemIndicator,
	selectScrollButton
};
var Select_default = /* @__PURE__ */ __plugin_vue_export_helper_default(Select_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": Select_vue_vue_type_style_index_0_lang_module_default }]]);
var _hoisted_1 = [
	"type",
	"value",
	"placeholder",
	"disabled",
	"maxlength",
	"autocomplete"
];
var _hoisted_2 = [
	"value",
	"placeholder",
	"disabled",
	"rows",
	"maxlength",
	"autocomplete"
];
var Input_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	name: "N8nInput2",
	__name: "Input",
	props: {
		modelValue: { default: "" },
		type: { default: "text" },
		size: { default: "large" },
		placeholder: { default: "" },
		disabled: {
			type: Boolean,
			default: false
		},
		clearable: {
			type: Boolean,
			default: false
		},
		rows: { default: 2 },
		maxlength: { default: void 0 },
		autosize: {
			type: [Boolean, Object],
			default: false
		},
		autofocus: {
			type: Boolean,
			default: false
		},
		autocomplete: { default: "off" }
	},
	emits: [
		"update:modelValue",
		"blur",
		"keydown"
	],
	setup(__props, { expose: __expose, emit: __emit }) {
		const $style = useCssModule();
		const props = __props;
		const emit = __emit;
		const inputRef = ref(null);
		const sizes = {
			xlarge: $style.xlarge,
			large: $style.large,
			medium: $style.medium,
			small: $style.small,
			mini: $style.mini
		};
		const sizeClass = computed(() => sizes[props.size]);
		const containerClasses = computed(() => [
			$style.inputContainer,
			sizeClass.value,
			{
				[$style.disabled]: props.disabled,
				[$style.focused]: isFocused.value,
				"ph-no-capture": props.type === "password"
			}
		]);
		const isFocused = ref(false);
		const onInput = (event) => {
			const target$1 = event.target;
			emit("update:modelValue", target$1.value);
		};
		const onBlur = (event) => {
			isFocused.value = false;
			emit("blur", event);
		};
		const onFocus = () => {
			isFocused.value = true;
		};
		const onKeydown = (event) => {
			emit("keydown", event);
		};
		const onClear = () => {
			emit("update:modelValue", "");
			focus$1();
		};
		const showClearButton = computed(() => {
			return props.clearable && !props.disabled && props.modelValue !== "" && props.modelValue !== null;
		});
		const textareaStyles = ref({});
		let hiddenTextarea$1;
		const CONTEXT_STYLE_PROPS = [
			"letter-spacing",
			"line-height",
			"padding-top",
			"padding-bottom",
			"font-family",
			"font-weight",
			"font-size",
			"text-rendering",
			"text-transform",
			"width",
			"text-indent",
			"padding-left",
			"padding-right",
			"border-width",
			"box-sizing"
		];
		function calcTextareaHeight$1(targetElement, minRows, maxRows) {
			if (!hiddenTextarea$1) {
				hiddenTextarea$1 = document.createElement("textarea");
				document.body.appendChild(hiddenTextarea$1);
			}
			const style = window.getComputedStyle(targetElement);
			const boxSizing = style.getPropertyValue("box-sizing");
			const paddingSize = parseFloat(style.getPropertyValue("padding-bottom")) + parseFloat(style.getPropertyValue("padding-top"));
			const borderSize = parseFloat(style.getPropertyValue("border-bottom-width")) + parseFloat(style.getPropertyValue("border-top-width"));
			const contextStyle = CONTEXT_STYLE_PROPS.map((name$1) => `${name$1}:${style.getPropertyValue(name$1)}`).join(";");
			hiddenTextarea$1.setAttribute("style", `${contextStyle};
		height:0 !important;
		visibility:hidden !important;
		overflow:hidden !important;
		position:absolute !important;
		z-index:-1000 !important;
		top:0 !important;
		right:0 !important;
	`);
			hiddenTextarea$1.value = targetElement.value || targetElement.placeholder || "";
			let height = hiddenTextarea$1.scrollHeight;
			const result = { height: "" };
			if (boxSizing === "border-box") height = height + borderSize;
			else if (boxSizing === "content-box") height = height - paddingSize;
			hiddenTextarea$1.value = "";
			const singleRowHeight = hiddenTextarea$1.scrollHeight - paddingSize;
			if (minRows !== void 0) {
				let minHeight = singleRowHeight * minRows;
				if (boxSizing === "border-box") minHeight = minHeight + paddingSize + borderSize;
				height = Math.max(minHeight, height);
				result.minHeight = `${minHeight}px`;
			}
			if (maxRows !== void 0) {
				let maxHeight = singleRowHeight * maxRows;
				if (boxSizing === "border-box") maxHeight = maxHeight + paddingSize + borderSize;
				height = Math.min(maxHeight, height);
			}
			result.height = `${height}px`;
			return result;
		}
		function cleanupHiddenTextarea() {
			if (hiddenTextarea$1?.parentNode) {
				hiddenTextarea$1.parentNode.removeChild(hiddenTextarea$1);
				hiddenTextarea$1 = void 0;
			}
		}
		const calculateTextareaHeight = () => {
			if (props.type !== "textarea" || !props.autosize || !inputRef.value) return;
			const textarea$1 = inputRef.value;
			textareaStyles.value = calcTextareaHeight$1(textarea$1, typeof props.autosize === "object" ? props.autosize.minRows : void 0, typeof props.autosize === "object" ? props.autosize.maxRows : void 0);
			cleanupHiddenTextarea();
		};
		useResizeObserver(computed(() => props.type === "textarea" && props.autosize ? inputRef.value : null), () => {
			calculateTextareaHeight();
		});
		onBeforeUnmount(() => {
			cleanupHiddenTextarea();
		});
		watch(() => props.modelValue, () => {
			if (props.type === "textarea" && props.autosize) nextTick(calculateTextareaHeight);
		});
		onMounted(() => {
			if (props.autofocus) focus$1();
			if (props.type === "textarea" && props.autosize) nextTick(calculateTextareaHeight);
		});
		const focus$1 = () => inputRef.value?.focus();
		const blur = () => inputRef.value?.blur();
		const select = () => inputRef.value?.select();
		__expose({
			focus: focus$1,
			blur,
			select
		});
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", { class: normalizeClass(containerClasses.value) }, [
				_ctx.$slots.prefix ? (openBlock(), createElementBlock("span", {
					key: 0,
					class: normalizeClass(unref($style).prefix)
				}, [renderSlot(_ctx.$slots, "prefix")], 2)) : createCommentVNode("", true),
				_ctx.type !== "textarea" ? (openBlock(), createElementBlock("input", {
					key: 1,
					ref_key: "inputRef",
					ref: inputRef,
					type: _ctx.type,
					value: _ctx.modelValue ?? "",
					class: normalizeClass(unref($style).input),
					placeholder: _ctx.placeholder,
					disabled: _ctx.disabled,
					maxlength: _ctx.maxlength,
					autocomplete: _ctx.autocomplete,
					onInput,
					onBlur,
					onFocus,
					onKeydown
				}, null, 42, _hoisted_1)) : (openBlock(), createElementBlock("textarea", {
					key: 2,
					ref_key: "inputRef",
					ref: inputRef,
					value: _ctx.modelValue ?? "",
					class: normalizeClass([unref($style).input, unref($style).textarea]),
					placeholder: _ctx.placeholder,
					disabled: _ctx.disabled,
					rows: _ctx.autosize ? void 0 : _ctx.rows,
					maxlength: _ctx.maxlength,
					autocomplete: _ctx.autocomplete,
					style: normalizeStyle(_ctx.autosize ? {
						...textareaStyles.value,
						resize: "none",
						overflow: "hidden"
					} : void 0),
					onInput,
					onBlur,
					onFocus,
					onKeydown
				}, null, 46, _hoisted_2)),
				_ctx.$slots.suffix ? (openBlock(), createElementBlock("span", {
					key: 3,
					class: normalizeClass(unref($style).suffix)
				}, [renderSlot(_ctx.$slots, "suffix")], 2)) : createCommentVNode("", true),
				showClearButton.value ? (openBlock(), createElementBlock("button", {
					key: 4,
					type: "button",
					class: normalizeClass(unref($style).clearButton),
					tabindex: "-1",
					onClick: onClear
				}, [createVNode(Icon_default, {
					icon: "x",
					size: "small"
				})], 2)) : createCommentVNode("", true)
			], 2);
		};
	}
});
var Input_vue_vue_type_style_index_0_lang_module_default = {
	inputContainer: "_inputContainer_1gphe_2",
	disabled: "_disabled_1gphe_15",
	focused: "_focused_1gphe_19",
	xlarge: "_xlarge_1gphe_31",
	large: "_large_1gphe_37",
	medium: "_medium_1gphe_43",
	small: "_small_1gphe_49",
	mini: "_mini_1gphe_55",
	input: "_input_1gphe_2",
	textarea: "_textarea_1gphe_82",
	prefix: "_prefix_1gphe_88",
	suffix: "_suffix_1gphe_89",
	clearButton: "_clearButton_1gphe_96"
};
var Input_default = /* @__PURE__ */ __plugin_vue_export_helper_default(Input_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": Input_vue_vue_type_style_index_0_lang_module_default }]]);
var Loading_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "Loading",
	props: {
		animated: {
			type: Boolean,
			default: true
		},
		loading: {
			type: Boolean,
			default: true
		},
		rows: { default: 1 },
		cols: { default: 0 },
		shrinkLast: {
			type: Boolean,
			default: true
		},
		variant: { default: "p" }
	},
	setup(__props) {
		const props = __props;
		const isLastRowShrunk = computed(() => props.shrinkLast && props.rows > 1);
		const showH1Layout = computed(() => props.variant === "h1" && !props.cols);
		const showPLayout = computed(() => props.variant === "p" && !props.cols);
		const showCustomLayout = computed(() => props.variant === "custom" && !props.cols);
		const showColsLayout = computed(() => props.cols > 0);
		const showDefaultLayout = computed(() => !showH1Layout.value && !showPLayout.value && !showCustomLayout.value && !showColsLayout.value);
		function isLastRow(index, total) {
			return index === total - 1;
		}
		return (_ctx, _cache) => {
			return _ctx.loading ? (openBlock(), createBlock(unref(Primitive), {
				key: 0,
				as: "div",
				class: normalizeClass([
					"n8n-loading",
					`n8n-loading-${_ctx.variant}`,
					"el-skeleton",
					_ctx.$style.loading
				]),
				"aria-hidden": "true"
			}, {
				default: withCtx(() => [showColsLayout.value ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(_ctx.cols, (i$1) => {
					return openBlock(), createElementBlock("div", {
						key: `col-${i$1}`,
						class: normalizeClass([
							_ctx.$style.item,
							_ctx.$style[_ctx.variant],
							{ [_ctx.$style.animated]: _ctx.animated }
						])
					}, null, 2);
				}), 128)) : showH1Layout.value ? (openBlock(), createElementBlock("div", {
					key: 1,
					class: normalizeClass(_ctx.$style.rowContainer)
				}, [(openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.rows, (_, index) => {
					return openBlock(), createElementBlock("div", {
						key: `h1-${index}`,
						class: normalizeClass({ [_ctx.$style.h1Last]: isLastRow(index, _ctx.rows) && isLastRowShrunk.value })
					}, [createBaseVNode("div", { class: normalizeClass([
						_ctx.$style.item,
						_ctx.$style.h1,
						{ [_ctx.$style.animated]: _ctx.animated }
					]) }, null, 2)], 2);
				}), 128))], 2)) : showPLayout.value ? (openBlock(), createElementBlock("div", {
					key: 2,
					class: normalizeClass(_ctx.$style.rowContainer)
				}, [(openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.rows, (_, index) => {
					return openBlock(), createElementBlock("div", {
						key: `p-${index}`,
						class: normalizeClass({ [_ctx.$style.pLast]: isLastRow(index, _ctx.rows) && isLastRowShrunk.value })
					}, [createBaseVNode("div", { class: normalizeClass([
						_ctx.$style.item,
						_ctx.$style.p,
						{ [_ctx.$style.animated]: _ctx.animated }
					]) }, null, 2)], 2);
				}), 128))], 2)) : showCustomLayout.value ? (openBlock(), createElementBlock("div", {
					key: 3,
					class: normalizeClass([
						_ctx.$style.item,
						_ctx.$style.custom,
						{ [_ctx.$style.animated]: _ctx.animated }
					])
				}, null, 2)) : showDefaultLayout.value ? (openBlock(), createElementBlock("div", {
					key: 4,
					class: normalizeClass([
						_ctx.$style.item,
						_ctx.$style[_ctx.variant],
						{ [_ctx.$style.animated]: _ctx.animated }
					])
				}, null, 2)) : createCommentVNode("", true)]),
				_: 1
			}, 8, ["class"])) : createCommentVNode("", true);
		};
	}
});
const loading = "_loading_18zq4_134";
const rowContainer = "_rowContainer_18zq4_138";
const item = "_item_18zq4_143";
const animated = "_animated_18zq4_148";
const p = "_p_18zq4_152";
const h1 = "_h1_18zq4_157";
const h3 = "_h3_18zq4_162";
const text = "_text_18zq4_166";
const caption = "_caption_18zq4_171";
const button = "_button_18zq4_175";
const image = "_image_18zq4_181";
const circle = "_circle_18zq4_186";
const rect = "_rect_18zq4_192";
const custom = "_custom_18zq4_197";
const h1Last = "_h1Last_18zq4_202";
const pLast = "_pLast_18zq4_206";
var Loading_vue_vue_type_style_index_0_lang_module_default = {
	loading,
	rowContainer,
	item,
	animated,
	"skeleton-pulse": "_skeleton-pulse_18zq4_1",
	p,
	h1,
	h3,
	text,
	caption,
	button,
	image,
	circle,
	rect,
	custom,
	h1Last,
	pLast
};
var Loading_default = /* @__PURE__ */ __plugin_vue_export_helper_default(Loading_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": Loading_vue_vue_type_style_index_0_lang_module_default }]]);
export { N8nInputLabel_default as $, useId$1 as $t, N8nNotice_default as A, _nodeUtil_default as An, ElOptionGroup as At, InlineAskAssistantButton_default as B, N8nHeading_default as Bn, ClickOutside as Bt, N8nResizeWrapper_default as C, flatten_default as Cn, useI18n as Ct, N8nPopoverReka_default as D, _overArg_default as Dn, ElSkeletonItem as Dt, N8nPulse_default as E, keys_default as En, ElSwitch as Et, N8nMarkdown_default as F, isArrayLike_default as Fn, ElColorPicker as Ft, N8nExternalLink_default as G, N8nIcon_default as Gn, FOCUS_TRAP_INJECTION_KEY as Gt, N8nFormInputs_default as H, N8nText_default as Hn, ElTooltip as Ht, N8nLogo_default as I, _overRest_default as In, ElCollapseTransition as It, N8nSelect_default as J, useFormItem as Jt, N8nDatatable_default as K, updatedIconSet as Kn, ElScrollbar as Kt, N8nInputNumber_default as L, _setToString_default as Ln, ElTag as Lt, N8nNodeCreatorNode_default as M, isBuffer_default as Mn, ElDropdown as Mt, N8nNavigationDropdown_default as N, isArguments_default as Nn, ElDropdownItem as Nt, N8nPopover_default as O, _arrayLikeKeys_default as On, ElPagination as Ot, N8nMenuItem_default as P, _isPrototype_default as Pn, ElDropdownMenu as Pt, N8nCheckbox_default as Q, useDelayedToggle as Qt, N8nInfoTip_default as R, identity_default as Rn, ElCheckbox as Rt, N8nSticky_default as S, _Stack_default as Sn, AskAssistantButton_default as St, N8nRadioButtons_default as T, _arrayPush_default as Tn, useProvideTooltipAppendTo as Tt, ResizeObserver_default as U, N8nButton_default as Un, TOOLTIP_INJECTION_KEY as Ut, N8nFormBox_default as V, N8nCallout_default as Vn, ElButton as Vt, N8nFormInput_default as W, N8nSpinner_default as Wn, ElFocusTrap as Wt, N8nColorPicker_default as X, useFormDisabled as Xt, N8nOption_default as Y, useFormItemInputId as Yt, N8nCircleLoader_default as Z, useFormSize as Zt, N8nTree_default as _, _getTag_default as _n, require_markdown_it as _t, N8nCommandBar_default as a, isValidComponentSize as an, N8nLoading_default as at, SuggestedActions_default as b, _getSymbols_default as bn, createFormEventBus as bt, N8nInlineTextEdit_default as c, datePickTypes as cn, useDeviceSupport as ct, N8nBreadcrumbs_default as d, isUndefined_default as dn, AskAssistantAvatar_default as dt, yn as en, N8nCard_default as et, N8nIconPicker_default as f, isNil_default as fn, AskAssistantIcon_default as ft, N8nUserInfo_default as g, _Uint8Array_default as gn, require_markdown_it_link_attributes as gt, N8nUserStack_default as h, _baseIteratee_default as hn, N8nTooltip_default as ht, N8nPlugin as i, flattedChildren as in, N8nActionToggle_default as it, N8nNodeIcon_default as j, _baseUnary_default as jn, ElSelect as jt, N8nSelectableList_default as k, isTypedArray_default as kn, ElOption as kt, TableHeaderControlsButton_default as l, composeRefs as ln, N8nBadge_default as lt, N8nUserSelect_default as m, debounce_default as mn, N8nLink_default as mt, Input_default as n, mutable as nn, N8nBlockUi_default as nt, DateRangePicker_default as o, CHANGE_EVENT as on, N8nActionDropdown_default as ot, N8nUsersList_default as p, isEqual_default as pn, AskAssistantChat_default as pt, TableBase_default as q, use as qn, ElInput as qt, Select_default as r, PatchFlags as rn, N8nAvatar_default as rt, N8nScrollArea_default as s, UPDATE_MODEL_EVENT as sn, N8nKeyboardShortcut_default as st, Loading_default as t, useDeprecated as tn, CanvasThinkingPill_default as tt, N8nDataTableServer_default as u, getScrollBarWidth as un, AskAssistantText_default as ut, N8nTags_default as v, _getAllKeys_default as vn, require_utils as vt, N8nRecycleScroller_default as w, _baseFlatten_default as wn, N8nActionBox_default as wt, N8nTag_default as x, stubArray_default as xn, N8nIconButton_default as xt, N8nTabs_default as y, _baseGetAllKeys_default as yn, N8nInput_default as yt, N8nInfoAccordion_default as z, obtainAllFocusableElements$1 as zn, vRepeatClick as zt };
