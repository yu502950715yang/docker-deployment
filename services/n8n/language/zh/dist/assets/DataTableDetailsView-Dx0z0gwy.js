import { o as __toESM } from "./chunk-6z4oVpB-.js";
import { At as isReactive, Bt as toRaw, C as computed, Cn as toDisplayString, D as createElementBlock, E as createCommentVNode, F as getCurrentInstance, G as nextTick, Gt as unref, H as mergeDefaults, Ht as toRefs, It as ref, M as createVNode, Mt as markRaw, P as defineComponent, Q as onUnmounted, T as createBlock, U as mergeModels, Z as onMounted, _ as Fragment, _t as watch, bn as normalizeStyle, bt as withCtx, et as openBlock, ft as useModel, h as withModifiers, it as renderList, j as createTextVNode, jt as isRef, kt as isProxy, m as withKeys, mt as useTemplateRef, o as render, p as vShow, vn as normalizeClass, w as createBaseVNode, xt as withDirectives } from "./vue.runtime.esm-bundler-tP5dCd7J.js";
import { g as onClickOutside, gt as useI18n } from "./_MapCache-DZpzsuCB.js";
import { $ as N8nInputLabel_default, D as N8nPopoverReka_default, Gn as N8nIcon_default, Hn as N8nText_default, J as N8nSelect_default, Ot as ElPagination, Un as N8nButton_default, Wn as N8nSpinner_default, Y as N8nOption_default, at as N8nLoading_default, c as N8nInlineTextEdit_default, d as N8nBreadcrumbs_default, ht as N8nTooltip_default, ot as N8nActionDropdown_default, xt as N8nIconButton_default, yt as N8nInput_default } from "./src-j4VKDieO.js";
import "./en-b3uD8cvU.js";
import "./preload-helper-CR0ecmWK.js";
import { t as __plugin_vue_export_helper_default } from "./_plugin-vue_export-helper-BwBpWJRZ.js";
import { y as useRouter } from "./truncate-BlCeUq7F.js";
import { t as ElDatePicker } from "./date-picker-DkviJuRa.js";
import "./overlay-Crh-SkkJ.js";
import "./empty-BuGRxzl4.js";
import { t as useMessage } from "./useMessage-LAVj4VkL.js";
import { Nn as useDocumentTitle, Oi as isFocusableEl, h as telemetry, n as useToast, p as useTelemetry } from "./builder.store-BjWbk2Wl.js";
import "./sanitize-html-Cft-jOcY.js";
import "./CalendarDate-B-JEhNYg.js";
import "./path-browserify-BgjP7RyT.js";
import { Br as EMPTY_VALUE, Ga as DateTime, Gr as NUMBER_DECIMAL_SEPARATOR, Hr as MAX_COLUMN_NAME_LENGTH, Ir as DATA_TABLE_VIEW, Jr as PROJECT_DATA_TABLES, Ki as DATA_TABLE_SYSTEM_COLUMNS, Kr as NUMBER_THOUSAND_SEPARATOR, Lr as DEFAULT_COLUMN_WIDTH, Mr as DATA_TABLE_HEADER_HEIGHT, Nr as DATA_TABLE_ID_COLUMN_WIDTH, Or as ADD_ROW_ROW_ID, Pr as DATA_TABLE_ROW_HEIGHT, R as DATA_TYPE_ICON_MAP, Ur as MIN_LOADING_TIME, Vr as LOOSE_DATE_REGEX, Wr as NULL_VALUE, kr as COLUMN_NAME_REGEX, qr as NUMBER_WITH_SPACES_REGEX, ss as MODAL_CONFIRM, zr as DEFAULT_ID_COLUMN_NAME } from "./constants-ksa9xIxI.js";
import "./merge-D6lLi7TL.js";
import { s as ResponseError } from "./_baseOrderBy-B2FQHwl_.js";
import "./dateformat-hG8NERse.js";
import { t as useDebounce } from "./useDebounce-Cb7xvwM5.js";
import { t as useClipboard } from "./useClipboard-Dy2su5yb.js";
import { n as reorderItem, t as useDataTableStore } from "./dataTable.store-DZQFcsqE.js";
import "./ProjectIcon-DTrnRNdg.js";
import { t as require_orderBy } from "./orderBy-CTdFEkRg.js";
import { t as ProjectBreadcrumb_default } from "./ProjectBreadcrumb-CB1NI9y9.js";
import { t as DataTableActions_default } from "./DataTableActions-cWWorS5A.js";
import { t as SelectedItemsInfo_default } from "./SelectedItemsInfo-CbclcA0l.js";
var BREADCRUMBS_SEPARATOR = "/";
var DataTableBreadcrumbs_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "DataTableBreadcrumbs",
	props: { dataTable: {} },
	setup(__props) {
		const props = __props;
		const renameInput = useTemplateRef("renameInput");
		const dataTableStore = useDataTableStore();
		const i18n = useI18n();
		const router = useRouter();
		const toast = useToast();
		const editableName = ref(props.dataTable.name);
		const project = computed(() => {
			return props.dataTable.project ?? null;
		});
		const breadcrumbs = computed(() => {
			if (!project.value) return [];
			return [{
				id: "datatables",
				label: i18n.baseText("dataTable.dataTables"),
				href: `/projects/${project.value.id}/datatables`
			}];
		});
		const onItemClicked = async (item) => {
			if (item.href) await router.push(item.href);
		};
		const onDelete = async () => {
			await router.push({
				name: PROJECT_DATA_TABLES,
				params: { projectId: props.dataTable.projectId }
			});
		};
		const onRename = async () => {
			await nextTick();
			if (renameInput.value && typeof renameInput.value.forceFocus === "function") renameInput.value.forceFocus();
		};
		const onNameSubmit = async (name) => {
			try {
				if (!await dataTableStore.updateDataTable(props.dataTable.id, name, props.dataTable.projectId)) throw new Error(i18n.baseText("generic.unknownError"));
				editableName.value = name;
				telemetry.track("User renamed data table", {
					data_table_id: props.dataTable.id,
					data_table_project_id: props.dataTable.projectId
				});
			} catch (error) {
				editableName.value = props.dataTable.name;
				toast.showError(error, i18n.baseText("dataTable.rename.error"));
			}
		};
		watch(() => props.dataTable.name, (newName) => {
			editableName.value = newName;
		});
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", {
				class: normalizeClass(_ctx.$style["data-table-breadcrumbs"]),
				"data-test-id": "data-table-breadcrumbs"
			}, [createVNode(unref(N8nBreadcrumbs_default), {
				items: breadcrumbs.value,
				separator: BREADCRUMBS_SEPARATOR,
				"highlight-last-item": false,
				onItemSelected: onItemClicked
			}, {
				prepend: withCtx(() => [project.value ? (openBlock(), createBlock(ProjectBreadcrumb_default, {
					key: 0,
					"current-project": project.value
				}, null, 8, ["current-project"])) : createCommentVNode("", true)]),
				append: withCtx(() => [createBaseVNode("span", { class: normalizeClass(_ctx.$style.separator) }, toDisplayString(BREADCRUMBS_SEPARATOR), 2), createVNode(unref(N8nInlineTextEdit_default), {
					ref_key: "renameInput",
					ref: renameInput,
					modelValue: editableName.value,
					"onUpdate:modelValue": [_cache[0] || (_cache[0] = ($event) => editableName.value = $event), onNameSubmit],
					"data-test-id": "data-table-header-name-input",
					placeholder: unref(i18n).baseText("dataTable.add.input.name.label"),
					class: normalizeClass(_ctx.$style["breadcrumb-current"]),
					"max-length": 30,
					"read-only": false,
					disabled: false
				}, null, 8, [
					"modelValue",
					"placeholder",
					"class"
				])]),
				_: 1
			}, 8, ["items"]), createBaseVNode("div", { class: normalizeClass(_ctx.$style["data-table-actions"]) }, [createVNode(DataTableActions_default, {
				"data-table": props.dataTable,
				location: "breadcrumbs",
				onRename,
				onOnDeleted: onDelete
			}, null, 8, ["data-table"])], 2)], 2);
		};
	}
});
const separator = "_separator_9bko0_133";
var DataTableBreadcrumbs_vue_vue_type_style_index_0_lang_module_default = {
	"data-table-breadcrumbs": "_data-table-breadcrumbs_9bko0_123",
	"data-table-actions": "_data-table-actions_9bko0_128",
	separator,
	"breadcrumb-current": "_breadcrumb-current_9bko0_139"
};
var DataTableBreadcrumbs_default = /* @__PURE__ */ __plugin_vue_export_helper_default(DataTableBreadcrumbs_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": DataTableBreadcrumbs_vue_vue_type_style_index_0_lang_module_default }]]);
var LocalEventService = class {
	constructor() {
		this.allSyncListeners = /* @__PURE__ */ new Map();
		this.allAsyncListeners = /* @__PURE__ */ new Map();
		this.globalSyncListeners = /* @__PURE__ */ new Set();
		this.globalAsyncListeners = /* @__PURE__ */ new Set();
		this.asyncFunctionsQueue = [];
		this.scheduled = false;
		this.firedEvents = {};
	}
	setFrameworkOverrides(frameworkOverrides) {
		this.frameworkOverrides = frameworkOverrides;
	}
	getListeners(eventType, async, autoCreateListenerCollection) {
		const listenerMap = async ? this.allAsyncListeners : this.allSyncListeners;
		let listeners = listenerMap.get(eventType);
		if (!listeners && autoCreateListenerCollection) {
			listeners = /* @__PURE__ */ new Set();
			listenerMap.set(eventType, listeners);
		}
		return listeners;
	}
	noRegisteredListenersExist() {
		return this.allSyncListeners.size === 0 && this.allAsyncListeners.size === 0 && this.globalSyncListeners.size === 0 && this.globalAsyncListeners.size === 0;
	}
	addEventListener(eventType, listener, async = false) {
		this.getListeners(eventType, async, true).add(listener);
	}
	removeEventListener(eventType, listener, async = false) {
		const listeners = this.getListeners(eventType, async, false);
		if (!listeners) return;
		listeners.delete(listener);
		if (listeners.size === 0) (async ? this.allAsyncListeners : this.allSyncListeners).delete(eventType);
	}
	addGlobalListener(listener, async = false) {
		this.getGlobalListeners(async).add(listener);
	}
	removeGlobalListener(listener, async = false) {
		this.getGlobalListeners(async).delete(listener);
	}
	dispatchEvent(event) {
		this.dispatchToListeners(event, true);
		this.dispatchToListeners(event, false);
		this.firedEvents[event.type] = true;
	}
	dispatchEventOnce(event) {
		if (!this.firedEvents[event.type]) this.dispatchEvent(event);
	}
	dispatchToListeners(event, async) {
		const eventType = event.type;
		if (async && "event" in event) {
			const browserEvent = event.event;
			if (browserEvent instanceof Event) event.eventPath = browserEvent.composedPath();
		}
		const { frameworkOverrides } = this;
		const runCallback = (func) => {
			const callback = frameworkOverrides ? () => frameworkOverrides.wrapIncoming(func) : func;
			if (async) this.dispatchAsync(callback);
			else callback();
		};
		const originalListeners = this.getListeners(eventType, async, false);
		if ((originalListeners?.size ?? 0) > 0) {
			const listeners = new Set(originalListeners);
			for (const listener of listeners) {
				if (!originalListeners?.has(listener)) continue;
				runCallback(() => listener(event));
			}
		}
		const globalListenersSrc = this.getGlobalListeners(async);
		if (globalListenersSrc.size > 0) {
			const globalListeners = new Set(globalListenersSrc);
			for (const listener of globalListeners) runCallback(() => listener(eventType, event));
		}
	}
	getGlobalListeners(async) {
		return async ? this.globalAsyncListeners : this.globalSyncListeners;
	}
	dispatchAsync(func) {
		this.asyncFunctionsQueue.push(func);
		if (!this.scheduled) {
			const flush = () => {
				window.setTimeout(this.flushAsyncQueue.bind(this), 0);
			};
			this.frameworkOverrides ? this.frameworkOverrides.wrapIncoming(flush) : flush();
			this.scheduled = true;
		}
	}
	flushAsyncQueue() {
		this.scheduled = false;
		const queueCopy = this.asyncFunctionsQueue.slice();
		this.asyncFunctionsQueue = [];
		queueCopy.forEach((func) => func());
	}
};
function defaultLocaleTextFunc(_key, defaultValue) {
	return defaultValue;
}
function _getLocaleTextFunc(localeSvc) {
	return localeSvc?.getLocaleTextFunc() ?? defaultLocaleTextFunc;
}
function _translate(bean, localeValues, key, variableValues) {
	const defaultValue = localeValues[key];
	return bean.getLocaleTextFunc()(key, typeof defaultValue === "function" ? defaultValue(variableValues) : defaultValue, variableValues);
}
function _makeNull(value) {
	if (value == null || value === "") return null;
	return value;
}
function _exists(value) {
	return value != null && value !== "";
}
function _missing(value) {
	return !_exists(value);
}
function _toStringOrNull(value) {
	return value != null && typeof value.toString === "function" ? value.toString() : null;
}
function _jsonEquals(val1, val2) {
	return (val1 ? JSON.stringify(val1) : null) === (val2 ? JSON.stringify(val2) : null);
}
function _defaultComparator(valueA, valueB, accentedCompare = false) {
	const valueAMissing = valueA == null;
	const valueBMissing = valueB == null;
	if (valueA && valueA.toNumber) valueA = valueA.toNumber();
	if (valueB && valueB.toNumber) valueB = valueB.toNumber();
	if (valueAMissing && valueBMissing) return 0;
	if (valueAMissing) return -1;
	if (valueBMissing) return 1;
	function doQuickCompare(a, b) {
		return a > b ? 1 : a < b ? -1 : 0;
	}
	if (typeof valueA !== "string") return doQuickCompare(valueA, valueB);
	if (!accentedCompare) return doQuickCompare(valueA, valueB);
	try {
		return valueA.localeCompare(valueB);
	} catch (e) {
		return doQuickCompare(valueA, valueB);
	}
}
var SKIP_JS_BUILTINS = /* @__PURE__ */ new Set([
	"__proto__",
	"constructor",
	"prototype"
]);
function _iterateObject(object, callback) {
	if (object == null) return;
	if (Array.isArray(object)) {
		for (let i = 0; i < object.length; i++) callback(i.toString(), object[i]);
		return;
	}
	for (const key of Object.keys(object).filter((key2) => !SKIP_JS_BUILTINS.has(key2))) callback(key, object[key]);
}
function _mergeDeep(dest, source, copyUndefined = true, makeCopyOfSimpleObjects = false) {
	if (!_exists(source)) return;
	_iterateObject(source, (key, sourceValue) => {
		let destValue = dest[key];
		if (destValue === sourceValue) return;
		if (makeCopyOfSimpleObjects) {
			if (destValue == null && sourceValue != null) {
				if (typeof sourceValue === "object" && sourceValue.constructor === Object) {
					destValue = {};
					dest[key] = destValue;
				}
			}
		}
		if (_isNonNullObject(sourceValue) && _isNonNullObject(destValue) && !Array.isArray(destValue)) _mergeDeep(destValue, sourceValue, copyUndefined, makeCopyOfSimpleObjects);
		else if (copyUndefined || sourceValue !== void 0) dest[key] = sourceValue;
	});
}
function _getValueUsingField(data, field, fieldContainsDots) {
	if (!field || !data) return;
	if (!fieldContainsDots) return data[field];
	const fields = field.split(".");
	let currentObject = data;
	for (let i = 0; i < fields.length; i++) {
		if (currentObject == null) return;
		currentObject = currentObject[fields[i]];
	}
	return currentObject;
}
function _isNonNullObject(value) {
	return typeof value === "object" && value !== null;
}
var _GlobalGridOptions = class _GlobalGridOptions$1 {
	static applyGlobalGridOptions(providedOptions) {
		if (!_GlobalGridOptions$1.gridOptions) return { ...providedOptions };
		let mergedGridOps = {};
		_mergeDeep(mergedGridOps, _GlobalGridOptions$1.gridOptions, true, true);
		if (_GlobalGridOptions$1.mergeStrategy === "deep") _mergeDeep(mergedGridOps, providedOptions, true, true);
		else mergedGridOps = {
			...mergedGridOps,
			...providedOptions
		};
		if (_GlobalGridOptions$1.gridOptions.context) mergedGridOps.context = _GlobalGridOptions$1.gridOptions.context;
		if (providedOptions.context) {
			if (_GlobalGridOptions$1.mergeStrategy === "deep" && mergedGridOps.context) _mergeDeep(providedOptions.context, mergedGridOps.context, true, true);
			mergedGridOps.context = providedOptions.context;
		}
		return mergedGridOps;
	}
};
_GlobalGridOptions.gridOptions = void 0;
_GlobalGridOptions.mergeStrategy = "shallow";
var GlobalGridOptions = _GlobalGridOptions;
var GRID_OPTION_DEFAULTS = {
	suppressContextMenu: false,
	preventDefaultOnContextMenu: false,
	allowContextMenuWithControlKey: false,
	suppressMenuHide: true,
	enableBrowserTooltips: false,
	tooltipTrigger: "hover",
	tooltipShowDelay: 2e3,
	tooltipHideDelay: 1e4,
	tooltipMouseTrack: false,
	tooltipShowMode: "standard",
	tooltipInteraction: false,
	copyHeadersToClipboard: false,
	copyGroupHeadersToClipboard: false,
	clipboardDelimiter: "	",
	suppressCopyRowsToClipboard: false,
	suppressCopySingleCellRanges: false,
	suppressLastEmptyLineOnPaste: false,
	suppressClipboardPaste: false,
	suppressClipboardApi: false,
	suppressCutToClipboard: false,
	maintainColumnOrder: false,
	enableStrictPivotColumnOrder: false,
	suppressFieldDotNotation: false,
	allowDragFromColumnsToolPanel: false,
	suppressMovableColumns: false,
	suppressColumnMoveAnimation: false,
	suppressMoveWhenColumnDragging: false,
	suppressDragLeaveHidesColumns: false,
	suppressRowGroupHidesColumns: false,
	suppressAutoSize: false,
	autoSizePadding: 20,
	skipHeaderOnAutoSize: false,
	singleClickEdit: false,
	suppressClickEdit: false,
	readOnlyEdit: false,
	stopEditingWhenCellsLoseFocus: false,
	enterNavigatesVertically: false,
	enterNavigatesVerticallyAfterEdit: false,
	enableCellEditingOnBackspace: false,
	undoRedoCellEditing: false,
	undoRedoCellEditingLimit: 10,
	suppressCsvExport: false,
	suppressExcelExport: false,
	cacheQuickFilter: false,
	includeHiddenColumnsInQuickFilter: false,
	excludeChildrenWhenTreeDataFiltering: false,
	enableAdvancedFilter: false,
	includeHiddenColumnsInAdvancedFilter: false,
	enableCharts: false,
	masterDetail: false,
	keepDetailRows: false,
	keepDetailRowsCount: 10,
	detailRowAutoHeight: false,
	tabIndex: 0,
	rowBuffer: 10,
	valueCache: false,
	valueCacheNeverExpires: false,
	enableCellExpressions: false,
	suppressTouch: false,
	suppressFocusAfterRefresh: false,
	suppressBrowserResizeObserver: false,
	suppressPropertyNamesCheck: false,
	suppressChangeDetection: false,
	debug: false,
	suppressLoadingOverlay: false,
	suppressNoRowsOverlay: false,
	pagination: false,
	paginationPageSize: 100,
	paginationPageSizeSelector: true,
	paginationAutoPageSize: false,
	paginateChildRows: false,
	suppressPaginationPanel: false,
	pivotMode: false,
	pivotPanelShow: "never",
	pivotDefaultExpanded: 0,
	pivotSuppressAutoColumn: false,
	suppressExpandablePivotGroups: false,
	functionsReadOnly: false,
	suppressAggFuncInHeader: false,
	alwaysAggregateAtRootLevel: false,
	aggregateOnlyChangedColumns: false,
	suppressAggFilteredOnly: false,
	removePivotHeaderRowWhenSingleValueColumn: false,
	animateRows: true,
	cellFlashDuration: 500,
	cellFadeDuration: 1e3,
	allowShowChangeAfterFilter: false,
	domLayout: "normal",
	ensureDomOrder: false,
	enableRtl: false,
	suppressColumnVirtualisation: false,
	suppressMaxRenderedRowRestriction: false,
	suppressRowVirtualisation: false,
	rowDragManaged: false,
	rowDragInsertDelay: 500,
	suppressRowDrag: false,
	suppressMoveWhenRowDragging: false,
	rowDragEntireRow: false,
	rowDragMultiRow: false,
	embedFullWidthRows: false,
	groupDisplayType: "singleColumn",
	groupDefaultExpanded: 0,
	groupMaintainOrder: false,
	groupSelectsChildren: false,
	groupSuppressBlankHeader: false,
	groupSelectsFiltered: false,
	showOpenedGroup: false,
	groupRemoveSingleChildren: false,
	groupRemoveLowestSingleChildren: false,
	groupHideOpenParents: false,
	groupAllowUnbalanced: false,
	rowGroupPanelShow: "never",
	suppressMakeColumnVisibleAfterUnGroup: false,
	treeData: false,
	rowGroupPanelSuppressSort: false,
	suppressGroupRowsSticky: false,
	rowModelType: "clientSide",
	asyncTransactionWaitMillis: 50,
	suppressModelUpdateAfterUpdateTransaction: false,
	cacheOverflowSize: 1,
	infiniteInitialRowCount: 1,
	serverSideInitialRowCount: 1,
	cacheBlockSize: 100,
	maxBlocksInCache: -1,
	maxConcurrentDatasourceRequests: 2,
	blockLoadDebounceMillis: 0,
	purgeClosedRowNodes: false,
	serverSideSortAllLevels: false,
	serverSideOnlyRefreshFilteredGroups: false,
	serverSidePivotResultFieldSeparator: "_",
	viewportRowModelPageSize: 5,
	viewportRowModelBufferSize: 5,
	alwaysShowHorizontalScroll: false,
	alwaysShowVerticalScroll: false,
	debounceVerticalScrollbar: false,
	suppressHorizontalScroll: false,
	suppressScrollOnNewData: false,
	suppressScrollWhenPopupsAreOpen: false,
	suppressAnimationFrame: false,
	suppressMiddleClickScrolls: false,
	suppressPreventDefaultOnMouseWheel: false,
	rowMultiSelectWithClick: false,
	suppressRowDeselection: false,
	suppressRowClickSelection: false,
	suppressCellFocus: false,
	suppressHeaderFocus: false,
	suppressMultiRangeSelection: false,
	enableCellTextSelection: false,
	enableRangeSelection: false,
	enableRangeHandle: false,
	enableFillHandle: false,
	fillHandleDirection: "xy",
	suppressClearOnFillReduction: false,
	accentedSort: false,
	unSortIcon: false,
	suppressMultiSort: false,
	alwaysMultiSort: false,
	suppressMaintainUnsortedOrder: false,
	suppressRowHoverHighlight: false,
	suppressRowTransform: false,
	columnHoverHighlight: false,
	deltaSort: false,
	enableGroupEdit: false,
	groupLockGroupColumns: 0,
	serverSideEnableClientSideSort: false,
	suppressServerSideFullWidthLoadingRow: false,
	pivotMaxGeneratedColumns: -1,
	columnMenu: "new",
	reactiveCustomComponents: true,
	suppressSetFilterByDefault: false,
	rowNumbers: false,
	enableFilterHandlers: false
};
function _toggleAriaAttribute(element, attribute, value) {
	if (value == null || typeof value === "string" && value == "") _removeAriaAttribute(element, attribute);
	else _setAriaAttribute(element, attribute, value);
}
function _setAriaAttribute(element, attribute, value) {
	element.setAttribute(_ariaAttributeName(attribute), value.toString());
}
function _removeAriaAttribute(element, attribute) {
	element.removeAttribute(_ariaAttributeName(attribute));
}
function _ariaAttributeName(attribute) {
	return `aria-${attribute}`;
}
function _setAriaRole(element, role) {
	if (role) element.setAttribute("role", role);
	else element.removeAttribute("role");
}
function _getAriaSortState(sortDirection) {
	let sort;
	if (sortDirection === "asc") sort = "ascending";
	else if (sortDirection === "desc") sort = "descending";
	else if (sortDirection === "mixed") sort = "other";
	else sort = "none";
	return sort;
}
function _getAriaLabel(element) {
	return element.getAttribute("aria-label");
}
function _setAriaLabel(element, label) {
	_toggleAriaAttribute(element, "label", label);
}
function _setAriaLabelledBy(element, labelledBy) {
	_toggleAriaAttribute(element, "labelledby", labelledBy);
}
function _setAriaLive(element, live) {
	_toggleAriaAttribute(element, "live", live);
}
function _setAriaAtomic(element, atomic) {
	_toggleAriaAttribute(element, "atomic", atomic);
}
function _setAriaRelevant(element, relevant) {
	_toggleAriaAttribute(element, "relevant", relevant);
}
function _setAriaInvalid(element, invalid) {
	_toggleAriaAttribute(element, "invalid", invalid);
}
function _setAriaHidden(element, hidden) {
	_toggleAriaAttribute(element, "hidden", hidden);
}
function _setAriaExpanded(element, expanded) {
	_setAriaAttribute(element, "expanded", expanded);
}
function _setAriaSetSize(element, setsize) {
	_setAriaAttribute(element, "setsize", setsize);
}
function _setAriaPosInSet(element, position) {
	_setAriaAttribute(element, "posinset", position);
}
function _setAriaMultiSelectable(element, multiSelectable) {
	_setAriaAttribute(element, "multiselectable", multiSelectable);
}
function _setAriaRowCount(element, rowCount) {
	_setAriaAttribute(element, "rowcount", rowCount);
}
function _setAriaRowIndex(element, rowIndex) {
	_setAriaAttribute(element, "rowindex", rowIndex);
}
function _setAriaColCount(element, colCount) {
	_setAriaAttribute(element, "colcount", colCount);
}
function _setAriaColIndex(element, colIndex) {
	_setAriaAttribute(element, "colindex", colIndex);
}
function _setAriaColSpan(element, colSpan) {
	_setAriaAttribute(element, "colspan", colSpan);
}
function _setAriaSort(element, sort) {
	_setAriaAttribute(element, "sort", sort);
}
function _removeAriaSort(element) {
	_removeAriaAttribute(element, "sort");
}
function _setAriaSelected(element, selected) {
	_toggleAriaAttribute(element, "selected", selected);
}
function _setAriaControls(controllerElement, controlledId) {
	_toggleAriaAttribute(controllerElement, "controls", controlledId);
}
function _setAriaControlsAndLabel(controllerElement, controlledElement) {
	_setAriaControls(controllerElement, controlledElement.id);
	_setAriaLabelledBy(controlledElement, controllerElement.id);
}
function _setAriaOwns(ownerElement, ownedId) {
	_toggleAriaAttribute(ownerElement, "owns", ownedId);
}
function _getAriaCheckboxStateName(translate, state) {
	return state === void 0 ? translate("ariaIndeterminate", "indeterminate") : state === true ? translate("ariaChecked", "checked") : translate("ariaUnchecked", "unchecked");
}
var isSafari;
var isFirefox;
var isMacOs;
var isIOS;
var invisibleScrollbar;
var browserScrollbarWidth;
var maxDivHeight;
function _isBrowserSafari() {
	if (isSafari === void 0) isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
	return isSafari;
}
function _isBrowserFirefox() {
	if (isFirefox === void 0) isFirefox = /(firefox)/i.test(navigator.userAgent);
	return isFirefox;
}
function _isMacOsUserAgent() {
	if (isMacOs === void 0) isMacOs = /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform);
	return isMacOs;
}
function _isIOSUserAgent() {
	if (isIOS === void 0) isIOS = /iPad|iPhone|iPod/.test(navigator.platform) || navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1;
	return isIOS;
}
function _getTabIndex(el) {
	if (!el) return null;
	const numberTabIndex = el.tabIndex;
	const tabIndex = el.getAttribute("tabIndex");
	if (numberTabIndex === -1 && (tabIndex === null || tabIndex === "" && !_isBrowserFirefox())) return null;
	return numberTabIndex.toString();
}
function _getMaxDivHeight() {
	if (maxDivHeight !== void 0) return maxDivHeight;
	if (!document.body) return -1;
	let res = 1e6;
	const testUpTo = _isBrowserFirefox() ? 6e6 : 1e9;
	const div = document.createElement("div");
	document.body.appendChild(div);
	while (true) {
		const test = res * 2;
		div.style.height = test + "px";
		if (test > testUpTo || div.clientHeight !== test) break;
		else res = test;
	}
	document.body.removeChild(div);
	maxDivHeight = res;
	return res;
}
function _getScrollbarWidth() {
	if (browserScrollbarWidth == null) initScrollbarWidthAndVisibility();
	return browserScrollbarWidth;
}
function initScrollbarWidthAndVisibility() {
	const body = document.body;
	const div = document.createElement("div");
	div.style.width = div.style.height = "100px";
	div.style.opacity = "0";
	div.style.overflow = "scroll";
	div.style.msOverflowStyle = "scrollbar";
	div.style.position = "absolute";
	body.appendChild(div);
	let width = div.offsetWidth - div.clientWidth;
	if (width === 0 && div.clientWidth === 0) width = null;
	if (div.parentNode) div.parentNode.removeChild(div);
	if (width != null) {
		browserScrollbarWidth = width;
		invisibleScrollbar = width === 0;
	}
}
function _isInvisibleScrollbar() {
	if (invisibleScrollbar == null) initScrollbarWidthAndVisibility();
	return invisibleScrollbar;
}
var FOCUSABLE_SELECTOR = "[tabindex], input, select, button, textarea, [href]";
var FOCUSABLE_EXCLUDE = "[disabled], .ag-disabled:not(.ag-button), .ag-disabled *";
function _isFocusableFormField(element) {
	const matches = Element.prototype.matches || Element.prototype.msMatchesSelector;
	const isFocusable = matches.call(element, "input, select, button, textarea");
	const isNotFocusable = matches.call(element, FOCUSABLE_EXCLUDE);
	const isElementVisible = _isVisible(element);
	return isFocusable && !isNotFocusable && isElementVisible;
}
function _setDisplayed(element, displayed, options = {}) {
	const { skipAriaHidden } = options;
	element.classList.toggle("ag-hidden", !displayed);
	if (!skipAriaHidden) _setAriaHidden(element, !displayed);
}
function _setVisible(element, visible, options = {}) {
	const { skipAriaHidden } = options;
	element.classList.toggle("ag-invisible", !visible);
	if (!skipAriaHidden) _setAriaHidden(element, !visible);
}
function _setDisabled(element, disabled) {
	const attributeName = "disabled";
	const addOrRemoveDisabledAttribute = disabled ? (e) => e.setAttribute(attributeName, "") : (e) => e.removeAttribute(attributeName);
	addOrRemoveDisabledAttribute(element);
	const inputs = element.querySelectorAll("input") ?? [];
	for (const input of inputs) addOrRemoveDisabledAttribute(input);
}
function _isElementChildOfClass(element, cls, maxNest) {
	let counter = 0;
	while (element) {
		if (element.classList.contains(cls)) return true;
		element = element.parentElement;
		if (typeof maxNest == "number") {
			if (++counter > maxNest) break;
		} else if (element === maxNest) break;
	}
	return false;
}
function _getElementSize(el) {
	const { height, width, borderTopWidth, borderRightWidth, borderBottomWidth, borderLeftWidth, paddingTop, paddingRight, paddingBottom, paddingLeft, marginTop, marginRight, marginBottom, marginLeft, boxSizing } = window.getComputedStyle(el);
	return {
		height: parseFloat(height || "0"),
		width: parseFloat(width || "0"),
		borderTopWidth: parseFloat(borderTopWidth || "0"),
		borderRightWidth: parseFloat(borderRightWidth || "0"),
		borderBottomWidth: parseFloat(borderBottomWidth || "0"),
		borderLeftWidth: parseFloat(borderLeftWidth || "0"),
		paddingTop: parseFloat(paddingTop || "0"),
		paddingRight: parseFloat(paddingRight || "0"),
		paddingBottom: parseFloat(paddingBottom || "0"),
		paddingLeft: parseFloat(paddingLeft || "0"),
		marginTop: parseFloat(marginTop || "0"),
		marginRight: parseFloat(marginRight || "0"),
		marginBottom: parseFloat(marginBottom || "0"),
		marginLeft: parseFloat(marginLeft || "0"),
		boxSizing
	};
}
function _getInnerHeight(el) {
	const size = _getElementSize(el);
	if (size.boxSizing === "border-box") return size.height - size.paddingTop - size.paddingBottom;
	return size.height;
}
function _getInnerWidth(el) {
	const size = _getElementSize(el);
	if (size.boxSizing === "border-box") return size.width - size.paddingLeft - size.paddingRight;
	return size.width;
}
function _getAbsoluteHeight(el) {
	const { height, marginBottom, marginTop } = _getElementSize(el);
	return Math.floor(height + marginBottom + marginTop);
}
function _getAbsoluteWidth(el) {
	const { width, marginLeft, marginRight } = _getElementSize(el);
	return Math.floor(width + marginLeft + marginRight);
}
function _getElementRectWithOffset(el) {
	const offsetElementRect = el.getBoundingClientRect();
	const { borderTopWidth, borderLeftWidth, borderRightWidth, borderBottomWidth } = _getElementSize(el);
	return {
		top: offsetElementRect.top + (borderTopWidth || 0),
		left: offsetElementRect.left + (borderLeftWidth || 0),
		right: offsetElementRect.right + (borderRightWidth || 0),
		bottom: offsetElementRect.bottom + (borderBottomWidth || 0)
	};
}
function _getScrollLeft(element, rtl) {
	let scrollLeft = element.scrollLeft;
	if (rtl) scrollLeft = Math.abs(scrollLeft);
	return scrollLeft;
}
function _setScrollLeft(element, value, rtl) {
	if (rtl) value *= -1;
	element.scrollLeft = value;
}
function _clearElement(el) {
	while (el && el.firstChild) el.removeChild(el.firstChild);
}
function _removeFromParent(node) {
	if (node && node.parentNode) node.parentNode.removeChild(node);
}
function _isInDOM(element) {
	return !!element.offsetParent;
}
function _isVisible(element) {
	const el = element;
	if (el.checkVisibility) return el.checkVisibility({ checkVisibilityCSS: true });
	return !(!_isInDOM(element) || window.getComputedStyle(element).visibility !== "visible");
}
function _loadTemplate(template) {
	const tempDiv = document.createElement("div");
	tempDiv.innerHTML = (template || "").trim();
	return tempDiv.firstChild;
}
function _ensureDomOrder(eContainer, eChild, eChildBefore) {
	if (eChildBefore && eChildBefore.nextSibling === eChild) return;
	if (!eContainer.firstChild) eContainer.appendChild(eChild);
	else if (eChildBefore) if (eChildBefore.nextSibling) eContainer.insertBefore(eChild, eChildBefore.nextSibling);
	else eContainer.appendChild(eChild);
	else if (eContainer.firstChild && eContainer.firstChild !== eChild) eContainer.insertAdjacentElement("afterbegin", eChild);
}
function _setDomChildOrder(eContainer, orderedChildren) {
	for (let i = 0; i < orderedChildren.length; i++) {
		const correctCellAtIndex = orderedChildren[i];
		const actualCellAtIndex = eContainer.children[i];
		if (actualCellAtIndex !== correctCellAtIndex) eContainer.insertBefore(correctCellAtIndex, actualCellAtIndex);
	}
}
function _camelCaseToHyphenated(camelCase) {
	return camelCase.replace(/[A-Z]/g, (s) => `-${s.toLocaleLowerCase()}`);
}
function _addStylesToElement(eElement, styles) {
	if (!styles) return;
	for (const key of Object.keys(styles)) {
		const value = styles[key];
		if (!key || !key.length || value == null) continue;
		const parsedKey = _camelCaseToHyphenated(key);
		const valueAsString = value.toString();
		const parsedValue = valueAsString.replace(/\s*!important/g, "");
		const priority = parsedValue.length != valueAsString.length ? "important" : void 0;
		eElement.style.setProperty(parsedKey, parsedValue, priority);
	}
}
function _isElementOverflowingCallback(getElement2) {
	return () => {
		const element = getElement2();
		if (!element) return true;
		return _isHorizontalScrollShowing(element) || _isVerticalScrollShowing(element);
	};
}
function _isHorizontalScrollShowing(element) {
	return element.clientWidth < element.scrollWidth;
}
function _isVerticalScrollShowing(element) {
	return element.clientHeight < element.scrollHeight;
}
function _setElementWidth(element, width) {
	if (width === "flex") {
		element.style.removeProperty("width");
		element.style.removeProperty("minWidth");
		element.style.removeProperty("maxWidth");
		element.style.flex = "1 1 auto";
	} else _setFixedWidth(element, width);
}
function _setFixedWidth(element, width) {
	width = _formatSize(width);
	element.style.width = width;
	element.style.maxWidth = width;
	element.style.minWidth = width;
}
function _setFixedHeight(element, height) {
	height = _formatSize(height);
	element.style.height = height;
	element.style.maxHeight = height;
	element.style.minHeight = height;
}
function _formatSize(size) {
	return typeof size === "number" ? `${size}px` : size;
}
function _isNodeOrElement(o) {
	return o instanceof Node || o instanceof HTMLElement;
}
function _addOrRemoveAttribute(element, name, value) {
	if (value == null || value === "") element.removeAttribute(name);
	else element.setAttribute(name, value.toString());
}
function _observeResize(beans, element, callback) {
	const ResizeObserverImpl = _getWindow(beans).ResizeObserver;
	const resizeObserver = ResizeObserverImpl ? new ResizeObserverImpl(callback) : null;
	resizeObserver?.observe(element);
	return () => resizeObserver?.disconnect();
}
function _requestAnimationFrame(beans, callback) {
	const win = _getWindow(beans);
	if (win.requestAnimationFrame) win.requestAnimationFrame(callback);
	else if (win.webkitRequestAnimationFrame) win.webkitRequestAnimationFrame(callback);
	else win.setTimeout(callback, 0);
}
var DataRefAttribute = "data-ref";
var whitespaceNode;
function getWhitespaceNode() {
	whitespaceNode ?? (whitespaceNode = document.createTextNode(" "));
	return whitespaceNode.cloneNode();
}
function _createElement(params) {
	const { attrs, children, cls, ref: ref$1, role, tag } = params;
	const element = document.createElement(tag);
	if (cls) element.className = cls;
	if (ref$1) element.setAttribute(DataRefAttribute, ref$1);
	if (role) element.setAttribute("role", role);
	if (attrs) for (const key of Object.keys(attrs)) element.setAttribute(key, attrs[key]);
	if (children) if (typeof children === "string") element.textContent = children;
	else {
		let addFirstWhitespace = true;
		for (const child of children) if (child) if (typeof child === "string") {
			element.appendChild(document.createTextNode(child));
			addFirstWhitespace = false;
		} else if (typeof child === "function") element.appendChild(child());
		else {
			if (addFirstWhitespace) {
				element.appendChild(getWhitespaceNode());
				addFirstWhitespace = false;
			}
			element.append(_createElement(child));
			element.appendChild(getWhitespaceNode());
		}
	}
	return element;
}
var doOnceFlags = {};
function _doOnce(func, key) {
	if (doOnceFlags[key]) return;
	func();
	doOnceFlags[key] = true;
}
function _logIfDebug(gos, message, ...args) {
	if (gos.get("debug")) console.log("AG Grid: " + message, ...args);
}
function _warnOnce(msg, ...args) {
	_doOnce(() => console.warn("AG Grid: " + msg, ...args), msg + args?.join(""));
}
function _errorOnce(msg, ...args) {
	_doOnce(() => console.error("AG Grid: " + msg, ...args), msg + args?.join(""));
}
var batchedCallsSetTimeout = {
	pending: false,
	funcs: []
};
var batchedCallsRaf = {
	pending: false,
	funcs: []
};
function _batchCall(func, mode = "setTimeout", beans) {
	const batch = mode === "raf" ? batchedCallsRaf : batchedCallsSetTimeout;
	batch.funcs.push(func);
	if (batch.pending) return;
	batch.pending = true;
	const runBatch = () => {
		const funcsCopy = batch.funcs.slice();
		batch.funcs.length = 0;
		batch.pending = false;
		funcsCopy.forEach((func2) => func2());
	};
	if (mode === "raf") _requestAnimationFrame(beans, runBatch);
	else window.setTimeout(runBatch, 0);
}
function _debounce(bean, func, delay) {
	let timeout;
	return function(...args) {
		const context = this;
		window.clearTimeout(timeout);
		timeout = window.setTimeout(function() {
			if (bean.isAlive()) func.apply(context, args);
		}, delay);
	};
}
function _throttle(func, wait) {
	let previousCall = 0;
	return function(...args) {
		const context = this;
		const currentCall = Date.now();
		if (currentCall - previousCall < wait) return;
		previousCall = currentCall;
		func.apply(context, args);
	};
}
function _waitUntil(condition, callback, timeout = 100, timeoutMessage) {
	const timeStamp = Date.now();
	let interval = null;
	let executed = false;
	const internalCallback = () => {
		const reachedTimeout = Date.now() - timeStamp > timeout;
		if (condition() || reachedTimeout) {
			callback();
			executed = true;
			if (interval != null) {
				window.clearInterval(interval);
				interval = null;
			}
			if (reachedTimeout && timeoutMessage) _warnOnce(timeoutMessage);
		}
	};
	internalCallback();
	if (!executed) interval = window.setInterval(internalCallback, 10);
}
var BASE_URL = "https://www.ag-grid.com";
var VERSION = "34.1.1";
var MAX_URL_LENGTH = 2e3;
var MIN_PARAM_LENGTH = 100;
var VERSION_PARAM_NAME = "_version_";
var validation = null;
var baseDocLink = `${BASE_URL}/javascript-data-grid`;
function provideValidationServiceLogger(logger) {
	validation = logger;
}
function setValidationDocLink(docLink) {
	baseDocLink = docLink;
}
function getErrorParts(id, args, defaultMessage) {
	return validation?.getConsoleMessage(id, args) ?? [minifiedLog(id, args, defaultMessage)];
}
function getMsgOrDefault(logger, id, args, defaultMessage) {
	logger(`error #${id}`, ...getErrorParts(id, args, defaultMessage));
}
function stringifyObject(inputObj) {
	if (!inputObj) return String(inputObj);
	const object = {};
	for (const prop of Object.keys(inputObj)) if (typeof inputObj[prop] !== "object" && typeof inputObj[prop] !== "function") object[prop] = inputObj[prop];
	return JSON.stringify(object);
}
function stringifyValue(value) {
	let output = value;
	if (value instanceof Error) output = value.toString();
	else if (typeof value === "object") output = stringifyObject(value);
	return output;
}
function toStringWithNullUndefined(str) {
	return str === void 0 ? "undefined" : str === null ? "null" : str;
}
function getParamsUrl(baseUrl, params) {
	return `${baseUrl}?${params.toString()}`;
}
function truncateUrl(baseUrl, params, maxLength) {
	const sortedParams = Array.from(params.entries()).sort((a, b) => b[1].length - a[1].length);
	let url = getParamsUrl(baseUrl, params);
	for (const [key, value] of sortedParams) {
		if (key === VERSION_PARAM_NAME) continue;
		const excessLength = url.length - maxLength;
		if (excessLength <= 0) break;
		const ellipse = "...";
		const truncateAmount = excessLength + 3;
		const truncatedValue = value.length - truncateAmount > MIN_PARAM_LENGTH ? value.slice(0, value.length - truncateAmount) + ellipse : value.slice(0, MIN_PARAM_LENGTH) + ellipse;
		params.set(key, truncatedValue);
		url = getParamsUrl(baseUrl, params);
	}
	return url;
}
function getErrorLink(errorNum, args) {
	const params = new URLSearchParams();
	params.append(VERSION_PARAM_NAME, VERSION);
	if (args) for (const key of Object.keys(args)) params.append(key, stringifyValue(args[key]));
	const baseUrl = `${baseDocLink}/errors/${errorNum}`;
	const url = getParamsUrl(baseUrl, params);
	return url.length <= MAX_URL_LENGTH ? url : truncateUrl(baseUrl, params, MAX_URL_LENGTH);
}
var minifiedLog = (errorNum, args, defaultMessage) => {
	const errorLink = getErrorLink(errorNum, args);
	return `${defaultMessage ? defaultMessage + " \n" : ""}Visit ${errorLink}${defaultMessage ? "" : " \n  Alternatively register the ValidationModule to see the full message in the console."}`;
};
function _warn(...args) {
	getMsgOrDefault(_warnOnce, args[0], args[1]);
}
function _error(...args) {
	getMsgOrDefault(_errorOnce, args[0], args[1]);
}
function _logPreInitErr(id, args, defaultMessage) {
	getMsgOrDefault(_errorOnce, id, args, defaultMessage);
}
function getErrMsg(defaultMessage, args) {
	const id = args[0];
	return `error #${id} ` + getErrorParts(id, args[1], defaultMessage).join(" ");
}
function _errMsg(...args) {
	return getErrMsg(void 0, args);
}
function isRowModelType(gos, rowModelType) {
	return gos.get("rowModelType") === rowModelType;
}
function _isClientSideRowModel(gos, rowModel) {
	return isRowModelType(gos, "clientSide");
}
function _isServerSideRowModel(gos, rowModel) {
	return isRowModelType(gos, "serverSide");
}
function _isDomLayout(gos, domLayout) {
	return gos.get("domLayout") === domLayout;
}
function _isRowSelection(gos) {
	return _getRowSelectionMode(gos) !== void 0;
}
function _isGetRowHeightFunction(gos) {
	return typeof gos.get("getRowHeight") === "function";
}
function _shouldMaintainColumnOrder(gos, isPivotColumns) {
	if (isPivotColumns) return !gos.get("enableStrictPivotColumnOrder");
	return gos.get("maintainColumnOrder");
}
function _getRowHeightForNode(beans, rowNode, allowEstimate = false, defaultRowHeight) {
	const { gos, environment } = beans;
	if (defaultRowHeight == null) defaultRowHeight = environment.getDefaultRowHeight();
	if (_isGetRowHeightFunction(gos)) {
		if (allowEstimate) return {
			height: defaultRowHeight,
			estimated: true
		};
		const params = {
			node: rowNode,
			data: rowNode.data
		};
		const height = gos.getCallback("getRowHeight")(params);
		if (isNumeric(height)) {
			if (height === 0) _warn(23);
			return {
				height: Math.max(1, height),
				estimated: false
			};
		}
	}
	if (rowNode.detail && gos.get("masterDetail")) return getMasterDetailRowHeight(gos);
	const gridOptionsRowHeight = gos.get("rowHeight");
	return {
		height: gridOptionsRowHeight && isNumeric(gridOptionsRowHeight) ? gridOptionsRowHeight : defaultRowHeight,
		estimated: false
	};
}
function getMasterDetailRowHeight(gos) {
	if (gos.get("detailRowAutoHeight")) return {
		height: 1,
		estimated: false
	};
	const defaultRowHeight = gos.get("detailRowHeight");
	if (isNumeric(defaultRowHeight)) return {
		height: defaultRowHeight,
		estimated: false
	};
	return {
		height: 300,
		estimated: false
	};
}
function _getRowHeightAsNumber(beans) {
	const { environment, gos } = beans;
	const gridOptionsRowHeight = gos.get("rowHeight");
	if (!gridOptionsRowHeight || _missing(gridOptionsRowHeight)) return environment.getDefaultRowHeight();
	const rowHeight = environment.refreshRowHeightVariable();
	if (rowHeight !== -1) return rowHeight;
	_warn(24);
	return environment.getDefaultRowHeight();
}
function isNumeric(value) {
	return !isNaN(value) && typeof value === "number" && isFinite(value);
}
function _getDomData(gos, element, key) {
	const domData = element[gos.getDomDataKey()];
	return domData ? domData[key] : void 0;
}
function _setDomData(gos, element, key, value) {
	const domDataKey = gos.getDomDataKey();
	let domData = element[domDataKey];
	if (_missing(domData)) {
		domData = {};
		element[domDataKey] = domData;
	}
	domData[key] = value;
}
function _getDocument(beans) {
	const { gos, eGridDiv } = beans;
	let result = null;
	const gridOptionsGetDocument = gos.get("getDocument");
	if (gridOptionsGetDocument && _exists(gridOptionsGetDocument)) result = gridOptionsGetDocument();
	else if (eGridDiv) result = eGridDiv.ownerDocument;
	if (result && _exists(result)) return result;
	return document;
}
function _getWindow(beans) {
	return _getDocument(beans).defaultView || window;
}
function _getRootNode(beans) {
	return beans.eGridDiv.getRootNode();
}
function _getActiveDomElement(beans) {
	return _getRootNode(beans).activeElement;
}
function _getPageBody(beans) {
	let rootNode = null;
	let targetEl = null;
	try {
		rootNode = _getDocument(beans).fullscreenElement;
	} catch (e) {} finally {
		if (!rootNode) rootNode = _getRootNode(beans);
		const body = rootNode.querySelector("body");
		if (body) targetEl = body;
		else if (rootNode instanceof ShadowRoot) targetEl = rootNode;
		else if (rootNode instanceof Document) targetEl = rootNode?.documentElement;
		else targetEl = rootNode;
	}
	return targetEl;
}
function _getBodyWidth(beans) {
	return _getPageBody(beans)?.clientWidth ?? (window.innerWidth || -1);
}
function _getBodyHeight(beans) {
	return _getPageBody(beans)?.clientHeight ?? (window.innerHeight || -1);
}
function _anchorElementToMouseMoveEvent(element, mouseMoveEvent, beans) {
	const height = element.getBoundingClientRect().height;
	const browserWidth = _getBodyWidth(beans) - 2;
	const browserHeight = _getBodyHeight(beans) - 2;
	if (!element.offsetParent) return;
	const offsetParentSize = _getElementRectWithOffset(element.offsetParent);
	const { clientY, clientX } = mouseMoveEvent;
	let top = clientY - offsetParentSize.top - height / 2;
	let left = clientX - offsetParentSize.left - 10;
	const eDocument = _getDocument(beans);
	const win = eDocument.defaultView || window;
	const windowScrollY = win.pageYOffset || eDocument.documentElement.scrollTop;
	const windowScrollX = win.pageXOffset || eDocument.documentElement.scrollLeft;
	if (browserWidth > 0 && left + element.clientWidth > browserWidth + windowScrollX) left = browserWidth + windowScrollX - element.clientWidth;
	if (left < 0) left = 0;
	if (browserHeight > 0 && top + element.clientHeight > browserHeight + windowScrollY) top = browserHeight + windowScrollY - element.clientHeight;
	if (top < 0) top = 0;
	element.style.left = `${left}px`;
	element.style.top = `${top}px`;
}
function _isNothingFocused(beans) {
	const activeEl = _getActiveDomElement(beans);
	return activeEl === null || activeEl === _getDocument(beans).body;
}
function _isAnimateRows(gos) {
	if (gos.get("ensureDomOrder")) return false;
	return gos.get("animateRows");
}
function _isGroupRowsSticky(gos) {
	if (gos.get("paginateChildRows") || gos.get("groupHideOpenParents") || _isDomLayout(gos, "print")) return false;
	return true;
}
function _isColumnsSortingCoupledToGroup(gos) {
	return !gos.get("autoGroupColumnDef")?.comparator && !gos.get("treeData");
}
function _getGroupAggFiltering(gos) {
	const userValue = gos.get("groupAggFiltering");
	if (typeof userValue === "function") return gos.getCallback("groupAggFiltering");
	if (userValue === true) return () => true;
}
function _getGrandTotalRow(gos) {
	return gos.get("grandTotalRow");
}
function _isGroupUseEntireRow(gos, pivotMode) {
	if (pivotMode) return false;
	return gos.get("groupDisplayType") === "groupRows";
}
function _isFullWidthGroupRow(gos, node, pivotMode) {
	return !!node.group && !node.footer && _isGroupUseEntireRow(gos, pivotMode);
}
function _getRowIdCallback(gos) {
	const getRowId = gos.getCallback("getRowId");
	if (getRowId === void 0) return getRowId;
	return (params) => {
		let id = getRowId(params);
		if (typeof id !== "string") {
			_doOnce(() => _warn(25, { id }), "getRowIdString");
			id = String(id);
		}
		return id;
	};
}
function _getCheckboxes(selection) {
	return selection?.checkboxes ?? true;
}
function _getHeaderCheckbox(selection) {
	return selection?.mode === "multiRow" && (selection.headerCheckbox ?? true);
}
function _getCheckboxLocation(rowSelection) {
	if (typeof rowSelection !== "object") return;
	return rowSelection.checkboxLocation ?? "selectionColumn";
}
function _getHideDisabledCheckboxes(selection) {
	return selection?.hideDisabledCheckboxes ?? false;
}
function _isUsingNewRowSelectionAPI(gos) {
	return typeof gos.get("rowSelection") !== "string";
}
function _isCellSelectionEnabled(gos) {
	const selection = gos.get("cellSelection");
	return selection !== void 0 ? !!selection : gos.get("enableRangeSelection");
}
function _getEnableClickSelection(gos) {
	const selection = gos.get("rowSelection") ?? "single";
	if (typeof selection === "string") {
		const suppressRowClickSelection = gos.get("suppressRowClickSelection");
		const suppressRowDeselection = gos.get("suppressRowDeselection");
		if (suppressRowClickSelection && suppressRowDeselection) return false;
		else if (suppressRowClickSelection) return "enableDeselection";
		else if (suppressRowDeselection) return "enableSelection";
		else return true;
	}
	return selection.mode === "singleRow" || selection.mode === "multiRow" ? selection.enableClickSelection ?? false : false;
}
function _getEnableSelection(gos) {
	const enableClickSelection = _getEnableClickSelection(gos);
	return enableClickSelection === true || enableClickSelection === "enableSelection";
}
function _getEnableDeselection(gos) {
	const enableClickSelection = _getEnableClickSelection(gos);
	return enableClickSelection === true || enableClickSelection === "enableDeselection";
}
function _getIsRowSelectable(gos) {
	const selection = gos.get("rowSelection");
	if (typeof selection === "string") return gos.get("isRowSelectable");
	return selection?.isRowSelectable;
}
function _getRowSelectionMode(arg) {
	const selection = "beanName" in arg && arg.beanName === "gos" ? arg.get("rowSelection") : arg.rowSelection;
	if (typeof selection === "string") switch (selection) {
		case "multiple": return "multiRow";
		case "single": return "singleRow";
		default: return;
	}
	switch (selection?.mode) {
		case "multiRow":
		case "singleRow": return selection.mode;
		default: return;
	}
}
function _isMultiRowSelection(arg) {
	return _getRowSelectionMode(arg) === "multiRow";
}
function _getEnableSelectionWithoutKeys(gos) {
	const selection = gos.get("rowSelection");
	if (typeof selection === "string") return gos.get("rowMultiSelectWithClick");
	return selection?.enableSelectionWithoutKeys ?? false;
}
function _getGroupSelection(gos) {
	const selection = gos.get("rowSelection");
	if (typeof selection === "string") {
		const groupSelectsChildren = gos.get("groupSelectsChildren");
		const groupSelectsFiltered = gos.get("groupSelectsFiltered");
		if (groupSelectsChildren && groupSelectsFiltered) return "filteredDescendants";
		else if (groupSelectsChildren) return "descendants";
		else return "self";
	}
	return selection?.mode === "multiRow" ? selection.groupSelects : void 0;
}
function _getSelectAll(gos, defaultValue = true) {
	const rowSelection = gos.get("rowSelection");
	if (typeof rowSelection !== "object") return defaultValue ? "all" : void 0;
	return rowSelection.mode === "multiRow" ? rowSelection.selectAll : "all";
}
function _getGroupSelectsDescendants(gos) {
	const groupSelection = _getGroupSelection(gos);
	return groupSelection === "descendants" || groupSelection === "filteredDescendants";
}
function _getMasterSelects(gos) {
	const rowSelection = gos.get("rowSelection");
	return typeof rowSelection === "object" && rowSelection.masterSelects || "self";
}
function _isSetFilterByDefault(gos) {
	return gos.isModuleRegistered("SetFilter") && !gos.get("suppressSetFilterByDefault");
}
function _isLegacyMenuEnabled(gos) {
	return gos.get("columnMenu") === "legacy";
}
function _isColumnMenuAnchoringEnabled(gos) {
	return !_isLegacyMenuEnabled(gos);
}
function _getCallbackForEvent(eventName) {
	if (!eventName || eventName.length < 2) return eventName;
	return "on" + eventName[0].toUpperCase() + eventName.substring(1);
}
function _combineAttributesAndGridOptions(gridOptions, component, gridOptionsKeys) {
	if (typeof gridOptions !== "object") gridOptions = {};
	const mergedOptions = { ...gridOptions };
	gridOptionsKeys.forEach((key) => {
		const value = component[key];
		if (typeof value !== "undefined") mergedOptions[key] = value;
	});
	return mergedOptions;
}
function _processOnChange(changes, api) {
	if (!changes) return;
	const gridChanges = {};
	let hasChanges = false;
	Object.keys(changes).forEach((key) => {
		gridChanges[key] = changes[key];
		hasChanges = true;
	});
	if (!hasChanges) return;
	const internalUpdateEvent = {
		type: "gridOptionsChanged",
		options: gridChanges
	};
	api.dispatchEvent(internalUpdateEvent);
	const event = {
		type: "componentStateChanged",
		...gridChanges
	};
	api.dispatchEvent(event);
}
function _addGridCommonParams(gos, params) {
	return gos.addGridCommonParams(params);
}
function _getGroupingApproach(gos) {
	if (gos.get("treeData")) {
		if (gos.get("treeDataParentIdField")) return "treeSelfRef";
		if (gos.get("treeDataChildrenField")) return "treeNested";
		return "treePath";
	}
	return "group";
}
var AG_GRID_STOP_PROPAGATION = "__ag_Grid_Stop_Propagation";
var PASSIVE_EVENTS = [
	"touchstart",
	"touchend",
	"touchmove",
	"touchcancel",
	"scroll"
];
var NON_PASSIVE_EVENTS = ["wheel"];
var supports = {};
function _stopPropagationForAgGrid(event) {
	event[AG_GRID_STOP_PROPAGATION] = true;
}
function _isStopPropagationForAgGrid(event) {
	return event[AG_GRID_STOP_PROPAGATION] === true;
}
var _isEventSupported = /* @__PURE__ */ (() => {
	const tags = {
		select: "input",
		change: "input",
		submit: "form",
		reset: "form",
		error: "img",
		load: "img",
		abort: "img"
	};
	const eventChecker = (eventName) => {
		if (typeof supports[eventName] === "boolean") return supports[eventName];
		const el = document.createElement(tags[eventName] || "div");
		eventName = "on" + eventName;
		return supports[eventName] = eventName in el;
	};
	return eventChecker;
})();
function _getCtrlForEventTarget(gos, eventTarget, type) {
	let sourceElement = eventTarget;
	while (sourceElement) {
		const renderedComp = _getDomData(gos, sourceElement, type);
		if (renderedComp) return renderedComp;
		sourceElement = sourceElement.parentElement;
	}
	return null;
}
function _isElementInEventPath(element, event) {
	if (!event || !element) return false;
	return _getEventPath(event).indexOf(element) >= 0;
}
function _createEventPath(event) {
	const res = [];
	let pointer = event.target;
	while (pointer) {
		res.push(pointer);
		pointer = pointer.parentElement;
	}
	return res;
}
function _getEventPath(event) {
	const eventNoType = event;
	if (eventNoType.path) return eventNoType.path;
	if (eventNoType.composedPath) return eventNoType.composedPath();
	return _createEventPath(eventNoType);
}
function _addSafePassiveEventListener(frameworkOverrides, eElement, event, listener) {
	const passive = getPassiveStateForEvent(event);
	let options;
	if (passive != null) options = { passive };
	if (frameworkOverrides && frameworkOverrides.addEventListener) frameworkOverrides.addEventListener(eElement, event, listener, options);
}
var getPassiveStateForEvent = (event) => {
	const isPassive = PASSIVE_EVENTS.includes(event);
	const isNonPassive = NON_PASSIVE_EVENTS.includes(event);
	if (isPassive) return true;
	if (isNonPassive) return false;
};
var BeanStub = class {
	constructor() {
		this.destroyFunctions = [];
		this.destroyed = false;
		this.__v_skip = true;
		this.propertyListenerId = 0;
		this.lastChangeSetIdLookup = {};
		this.isAlive = () => !this.destroyed;
	}
	preWireBeans(beans) {
		this.beans = beans;
		this.stubContext = beans.context;
		this.eventSvc = beans.eventSvc;
		this.gos = beans.gos;
	}
	destroy() {
		const { destroyFunctions } = this;
		for (let i = 0; i < destroyFunctions.length; i++) destroyFunctions[i]();
		destroyFunctions.length = 0;
		this.destroyed = true;
		this.dispatchLocalEvent({ type: "destroyed" });
	}
	addEventListener(eventType, listener, async) {
		if (!this.localEventService) this.localEventService = new LocalEventService();
		this.localEventService.addEventListener(eventType, listener, async);
	}
	removeEventListener(eventType, listener, async) {
		this.localEventService?.removeEventListener(eventType, listener, async);
	}
	dispatchLocalEvent(event) {
		this.localEventService?.dispatchEvent(event);
	}
	addManagedElementListeners(object, handlers) {
		return this._setupListeners(object, handlers);
	}
	addManagedEventListeners(handlers) {
		return this._setupListeners(this.eventSvc, handlers);
	}
	addManagedListeners(object, handlers) {
		return this._setupListeners(object, handlers);
	}
	_setupListeners(object, handlers) {
		const destroyFuncs = [];
		for (const k of Object.keys(handlers)) {
			const handler = handlers[k];
			if (handler) destroyFuncs.push(this._setupListener(object, k, handler));
		}
		return destroyFuncs;
	}
	_setupListener(object, event, listener) {
		if (this.destroyed) return () => null;
		let destroyFunc;
		if (isAgEventEmitter(object)) {
			object.__addEventListener(event, listener);
			destroyFunc = () => {
				object.__removeEventListener(event, listener);
				return null;
			};
		} else {
			if (object instanceof HTMLElement) _addSafePassiveEventListener(this.beans.frameworkOverrides, object, event, listener);
			else object.addEventListener(event, listener);
			destroyFunc = () => {
				object.removeEventListener(event, listener);
				return null;
			};
		}
		this.destroyFunctions.push(destroyFunc);
		return () => {
			destroyFunc();
			this.destroyFunctions = this.destroyFunctions.filter((fn) => fn !== destroyFunc);
			return null;
		};
	}
	setupGridOptionListener(event, listener) {
		const { gos } = this;
		gos.addPropertyEventListener(event, listener);
		const destroyFunc = () => {
			gos.removePropertyEventListener(event, listener);
			return null;
		};
		this.destroyFunctions.push(destroyFunc);
		return () => {
			destroyFunc();
			this.destroyFunctions = this.destroyFunctions.filter((fn) => fn !== destroyFunc);
			return null;
		};
	}
	addManagedPropertyListener(event, listener) {
		if (this.destroyed) return () => null;
		return this.setupGridOptionListener(event, listener);
	}
	addManagedPropertyListeners(events, listener) {
		if (this.destroyed) return;
		const eventsKey = events.join("-") + this.propertyListenerId++;
		const wrappedListener = (event) => {
			if (event.changeSet) {
				if (event.changeSet && event.changeSet.id === this.lastChangeSetIdLookup[eventsKey]) return;
				this.lastChangeSetIdLookup[eventsKey] = event.changeSet.id;
			}
			listener({
				type: "gridPropertyChanged",
				changeSet: event.changeSet,
				source: event.source
			});
		};
		events.forEach((event) => this.setupGridOptionListener(event, wrappedListener));
	}
	getLocaleTextFunc() {
		return _getLocaleTextFunc(this.beans.localeSvc);
	}
	addDestroyFunc(func) {
		if (this.isAlive()) this.destroyFunctions.push(func);
		else func();
	}
	createOptionalManagedBean(bean, context) {
		return bean ? this.createManagedBean(bean, context) : void 0;
	}
	createManagedBean(bean, context) {
		const res = this.createBean(bean, context);
		this.addDestroyFunc(this.destroyBean.bind(this, bean, context));
		return res;
	}
	createBean(bean, context, afterPreCreateCallback) {
		return (context || this.stubContext).createBean(bean, afterPreCreateCallback);
	}
	destroyBean(bean, context) {
		return (context || this.stubContext).destroyBean(bean);
	}
	destroyBeans(beans, context) {
		return (context || this.stubContext).destroyBeans(beans);
	}
};
function isAgEventEmitter(object) {
	return object.__addEventListener !== void 0;
}
var reUnescapedHtml = /[&<>"']/g;
var HTML_ESCAPES = {
	"&": "&amp;",
	"<": "&lt;",
	">": "&gt;",
	"\"": "&quot;",
	"'": "&#39;"
};
function _toString(toEscape) {
	return toEscape?.toString().toString() ?? null;
}
function _escapeString(toEscape) {
	return _toString(toEscape)?.replace(reUnescapedHtml, (chr) => HTML_ESCAPES[chr]) ?? null;
}
var COL_DEF_DEFAULTS = {
	resizable: true,
	sortable: true
};
var instanceIdSequence = 0;
function getNextColInstanceId() {
	return instanceIdSequence++;
}
function isColumn(col) {
	return col instanceof AgColumn;
}
var AgColumn = class extends BeanStub {
	constructor(colDef, userProvidedColDef, colId, primary) {
		super();
		this.colDef = colDef;
		this.userProvidedColDef = userProvidedColDef;
		this.colId = colId;
		this.primary = primary;
		this.isColumn = true;
		this.instanceId = getNextColInstanceId();
		this.autoHeaderHeight = null;
		this.moving = false;
		this.resizing = false;
		this.menuVisible = false;
		this.lastLeftPinned = false;
		this.firstRightPinned = false;
		this.filterActive = false;
		this.colEventSvc = new LocalEventService();
		this.tooltipEnabled = false;
		this.rowGroupActive = false;
		this.pivotActive = false;
		this.aggregationActive = false;
		this.flex = null;
		this.colIdSanitised = _escapeString(colId);
	}
	destroy() {
		super.destroy();
		this.beans.rowSpanSvc?.deregister(this);
	}
	getInstanceId() {
		return this.instanceId;
	}
	setState() {
		const { colDef, beans: { sortSvc, pinnedCols, colFlex } } = this;
		sortSvc?.initCol(this);
		const hide = colDef.hide;
		if (hide !== void 0) this.visible = !hide;
		else this.visible = !colDef.initialHide;
		pinnedCols?.initCol(this);
		colFlex?.initCol(this);
	}
	setColDef(colDef, userProvidedColDef, source) {
		const colSpanChanged = colDef.spanRows !== this.colDef.spanRows;
		this.colDef = colDef;
		this.userProvidedColDef = userProvidedColDef;
		this.initMinAndMaxWidths();
		this.initDotNotation();
		this.initTooltip();
		if (colSpanChanged) {
			this.beans.rowSpanSvc?.deregister(this);
			this.initRowSpan();
		}
		this.dispatchColEvent("colDefChanged", source);
	}
	getUserProvidedColDef() {
		return this.userProvidedColDef;
	}
	getParent() {
		return this.parent;
	}
	getOriginalParent() {
		return this.originalParent;
	}
	postConstruct() {
		this.setState();
		this.initMinAndMaxWidths();
		this.resetActualWidth("gridInitializing");
		this.initDotNotation();
		this.initTooltip();
		this.initRowSpan();
		this.addPivotListener();
	}
	initDotNotation() {
		const { gos, colDef: { field, tooltipField } } = this;
		const suppressDotNotation = gos.get("suppressFieldDotNotation");
		this.fieldContainsDots = _exists(field) && field.indexOf(".") >= 0 && !suppressDotNotation;
		this.tooltipFieldContainsDots = _exists(tooltipField) && tooltipField.indexOf(".") >= 0 && !suppressDotNotation;
	}
	initMinAndMaxWidths() {
		const colDef = this.colDef;
		this.minWidth = colDef.minWidth ?? this.beans.environment.getDefaultColumnMinWidth();
		this.maxWidth = colDef.maxWidth ?? Number.MAX_SAFE_INTEGER;
	}
	initTooltip() {
		this.beans.tooltipSvc?.initCol(this);
	}
	initRowSpan() {
		if (this.colDef.spanRows) this.beans.rowSpanSvc?.register(this);
	}
	addPivotListener() {
		const pivotColDefSvc = this.beans.pivotColDefSvc;
		const pivotValueColumn = this.colDef.pivotValueColumn;
		if (!pivotColDefSvc || !pivotValueColumn) return;
		this.addManagedListeners(pivotValueColumn, { colDefChanged: (evt) => {
			const colDef = pivotColDefSvc.recreateColDef(this.colDef);
			this.setColDef(colDef, colDef, evt.source);
		} });
	}
	resetActualWidth(source) {
		const initialWidth = this.calculateColInitialWidth(this.colDef);
		this.setActualWidth(initialWidth, source, true);
	}
	calculateColInitialWidth(colDef) {
		let width;
		const colDefWidth = colDef.width;
		const colDefInitialWidth = colDef.initialWidth;
		if (colDefWidth != null) width = colDefWidth;
		else if (colDefInitialWidth != null) width = colDefInitialWidth;
		else width = 200;
		return Math.max(Math.min(width, this.maxWidth), this.minWidth);
	}
	isEmptyGroup() {
		return false;
	}
	isRowGroupDisplayed(colId) {
		return this.beans.showRowGroupCols?.isRowGroupDisplayed(this, colId) ?? false;
	}
	isPrimary() {
		return this.primary;
	}
	isFilterAllowed() {
		return !!this.colDef.filter;
	}
	isFieldContainsDots() {
		return this.fieldContainsDots;
	}
	isTooltipEnabled() {
		return this.tooltipEnabled;
	}
	isTooltipFieldContainsDots() {
		return this.tooltipFieldContainsDots;
	}
	getHighlighted() {
		return this.highlighted;
	}
	__addEventListener(eventType, listener) {
		this.colEventSvc.addEventListener(eventType, listener);
	}
	__removeEventListener(eventType, listener) {
		this.colEventSvc.removeEventListener(eventType, listener);
	}
	addEventListener(eventType, userListener) {
		this.frameworkEventListenerService = this.beans.frameworkOverrides.createLocalEventListenerWrapper?.(this.frameworkEventListenerService, this.colEventSvc);
		const listener = this.frameworkEventListenerService?.wrap(eventType, userListener) ?? userListener;
		this.colEventSvc.addEventListener(eventType, listener);
	}
	removeEventListener(eventType, userListener) {
		const listener = this.frameworkEventListenerService?.unwrap(eventType, userListener) ?? userListener;
		this.colEventSvc.removeEventListener(eventType, listener);
	}
	createColumnFunctionCallbackParams(rowNode) {
		return _addGridCommonParams(this.gos, {
			node: rowNode,
			data: rowNode.data,
			column: this,
			colDef: this.colDef
		});
	}
	isSuppressNavigable(rowNode) {
		return this.beans.cellNavigation?.isSuppressNavigable(this, rowNode) ?? false;
	}
	isCellEditable(rowNode) {
		return this.beans.editSvc?.isCellEditable({
			rowNode,
			column: this
		}) ?? false;
	}
	isSuppressFillHandle() {
		return !!this.colDef.suppressFillHandle;
	}
	isAutoHeight() {
		return !!this.colDef.autoHeight;
	}
	isAutoHeaderHeight() {
		return !!this.colDef.autoHeaderHeight;
	}
	isRowDrag(rowNode) {
		return this.isColumnFunc(rowNode, this.colDef.rowDrag);
	}
	isDndSource(rowNode) {
		return this.isColumnFunc(rowNode, this.colDef.dndSource);
	}
	isCellCheckboxSelection(rowNode) {
		return this.beans.selectionSvc?.isCellCheckboxSelection(this, rowNode) ?? false;
	}
	isSuppressPaste(rowNode) {
		return this.isColumnFunc(rowNode, this.colDef?.suppressPaste ?? null);
	}
	isResizable() {
		return !!this.getColDefValue("resizable");
	}
	getColDefValue(key) {
		return this.colDef[key] ?? COL_DEF_DEFAULTS[key];
	}
	isColumnFunc(rowNode, value) {
		if (typeof value === "boolean") return value;
		if (typeof value === "function") return value(this.createColumnFunctionCallbackParams(rowNode));
		return false;
	}
	createColumnEvent(type, source) {
		return _addGridCommonParams(this.gos, {
			type,
			column: this,
			columns: [this],
			source
		});
	}
	isMoving() {
		return this.moving;
	}
	getSort() {
		return this.sort;
	}
	isSortable() {
		return !!this.getColDefValue("sortable");
	}
	isSortAscending() {
		return this.sort === "asc";
	}
	isSortDescending() {
		return this.sort === "desc";
	}
	isSortNone() {
		return _missing(this.sort);
	}
	isSorting() {
		return _exists(this.sort);
	}
	getSortIndex() {
		return this.sortIndex;
	}
	isMenuVisible() {
		return this.menuVisible;
	}
	getAggFunc() {
		return this.aggFunc;
	}
	getLeft() {
		return this.left;
	}
	getOldLeft() {
		return this.oldLeft;
	}
	getRight() {
		return this.left + this.actualWidth;
	}
	setLeft(left, source) {
		this.oldLeft = this.left;
		if (this.left !== left) {
			this.left = left;
			this.dispatchColEvent("leftChanged", source);
		}
	}
	isFilterActive() {
		return this.filterActive;
	}
	isHovered() {
		_warn(261);
		return !!this.beans.colHover?.isHovered(this);
	}
	setFirstRightPinned(firstRightPinned, source) {
		if (this.firstRightPinned !== firstRightPinned) {
			this.firstRightPinned = firstRightPinned;
			this.dispatchColEvent("firstRightPinnedChanged", source);
		}
	}
	setLastLeftPinned(lastLeftPinned, source) {
		if (this.lastLeftPinned !== lastLeftPinned) {
			this.lastLeftPinned = lastLeftPinned;
			this.dispatchColEvent("lastLeftPinnedChanged", source);
		}
	}
	isFirstRightPinned() {
		return this.firstRightPinned;
	}
	isLastLeftPinned() {
		return this.lastLeftPinned;
	}
	isPinned() {
		return this.pinned === "left" || this.pinned === "right";
	}
	isPinnedLeft() {
		return this.pinned === "left";
	}
	isPinnedRight() {
		return this.pinned === "right";
	}
	getPinned() {
		return this.pinned;
	}
	setVisible(visible, source) {
		const newValue = visible === true;
		if (this.visible !== newValue) {
			this.visible = newValue;
			this.dispatchColEvent("visibleChanged", source);
		}
		this.dispatchStateUpdatedEvent("hide");
	}
	isVisible() {
		return this.visible;
	}
	isSpanHeaderHeight() {
		return !this.getColDef().suppressSpanHeaderHeight;
	}
	getFirstRealParent() {
		let parent = this.getOriginalParent();
		while (parent && parent.isPadding()) parent = parent.getOriginalParent();
		return parent;
	}
	getColumnGroupPaddingInfo() {
		let parent = this.getParent();
		if (!parent || !parent.isPadding()) return {
			numberOfParents: 0,
			isSpanningTotal: false
		};
		const numberOfParents = parent.getPaddingLevel() + 1;
		let isSpanningTotal = true;
		while (parent) {
			if (!parent.isPadding()) {
				isSpanningTotal = false;
				break;
			}
			parent = parent.getParent();
		}
		return {
			numberOfParents,
			isSpanningTotal
		};
	}
	getColDef() {
		return this.colDef;
	}
	getDefinition() {
		return this.colDef;
	}
	getColumnGroupShow() {
		return this.colDef.columnGroupShow;
	}
	getColId() {
		return this.colId;
	}
	getId() {
		return this.colId;
	}
	getUniqueId() {
		return this.colId;
	}
	getActualWidth() {
		return this.actualWidth;
	}
	getAutoHeaderHeight() {
		return this.autoHeaderHeight;
	}
	setAutoHeaderHeight(height) {
		const changed = height !== this.autoHeaderHeight;
		this.autoHeaderHeight = height;
		return changed;
	}
	createBaseColDefParams(rowNode) {
		return _addGridCommonParams(this.gos, {
			node: rowNode,
			data: rowNode.data,
			colDef: this.colDef,
			column: this
		});
	}
	getColSpan(rowNode) {
		if (_missing(this.colDef.colSpan)) return 1;
		const params = this.createBaseColDefParams(rowNode);
		const colSpan = this.colDef.colSpan(params);
		return Math.max(colSpan, 1);
	}
	getRowSpan(rowNode) {
		if (_missing(this.colDef.rowSpan)) return 1;
		const params = this.createBaseColDefParams(rowNode);
		const rowSpan = this.colDef.rowSpan(params);
		return Math.max(rowSpan, 1);
	}
	setActualWidth(actualWidth, source, silent = false) {
		actualWidth = Math.max(actualWidth, this.minWidth);
		actualWidth = Math.min(actualWidth, this.maxWidth);
		if (this.actualWidth !== actualWidth) {
			this.actualWidth = actualWidth;
			if (this.flex != null && source !== "flex" && source !== "gridInitializing") this.flex = null;
			if (!silent) this.fireColumnWidthChangedEvent(source);
		}
		this.dispatchStateUpdatedEvent("width");
	}
	fireColumnWidthChangedEvent(source) {
		this.dispatchColEvent("widthChanged", source);
	}
	isGreaterThanMax(width) {
		return width > this.maxWidth;
	}
	getMinWidth() {
		return this.minWidth;
	}
	getMaxWidth() {
		return this.maxWidth;
	}
	getFlex() {
		return this.flex;
	}
	isRowGroupActive() {
		return this.rowGroupActive;
	}
	isPivotActive() {
		return this.pivotActive;
	}
	isAnyFunctionActive() {
		return this.isPivotActive() || this.isRowGroupActive() || this.isValueActive();
	}
	isAnyFunctionAllowed() {
		return this.isAllowPivot() || this.isAllowRowGroup() || this.isAllowValue();
	}
	isValueActive() {
		return this.aggregationActive;
	}
	isAllowPivot() {
		return this.colDef.enablePivot === true;
	}
	isAllowValue() {
		return this.colDef.enableValue === true;
	}
	isAllowRowGroup() {
		return this.colDef.enableRowGroup === true;
	}
	dispatchColEvent(type, source, additionalEventAttributes) {
		const colEvent = this.createColumnEvent(type, source);
		if (additionalEventAttributes) _mergeDeep(colEvent, additionalEventAttributes);
		this.colEventSvc.dispatchEvent(colEvent);
	}
	dispatchStateUpdatedEvent(key) {
		this.colEventSvc.dispatchEvent({
			type: "columnStateUpdated",
			key
		});
	}
};
function isProvidedColumnGroup(col) {
	return col instanceof AgProvidedColumnGroup;
}
var AgProvidedColumnGroup = class extends BeanStub {
	constructor(colGroupDef, groupId, padding, level) {
		super();
		this.colGroupDef = colGroupDef;
		this.groupId = groupId;
		this.padding = padding;
		this.level = level;
		this.isColumn = false;
		this.expandable = false;
		this.instanceId = getNextColInstanceId();
		this.expandableListenerRemoveCallback = null;
		this.expanded = !!colGroupDef?.openByDefault;
	}
	destroy() {
		if (this.expandableListenerRemoveCallback) this.reset(null, void 0);
		super.destroy();
	}
	reset(colGroupDef, level) {
		this.colGroupDef = colGroupDef;
		this.level = level;
		this.originalParent = null;
		if (this.expandableListenerRemoveCallback) this.expandableListenerRemoveCallback();
		this.children = void 0;
		this.expandable = void 0;
	}
	getInstanceId() {
		return this.instanceId;
	}
	getOriginalParent() {
		return this.originalParent;
	}
	getLevel() {
		return this.level;
	}
	isVisible() {
		if (this.children) return this.children.some((child) => child.isVisible());
		return false;
	}
	isPadding() {
		return this.padding;
	}
	setExpanded(expanded) {
		this.expanded = expanded === void 0 ? false : expanded;
		this.dispatchLocalEvent({ type: "expandedChanged" });
	}
	isExpandable() {
		return this.expandable;
	}
	isExpanded() {
		return this.expanded;
	}
	getGroupId() {
		return this.groupId;
	}
	getId() {
		return this.getGroupId();
	}
	setChildren(children) {
		this.children = children;
	}
	getChildren() {
		return this.children;
	}
	getColGroupDef() {
		return this.colGroupDef;
	}
	getLeafColumns() {
		const result = [];
		this.addLeafColumns(result);
		return result;
	}
	forEachLeafColumn(callback) {
		if (!this.children) return;
		for (const child of this.children) if (isColumn(child)) callback(child);
		else if (isProvidedColumnGroup(child)) child.forEachLeafColumn(callback);
	}
	addLeafColumns(leafColumns) {
		if (!this.children) return;
		this.children.forEach((child) => {
			if (isColumn(child)) leafColumns.push(child);
			else if (isProvidedColumnGroup(child)) child.addLeafColumns(leafColumns);
		});
	}
	getColumnGroupShow() {
		const colGroupDef = this.colGroupDef;
		if (!colGroupDef) return;
		return colGroupDef.columnGroupShow;
	}
	setupExpandable() {
		this.setExpandable();
		if (this.expandableListenerRemoveCallback) this.expandableListenerRemoveCallback();
		const listener = this.onColumnVisibilityChanged.bind(this);
		this.getLeafColumns().forEach((col) => col.__addEventListener("visibleChanged", listener));
		this.expandableListenerRemoveCallback = () => {
			this.getLeafColumns().forEach((col) => col.__removeEventListener("visibleChanged", listener));
			this.expandableListenerRemoveCallback = null;
		};
	}
	setExpandable() {
		if (this.isPadding()) return;
		let atLeastOneShowingWhenOpen = false;
		let atLeastOneShowingWhenClosed = false;
		let atLeastOneChangeable = false;
		const children = this.findChildrenRemovingPadding();
		for (let i = 0, j = children.length; i < j; i++) {
			const abstractColumn = children[i];
			if (!abstractColumn.isVisible()) continue;
			const headerGroupShow = abstractColumn.getColumnGroupShow();
			if (headerGroupShow === "open") {
				atLeastOneShowingWhenOpen = true;
				atLeastOneChangeable = true;
			} else if (headerGroupShow === "closed") {
				atLeastOneShowingWhenClosed = true;
				atLeastOneChangeable = true;
			} else {
				atLeastOneShowingWhenOpen = true;
				atLeastOneShowingWhenClosed = true;
			}
		}
		const expandable = atLeastOneShowingWhenOpen && atLeastOneShowingWhenClosed && atLeastOneChangeable;
		if (this.expandable !== expandable) {
			this.expandable = expandable;
			this.dispatchLocalEvent({ type: "expandableChanged" });
		}
	}
	findChildrenRemovingPadding() {
		const res = [];
		const process = (items) => {
			items.forEach((item) => {
				if (isProvidedColumnGroup(item) && item.isPadding()) process(item.children);
				else res.push(item);
			});
		};
		process(this.children);
		return res;
	}
	onColumnVisibilityChanged() {
		this.setExpandable();
	}
};
var DefaultColumnTypes = {
	numericColumn: {
		headerClass: "ag-right-aligned-header",
		cellClass: "ag-right-aligned-cell"
	},
	rightAligned: {
		headerClass: "ag-right-aligned-header",
		cellClass: "ag-right-aligned-cell"
	}
};
function createMergedColGroupDef(beans, colGroupDef, groupId) {
	const colGroupDefMerged = {};
	const gos = beans.gos;
	Object.assign(colGroupDefMerged, gos.get("defaultColGroupDef"));
	Object.assign(colGroupDefMerged, colGroupDef);
	gos.validateColDef(colGroupDefMerged, groupId);
	return colGroupDefMerged;
}
var ColumnKeyCreator = class {
	constructor() {
		this.existingKeys = {};
	}
	addExistingKeys(keys) {
		for (let i = 0; i < keys.length; i++) this.existingKeys[keys[i]] = true;
	}
	getUniqueKey(colId, colField) {
		colId = _toStringOrNull(colId);
		let count = 0;
		while (true) {
			let idToTry = colId ?? colField;
			if (idToTry) {
				if (count !== 0) idToTry += "_" + count;
			} else idToTry = count;
			if (!this.existingKeys[idToTry]) {
				const usedId = String(idToTry);
				if (colId && count > 0) _warn(273, {
					providedId: colId,
					usedId
				});
				this.existingKeys[usedId] = true;
				return usedId;
			}
			count++;
		}
	}
};
var _EmptyArray = Object.freeze([]);
function _last(arr) {
	if (!arr?.length) return;
	return arr[arr.length - 1];
}
function _areEqual(a, b, comparator) {
	if (a == null && b == null) return true;
	return a != null && b != null && a.length === b.length && a.every((value, index) => comparator ? comparator(value, b[index]) : b[index] === value);
}
function _forAll(array, callback) {
	if (!array) return;
	for (const value of array) callback(value);
}
function _removeFromArray(array, object) {
	const index = array.indexOf(object);
	if (index >= 0) array.splice(index, 1);
}
function _moveInArray(array, objectsToMove, toIndex) {
	for (let i = 0; i < objectsToMove.length; i++) _removeFromArray(array, objectsToMove[i]);
	for (let i = objectsToMove.length - 1; i >= 0; i--) array.splice(toIndex, 0, objectsToMove[i]);
}
var GROUP_AUTO_COLUMN_ID = "ag-Grid-AutoColumn";
var SELECTION_COLUMN_ID = "ag-Grid-SelectionColumn";
function _getColumnsFromTree(rootColumns) {
	const result = [];
	const recursiveFindColumns = (childColumns) => {
		for (let i = 0; i < childColumns.length; i++) {
			const child = childColumns[i];
			if (isColumn(child)) result.push(child);
			else if (isProvidedColumnGroup(child)) recursiveFindColumns(child.getChildren());
		}
	};
	recursiveFindColumns(rootColumns);
	return result;
}
function getWidthOfColsInList(columnList) {
	return columnList.reduce((width, col) => width + col.getActualWidth(), 0);
}
function _destroyColumnTree(beans, oldTree, newTree) {
	const oldObjectsById = {};
	if (!oldTree) return;
	depthFirstOriginalTreeSearch(null, oldTree, (child) => {
		oldObjectsById[child.getInstanceId()] = child;
	});
	if (newTree) depthFirstOriginalTreeSearch(null, newTree, (child) => {
		oldObjectsById[child.getInstanceId()] = null;
	});
	const colsToDestroy = Object.values(oldObjectsById).filter((item) => item != null);
	beans.context.destroyBeans(colsToDestroy);
}
function isColumnGroupAutoCol(col) {
	return col.getId().startsWith(GROUP_AUTO_COLUMN_ID);
}
function isColumnSelectionCol(col) {
	return (typeof col === "string" ? col : "getColId" in col ? col.getColId() : col.colId)?.startsWith("ag-Grid-SelectionColumn") ?? false;
}
function isRowNumberCol(col) {
	return (typeof col === "string" ? col : "getColId" in col ? col.getColId() : col.colId)?.startsWith("ag-Grid-RowNumbersColumn") ?? false;
}
function isSpecialCol(col) {
	return isColumnSelectionCol(col) || isRowNumberCol(col);
}
function convertColumnTypes(type) {
	let typeKeys = [];
	if (type instanceof Array) typeKeys = type;
	else if (typeof type === "string") typeKeys = type.split(",");
	return typeKeys;
}
function _areColIdsEqual(colsA, colsB) {
	return _areEqual(colsA, colsB, (a, b) => a.getColId() === b.getColId());
}
function _updateColsMap(cols) {
	cols.map = {};
	cols.list.forEach((col) => cols.map[col.getId()] = col);
}
function _convertColumnEventSourceType(source) {
	return source === "gridOptionsUpdated" ? "gridOptionsChanged" : source;
}
function _columnsMatch(column, key) {
	const columnMatches = column === key;
	const colDefMatches = column.getColDef() === key;
	const idMatches = column.getColId() == key;
	return columnMatches || colDefMatches || idMatches;
}
var getValueFactory = (stateItem, defaultState) => (key1, key2) => {
	const obj = {
		value1: void 0,
		value2: void 0
	};
	let calculated = false;
	if (stateItem) {
		if (stateItem[key1] !== void 0) {
			obj.value1 = stateItem[key1];
			calculated = true;
		}
		if (_exists(key2) && stateItem[key2] !== void 0) {
			obj.value2 = stateItem[key2];
			calculated = true;
		}
	}
	if (!calculated && defaultState) {
		if (defaultState[key1] !== void 0) obj.value1 = defaultState[key1];
		if (_exists(key2) && defaultState[key2] !== void 0) obj.value2 = defaultState[key2];
	}
	return obj;
};
function _createColumnTree(beans, defs = null, primaryColumns, existingTree, source) {
	const columnKeyCreator = new ColumnKeyCreator();
	const { existingCols, existingGroups, existingColKeys } = extractExistingTreeData(existingTree);
	columnKeyCreator.addExistingKeys(existingColKeys);
	const unbalancedTree = _recursivelyCreateColumns(beans, defs, 0, primaryColumns, existingCols, columnKeyCreator, existingGroups, source);
	const { colGroupSvc } = beans;
	const treeDepth = colGroupSvc?.findMaxDepth(unbalancedTree, 0) ?? 0;
	const columnTree = colGroupSvc ? colGroupSvc.balanceColumnTree(unbalancedTree, 0, treeDepth, columnKeyCreator) : unbalancedTree;
	const depthFirstCallback = (child, parent) => {
		if (isProvidedColumnGroup(child)) child.setupExpandable();
		child.originalParent = parent;
	};
	depthFirstOriginalTreeSearch(null, columnTree, depthFirstCallback);
	return {
		columnTree,
		treeDepth
	};
}
function extractExistingTreeData(existingTree) {
	const existingCols = [];
	const existingGroups = [];
	const existingColKeys = [];
	if (existingTree) depthFirstOriginalTreeSearch(null, existingTree, (item) => {
		if (isProvidedColumnGroup(item)) {
			const group = item;
			existingGroups.push(group);
		} else {
			const col = item;
			existingColKeys.push(col.getId());
			existingCols.push(col);
		}
	});
	return {
		existingCols,
		existingGroups,
		existingColKeys
	};
}
function _recursivelyCreateColumns(beans, defs, level, primaryColumns, existingColsCopy, columnKeyCreator, existingGroups, source) {
	if (!defs) return [];
	const { colGroupSvc } = beans;
	const result = new Array(defs.length);
	for (let i = 0; i < result.length; i++) {
		const def = defs[i];
		if (colGroupSvc && isColumnGroupDef(def)) result[i] = colGroupSvc.createProvidedColumnGroup(primaryColumns, def, level, existingColsCopy, columnKeyCreator, existingGroups, source);
		else result[i] = createColumn(beans, primaryColumns, def, existingColsCopy, columnKeyCreator, source);
	}
	return result;
}
function createColumn(beans, primaryColumns, colDef, existingColsCopy, columnKeyCreator, source) {
	const existingColAndIndex = findExistingColumn(colDef, existingColsCopy);
	if (existingColAndIndex) existingColsCopy?.splice(existingColAndIndex.idx, 1);
	let column = existingColAndIndex?.column;
	if (!column) {
		const colId = columnKeyCreator.getUniqueKey(colDef.colId, colDef.field);
		column = new AgColumn(_addColumnDefaultAndTypes(beans, colDef, colId), colDef, colId, primaryColumns);
		beans.context.createBean(column);
	} else {
		const colDefMerged = _addColumnDefaultAndTypes(beans, colDef, column.getColId());
		column.setColDef(colDefMerged, colDef, source);
		_updateColumnState(beans, column, colDefMerged, source);
	}
	beans.dataTypeSvc?.addColumnListeners(column);
	return column;
}
function updateSomeColumnState(beans, column, hide, sort, sortIndex, pinned, flex, source) {
	const { sortSvc, pinnedCols, colFlex } = beans;
	if (hide !== void 0) column.setVisible(!hide, source);
	if (sortSvc) {
		sortSvc.updateColSort(column, sort, source);
		if (sortIndex !== void 0) sortSvc.setColSortIndex(column, sortIndex);
	}
	if (pinned !== void 0) pinnedCols?.setColPinned(column, pinned);
	if (flex !== void 0) colFlex?.setColFlex(column, flex);
}
function _updateColumnState(beans, column, colDef, source) {
	updateSomeColumnState(beans, column, colDef.hide, colDef.sort, colDef.sortIndex, colDef.pinned, colDef.flex, source);
	const colFlex = column.getFlex();
	if (colFlex != null && colFlex > 0) return;
	if (colDef.width != null) column.setActualWidth(colDef.width, source);
	else {
		const widthBeforeUpdate = column.getActualWidth();
		column.setActualWidth(widthBeforeUpdate, source);
	}
}
function findExistingColumn(newColDef, existingColsCopy) {
	if (!existingColsCopy) return void 0;
	for (let i = 0; i < existingColsCopy.length; i++) {
		const def = existingColsCopy[i].getUserProvidedColDef();
		if (!def) continue;
		if (newColDef.colId != null) {
			if (existingColsCopy[i].getId() === newColDef.colId) return {
				idx: i,
				column: existingColsCopy[i]
			};
			continue;
		}
		if (newColDef.field != null) {
			if (def.field === newColDef.field) return {
				idx: i,
				column: existingColsCopy[i]
			};
			continue;
		}
		if (def === newColDef) return {
			idx: i,
			column: existingColsCopy[i]
		};
	}
}
function _addColumnDefaultAndTypes(beans, colDef, colId, isAutoCol) {
	const { gos, dataTypeSvc } = beans;
	const res = {};
	_mergeDeep(res, gos.get("defaultColDef"), false, true);
	const columnType = updateColDefAndGetColumnType(beans, res, colDef, colId);
	if (columnType) assignColumnTypes(beans, columnType, res);
	const cellDataType = res.cellDataType;
	_mergeDeep(res, colDef, false, true);
	if (cellDataType !== void 0) res.cellDataType = cellDataType;
	const autoGroupColDef = gos.get("autoGroupColumnDef");
	const isSortingCoupled = _isColumnsSortingCoupledToGroup(gos);
	if (colDef.rowGroup && autoGroupColDef && isSortingCoupled) _mergeDeep(res, {
		sort: autoGroupColDef.sort,
		initialSort: autoGroupColDef.initialSort
	}, false, true);
	if (dataTypeSvc) {
		dataTypeSvc.postProcess(res);
		dataTypeSvc.validateColDef(res);
	}
	gos.validateColDef(res, colId, isAutoCol);
	return res;
}
function updateColDefAndGetColumnType(beans, colDef, userColDef, colId) {
	const dataTypeDefinitionColumnType = beans.dataTypeSvc?.updateColDefAndGetColumnType(colDef, userColDef, colId);
	const columnTypes = userColDef.type ?? dataTypeDefinitionColumnType ?? colDef.type;
	colDef.type = columnTypes;
	return columnTypes ? convertColumnTypes(columnTypes) : void 0;
}
function assignColumnTypes(beans, typeKeys, colDefMerged) {
	if (!typeKeys.length) return;
	const allColumnTypes = Object.assign({}, DefaultColumnTypes);
	const userTypes = beans.gos.get("columnTypes") || {};
	for (const key of Object.keys(userTypes)) {
		const value = userTypes[key];
		if (key in allColumnTypes) _warn(34, { key });
		else {
			if (value.type) _warn(35);
			allColumnTypes[key] = value;
		}
	}
	typeKeys.forEach((t) => {
		const typeColDef = allColumnTypes[t.trim()];
		if (typeColDef) _mergeDeep(colDefMerged, typeColDef, false, true);
		else _warn(36, { t });
	});
}
function isColumnGroupDef(abstractColDef) {
	return abstractColDef.children !== void 0;
}
function depthFirstOriginalTreeSearch(parent, tree, callback) {
	if (!tree) return;
	for (let i = 0; i < tree.length; i++) {
		const child = tree[i];
		if (isProvidedColumnGroup(child)) depthFirstOriginalTreeSearch(child, child.getChildren(), callback);
		callback(child, parent);
	}
}
function placeLockedColumns(cols, gos) {
	const left = [];
	const normal = [];
	const right = [];
	cols.forEach((col) => {
		const position = col.getColDef().lockPosition;
		if (position === "right") right.push(col);
		else if (position === "left" || position === true) left.push(col);
		else normal.push(col);
	});
	if (gos.get("enableRtl")) return [
		...right,
		...normal,
		...left
	];
	return [
		...left,
		...normal,
		...right
	];
}
function doesMovePassMarryChildren(allColumnsCopy, gridBalancedTree) {
	let rulePassed = true;
	depthFirstOriginalTreeSearch(null, gridBalancedTree, (child) => {
		if (!isProvidedColumnGroup(child)) return;
		const columnGroup = child;
		const colGroupDef = columnGroup.getColGroupDef();
		if (!(colGroupDef && colGroupDef.marryChildren)) return;
		const newIndexes = [];
		columnGroup.getLeafColumns().forEach((col) => {
			const newColIndex = allColumnsCopy.indexOf(col);
			newIndexes.push(newColIndex);
		});
		if (Math.max.apply(Math, newIndexes) - Math.min.apply(Math, newIndexes) > columnGroup.getLeafColumns().length - 1) rulePassed = false;
	});
	return rulePassed;
}
function getCommonValue(cols, valueGetter) {
	if (!cols || cols.length == 0) return;
	const firstValue = valueGetter(cols[0]);
	for (let i = 1; i < cols.length; i++) if (firstValue !== valueGetter(cols[i])) return;
	return firstValue;
}
function dispatchColumnPinnedEvent(eventSvc, changedColumns, source) {
	if (!changedColumns.length) return;
	const column = changedColumns.length === 1 ? changedColumns[0] : null;
	const pinned = getCommonValue(changedColumns, (col) => col.getPinned());
	eventSvc.dispatchEvent({
		type: "columnPinned",
		pinned: pinned != null ? pinned : null,
		columns: changedColumns,
		column,
		source
	});
}
function dispatchColumnVisibleEvent(eventSvc, changedColumns, source) {
	if (!changedColumns.length) return;
	const column = changedColumns.length === 1 ? changedColumns[0] : null;
	const visible = getCommonValue(changedColumns, (col) => col.isVisible());
	eventSvc.dispatchEvent({
		type: "columnVisible",
		visible,
		columns: changedColumns,
		column,
		source
	});
}
function dispatchColumnChangedEvent(eventSvc, type, columns, source) {
	eventSvc.dispatchEvent({
		type,
		columns,
		column: columns && columns.length == 1 ? columns[0] : null,
		source
	});
}
function dispatchColumnResizedEvent(eventSvc, columns, finished, source, flexColumns = null) {
	if (columns?.length) eventSvc.dispatchEvent({
		type: "columnResized",
		columns,
		column: columns.length === 1 ? columns[0] : null,
		flexColumns,
		finished,
		source
	});
}
function _applyColumnState(beans, params, source) {
	const { colModel, rowGroupColsSvc, pivotColsSvc, autoColSvc, selectionColSvc, colAnimation, visibleCols, pivotResultCols, environment, valueColsSvc, eventSvc, gos } = beans;
	const providedCols = colModel.getColDefCols() ?? [];
	const selectionCols = selectionColSvc?.getColumns();
	if (!providedCols?.length && !selectionCols?.length) return false;
	if (params?.state && !params.state.forEach) {
		_warn(32);
		return false;
	}
	const syncColumnWithStateItem = (column, stateItem, rowGroupIndexes, pivotIndexes, autoCol) => {
		if (!column) return;
		const getValue = getValueFactory(stateItem, params.defaultState);
		const flex = getValue("flex").value1;
		updateSomeColumnState(beans, column, getValue("hide").value1, getValue("sort").value1, getValue("sortIndex").value1, getValue("pinned").value1, flex, source);
		if (flex == null) {
			const width = getValue("width").value1;
			if (width != null) {
				const minColWidth = column.getColDef().minWidth ?? environment.getDefaultColumnMinWidth();
				if (minColWidth != null && width >= minColWidth) column.setActualWidth(width, source);
			}
		}
		if (autoCol || !column.isPrimary()) return;
		valueColsSvc?.syncColumnWithState(column, source, getValue);
		rowGroupColsSvc?.syncColumnWithState(column, source, getValue, rowGroupIndexes);
		pivotColsSvc?.syncColumnWithState(column, source, getValue, pivotIndexes);
	};
	const applyStates = (states, existingColumns, getById2) => {
		const dispatchEventsFunc = _compareColumnStatesAndDispatchEvents(beans, source);
		const columnsWithNoState = existingColumns.slice();
		const rowGroupIndexes = {};
		const pivotIndexes = {};
		const autoColStates = [];
		const selectionColStates = [];
		const unmatchedAndAutoStates2 = [];
		let unmatchedCount2 = 0;
		const previousRowGroupCols = rowGroupColsSvc?.columns.slice() ?? [];
		const previousPivotCols = pivotColsSvc?.columns.slice() ?? [];
		states.forEach((state) => {
			const colId = state.colId;
			if (colId.startsWith("ag-Grid-AutoColumn")) {
				autoColStates.push(state);
				unmatchedAndAutoStates2.push(state);
				return;
			}
			if (isColumnSelectionCol(colId)) {
				selectionColStates.push(state);
				unmatchedAndAutoStates2.push(state);
				return;
			}
			const column = getById2(colId);
			if (!column) {
				unmatchedAndAutoStates2.push(state);
				unmatchedCount2 += 1;
			} else {
				syncColumnWithStateItem(column, state, rowGroupIndexes, pivotIndexes, false);
				_removeFromArray(columnsWithNoState, column);
			}
		});
		const applyDefaultsFunc = (col) => syncColumnWithStateItem(col, null, rowGroupIndexes, pivotIndexes, false);
		columnsWithNoState.forEach(applyDefaultsFunc);
		rowGroupColsSvc?.sortColumns(comparatorByIndex.bind(rowGroupColsSvc, rowGroupIndexes, previousRowGroupCols));
		pivotColsSvc?.sortColumns(comparatorByIndex.bind(pivotColsSvc, pivotIndexes, previousPivotCols));
		colModel.refreshCols(false);
		const syncColStates = (getCol, colStates, columns = []) => {
			colStates.forEach((stateItem) => {
				const col = getCol(stateItem.colId);
				_removeFromArray(columns, col);
				syncColumnWithStateItem(col, stateItem, null, null, true);
			});
			columns.forEach(applyDefaultsFunc);
		};
		syncColStates((colId) => autoColSvc?.getColumn(colId) ?? null, autoColStates, autoColSvc?.getColumns()?.slice());
		syncColStates((colId) => selectionColSvc?.getColumn(colId) ?? null, selectionColStates, selectionColSvc?.getColumns()?.slice());
		orderLiveColsLikeState(params, colModel, gos);
		visibleCols.refresh(source);
		eventSvc.dispatchEvent({
			type: "columnEverythingChanged",
			source
		});
		dispatchEventsFunc();
		return {
			unmatchedAndAutoStates: unmatchedAndAutoStates2,
			unmatchedCount: unmatchedCount2
		};
	};
	colAnimation?.start();
	let { unmatchedAndAutoStates, unmatchedCount } = applyStates(params.state || [], providedCols, (id) => colModel.getColDefCol(id));
	if (unmatchedAndAutoStates.length > 0 || _exists(params.defaultState)) unmatchedCount = applyStates(unmatchedAndAutoStates, pivotResultCols?.getPivotResultCols()?.list ?? [], (id) => pivotResultCols?.getPivotResultCol(id) ?? null).unmatchedCount;
	colAnimation?.finish();
	return unmatchedCount === 0;
}
function _resetColumnState(beans, source) {
	const { colModel, autoColSvc, selectionColSvc, eventSvc, gos } = beans;
	const primaryCols = colModel.getColDefCols();
	if (!primaryCols?.length) return;
	const primaryColumns = _getColumnsFromTree(colModel.getColDefColTree());
	const columnStates = [];
	let letRowGroupIndex = 1e3;
	let letPivotIndex = 1e3;
	const addColState = (col) => {
		const stateItem = getColumnStateFromColDef(col);
		if (_missing(stateItem.rowGroupIndex) && stateItem.rowGroup) stateItem.rowGroupIndex = letRowGroupIndex++;
		if (_missing(stateItem.pivotIndex) && stateItem.pivot) stateItem.pivotIndex = letPivotIndex++;
		columnStates.push(stateItem);
	};
	autoColSvc?.getColumns()?.forEach(addColState);
	selectionColSvc?.getColumns()?.forEach(addColState);
	primaryColumns?.forEach(addColState);
	_applyColumnState(beans, { state: columnStates }, source);
	const autoCols = autoColSvc?.getColumns() ?? [];
	_applyColumnState(beans, {
		state: [
			...selectionColSvc?.getColumns() ?? [],
			...autoCols,
			...primaryCols
		].map((col) => ({ colId: col.colId })),
		applyOrder: true
	}, source);
	eventSvc.dispatchEvent(_addGridCommonParams(gos, {
		type: "columnsReset",
		source
	}));
}
function _compareColumnStatesAndDispatchEvents(beans, source) {
	const { rowGroupColsSvc, pivotColsSvc, valueColsSvc, colModel, sortSvc, eventSvc } = beans;
	const startState = {
		rowGroupColumns: rowGroupColsSvc?.columns.slice() ?? [],
		pivotColumns: pivotColsSvc?.columns.slice() ?? [],
		valueColumns: valueColsSvc?.columns.slice() ?? []
	};
	const columnStateBefore = _getColumnState(beans);
	const columnStateBeforeMap = {};
	columnStateBefore.forEach((col) => {
		columnStateBeforeMap[col.colId] = col;
	});
	return () => {
		const dispatchWhenListsDifferent = (eventType, colsBefore, colsAfter, idMapper) => {
			if (_areEqual(colsBefore.map(idMapper), colsAfter.map(idMapper))) return;
			const changes = new Set(colsBefore);
			colsAfter.forEach((id) => {
				if (!changes.delete(id)) changes.add(id);
			});
			const changesArr = [...changes];
			eventSvc.dispatchEvent({
				type: eventType,
				columns: changesArr,
				column: changesArr.length === 1 ? changesArr[0] : null,
				source
			});
		};
		const getChangedColumns = (changedPredicate) => {
			const changedColumns2 = [];
			colModel.forAllCols((column) => {
				const colStateBefore = columnStateBeforeMap[column.getColId()];
				if (colStateBefore && changedPredicate(colStateBefore, column)) changedColumns2.push(column);
			});
			return changedColumns2;
		};
		const columnIdMapper = (c) => c.getColId();
		dispatchWhenListsDifferent("columnRowGroupChanged", startState.rowGroupColumns, rowGroupColsSvc?.columns ?? [], columnIdMapper);
		dispatchWhenListsDifferent("columnPivotChanged", startState.pivotColumns, pivotColsSvc?.columns ?? [], columnIdMapper);
		const valueChangePredicate = (cs, c) => {
			const oldActive = cs.aggFunc != null;
			const activeChanged = oldActive != c.isValueActive();
			const aggFuncChanged = oldActive && cs.aggFunc != c.getAggFunc();
			return activeChanged || aggFuncChanged;
		};
		const changedValues = getChangedColumns(valueChangePredicate);
		if (changedValues.length > 0) dispatchColumnChangedEvent(eventSvc, "columnValueChanged", changedValues, source);
		const resizeChangePredicate = (cs, c) => cs.width != c.getActualWidth();
		dispatchColumnResizedEvent(eventSvc, getChangedColumns(resizeChangePredicate), true, source);
		const pinnedChangePredicate = (cs, c) => cs.pinned != c.getPinned();
		dispatchColumnPinnedEvent(eventSvc, getChangedColumns(pinnedChangePredicate), source);
		const visibilityChangePredicate = (cs, c) => cs.hide == c.isVisible();
		dispatchColumnVisibleEvent(eventSvc, getChangedColumns(visibilityChangePredicate), source);
		const sortChangePredicate = (cs, c) => cs.sort != c.getSort() || cs.sortIndex != c.getSortIndex();
		const changedColumns = getChangedColumns(sortChangePredicate);
		if (changedColumns.length > 0) sortSvc?.dispatchSortChangedEvents(source, changedColumns);
		normaliseColumnMovedEventForColumnState(columnStateBefore, _getColumnState(beans), source, colModel, eventSvc);
	};
}
function _getColumnState(beans) {
	const { colModel, rowGroupColsSvc, pivotColsSvc } = beans;
	if (_missing(colModel.getColDefCols()) || !colModel.isAlive()) return [];
	const rowGroupColumns = rowGroupColsSvc?.columns;
	const pivotColumns = pivotColsSvc?.columns;
	const res = [];
	const createStateItemFromColumn = (column) => {
		const rowGroupIndex = column.isRowGroupActive() && rowGroupColumns ? rowGroupColumns.indexOf(column) : null;
		const pivotIndex = column.isPivotActive() && pivotColumns ? pivotColumns.indexOf(column) : null;
		const aggFunc = column.isValueActive() ? column.getAggFunc() : null;
		const sort = column.getSort() != null ? column.getSort() : null;
		const sortIndex = column.getSortIndex() != null ? column.getSortIndex() : null;
		res.push({
			colId: column.getColId(),
			width: column.getActualWidth(),
			hide: !column.isVisible(),
			pinned: column.getPinned(),
			sort,
			sortIndex,
			aggFunc,
			rowGroup: column.isRowGroupActive(),
			rowGroupIndex,
			pivot: column.isPivotActive(),
			pivotIndex,
			flex: column.getFlex() ?? null
		});
	};
	colModel.forAllCols((col) => createStateItemFromColumn(col));
	const colIdToGridIndexMap = new Map(colModel.getCols().map((col, index) => [col.getColId(), index]));
	res.sort((itemA, itemB) => {
		return (colIdToGridIndexMap.has(itemA.colId) ? colIdToGridIndexMap.get(itemA.colId) : -1) - (colIdToGridIndexMap.has(itemB.colId) ? colIdToGridIndexMap.get(itemB.colId) : -1);
	});
	return res;
}
function getColumnStateFromColDef(column) {
	const getValueOrNull = (a, b) => a != null ? a : b != null ? b : null;
	const colDef = column.getColDef();
	const sort = getValueOrNull(colDef.sort, colDef.initialSort);
	const sortIndex = getValueOrNull(colDef.sortIndex, colDef.initialSortIndex);
	const hide = getValueOrNull(colDef.hide, colDef.initialHide);
	const pinned = getValueOrNull(colDef.pinned, colDef.initialPinned);
	const width = getValueOrNull(colDef.width, colDef.initialWidth);
	const flex = getValueOrNull(colDef.flex, colDef.initialFlex);
	let rowGroupIndex = getValueOrNull(colDef.rowGroupIndex, colDef.initialRowGroupIndex);
	let rowGroup = getValueOrNull(colDef.rowGroup, colDef.initialRowGroup);
	if (rowGroupIndex == null && (rowGroup == null || rowGroup == false)) {
		rowGroupIndex = null;
		rowGroup = null;
	}
	let pivotIndex = getValueOrNull(colDef.pivotIndex, colDef.initialPivotIndex);
	let pivot = getValueOrNull(colDef.pivot, colDef.initialPivot);
	if (pivotIndex == null && (pivot == null || pivot == false)) {
		pivotIndex = null;
		pivot = null;
	}
	const aggFunc = getValueOrNull(colDef.aggFunc, colDef.initialAggFunc);
	return {
		colId: column.getColId(),
		sort,
		sortIndex,
		hide,
		pinned,
		width,
		flex,
		rowGroup,
		rowGroupIndex,
		pivot,
		pivotIndex,
		aggFunc
	};
}
function orderLiveColsLikeState(params, colModel, gos) {
	if (!params.applyOrder || !params.state) return;
	const colIds = [];
	params.state.forEach((item) => {
		if (item.colId != null) colIds.push(item.colId);
	});
	sortColsLikeKeys(colModel.cols, colIds, colModel, gos);
}
function sortColsLikeKeys(cols, colIds, colModel, gos) {
	if (cols == null) return;
	let newOrder = [];
	const processedColIds = {};
	colIds.forEach((colId) => {
		if (processedColIds[colId]) return;
		const col = cols.map[colId];
		if (col) {
			newOrder.push(col);
			processedColIds[colId] = true;
		}
	});
	let autoGroupInsertIndex = 0;
	cols.list.forEach((col) => {
		const colId = col.getColId();
		if (processedColIds[colId] != null) return;
		if (colId.startsWith("ag-Grid-AutoColumn")) newOrder.splice(autoGroupInsertIndex++, 0, col);
		else newOrder.push(col);
	});
	newOrder = placeLockedColumns(newOrder, gos);
	if (!doesMovePassMarryChildren(newOrder, colModel.getColTree())) {
		_warn(39);
		return;
	}
	cols.list = newOrder;
}
function normaliseColumnMovedEventForColumnState(colStateBefore, colStateAfter, source, colModel, eventSvc) {
	const colStateAfterMapped = {};
	colStateAfter.forEach((s) => colStateAfterMapped[s.colId] = s);
	const colsIntersectIds = {};
	colStateBefore.forEach((s) => {
		if (colStateAfterMapped[s.colId]) colsIntersectIds[s.colId] = true;
	});
	const beforeFiltered = colStateBefore.filter((c) => colsIntersectIds[c.colId]);
	const afterFiltered = colStateAfter.filter((c) => colsIntersectIds[c.colId]);
	const movedColumns = [];
	afterFiltered.forEach((csAfter, index) => {
		const csBefore = beforeFiltered && beforeFiltered[index];
		if (csBefore && csBefore.colId !== csAfter.colId) {
			const gridCol = colModel.getCol(csBefore.colId);
			if (gridCol) movedColumns.push(gridCol);
		}
	});
	if (!movedColumns.length) return;
	eventSvc.dispatchEvent({
		type: "columnMoved",
		columns: movedColumns,
		column: movedColumns.length === 1 ? movedColumns[0] : null,
		finished: true,
		source
	});
}
var comparatorByIndex = (indexes, oldList, colA, colB) => {
	const indexA = indexes[colA.getId()];
	const indexB = indexes[colB.getId()];
	const aHasIndex = indexA != null;
	const bHasIndex = indexB != null;
	if (aHasIndex && bHasIndex) return indexA - indexB;
	if (aHasIndex) return -1;
	if (bHasIndex) return 1;
	const oldIndexA = oldList.indexOf(colA);
	const oldIndexB = oldList.indexOf(colB);
	const aHasOldIndex = oldIndexA >= 0;
	if (aHasOldIndex && oldIndexB >= 0) return oldIndexA - oldIndexB;
	if (aHasOldIndex) return -1;
	return 1;
};
var ColumnModel = class extends BeanStub {
	constructor() {
		super(...arguments);
		this.beanName = "colModel";
		this.pivotMode = false;
		this.ready = false;
		this.changeEventsDispatching = false;
	}
	postConstruct() {
		this.pivotMode = this.gos.get("pivotMode");
		this.addManagedPropertyListeners([
			"groupDisplayType",
			"treeData",
			"treeDataDisplayType",
			"groupHideOpenParents",
			"rowNumbers",
			"hidePaddedHeaderRows"
		], (event) => this.refreshAll(_convertColumnEventSourceType(event.source)));
		this.addManagedPropertyListeners([
			"defaultColDef",
			"defaultColGroupDef",
			"columnTypes",
			"suppressFieldDotNotation"
		], this.recreateColumnDefs.bind(this));
		this.addManagedPropertyListener("pivotMode", (event) => this.setPivotMode(this.gos.get("pivotMode"), _convertColumnEventSourceType(event.source)));
	}
	createColsFromColDefs(source) {
		const { beans } = this;
		const { valueCache, colAutosize, rowGroupColsSvc, pivotColsSvc, valueColsSvc, visibleCols, eventSvc } = beans;
		const dispatchEventsFunc = this.colDefs ? _compareColumnStatesAndDispatchEvents(beans, source) : void 0;
		valueCache?.expire();
		const oldCols = this.colDefCols?.list;
		const oldTree = this.colDefCols?.tree;
		const newTree = _createColumnTree(beans, this.colDefs, true, oldTree, source);
		_destroyColumnTree(beans, this.colDefCols?.tree, newTree.columnTree);
		const tree = newTree.columnTree;
		const treeDepth = newTree.treeDepth;
		const list = _getColumnsFromTree(tree);
		const map = {};
		list.forEach((col) => map[col.getId()] = col);
		this.colDefCols = {
			tree,
			treeDepth,
			list,
			map
		};
		rowGroupColsSvc?.extractCols(source, oldCols);
		pivotColsSvc?.extractCols(source, oldCols);
		valueColsSvc?.extractCols(source, oldCols);
		this.ready = true;
		this.refreshCols(true);
		visibleCols.refresh(source);
		eventSvc.dispatchEvent({
			type: "columnEverythingChanged",
			source
		});
		if (dispatchEventsFunc) {
			this.changeEventsDispatching = true;
			dispatchEventsFunc();
			this.changeEventsDispatching = false;
		}
		eventSvc.dispatchEvent({
			type: "newColumnsLoaded",
			source
		});
		if (source === "gridInitializing") colAutosize?.applyAutosizeStrategy();
	}
	refreshCols(newColDefs) {
		if (!this.colDefCols) return;
		const prevColTree = this.cols?.tree;
		this.saveColOrder();
		const { autoColSvc, selectionColSvc, rowNumbersSvc, quickFilter, pivotResultCols, showRowGroupCols, rowAutoHeight, visibleCols, colViewport, eventSvc } = this.beans;
		const cols = this.selectCols(pivotResultCols, this.colDefCols);
		this.createColumnsForService([
			autoColSvc,
			selectionColSvc,
			rowNumbersSvc
		], cols);
		const shouldSortNewColDefs = _shouldMaintainColumnOrder(this.gos, this.showingPivotResult);
		if (!newColDefs || shouldSortNewColDefs) this.restoreColOrder(cols);
		this.positionLockedCols(cols);
		showRowGroupCols?.refresh();
		quickFilter?.refreshCols();
		this.setColSpanActive();
		rowAutoHeight?.setAutoHeightActive(cols);
		visibleCols.clear();
		colViewport.clear();
		if (!_areEqual(prevColTree, this.cols.tree)) eventSvc.dispatchEvent({ type: "gridColumnsChanged" });
	}
	createColumnsForService(services, cols) {
		for (const service of services) {
			if (!service) continue;
			service.createColumns(cols, (updateOrder) => {
				this.lastOrder = updateOrder(this.lastOrder);
				this.lastPivotOrder = updateOrder(this.lastPivotOrder);
			});
			service.addColumns(cols);
		}
	}
	selectCols(pivotResultColsSvc, colDefCols) {
		const pivotResultCols = pivotResultColsSvc?.getPivotResultCols() ?? null;
		this.showingPivotResult = pivotResultCols != null;
		const { map, list, tree, treeDepth } = pivotResultCols ?? colDefCols;
		this.cols = {
			list: list.slice(),
			map: { ...map },
			tree: tree.slice(),
			treeDepth
		};
		if (pivotResultCols) {
			if (!pivotResultCols.list.some((col) => this.cols?.map[col.getColId()] !== void 0)) this.lastPivotOrder = null;
		}
		return this.cols;
	}
	getColsToShow() {
		if (!this.cols) return [];
		const { valueColsSvc, selectionColSvc, gos } = this.beans;
		const showAutoGroupAndValuesOnly = this.isPivotMode() && !this.showingPivotResult;
		const showSelectionColumn = selectionColSvc?.isSelectionColumnEnabled();
		const showRowNumbers = gos.get("rowNumbers");
		const valueColumns = valueColsSvc?.columns;
		return this.cols.list.filter((col) => {
			const isAutoGroupCol = isColumnGroupAutoCol(col);
			if (showAutoGroupAndValuesOnly) {
				const isValueCol = valueColumns?.includes(col);
				return isAutoGroupCol || isValueCol || showSelectionColumn && isColumnSelectionCol(col) || showRowNumbers && isRowNumberCol(col);
			} else return isAutoGroupCol || col.isVisible();
		});
	}
	refreshAll(source) {
		if (!this.ready) return;
		this.refreshCols(false);
		this.beans.visibleCols.refresh(source);
	}
	setColsVisible(keys, visible = false, source) {
		_applyColumnState(this.beans, { state: keys.map((key) => ({
			colId: typeof key === "string" ? key : key.getColId(),
			hide: !visible
		})) }, source);
	}
	restoreColOrder(cols) {
		const lastOrder = this.showingPivotResult ? this.lastPivotOrder : this.lastOrder;
		if (!lastOrder) return;
		const preservedOrder = lastOrder.filter((col) => cols.map[col.getId()] != null);
		if (preservedOrder.length === 0) return;
		if (preservedOrder.length === cols.list.length) {
			cols.list = preservedOrder;
			return;
		}
		const hasSiblings = (col) => {
			const ancestor = col.getOriginalParent();
			if (!ancestor) return false;
			if (ancestor.getChildren().length > 1) return true;
			return hasSiblings(ancestor);
		};
		if (!preservedOrder.some((col) => hasSiblings(col))) {
			const preservedOrderSet = new Set(preservedOrder);
			for (const col of cols.list) if (!preservedOrderSet.has(col)) preservedOrder.push(col);
			cols.list = preservedOrder;
			return;
		}
		const colPositionMap = /* @__PURE__ */ new Map();
		for (let i = 0; i < preservedOrder.length; i++) {
			const col = preservedOrder[i];
			colPositionMap.set(col, i);
		}
		const additionalCols = cols.list.filter((col) => !colPositionMap.has(col));
		if (additionalCols.length === 0) {
			cols.list = preservedOrder;
			return;
		}
		const getPreviousSibling = (col, group) => {
			const parent = group ? group.getOriginalParent() : col.getOriginalParent();
			if (!parent) return null;
			let highestIdx = null;
			let highestSibling = null;
			for (const child of parent.getChildren()) {
				if (child === group || child === col) continue;
				if (child instanceof AgColumn) {
					const colIdx = colPositionMap.get(child);
					if (colIdx == null) continue;
					if (highestIdx == null || highestIdx < colIdx) {
						highestIdx = colIdx;
						highestSibling = child;
					}
					continue;
				}
				child.forEachLeafColumn((leafCol) => {
					const colIdx = colPositionMap.get(leafCol);
					if (colIdx == null) return;
					if (highestIdx == null || highestIdx < colIdx) {
						highestIdx = colIdx;
						highestSibling = leafCol;
					}
				});
			}
			if (highestSibling == null) return getPreviousSibling(col, parent);
			return highestSibling;
		};
		const noSiblingsAvailable = [];
		const previousSiblingPosMap = /* @__PURE__ */ new Map();
		for (const col of additionalCols) {
			const prevSiblingIdx = getPreviousSibling(col, null);
			if (prevSiblingIdx == null) {
				noSiblingsAvailable.push(col);
				continue;
			}
			const prev = previousSiblingPosMap.get(prevSiblingIdx);
			if (prev === void 0) previousSiblingPosMap.set(prevSiblingIdx, col);
			else if (Array.isArray(prev)) prev.push(col);
			else previousSiblingPosMap.set(prevSiblingIdx, [prev, col]);
		}
		const result = new Array(cols.list.length);
		let resultPointer = result.length - 1;
		for (let i = noSiblingsAvailable.length - 1; i >= 0; i--) result[resultPointer--] = noSiblingsAvailable[i];
		for (let i = preservedOrder.length - 1; i >= 0; i--) {
			const nextCol = preservedOrder[i];
			const extraCols = previousSiblingPosMap.get(nextCol);
			if (extraCols) if (Array.isArray(extraCols)) for (let x = extraCols.length - 1; x >= 0; x--) {
				const col = extraCols[x];
				result[resultPointer--] = col;
			}
			else result[resultPointer--] = extraCols;
			result[resultPointer--] = nextCol;
		}
		cols.list = result;
	}
	positionLockedCols(cols) {
		cols.list = placeLockedColumns(cols.list, this.gos);
	}
	saveColOrder() {
		if (this.showingPivotResult) this.lastPivotOrder = this.cols?.list ?? null;
		else this.lastOrder = this.cols?.list ?? null;
	}
	getColumnDefs() {
		return this.colDefCols ? this.beans.colDefFactory?.getColumnDefs(this.colDefCols.list, this.showingPivotResult, this.lastOrder, this.cols?.list ?? []) : void 0;
	}
	setColSpanActive() {
		this.colSpanActive = !!this.cols?.list.some((col) => col.getColDef().colSpan != null);
	}
	isPivotMode() {
		return this.pivotMode;
	}
	setPivotMode(pivotMode, source) {
		if (pivotMode === this.pivotMode) return;
		this.pivotMode = pivotMode;
		if (!this.ready) return;
		this.refreshCols(false);
		const { visibleCols, eventSvc } = this.beans;
		visibleCols.refresh(source);
		eventSvc.dispatchEvent({ type: "columnPivotModeChanged" });
	}
	isPivotActive() {
		const pivotColumns = this.beans.pivotColsSvc?.columns;
		return this.pivotMode && !!pivotColumns?.length;
	}
	recreateColumnDefs(e) {
		if (!this.cols) return;
		this.beans.autoColSvc?.updateColumns(e);
		const source = _convertColumnEventSourceType(e.source);
		this.createColsFromColDefs(source);
	}
	setColumnDefs(columnDefs, source) {
		this.colDefs = columnDefs;
		this.createColsFromColDefs(source);
	}
	destroy() {
		_destroyColumnTree(this.beans, this.colDefCols?.tree);
		super.destroy();
	}
	getColTree() {
		return this.cols?.tree ?? [];
	}
	getColDefColTree() {
		return this.colDefCols?.tree ?? [];
	}
	getColDefCols() {
		return this.colDefCols?.list ?? null;
	}
	getCols() {
		return this.cols?.list ?? [];
	}
	forAllCols(callback) {
		const { pivotResultCols, autoColSvc, selectionColSvc } = this.beans;
		_forAll(this.colDefCols?.list, callback);
		_forAll(autoColSvc?.columns?.list, callback);
		_forAll(selectionColSvc?.columns?.list, callback);
		_forAll(pivotResultCols?.getPivotResultCols()?.list, callback);
	}
	getColsForKeys(keys) {
		if (!keys) return [];
		return keys.map((key) => this.getCol(key)).filter((col) => col != null);
	}
	getColDefCol(key) {
		if (!this.colDefCols?.list) return null;
		return this.getColFromCollection(key, this.colDefCols);
	}
	getCol(key) {
		if (key == null) return null;
		return this.getColFromCollection(key, this.cols);
	}
	getColById(key) {
		return this.cols?.map[key] ?? null;
	}
	getColFromCollection(key, cols) {
		if (cols == null) return null;
		const { map, list } = cols;
		if (typeof key == "string" && map[key]) return map[key];
		for (let i = 0; i < list.length; i++) if (_columnsMatch(list[i], key)) return list[i];
		return this.beans.autoColSvc?.getColumn(key) ?? this.beans.selectionColSvc?.getColumn(key) ?? null;
	}
};
var GroupInstanceIdCreator = class {
	constructor() {
		this.existingIds = {};
	}
	getInstanceIdForKey(key) {
		const lastResult = this.existingIds[key];
		let result;
		if (typeof lastResult !== "number") result = 0;
		else result = lastResult + 1;
		this.existingIds[key] = result;
		return result;
	}
};
function setupCompBean(ctrl, ctx, compBean) {
	if (compBean) ctrl.addDestroyFunc(() => ctx.destroyBean(compBean));
	return compBean ?? ctrl;
}
var CssClassManager = class {
	constructor(getGui) {
		this.cssClassStates = {};
		this.getGui = getGui;
	}
	toggleCss(className, addOrRemove) {
		if (!className) return;
		if (className.indexOf(" ") >= 0) {
			const list = (className || "").split(" ");
			if (list.length > 1) {
				list.forEach((cls) => this.toggleCss(cls, addOrRemove));
				return;
			}
		}
		if (this.cssClassStates[className] !== addOrRemove && className.length) {
			this.getGui()?.classList.toggle(className, addOrRemove);
			this.cssClassStates[className] = addOrRemove;
		}
	}
};
var compIdSequence = 0;
var Component = class extends BeanStub {
	constructor(templateOrParams, componentSelectors) {
		super();
		this.suppressDataRefValidation = false;
		this.displayed = true;
		this.visible = true;
		this.compId = compIdSequence++;
		this.cssManager = new CssClassManager(() => this.eGui);
		this.componentSelectors = new Map((componentSelectors ?? []).map((comp) => [comp.selector, comp]));
		if (templateOrParams) this.setTemplate(templateOrParams);
	}
	preConstruct() {
		this.wireTemplate(this.getGui());
		const debugId = "component-" + Object.getPrototypeOf(this)?.constructor?.name;
		this.css?.forEach((css) => this.beans.environment.addGlobalCSS(css, debugId));
	}
	wireTemplate(element, paramsMap) {
		if (element && this.gos) {
			this.applyElementsToComponent(element);
			this.createChildComponentsFromTags(element, paramsMap);
		}
	}
	getCompId() {
		return this.compId;
	}
	getDataRefAttribute(element) {
		if (element.getAttribute) return element.getAttribute(DataRefAttribute);
		return null;
	}
	applyElementsToComponent(element, elementRef, paramsMap, newComponent = null) {
		if (elementRef === void 0) elementRef = this.getDataRefAttribute(element);
		if (elementRef) {
			const current = this[elementRef];
			if (current === null) this[elementRef] = newComponent ?? element;
			else {
				const usedAsParamRef = paramsMap && paramsMap[elementRef];
				if (!this.suppressDataRefValidation && !usedAsParamRef) throw new Error(`data-ref: ${elementRef} on ${this.constructor.name} with ${current}`);
			}
		}
	}
	createChildComponentsFromTags(parentNode, paramsMap) {
		const childNodeList = [];
		for (const childNode of parentNode.childNodes ?? []) childNodeList.push(childNode);
		childNodeList.forEach((childNode) => {
			if (!(childNode instanceof HTMLElement)) return;
			const childComp = this.createComponentFromElement(childNode, (childComp2) => {
				const childGui = childComp2.getGui();
				if (childGui) for (const attr of childNode.attributes ?? []) childGui.setAttribute(attr.name, attr.value);
			}, paramsMap);
			if (childComp) {
				if (childComp.addItems && childNode.children.length) {
					this.createChildComponentsFromTags(childNode, paramsMap);
					const items = Array.prototype.slice.call(childNode.children);
					childComp.addItems(items);
				}
				this.swapComponentForNode(childComp, parentNode, childNode);
			} else if (childNode.childNodes) this.createChildComponentsFromTags(childNode, paramsMap);
		});
	}
	createComponentFromElement(element, afterPreCreateCallback, paramsMap) {
		const key = element.nodeName;
		const elementRef = this.getDataRefAttribute(element);
		const isAgGridComponent = key.indexOf("AG-") === 0;
		const componentSelector = isAgGridComponent ? this.componentSelectors.get(key) : null;
		let newComponent = null;
		if (componentSelector) {
			const componentParams = paramsMap && elementRef ? paramsMap[elementRef] : void 0;
			newComponent = new componentSelector.component(componentParams);
			newComponent.setParentComponent(this);
			this.createBean(newComponent, null, afterPreCreateCallback);
		} else if (isAgGridComponent) throw new Error(`selector: ${key}`);
		this.applyElementsToComponent(element, elementRef, paramsMap, newComponent);
		return newComponent;
	}
	swapComponentForNode(newComponent, parentNode, childNode) {
		const eComponent = newComponent.getGui();
		parentNode.replaceChild(eComponent, childNode);
		parentNode.insertBefore(document.createComment(childNode.nodeName), eComponent);
		this.addDestroyFunc(this.destroyBean.bind(this, newComponent));
	}
	activateTabIndex(elements) {
		const tabIndex = this.gos.get("tabIndex");
		if (!elements) elements = [];
		if (!elements.length) elements.push(this.getGui());
		elements.forEach((el) => el.setAttribute("tabindex", tabIndex.toString()));
	}
	setTemplate(templateOrParams, componentSelectors, paramsMap) {
		let eGui;
		if (typeof templateOrParams === "string" || templateOrParams == null) eGui = _loadTemplate(templateOrParams);
		else eGui = _createElement(templateOrParams);
		this.setTemplateFromElement(eGui, componentSelectors, paramsMap);
	}
	setTemplateFromElement(element, components, paramsMap, suppressDataRefValidation = false) {
		this.eGui = element;
		this.suppressDataRefValidation = suppressDataRefValidation;
		if (components) for (let i = 0; i < components.length; i++) {
			const component = components[i];
			this.componentSelectors.set(component.selector, component);
		}
		this.wireTemplate(element, paramsMap);
	}
	getGui() {
		return this.eGui;
	}
	getFocusableElement() {
		return this.eGui;
	}
	getAriaElement() {
		return this.getFocusableElement();
	}
	setParentComponent(component) {
		this.parentComponent = component;
	}
	getParentComponent() {
		return this.parentComponent;
	}
	setGui(eGui) {
		this.eGui = eGui;
	}
	queryForHtmlElement(cssSelector) {
		return this.eGui.querySelector(cssSelector);
	}
	getContainerAndElement(newChild, container) {
		let parent = container;
		if (newChild == null) return null;
		if (!parent) parent = this.eGui;
		if (_isNodeOrElement(newChild)) return {
			element: newChild,
			parent
		};
		return {
			element: newChild.getGui(),
			parent
		};
	}
	prependChild(newChild, container) {
		const { element, parent } = this.getContainerAndElement(newChild, container) || {};
		if (!element || !parent) return;
		parent.insertAdjacentElement("afterbegin", element);
	}
	appendChild(newChild, container) {
		const { element, parent } = this.getContainerAndElement(newChild, container) || {};
		if (!element || !parent) return;
		parent.appendChild(element);
	}
	isDisplayed() {
		return this.displayed;
	}
	setVisible(visible, options = {}) {
		if (visible !== this.visible) {
			this.visible = visible;
			const { skipAriaHidden } = options;
			_setVisible(this.eGui, visible, { skipAriaHidden });
		}
	}
	setDisplayed(displayed, options = {}) {
		if (displayed !== this.displayed) {
			this.displayed = displayed;
			const { skipAriaHidden } = options;
			_setDisplayed(this.eGui, displayed, { skipAriaHidden });
			const event = {
				type: "displayChanged",
				visible: this.displayed
			};
			this.dispatchLocalEvent(event);
		}
	}
	destroy() {
		if (this.parentComponent) this.parentComponent = void 0;
		super.destroy();
	}
	addGuiEventListener(event, listener, options) {
		this.eGui.addEventListener(event, listener, options);
		this.addDestroyFunc(() => this.eGui.removeEventListener(event, listener));
	}
	addCss(className) {
		this.cssManager.toggleCss(className, true);
	}
	removeCss(className) {
		this.cssManager.toggleCss(className, false);
	}
	toggleCss(className, addOrRemove) {
		this.cssManager.toggleCss(className, addOrRemove);
	}
	registerCSS(css) {
		this.css || (this.css = []);
		this.css.push(css);
	}
};
function isColumnFilterComp(filter) {
	return typeof filter === "object" && !!filter.component;
}
var AgPromise = class _AgPromise {
	constructor(callback) {
		this.status = 0;
		this.resolution = null;
		this.waiters = [];
		callback((value) => this.onDone(value), (params) => this.onReject(params));
	}
	static all(promises) {
		return promises.length ? new _AgPromise((resolve) => {
			let remainingToResolve = promises.length;
			const combinedValues = new Array(remainingToResolve);
			promises.forEach((promise, index) => {
				promise.then((value) => {
					combinedValues[index] = value;
					remainingToResolve--;
					if (remainingToResolve === 0) resolve(combinedValues);
				});
			});
		}) : _AgPromise.resolve();
	}
	static resolve(value = null) {
		return new _AgPromise((resolve) => resolve(value));
	}
	then(func) {
		return new _AgPromise((resolve) => {
			if (this.status === 1) resolve(func(this.resolution));
			else this.waiters.push((value) => resolve(func(value)));
		});
	}
	onDone(value) {
		this.status = 1;
		this.resolution = value;
		this.waiters.forEach((waiter) => waiter(value));
	}
	onReject(_) {}
};
function doesImplementIComponent(candidate) {
	if (!candidate) return false;
	return candidate.prototype && "getGui" in candidate.prototype;
}
function _getUserCompKeys(frameworkOverrides, defObject, type, params) {
	const { name } = type;
	let compName;
	let jsComp;
	let fwComp;
	let paramsFromSelector;
	let popupFromSelector;
	let popupPositionFromSelector;
	if (defObject) {
		const defObjectAny = defObject;
		const selectorFunc = defObjectAny[name + "Selector"];
		const selectorRes = selectorFunc ? selectorFunc(params) : null;
		const assignComp = (providedJsComp) => {
			if (typeof providedJsComp === "string") compName = providedJsComp;
			else if (providedJsComp != null && providedJsComp !== true) if (frameworkOverrides.isFrameworkComponent(providedJsComp)) fwComp = providedJsComp;
			else jsComp = providedJsComp;
		};
		if (selectorRes) {
			assignComp(selectorRes.component);
			paramsFromSelector = selectorRes.params;
			popupFromSelector = selectorRes.popup;
			popupPositionFromSelector = selectorRes.popupPosition;
		} else assignComp(defObjectAny[name]);
	}
	return {
		compName,
		jsComp,
		fwComp,
		paramsFromSelector,
		popupFromSelector,
		popupPositionFromSelector
	};
}
var UserComponentFactory = class extends BeanStub {
	constructor() {
		super(...arguments);
		this.beanName = "userCompFactory";
	}
	wireBeans(beans) {
		this.agCompUtils = beans.agCompUtils;
		this.registry = beans.registry;
		this.frameworkCompWrapper = beans.frameworkCompWrapper;
		this.gridOptions = beans.gridOptions;
	}
	getCompDetailsFromGridOptions(type, defaultName, params, mandatory = false) {
		return this.getCompDetails(this.gridOptions, type, defaultName, params, mandatory);
	}
	getCompDetails(defObject, type, defaultName, params, mandatory = false) {
		const { name, cellRenderer } = type;
		let { compName, jsComp, fwComp, paramsFromSelector, popupFromSelector, popupPositionFromSelector } = _getUserCompKeys(this.beans.frameworkOverrides, defObject, type, params);
		let defaultCompParams;
		let defaultCompProcessParams;
		const lookupFromRegistry = (key) => {
			const item = this.registry.getUserComponent(name, key);
			if (item) {
				jsComp = !item.componentFromFramework ? item.component : void 0;
				fwComp = item.componentFromFramework ? item.component : void 0;
				defaultCompParams = item.params;
				defaultCompProcessParams = item.processParams;
			}
		};
		if (compName != null) lookupFromRegistry(compName);
		if (jsComp == null && fwComp == null && defaultName != null) lookupFromRegistry(defaultName);
		if (jsComp && cellRenderer && !doesImplementIComponent(jsComp)) jsComp = this.agCompUtils?.adaptFunction(type, jsComp);
		if (!jsComp && !fwComp) {
			const { validation: validation2 } = this.beans;
			if (mandatory && (compName !== defaultName || !defaultName)) if (compName) {
				if (!validation2?.isProvidedUserComp(compName)) _error(50, { compName });
			} else if (defaultName) {
				if (!validation2) _error(260, {
					...this.gos.getModuleErrorParams(),
					propName: name,
					compName: defaultName
				});
			} else _error(216, { name });
			else if (defaultName && !validation2) _error(146, { comp: defaultName });
			return;
		}
		const paramsMerged = this.mergeParams(defObject, type, params, paramsFromSelector, defaultCompParams, defaultCompProcessParams);
		const componentFromFramework = jsComp == null;
		const componentClass = jsComp ?? fwComp;
		return {
			componentFromFramework,
			componentClass,
			params: paramsMerged,
			type,
			popupFromSelector,
			popupPositionFromSelector,
			newAgStackInstance: () => this.newAgStackInstance(componentClass, componentFromFramework, paramsMerged, type)
		};
	}
	newAgStackInstance(ComponentClass, componentFromFramework, params, type) {
		const jsComponent = !componentFromFramework;
		let instance;
		if (jsComponent) instance = new ComponentClass();
		else instance = this.frameworkCompWrapper.wrap(ComponentClass, type.mandatoryMethods, type.optionalMethods, type);
		this.createBean(instance);
		const deferredInit = instance.init?.(params);
		if (deferredInit == null) return AgPromise.resolve(instance);
		return deferredInit.then(() => instance);
	}
	mergeParams(defObject, type, paramsFromGrid, paramsFromSelector = null, defaultCompParams, defaultCompProcessParams) {
		const params = {
			...paramsFromGrid,
			...defaultCompParams
		};
		const defObjectAny = defObject;
		const userParams = defObjectAny && defObjectAny[type.name + "Params"];
		if (typeof userParams === "function") _mergeDeep(params, userParams(paramsFromGrid));
		else if (typeof userParams === "object") _mergeDeep(params, userParams);
		_mergeDeep(params, paramsFromSelector);
		return defaultCompProcessParams ? defaultCompProcessParams(params) : params;
	}
};
var DateComponent = {
	name: "dateComponent",
	mandatoryMethods: ["getDate", "setDate"],
	optionalMethods: [
		"afterGuiAttached",
		"setInputPlaceholder",
		"setInputAriaLabel",
		"setDisabled",
		"refresh"
	]
};
var DragAndDropImageComponent = {
	name: "dragAndDropImageComponent",
	mandatoryMethods: ["setIcon", "setLabel"]
};
var HeaderComponent = {
	name: "headerComponent",
	optionalMethods: ["refresh"]
};
var InnerHeaderComponent = { name: "innerHeaderComponent" };
var InnerHeaderGroupComponent = { name: "innerHeaderGroupComponent" };
var HeaderGroupComponent = { name: "headerGroupComponent" };
var CellRendererComponent = {
	name: "cellRenderer",
	optionalMethods: ["refresh", "afterGuiAttached"],
	cellRenderer: true
};
var LoadingCellRendererComponent = {
	name: "loadingCellRenderer",
	cellRenderer: true
};
var CellEditorComponent = {
	name: "cellEditor",
	mandatoryMethods: ["getValue"],
	optionalMethods: [
		"isPopup",
		"isCancelBeforeStart",
		"isCancelAfterEnd",
		"getPopupPosition",
		"focusIn",
		"focusOut",
		"afterGuiAttached",
		"refresh"
	]
};
var LoadingOverlayComponent = {
	name: "loadingOverlayComponent",
	optionalMethods: ["refresh"]
};
var NoRowsOverlayComponent = {
	name: "noRowsOverlayComponent",
	optionalMethods: ["refresh"]
};
var TooltipComponent = { name: "tooltipComponent" };
var FilterComponent = {
	name: "filter",
	mandatoryMethods: [
		"isFilterActive",
		"doesFilterPass",
		"getModel",
		"setModel"
	],
	optionalMethods: [
		"afterGuiAttached",
		"afterGuiDetached",
		"onNewRowsLoaded",
		"getModelAsString",
		"onFloatingFilterChanged",
		"onAnyFilterChanged",
		"refresh"
	]
};
var FloatingFilterComponent = {
	name: "floatingFilterComponent",
	mandatoryMethods: ["onParentModelChanged"],
	optionalMethods: ["afterGuiAttached", "refresh"]
};
var FullWidth = {
	name: "fullWidthCellRenderer",
	optionalMethods: ["refresh", "afterGuiAttached"],
	cellRenderer: true
};
var FullWidthLoading = {
	name: "loadingCellRenderer",
	cellRenderer: true
};
var FullWidthGroup = {
	name: "groupRowRenderer",
	optionalMethods: ["afterGuiAttached"],
	cellRenderer: true
};
var FullWidthDetail = {
	name: "detailCellRenderer",
	optionalMethods: ["refresh"],
	cellRenderer: true
};
function _getDragAndDropImageCompDetails(userCompFactory, params) {
	return userCompFactory.getCompDetailsFromGridOptions(DragAndDropImageComponent, "agDragAndDropImage", params, true);
}
function _getHeaderCompDetails(userCompFactory, colDef, params) {
	return userCompFactory.getCompDetails(colDef, HeaderComponent, "agColumnHeader", params);
}
function _getInnerHeaderCompDetails(userCompFactory, headerCompParams, params) {
	return userCompFactory.getCompDetails(headerCompParams, InnerHeaderComponent, void 0, params);
}
function _getHeaderGroupCompDetails(userCompFactory, params) {
	const colGroupDef = params.columnGroup.getColGroupDef();
	return userCompFactory.getCompDetails(colGroupDef, HeaderGroupComponent, "agColumnGroupHeader", params);
}
function _getInnerHeaderGroupCompDetails(userCompFactory, headerGroupCompParams, params) {
	return userCompFactory.getCompDetails(headerGroupCompParams, InnerHeaderGroupComponent, void 0, params);
}
function _getFullWidthCellRendererDetails(userCompFactory, params) {
	return userCompFactory.getCompDetailsFromGridOptions(FullWidth, void 0, params, true);
}
function _getFullWidthLoadingCellRendererDetails(userCompFactory, params) {
	return userCompFactory.getCompDetailsFromGridOptions(FullWidthLoading, "agLoadingCellRenderer", params, true);
}
function _getFullWidthGroupCellRendererDetails(userCompFactory, params) {
	return userCompFactory.getCompDetailsFromGridOptions(FullWidthGroup, "agGroupRowRenderer", params, true);
}
function _getFullWidthDetailCellRendererDetails(userCompFactory, params) {
	return userCompFactory.getCompDetailsFromGridOptions(FullWidthDetail, "agDetailCellRenderer", params, true);
}
function _getCellRendererDetails(userCompFactory, def, params) {
	return userCompFactory.getCompDetails(def, CellRendererComponent, void 0, params);
}
function _getLoadingCellRendererDetails(userCompFactory, def, params) {
	return userCompFactory.getCompDetails(def, LoadingCellRendererComponent, "agSkeletonCellRenderer", params, true);
}
function _getCellEditorDetails(userCompFactory, def, params) {
	return userCompFactory.getCompDetails(def, CellEditorComponent, "agCellEditor", params, true);
}
function _getFilterDetails(userCompFactory, def, params, defaultFilter) {
	const filter = def.filter;
	if (isColumnFilterComp(filter)) def = {
		filter: filter.component,
		filterParams: def.filterParams
	};
	return userCompFactory.getCompDetails(def, FilterComponent, defaultFilter, params, true);
}
function _getDateCompDetails(userCompFactory, def, params) {
	return userCompFactory.getCompDetails(def, DateComponent, "agDateInput", params, true);
}
function _getLoadingOverlayCompDetails(userCompFactory, params) {
	return userCompFactory.getCompDetailsFromGridOptions(LoadingOverlayComponent, "agLoadingOverlay", params, true);
}
function _getNoRowsOverlayCompDetails(userCompFactory, params) {
	return userCompFactory.getCompDetailsFromGridOptions(NoRowsOverlayComponent, "agNoRowsOverlay", params, true);
}
function _getTooltipCompDetails(userCompFactory, params) {
	return userCompFactory.getCompDetails(params.colDef, TooltipComponent, "agTooltipComponent", params, true);
}
function _getFloatingFilterCompDetails(userCompFactory, def, params, defaultFloatingFilter) {
	return userCompFactory.getCompDetails(def, FloatingFilterComponent, defaultFloatingFilter, params);
}
function _getFilterCompKeys(frameworkOverrides, def) {
	return _getUserCompKeys(frameworkOverrides, def, FilterComponent);
}
function _mergeFilterParamsWithApplicationProvidedParams(userCompFactory, defObject, paramsFromGrid) {
	return userCompFactory.mergeParams(defObject, FilterComponent, paramsFromGrid);
}
function _unwrapUserComp(comp) {
	const compAsAny = comp;
	return compAsAny != null && compAsAny.getFrameworkComponentInstance != null ? compAsAny.getFrameworkComponentInstance() : comp;
}
var allRegisteredModules = /* @__PURE__ */ new Set();
var globalModulesMap = {};
var gridModulesMap = {};
var currentModuleVersion;
var userHasRegistered = false;
var areGridScopedModules = false;
var isUmd = false;
function isValidModuleVersion(module) {
	const [moduleMajor, moduleMinor] = module.version.split(".") || [];
	const [currentModuleMajor, currentModuleMinor] = currentModuleVersion.split(".") || [];
	return moduleMajor === currentModuleMajor && moduleMinor === currentModuleMinor;
}
function runVersionChecks(module) {
	if (!currentModuleVersion) currentModuleVersion = module.version;
	const errorMsg = (details) => `You are using incompatible versions of AG Grid modules. Major and minor versions should always match across modules. ${details} Please update all modules to the same version.`;
	if (!module.version) _errorOnce(errorMsg(`'${module.moduleName}' is incompatible.`));
	else if (!isValidModuleVersion(module)) _errorOnce(errorMsg(`'${module.moduleName}' is version ${module.version} but the other modules are version ${currentModuleVersion}.`));
	if (module.validate) {
		const result = module.validate();
		if (!result.isValid) _errorOnce(`${result.message}`);
	}
}
function _registerModule(module, gridId, isInternalRegistration = false) {
	if (!isInternalRegistration) userHasRegistered = true;
	runVersionChecks(module);
	const rowModels = module.rowModels ?? ["all"];
	allRegisteredModules.add(module);
	let moduleStore;
	if (gridId !== void 0) {
		areGridScopedModules = true;
		if (gridModulesMap[gridId] === void 0) gridModulesMap[gridId] = {};
		moduleStore = gridModulesMap[gridId];
	} else moduleStore = globalModulesMap;
	rowModels.forEach((rowModel) => {
		if (moduleStore[rowModel] === void 0) moduleStore[rowModel] = {};
		moduleStore[rowModel][module.moduleName] = module;
	});
	if (module.dependsOn) module.dependsOn.forEach((dependency) => _registerModule(dependency, gridId, isInternalRegistration));
}
function _unRegisterGridModules(gridId) {
	delete gridModulesMap[gridId];
}
function _isModuleRegistered(moduleName, gridId, rowModel) {
	const isRegisteredForRowModel = (model) => !!globalModulesMap[model]?.[moduleName] || !!gridModulesMap[gridId]?.[model]?.[moduleName];
	return isRegisteredForRowModel(rowModel) || isRegisteredForRowModel("all");
}
function _areModulesGridScoped() {
	return areGridScopedModules;
}
function _getRegisteredModules(gridId, rowModel) {
	const gridModules = gridModulesMap[gridId] ?? {};
	return [
		...Object.values(globalModulesMap["all"] ?? {}),
		...Object.values(gridModules["all"] ?? {}),
		...Object.values(globalModulesMap[rowModel] ?? {}),
		...Object.values(gridModules[rowModel] ?? {})
	];
}
function _getAllRegisteredModules() {
	return new Set(allRegisteredModules);
}
function _hasUserRegistered() {
	return userHasRegistered;
}
function _isUmd() {
	return isUmd;
}
var ModuleRegistry = class {
	static register(module) {
		_registerModule(module, void 0);
	}
	static registerModules(modules) {
		modules.forEach((module) => _registerModule(module, void 0));
	}
};
var GenericContext = class {
	constructor(params) {
		this.beans = {};
		this.createdBeans = [];
		this.destroyed = false;
		if (!params || !params.beanClasses) return;
		this.beanDestroyComparator = params.beanDestroyComparator;
		this.init(params);
	}
	init(params) {
		for (const beanName of Object.keys(params.providedBeanInstances)) this.beans[beanName] = params.providedBeanInstances[beanName];
		params.beanClasses.forEach((BeanClass) => {
			const instance = new BeanClass();
			if (instance.beanName) this.beans[instance.beanName] = instance;
			else console.error(`Bean ${BeanClass.name} is missing beanName`);
			this.createdBeans.push(instance);
		});
		params.derivedBeans?.forEach((beanFunc) => {
			const { beanName, bean } = beanFunc(this);
			this.beans[beanName] = bean;
			this.createdBeans.push(bean);
		});
		if (params.beanInitComparator) this.createdBeans.sort(params.beanInitComparator);
		this.initBeans(this.createdBeans);
	}
	getBeanInstances() {
		return Object.values(this.beans);
	}
	createBean(bean, afterPreCreateCallback) {
		this.initBeans([bean], afterPreCreateCallback);
		return bean;
	}
	initBeans(beanInstances, afterPreCreateCallback) {
		beanInstances.forEach((instance) => {
			instance.preWireBeans?.(this.beans);
			instance.wireBeans?.(this.beans);
		});
		beanInstances.forEach((instance) => instance.preConstruct?.());
		if (afterPreCreateCallback) beanInstances.forEach(afterPreCreateCallback);
		beanInstances.forEach((instance) => instance.postConstruct?.());
	}
	getBeans() {
		return this.beans;
	}
	getBean(name) {
		return this.beans[name];
	}
	destroy() {
		if (this.destroyed) return;
		this.destroyed = true;
		const beanInstances = this.getBeanInstances();
		if (this.beanDestroyComparator) beanInstances.sort(this.beanDestroyComparator);
		this.destroyBeans(beanInstances);
		this.beans = {};
		this.createdBeans = [];
	}
	destroyBean(bean) {
		bean?.destroy?.();
	}
	destroyBeans(beans) {
		if (beans) for (let i = 0; i < beans.length; i++) this.destroyBean(beans[i]);
		return [];
	}
	isDestroyed() {
		return this.destroyed;
	}
};
function isComponentMetaFunc(componentMeta) {
	return typeof componentMeta === "object" && !!componentMeta.getComp;
}
var Context = class extends GenericContext {
	init(params) {
		this.gridId = params.gridId;
		this.beans.context = this;
		this.destroyCallback = params.destroyCallback;
		super.init(params);
	}
	destroy() {
		super.destroy();
		_unRegisterGridModules(this.gridId);
		this.destroyCallback?.();
	}
	getGridId() {
		return this.gridId;
	}
};
var EditModelService = class extends BeanStub {
	constructor() {
		super(...arguments);
		this.beanName = "editModelSvc";
		this.edits = /* @__PURE__ */ new Map();
		this.cellValidations = new EditCellValidationModel();
		this.rowValidations = new EditRowValidationModel();
		this.suspendEdits = false;
	}
	suspend(suspend) {
		this.suspendEdits = suspend;
	}
	removeEdits({ rowNode, column }) {
		if (!this.hasEdits({ rowNode }) || !rowNode) return;
		const editRow = this.getEditRow(rowNode);
		if (column) editRow.delete(column);
		else editRow.clear();
		if (editRow.size === 0) this.edits.delete(rowNode);
	}
	getEditRow(rowNode, params = {}) {
		if (this.suspendEdits) return;
		if (this.edits.size === 0) return;
		const edits = rowNode && this.edits.get(rowNode);
		if (edits) return edits;
		if (params.checkSiblings) {
			const pinnedSibling = rowNode.pinnedSibling;
			if (pinnedSibling) return this.getEditRow(pinnedSibling);
		}
	}
	getEditRowDataValue(rowNode, { checkSiblings } = {}) {
		if (this.edits.size === 0) return rowNode.data;
		const editRow = this.getEditRow(rowNode);
		const pinnedSibling = rowNode.pinnedSibling;
		const siblingRow = checkSiblings && pinnedSibling && this.getEditRow(pinnedSibling);
		if (!editRow && !siblingRow) return rowNode.data;
		const data = Object.assign({}, rowNode.data);
		const applyEdits = (edits, data2) => edits.forEach(({ pendingValue }, column) => {
			if (pendingValue !== UNEDITED) data2[column.getColId()] = pendingValue;
		});
		if (editRow) applyEdits(editRow, data);
		if (siblingRow) applyEdits(siblingRow, data);
		return data;
	}
	getEdit(position, copy) {
		const edit = this._getEdit(position);
		return copy && edit ? { ...edit } : edit;
	}
	_getEdit(position) {
		if (this.suspendEdits) return;
		if (this.edits.size === 0) return;
		return position.rowNode && position.column && this.getEditRow(position.rowNode)?.get(position.column);
	}
	getEditMap(copy = true) {
		if (this.suspendEdits || this.edits.size === 0) return /* @__PURE__ */ new Map();
		if (!copy) return this.edits;
		const map = /* @__PURE__ */ new Map();
		this.edits.forEach((editRow, rowNode) => map.set(rowNode, new Map(editRow)));
		return map;
	}
	setEditMap(newEdits) {
		this.edits.clear();
		newEdits.forEach((editRow, rowNode) => {
			const newRow = /* @__PURE__ */ new Map();
			editRow.forEach((cellData, column) => newRow.set(column, { ...cellData }));
			this.edits.set(rowNode, newRow);
		});
	}
	setEdit(position, edit) {
		(this.edits.size === 0 || !this.edits.has(position.rowNode)) && this.edits.set(position.rowNode, /* @__PURE__ */ new Map());
		const currentEdit = {
			...this._getEdit(position),
			...edit
		};
		this.getEditRow(position.rowNode).set(position.column, currentEdit);
		return currentEdit;
	}
	clearEditValue(position) {
		const { rowNode, column } = position;
		if (rowNode) if (column) {
			const edit = this._getEdit(position);
			if (edit) {
				edit.editorValue = void 0;
				edit.pendingValue = edit.sourceValue;
				edit.state = "changed";
			}
		} else this.getEditRow(rowNode)?.forEach((cellData) => {
			cellData.editorValue = void 0;
			cellData.pendingValue = cellData.sourceValue;
			cellData.state = "changed";
		});
	}
	getState(position) {
		if (this.suspendEdits) return;
		return this.getEdit(position)?.state;
	}
	getEditPositions(editMap) {
		if (this.suspendEdits || (editMap ?? this.edits).size === 0) return [];
		const positions = [];
		(editMap ?? this.edits).forEach((editRow, rowNode) => {
			for (const column of editRow.keys()) positions.push({
				rowNode,
				column,
				...editRow.get(column)
			});
		});
		return positions;
	}
	hasRowEdits(rowNode, params) {
		if (this.suspendEdits) return false;
		if (this.edits.size === 0) return false;
		return !!this.getEditRow(rowNode, params);
	}
	hasEdits(position = {}, params = {}) {
		if (this.suspendEdits) return false;
		if (this.edits.size === 0) return false;
		const { rowNode, column } = position;
		const { withOpenEditor } = params;
		if (rowNode) {
			const rowEdits = this.getEditRow(rowNode, params);
			if (!rowEdits) return false;
			if (column) {
				if (withOpenEditor) return this.getEdit(position)?.state === "editing";
				return rowEdits.has(column) ?? false;
			}
			if (rowEdits.size !== 0) {
				if (withOpenEditor) return Array.from(rowEdits.values()).some(({ state }) => state === "editing");
				return true;
			}
			return false;
		}
		if (withOpenEditor) return this.getEditPositions().some(({ state }) => state === "editing");
		return this.edits.size > 0;
	}
	start(position) {
		const map = this.getEditRow(position.rowNode) ?? /* @__PURE__ */ new Map();
		const { rowNode, column } = position;
		if (column && !map.has(column)) map.set(column, {
			editorValue: void 0,
			pendingValue: UNEDITED,
			sourceValue: this.beans.valueSvc.getValue(column, rowNode, true, "api"),
			state: "editing"
		});
		this.edits.set(rowNode, map);
	}
	stop(position) {
		if (!this.hasEdits(position)) return;
		if (position) this.removeEdits(position);
		else this.clear();
	}
	clear() {
		for (const pendingRowEdits of this.edits.values()) pendingRowEdits.clear();
		this.edits.clear();
	}
	getCellValidationModel() {
		return this.cellValidations;
	}
	getRowValidationModel() {
		return this.rowValidations;
	}
	setCellValidationModel(model) {
		this.cellValidations = model;
	}
	setRowValidationModel(model) {
		this.rowValidations = model;
	}
	destroy() {
		super.destroy();
		this.clear();
	}
};
var EditCellValidationModel = class {
	constructor() {
		this.cellValidations = /* @__PURE__ */ new Map();
	}
	getCellValidation(position) {
		const { rowNode, column } = position || {};
		return this.cellValidations?.get(rowNode)?.get(column);
	}
	hasCellValidation(position) {
		if (!position || !position.rowNode || !position.column) return this.cellValidations.size > 0;
		return !!this.getCellValidation(position);
	}
	setCellValidation(position, validation2) {
		const { rowNode, column } = position;
		if (!this.cellValidations.has(rowNode)) this.cellValidations.set(rowNode, /* @__PURE__ */ new Map());
		this.cellValidations.get(rowNode).set(column, validation2);
	}
	clearCellValidation(position) {
		const { rowNode, column } = position;
		this.cellValidations.get(rowNode)?.delete(column);
	}
	setCellValidationMap(validationMap) {
		this.cellValidations = validationMap;
	}
	getCellValidationMap() {
		return this.cellValidations;
	}
	clearCellValidationMap() {
		this.cellValidations.clear();
	}
};
var EditRowValidationModel = class {
	constructor() {
		this.rowValidations = /* @__PURE__ */ new Map();
	}
	getRowValidation(position) {
		const { rowNode } = position || {};
		return this.rowValidations.get(rowNode);
	}
	hasRowValidation(position) {
		if (!position || !position.rowNode) return this.rowValidations.size > 0;
		return !!this.getRowValidation(position);
	}
	setRowValidation({ rowNode }, rowValidation) {
		this.rowValidations.set(rowNode, rowValidation);
	}
	clearRowValidation({ rowNode }) {
		this.rowValidations.delete(rowNode);
	}
	setRowValidationMap(validationMap) {
		this.rowValidations = validationMap;
	}
	getRowValidationMap() {
		return this.rowValidations;
	}
	clearRowValidationMap() {
		this.rowValidations.clear();
	}
};
function _areCellsEqual(cellA, cellB) {
	const colsMatch = cellA.column === cellB.column;
	const floatingMatch = cellA.rowPinned === cellB.rowPinned;
	const indexMatch = cellA.rowIndex === cellB.rowIndex;
	return colsMatch && floatingMatch && indexMatch;
}
function _isRowBefore(rowA, rowB) {
	switch (rowA.rowPinned) {
		case "top":
			if (rowB.rowPinned !== "top") return true;
			break;
		case "bottom":
			if (rowB.rowPinned !== "bottom") return false;
			break;
		default:
			if (_exists(rowB.rowPinned)) return rowB.rowPinned !== "top";
			break;
	}
	return rowA.rowIndex < rowB.rowIndex;
}
function _isSameRow(rowA, rowB) {
	if (!rowA && !rowB) return true;
	if (rowA && !rowB || !rowA && rowB) return false;
	return rowA.rowIndex === rowB.rowIndex && rowA.rowPinned == rowB.rowPinned;
}
function _getFirstRow(beans) {
	let rowIndex = 0;
	let rowPinned;
	const { pinnedRowModel, rowModel, pageBounds } = beans;
	if (pinnedRowModel?.getPinnedTopRowCount()) rowPinned = "top";
	else if (rowModel.getRowCount()) {
		rowPinned = null;
		rowIndex = pageBounds.getFirstRow();
	} else if (pinnedRowModel?.getPinnedBottomRowCount()) rowPinned = "bottom";
	return rowPinned === void 0 ? null : {
		rowIndex,
		rowPinned
	};
}
function _getLastRow(beans) {
	let rowIndex;
	let rowPinned = null;
	const { pinnedRowModel, pageBounds } = beans;
	const pinnedBottomCount = pinnedRowModel?.getPinnedBottomRowCount();
	const pinnedTopCount = pinnedRowModel?.getPinnedTopRowCount();
	if (pinnedBottomCount) {
		rowPinned = "bottom";
		rowIndex = pinnedBottomCount - 1;
	} else if (beans.rowModel.getRowCount()) {
		rowPinned = null;
		rowIndex = pageBounds.getLastRow();
	} else if (pinnedTopCount) {
		rowPinned = "top";
		rowIndex = pinnedTopCount - 1;
	}
	return rowIndex === void 0 ? null : {
		rowIndex,
		rowPinned
	};
}
function _getRowNode(beans, gridRow) {
	switch (gridRow.rowPinned) {
		case "top": return beans.pinnedRowModel?.getPinnedTopRow(gridRow.rowIndex);
		case "bottom": return beans.pinnedRowModel?.getPinnedBottomRow(gridRow.rowIndex);
		default: return beans.rowModel.getRow(gridRow.rowIndex);
	}
}
function _getCellByPosition(beans, cellPosition) {
	const spannedCellCtrl = beans.spannedRowRenderer?.getCellByPosition(cellPosition);
	if (spannedCellCtrl) return spannedCellCtrl;
	const rowCtrl = beans.rowRenderer.getRowByPosition(cellPosition);
	if (!rowCtrl) return null;
	return rowCtrl.getCellCtrl(cellPosition.column);
}
function _getRowById(beans, rowId, rowPinned) {
	const { rowModel: rm, pinnedRowModel: prm } = beans;
	let node;
	node ?? (node = rm?.getRowNode(rowId));
	if (rowPinned) node ?? (node = prm?.getPinnedRowById(rowId, rowPinned));
	else {
		node ?? (node = prm?.getPinnedRowById(rowId, "top"));
		node ?? (node = prm?.getPinnedRowById(rowId, "bottom"));
	}
	return node;
}
function _getRowAbove(beans, rowPosition) {
	const { rowIndex: index, rowPinned: pinned } = rowPosition;
	const { pageBounds, pinnedRowModel, rowModel } = beans;
	if (index === 0) {
		if (pinned === "top") return null;
		if (pinned === "bottom" && rowModel.isRowsToRender()) return {
			rowIndex: pageBounds.getLastRow(),
			rowPinned: null
		};
		return pinnedRowModel?.isRowsToRender("top") ? {
			rowIndex: pinnedRowModel.getPinnedTopRowCount() - 1,
			rowPinned: "top"
		} : null;
	}
	return getNextStickyPosition(beans, pinned ? void 0 : rowModel.getRow(index), true) ?? {
		rowIndex: index - 1,
		rowPinned: pinned
	};
}
function _getRowBelow(beans, rowPosition) {
	const { rowIndex: index, rowPinned: pinned } = rowPosition;
	const { pageBounds, pinnedRowModel, rowModel } = beans;
	if (isLastRowInContainer(beans, rowPosition)) {
		if (pinned === "bottom") return null;
		if (pinned === "top" && rowModel.isRowsToRender()) return {
			rowIndex: pageBounds.getFirstRow(),
			rowPinned: null
		};
		return pinnedRowModel?.isRowsToRender("bottom") ? {
			rowIndex: 0,
			rowPinned: "bottom"
		} : null;
	}
	return getNextStickyPosition(beans, pinned ? void 0 : rowModel.getRow(index)) ?? {
		rowIndex: index + 1,
		rowPinned: pinned
	};
}
function getNextStickyPosition(beans, rowNode, up = false) {
	const { gos, rowRenderer } = beans;
	if (!rowNode?.sticky || !_isGroupRowsSticky(gos)) return;
	const stickyTopCtrls = rowRenderer.getStickyTopRowCtrls();
	const stickyBottomCtrls = rowRenderer.getStickyBottomRowCtrls();
	const isStickyTop = !stickyBottomCtrls.some((ctrl) => ctrl.rowNode.rowIndex === rowNode.rowIndex);
	const stickyRowCtrls = isStickyTop ? stickyTopCtrls : stickyBottomCtrls;
	const increment = (up ? -1 : 1) * (isStickyTop ? -1 : 1);
	let nextCtrl;
	for (let i = 0; i < stickyRowCtrls.length; i++) if (stickyRowCtrls[i].rowNode.rowIndex === rowNode.rowIndex) {
		nextCtrl = stickyRowCtrls[i + increment];
		break;
	}
	return nextCtrl ? {
		rowIndex: nextCtrl.rowNode.rowIndex,
		rowPinned: null
	} : void 0;
}
function isLastRowInContainer(beans, rowPosition) {
	const { rowPinned, rowIndex } = rowPosition;
	const { pinnedRowModel, pageBounds } = beans;
	if (rowPinned === "top") return (pinnedRowModel?.getPinnedTopRowCount() ?? 0) - 1 <= rowIndex;
	if (rowPinned === "bottom") return (pinnedRowModel?.getPinnedBottomRowCount() ?? 0) - 1 <= rowIndex;
	return pageBounds.getLastRow() <= rowIndex;
}
function _getRowCtrl(beans, inputs = {}) {
	const { rowIndex, rowId, rowCtrl, rowPinned } = inputs;
	if (rowCtrl) return rowCtrl;
	const { rowModel, rowRenderer } = beans;
	let { rowNode } = inputs;
	if (!rowNode) {
		if (rowId) rowNode = _getRowById(beans, rowId, rowPinned);
		else if (rowIndex != null) rowNode = rowModel.getRow(rowIndex);
	}
	return rowRenderer.getRowCtrls(rowNode ? [rowNode] : [])?.[0];
}
function _getCellCtrl(beans, inputs = {}) {
	const { cellCtrl, colId, columnId, column } = inputs;
	if (cellCtrl) return cellCtrl;
	const actualColumn = beans.colModel.getCol(colId ?? columnId ?? _getColId(column));
	const rowCtrl = inputs.rowCtrl ?? _getRowCtrl(beans, inputs);
	const result = rowCtrl?.getCellCtrl(actualColumn) ?? void 0;
	if (result) return result;
	const rowNode = inputs.rowNode ?? rowCtrl?.rowNode;
	if (rowNode) return beans.rowRenderer.getCellCtrls([rowNode], [actualColumn])?.[0];
}
function _stopEditing(beans) {
	const { editSvc } = beans;
	if (editSvc?.isBatchEditing()) _destroyEditors(beans);
	else editSvc?.stopEditing(void 0, { source: "api" });
}
function _addStopEditingWhenGridLosesFocus(bean, beans, viewports) {
	const { gos, popupSvc } = beans;
	if (!gos.get("stopEditingWhenCellsLoseFocus")) return;
	const focusOutListener = (event) => {
		const elementWithFocus = event.relatedTarget;
		if (_getTabIndex(elementWithFocus) === null) {
			_stopEditing(beans);
			return;
		}
		let clickInsideGrid = viewports.some((viewport) => viewport.contains(elementWithFocus)) && _isElementInThisGrid(gos, elementWithFocus);
		if (!clickInsideGrid) clickInsideGrid = !!popupSvc && (popupSvc.getActivePopups().some((popup) => popup.contains(elementWithFocus)) || popupSvc.isElementWithinCustomPopup(elementWithFocus));
		if (!clickInsideGrid) _stopEditing(beans);
	};
	viewports.forEach((viewport) => bean.addManagedElementListeners(viewport, { focusout: focusOutListener }));
}
function _getColId(column) {
	if (!column) return;
	if (typeof column === "string") return column;
	return column.getColId();
}
var UNEDITED = Symbol("unedited");
function getCellEditorInstanceMap(beans, params = {}) {
	const res = [];
	const ctrls = beans.rowRenderer.getCellCtrls(params.rowNodes, params.columns);
	for (const ctrl of ctrls) {
		const cellEditor = ctrl.comp?.getCellEditor();
		if (cellEditor) res.push({
			ctrl,
			editor: _unwrapUserComp(cellEditor)
		});
	}
	return res;
}
var getCellEditorInstances = (beans, params = {}) => getCellEditorInstanceMap(beans, params).map((res) => res.editor);
function _setupEditors(beans, editingCells, position, key, event, cellStartedEdit) {
	if (editingCells.length === 0 && position?.rowNode && position?.column) _setupEditor(beans, position, {
		key,
		event,
		cellStartedEdit
	});
	const { valueSvc, editSvc, editModelSvc } = beans;
	const { rowNode, column } = position ?? {};
	for (const cellPosition of editingCells) {
		const { rowNode: cellRowNode, column: cellColumn } = cellPosition;
		const curCellCtrl = _getCellCtrl(beans, cellPosition);
		if (!curCellCtrl) {
			if (cellRowNode && cellColumn) {
				const oldValue = valueSvc.getValue(cellColumn, cellRowNode, void 0, "api");
				const newValue = (position?.rowNode === cellRowNode && position?.column === cellColumn && key || void 0) ?? editSvc?.getCellDataValue(cellPosition, false) ?? valueSvc.getValueForDisplay(cellColumn, cellRowNode)?.value ?? oldValue ?? UNEDITED;
				editModelSvc?.setEdit(cellPosition, {
					pendingValue: newValue,
					sourceValue: oldValue,
					state: "editing"
				});
			}
			continue;
		}
		const shouldStartEditing = cellStartedEdit && rowNode === curCellCtrl.rowNode && curCellCtrl.column === column;
		_setupEditor(beans, {
			rowNode,
			column: curCellCtrl.column
		}, {
			key: shouldStartEditing ? key : null,
			event: shouldStartEditing ? event : null,
			cellStartedEdit: shouldStartEditing
		});
	}
}
function _sourceAndPendingDiffer({ pendingValue, sourceValue }) {
	if (pendingValue === UNEDITED) pendingValue = sourceValue;
	return pendingValue !== sourceValue;
}
function _setupEditor(beans, position, params) {
	const { key, event, cellStartedEdit, silent } = params ?? {};
	const cellCtrl = _getCellCtrl(beans, position);
	const editorComp = cellCtrl?.comp?.getCellEditor();
	const editorParams = _createEditorParams(beans, position, key, cellStartedEdit);
	const previousEdit = beans.editModelSvc?.getEdit(position);
	let newValue = key?.length === 1 ? key : editorParams.value;
	if (newValue === void 0) newValue = previousEdit?.sourceValue;
	beans.editModelSvc?.setEdit(position, {
		editorValue: newValue,
		state: "editing"
	});
	if (editorComp) {
		editorComp.refresh?.(editorParams);
		return;
	}
	const colDef = position.column.getColDef();
	const compDetails = _getCellEditorDetails(beans.userCompFactory, colDef, editorParams);
	const popup = compDetails?.popupFromSelector != null ? compDetails.popupFromSelector : !!colDef.cellEditorPopup;
	const popupLocation = compDetails?.popupPositionFromSelector != null ? compDetails.popupPositionFromSelector : colDef.cellEditorPopupPosition;
	checkAndPreventDefault(compDetails.params, event);
	if (cellCtrl) {
		cellCtrl.editCompDetails = compDetails;
		cellCtrl.comp?.setEditDetails(compDetails, popup, popupLocation, beans.gos.get("reactiveCustomComponents"));
		cellCtrl?.rowCtrl?.refreshRow({ suppressFlash: true });
		if (!silent) beans.editSvc?.dispatchCellEvent(position, event, "cellEditingStarted");
	}
}
function _valueFromEditor(cellEditor) {
	const noValueResult = { editorValueExists: false };
	if (((cellEditor.getValidationErrors?.())?.length ?? 0) > 0) return noValueResult;
	return {
		editorValue: cellEditor.getValue(),
		editorValueExists: true
	};
}
function _createEditorParams(beans, position, key, cellStartedEdit) {
	const { valueSvc, gos, editSvc } = beans;
	const cellCtrl = _getCellCtrl(beans, position);
	const rowIndex = position.rowNode?.rowIndex ?? void 0;
	const batchEdit = editSvc?.isBatchEditing();
	const agColumn = beans.colModel.getCol(position.column.getId());
	const { rowNode, column } = position;
	const editor = cellCtrl.comp?.getCellEditor();
	const initialNewValue = editSvc?.getCellDataValue(position, false) ?? (editor ? _valueFromEditor(editor)?.editorValue : void 0);
	return _addGridCommonParams(gos, {
		value: initialNewValue === UNEDITED ? valueSvc.getValueForDisplay(agColumn, rowNode)?.value : initialNewValue,
		eventKey: key ?? null,
		column,
		colDef: column.getColDef(),
		rowIndex,
		node: rowNode,
		data: rowNode.data,
		cellStartedEdit: cellStartedEdit ?? false,
		onKeyDown: cellCtrl?.onKeyDown.bind(cellCtrl),
		stopEditing: (suppressNavigateAfterEdit) => {
			editSvc.stopEditing(position, {
				source: batchEdit ? "ui" : "api",
				suppressNavigateAfterEdit
			});
			_destroyEditor(beans, position);
		},
		eGridCell: cellCtrl?.eGui,
		parseValue: (newValue) => valueSvc.parseValue(agColumn, rowNode, newValue, cellCtrl?.value),
		formatValue: cellCtrl?.formatValue.bind(cellCtrl),
		validate: () => {
			editSvc?.validateEdit();
		}
	});
}
function _purgeUnchangedEdits(beans, includeEditing) {
	const { editModelSvc } = beans;
	editModelSvc?.getEditMap().forEach((editRow, rowNode) => {
		editRow.forEach((edit, column) => {
			if (!includeEditing && (edit.state === "editing" || edit.pendingValue === UNEDITED)) return;
			if (!_sourceAndPendingDiffer(edit) && (edit.state !== "editing" || includeEditing)) editModelSvc?.removeEdits({
				rowNode,
				column
			});
		});
	});
}
function _refreshEditorOnColDefChanged(beans, cellCtrl) {
	const editor = cellCtrl.comp?.getCellEditor();
	if (!editor?.refresh) return;
	const { eventKey, cellStartedEdit } = cellCtrl.editCompDetails.params;
	const { column } = cellCtrl;
	const editorParams = _createEditorParams(beans, cellCtrl, eventKey, cellStartedEdit);
	const colDef = column.getColDef();
	const compDetails = _getCellEditorDetails(beans.userCompFactory, colDef, editorParams);
	editor.refresh(checkAndPreventDefault(compDetails.params, eventKey));
}
function checkAndPreventDefault(params, event) {
	if (event instanceof KeyboardEvent && params.column.getColDef().cellEditor === "agNumberCellEditor") params.suppressPreventDefault = [
		"-",
		"+",
		".",
		"e"
	].includes(event?.key ?? "") || params.suppressPreventDefault;
	else event?.preventDefault?.();
	return params;
}
function _syncFromEditors(beans, persist) {
	beans.editModelSvc?.getEditPositions().forEach((cellId) => {
		const cellCtrl = _getCellCtrl(beans, cellId);
		if (!cellCtrl) return;
		const editor = cellCtrl.comp.getCellEditor();
		if (!editor) return;
		const { editorValue, editorValueExists } = _valueFromEditor(editor);
		_syncFromEditor(beans, cellId, persist, editorValue, void 0, !editorValueExists);
	});
}
function _syncFromEditor(beans, position, persist, editorValue, _source, valueSameAsSource) {
	const { editModelSvc, valueSvc } = beans;
	if (!editModelSvc) return;
	const { rowNode, column } = position;
	if (!(rowNode && column)) return;
	const hasEditor = !!_getCellCtrl(beans, position)?.comp?.getCellEditor();
	let edit = editModelSvc.getEdit(position, true);
	if (!edit?.sourceValue) edit = editModelSvc.setEdit(position, {
		sourceValue: valueSvc.getValue(column, rowNode, void 0, "api"),
		pendingValue: UNEDITED,
		state: hasEditor ? "editing" : "changed"
	});
	editModelSvc.setEdit(position, {
		editorValue: valueSameAsSource ? edit.sourceValue : editorValue,
		state: hasEditor ? "editing" : "changed"
	});
	if (persist) _persistEditorValue(beans, position);
}
function _persistEditorValue(beans, position) {
	const { editModelSvc } = beans;
	const edit = editModelSvc?.getEdit(position, true);
	editModelSvc?.setEdit(position, { pendingValue: edit?.editorValue });
}
function _destroyEditors(beans, edits, params) {
	if (!edits) edits = beans.editModelSvc?.getEditPositions();
	edits.forEach((cellPosition) => _destroyEditor(beans, cellPosition, params));
}
function _destroyEditor(beans, position, params) {
	const { editSvc, editModelSvc } = beans;
	const { rowNode, column } = position;
	const cellCtrl = _getCellCtrl(beans, position);
	if (!cellCtrl) {
		if (editModelSvc?.hasEdits(position) && rowNode && column) editModelSvc?.setEdit(position, { state: "changed" });
		return;
	}
	const { comp } = cellCtrl;
	if (comp && !comp.getCellEditor()) return;
	const errorMessages = comp?.getCellEditor()?.getValidationErrors?.();
	const cellValidationModel = editModelSvc?.getCellValidationModel();
	if (errorMessages?.length) cellValidationModel?.setCellValidation(position, { errorMessages });
	else cellValidationModel?.clearCellValidation(position);
	if (editModelSvc?.getEdit(position)) editModelSvc?.setEdit(position, { state: "changed" });
	comp?.setEditDetails();
	comp?.refreshEditStyles(false, false);
	cellCtrl?.refreshCell({
		force: true,
		suppressFlash: true
	});
	const latest = editModelSvc?.getEdit(position);
	if (latest?.state === "changed" && !params?.silent) editSvc?.dispatchCellEvent(position, params?.event, "cellEditingStopped", {
		valueChanged: _sourceAndPendingDiffer(latest),
		newValue: latest?.pendingValue,
		oldValue: latest?.sourceValue
	});
}
function _populateModelValidationErrors(beans) {
	const mappedEditors = getCellEditorInstanceMap(beans);
	const cellValidationModel = new EditCellValidationModel();
	const { ariaAnnounce, localeSvc, editModelSvc, gos } = beans;
	const includeRows = gos.get("editType") === "fullRow";
	const ariaValidationErrorPrefix = _getLocaleTextFunc(localeSvc)("ariaValidationErrorPrefix", "Cell Editor Validation");
	for (const mappedEditor of mappedEditors) {
		const { ctrl, editor } = mappedEditor;
		const { rowNode, column } = ctrl;
		const errorMessages = editor.getValidationErrors?.() ?? [];
		const el = editor.getValidationElement?.(false) || !editor.isPopup?.() && ctrl.eGui;
		if (el) {
			const isInvalid = errorMessages != null && errorMessages.length > 0;
			const invalidMessage = isInvalid ? errorMessages.join(". ") : "";
			_setAriaInvalid(el, isInvalid);
			if (isInvalid) ariaAnnounce.announceValue(`${ariaValidationErrorPrefix} ${errorMessages}`, "editorValidation");
			if (el instanceof HTMLInputElement) el.setCustomValidity(invalidMessage);
			else el.classList.toggle("invalid", isInvalid);
		}
		if (errorMessages?.length > 0) cellValidationModel.setCellValidation({
			rowNode,
			column
		}, { errorMessages });
	}
	_syncFromEditors(beans, false);
	editModelSvc?.setCellValidationModel(cellValidationModel);
	const rowCtrlSet = /* @__PURE__ */ new Set();
	for (const { ctrl } of mappedEditors) rowCtrlSet.add(ctrl.rowCtrl);
	if (includeRows) {
		const rowValidations = _generateRowValidationErrors(beans);
		editModelSvc?.setRowValidationModel(rowValidations);
	}
	for (const rowCtrl of rowCtrlSet.values()) {
		rowCtrl.rowEditStyleFeature?.applyRowStyles();
		for (const cellCtrl of rowCtrl.getAllCellCtrls()) {
			cellCtrl.tooltipFeature?.refreshTooltip(true);
			cellCtrl.editorTooltipFeature?.refreshTooltip(true);
			cellCtrl.editStyleFeature?.applyCellStyles?.();
		}
	}
}
var _generateRowValidationErrors = (beans) => {
	const rowValidationModel = new EditRowValidationModel();
	const getFullRowEditValidationErrors = beans.gos.get("getFullRowEditValidationErrors");
	const editMap = beans.editModelSvc?.getEditMap();
	if (!editMap) return rowValidationModel;
	for (const rowNode of editMap.keys()) {
		const rowEditMap = editMap.get(rowNode);
		if (!rowEditMap) continue;
		const editorsState = [];
		const { rowIndex, rowPinned } = rowNode;
		for (const column of rowEditMap.keys()) {
			const editValue = rowEditMap.get(column);
			if (!editValue) continue;
			const { editorValue, pendingValue, sourceValue } = editValue;
			const newValue = editorValue ?? (pendingValue === UNEDITED ? void 0 : pendingValue) ?? sourceValue;
			editorsState.push({
				column,
				colId: column.getColId(),
				rowIndex,
				rowPinned,
				oldValue: sourceValue,
				newValue
			});
		}
		const errorMessages = getFullRowEditValidationErrors?.({ editorsState }) ?? [];
		if (errorMessages.length > 0) rowValidationModel.setRowValidation({ rowNode }, { errorMessages });
	}
	return rowValidationModel;
};
function _validateEdit(beans) {
	_populateModelValidationErrors(beans);
	const map = beans.editModelSvc?.getCellValidationModel().getCellValidationMap();
	if (!map) return null;
	const validations = [];
	map.forEach((rowValidations, rowNode) => {
		rowValidations.forEach(({ errorMessages }, column) => {
			validations.push({
				column,
				rowIndex: rowNode.rowIndex,
				rowPinned: rowNode.rowPinned,
				messages: errorMessages ?? null
			});
		});
	});
	return validations;
}
var CSS_FIRST_COLUMN = "ag-column-first";
var CSS_LAST_COLUMN = "ag-column-last";
function _getHeaderClassesFromColDef(abstractColDef, gos, column, columnGroup) {
	if (_missing(abstractColDef)) return [];
	return getColumnClassesFromCollDef(abstractColDef.headerClass, abstractColDef, gos, column, columnGroup);
}
function refreshFirstAndLastStyles(comp, column, presentedColsService) {
	comp.toggleCss(CSS_FIRST_COLUMN, presentedColsService.isColAtEdge(column, "first"));
	comp.toggleCss(CSS_LAST_COLUMN, presentedColsService.isColAtEdge(column, "last"));
}
function getClassParams(abstractColDef, gos, column, columnGroup) {
	return _addGridCommonParams(gos, {
		colDef: abstractColDef,
		column,
		columnGroup
	});
}
function getColumnClassesFromCollDef(classesOrFunc, abstractColDef, gos, column, columnGroup) {
	if (_missing(classesOrFunc)) return [];
	let classToUse;
	if (typeof classesOrFunc === "function") classToUse = classesOrFunc(getClassParams(abstractColDef, gos, column, columnGroup));
	else classToUse = classesOrFunc;
	if (typeof classToUse === "string") return [classToUse];
	if (Array.isArray(classToUse)) return [...classToUse];
	return [];
}
function _isManualPinnedRow(rowNode) {
	return !!(rowNode.rowPinned && rowNode.pinnedSibling);
}
function _getNodesInRangeForSelection(rowModel, float, start, end) {
	const isTop = float === "top";
	if (!start) return _getNodesInRangeForSelection(rowModel, float, isTop ? rowModel.getPinnedTopRow(0) : rowModel.getPinnedBottomRow(0), end);
	if (!end) {
		const count = isTop ? rowModel.getPinnedTopRowCount() : rowModel.getPinnedBottomRowCount();
		return _getNodesInRangeForSelection(rowModel, float, start, isTop ? rowModel.getPinnedTopRow(count - 1) : rowModel.getPinnedBottomRow(count - 1));
	}
	let started = false;
	let finished = false;
	const range = [];
	rowModel.forEachPinnedRow(float, (node) => {
		if (node === start && !started) {
			started = true;
			range.push(node);
			return;
		}
		if (started && node === end) {
			finished = true;
			range.push(node);
			return;
		}
		if (started && !finished) range.push(node);
	});
	return range;
}
var KeyCode = {
	BACKSPACE: "Backspace",
	TAB: "Tab",
	ENTER: "Enter",
	ESCAPE: "Escape",
	SPACE: " ",
	LEFT: "ArrowLeft",
	UP: "ArrowUp",
	RIGHT: "ArrowRight",
	DOWN: "ArrowDown",
	DELETE: "Delete",
	F2: "F2",
	PAGE_UP: "PageUp",
	PAGE_DOWN: "PageDown",
	PAGE_HOME: "Home",
	PAGE_END: "End",
	A: "KeyA",
	C: "KeyC",
	D: "KeyD",
	V: "KeyV",
	X: "KeyX",
	Y: "KeyY",
	Z: "KeyZ"
};
var keyboardModeActive = false;
var instanceCount = 0;
function addKeyboardModeEvents(doc) {
	if (instanceCount > 0) return;
	doc.addEventListener("keydown", toggleKeyboardMode);
	doc.addEventListener("mousedown", toggleKeyboardMode);
}
function removeKeyboardModeEvents(doc) {
	if (instanceCount > 0) return;
	doc.removeEventListener("keydown", toggleKeyboardMode);
	doc.removeEventListener("mousedown", toggleKeyboardMode);
}
function toggleKeyboardMode(event) {
	const isKeyboardActive = keyboardModeActive;
	const isKeyboardEvent = event.type === "keydown";
	if (isKeyboardEvent) {
		if (event.ctrlKey || event.metaKey || event.altKey) return;
	}
	if (isKeyboardActive === isKeyboardEvent) return;
	keyboardModeActive = isKeyboardEvent;
}
function _registerKeyboardFocusEvents(beans) {
	const eDocument = _getDocument(beans);
	addKeyboardModeEvents(eDocument);
	instanceCount++;
	return () => {
		instanceCount--;
		removeKeyboardModeEvents(eDocument);
	};
}
function _isKeyboardMode() {
	return keyboardModeActive;
}
function _findFocusableElements(rootNode, exclude, onlyUnmanaged = false) {
	const focusableString = FOCUSABLE_SELECTOR;
	let excludeString = FOCUSABLE_EXCLUDE;
	if (exclude) excludeString += ", " + exclude;
	if (onlyUnmanaged) excludeString += ", [tabindex=\"-1\"]";
	const nodes = Array.prototype.slice.apply(rootNode.querySelectorAll(focusableString)).filter((node) => {
		return _isVisible(node);
	});
	const excludeNodes = Array.prototype.slice.apply(rootNode.querySelectorAll(excludeString));
	if (!excludeNodes.length) return nodes;
	const diff = (a, b) => a.filter((element) => b.indexOf(element) === -1);
	return diff(nodes, excludeNodes);
}
function _focusInto(rootNode, up = false, onlyUnmanaged = false, excludeTabGuards = false) {
	const focusableElements = _findFocusableElements(rootNode, excludeTabGuards ? ".ag-tab-guard" : null, onlyUnmanaged);
	const toFocus = up ? _last(focusableElements) : focusableElements[0];
	if (toFocus) {
		toFocus.focus({ preventScroll: true });
		return true;
	}
	return false;
}
function _findNextFocusableElement(beans, rootNode, onlyManaged, backwards) {
	const focusable = _findFocusableElements(rootNode, onlyManaged ? ":not([tabindex=\"-1\"])" : null);
	const activeEl = _getActiveDomElement(beans);
	let currentIndex;
	if (onlyManaged) currentIndex = focusable.findIndex((el) => el.contains(activeEl));
	else currentIndex = focusable.indexOf(activeEl);
	const nextIndex = currentIndex + (backwards ? -1 : 1);
	if (nextIndex < 0 || nextIndex >= focusable.length) return null;
	return focusable[nextIndex];
}
function _findTabbableParent(node, limit = 5) {
	let counter = 0;
	while (node && _getTabIndex(node) === null && ++counter <= limit) node = node.parentElement;
	if (_getTabIndex(node) === null) return null;
	return node;
}
function _isHeaderFocusSuppressed(beans) {
	return beans.gos.get("suppressHeaderFocus") || !!beans.overlays?.isExclusive();
}
function _isCellFocusSuppressed(beans) {
	return beans.gos.get("suppressCellFocus") || !!beans.overlays?.isExclusive();
}
function _focusNextGridCoreContainer(beans, backwards, forceOut = false) {
	const gridCtrl = beans.ctrlsSvc.get("gridCtrl");
	if (!forceOut && gridCtrl.focusNextInnerContainer(backwards)) return true;
	if (forceOut || !backwards && !gridCtrl.isDetailGrid()) gridCtrl.forceFocusOutOfContainer(backwards);
	return false;
}
function _createCellEvent(beans, domEvent, eventType, { rowNode, column }, value) {
	return _addGridCommonParams(beans.gos, {
		type: eventType,
		node: rowNode,
		data: rowNode.data,
		value,
		column,
		colDef: column.getColDef(),
		rowPinned: rowNode.rowPinned,
		event: domEvent,
		rowIndex: rowNode.rowIndex
	});
}
function _isDeleteKey(key, alwaysReturnFalseOnBackspace = false) {
	if (key === KeyCode.DELETE) return true;
	if (!alwaysReturnFalseOnBackspace && key === KeyCode.BACKSPACE) return _isMacOsUserAgent();
	return false;
}
var CellKeyboardListenerFeature = class extends BeanStub {
	constructor(cellCtrl, beans, rowNode, rowCtrl) {
		super();
		this.cellCtrl = cellCtrl;
		this.rowNode = rowNode;
		this.rowCtrl = rowCtrl;
		this.beans = beans;
	}
	init() {
		this.eGui = this.cellCtrl.eGui;
	}
	onKeyDown(event) {
		const key = event.key;
		switch (key) {
			case KeyCode.ENTER:
				this.onEnterKeyDown(event);
				break;
			case KeyCode.F2:
				this.onF2KeyDown(event);
				break;
			case KeyCode.ESCAPE:
				this.onEscapeKeyDown(event);
				break;
			case KeyCode.TAB:
				this.onTabKeyDown(event);
				break;
			case KeyCode.BACKSPACE:
			case KeyCode.DELETE:
				this.onBackspaceOrDeleteKeyDown(key, event);
				break;
			case KeyCode.DOWN:
			case KeyCode.UP:
			case KeyCode.RIGHT:
			case KeyCode.LEFT:
				this.onNavigationKeyDown(event, key);
				break;
		}
	}
	onNavigationKeyDown(event, key) {
		const { cellCtrl, beans } = this;
		if (beans.editSvc?.isEditing(cellCtrl, { withOpenEditor: true })) return;
		if (event.shiftKey && cellCtrl.isRangeSelectionEnabled()) this.onShiftRangeSelect(event);
		else {
			const currentCellPosition = cellCtrl.getFocusedCellPosition();
			beans.navigation?.navigateToNextCell(event, key, currentCellPosition, true);
		}
		event.preventDefault();
	}
	onShiftRangeSelect(event) {
		const { rangeSvc, navigation } = this.beans;
		if (!rangeSvc) return;
		const endCell = rangeSvc.extendLatestRangeInDirection(event);
		if (!endCell) return;
		if (event.key === KeyCode.LEFT || event.key === KeyCode.RIGHT) navigation?.ensureColumnVisible(endCell.column);
		else navigation?.ensureRowVisible(endCell.rowIndex);
	}
	onTabKeyDown(event) {
		this.beans.navigation?.onTabKeyDown(this.cellCtrl, event);
	}
	onBackspaceOrDeleteKeyDown(key, event) {
		const { cellCtrl, beans, rowNode } = this;
		const { gos, rangeSvc, eventSvc, editSvc } = beans;
		eventSvc.dispatchEvent({ type: "keyShortcutChangedCellStart" });
		if (_isDeleteKey(key, gos.get("enableCellEditingOnBackspace")) && !editSvc?.isEditing(cellCtrl, { withOpenEditor: true })) {
			if (rangeSvc && _isCellSelectionEnabled(gos)) rangeSvc.clearCellRangeCellValues({
				dispatchWrapperEvents: true,
				wrapperEventSource: "deleteKey"
			});
			else if (cellCtrl.isCellEditable()) {
				const { column } = cellCtrl;
				const emptyValue = this.beans.valueSvc.getDeleteValue(column, rowNode);
				rowNode.setDataValue(column, emptyValue, "cellClear");
			}
		} else if (!editSvc?.isEditing(cellCtrl, { withOpenEditor: true })) beans.editSvc?.startEditing(cellCtrl, {
			startedEdit: true,
			event
		});
		eventSvc.dispatchEvent({ type: "keyShortcutChangedCellEnd" });
	}
	onEnterKeyDown(event) {
		const { cellCtrl, beans } = this;
		const { editSvc, navigation } = beans;
		const cellEditing = editSvc?.isEditing(cellCtrl);
		const rowNode = cellCtrl.rowNode;
		const rowEditing = editSvc?.isRowEditing(rowNode);
		const startEditingAction = (cellCtrl2) => {
			if (editSvc?.startEditing(cellCtrl2, {
				startedEdit: true,
				event
			})) event.preventDefault();
		};
		if (cellEditing || rowEditing) {
			if (this.isCtrlEnter(event)) {
				editSvc?.applyBulkEdit(cellCtrl, beans?.rangeSvc?.getCellRanges() || []);
				return;
			}
			_populateModelValidationErrors(beans);
			if (editSvc?.checkNavWithValidation(void 0, event) === "block-stop") return;
			if (editSvc?.isEditing(cellCtrl, { withOpenEditor: true })) editSvc?.stopEditing(cellCtrl, { event });
			else if (rowEditing && !cellCtrl.isCellEditable()) editSvc?.stopEditing({ rowNode }, { event });
			else startEditingAction(cellCtrl);
		} else if (beans.gos.get("enterNavigatesVertically")) {
			const key = event.shiftKey ? KeyCode.UP : KeyCode.DOWN;
			navigation?.navigateToNextCell(null, key, cellCtrl.cellPosition, false);
		} else {
			if (editSvc?.hasValidationErrors()) return;
			if (editSvc?.hasValidationErrors(cellCtrl)) editSvc.revertSingleCellEdit(cellCtrl, true);
			startEditingAction(cellCtrl);
		}
	}
	isCtrlEnter(e) {
		return (e.ctrlKey || e.metaKey) && e.key === KeyCode.ENTER;
	}
	onF2KeyDown(event) {
		const { cellCtrl, beans: { editSvc } } = this;
		if (editSvc?.isEditing()) {
			_populateModelValidationErrors(this.beans);
			if (editSvc?.checkNavWithValidation(void 0, event) === "block-stop") return;
		}
		editSvc?.startEditing(cellCtrl, {
			startedEdit: true,
			event
		});
	}
	onEscapeKeyDown(event) {
		const { cellCtrl, beans: { editSvc } } = this;
		if (editSvc?.checkNavWithValidation(cellCtrl, event) === "block-stop") editSvc.revertSingleCellEdit(cellCtrl);
		editSvc?.stopEditing(cellCtrl, {
			event,
			cancel: true
		});
	}
	processCharacter(event) {
		const eventOnChildComponent = event.target !== this.eGui;
		const { beans: { editSvc }, cellCtrl } = this;
		if (eventOnChildComponent) return;
		if (editSvc?.isEditing(cellCtrl, { withOpenEditor: true })) return;
		if (event.key === KeyCode.SPACE) this.onSpaceKeyDown(event);
		else if (editSvc?.isCellEditable(cellCtrl, "ui")) {
			if (editSvc?.hasValidationErrors() && !editSvc?.hasValidationErrors(cellCtrl)) return;
			editSvc?.startEditing(cellCtrl, {
				startedEdit: true,
				event,
				source: "api"
			});
			if (!cellCtrl.editCompDetails?.params?.suppressPreventDefault) event.preventDefault();
		}
	}
	onSpaceKeyDown(event) {
		const { gos, editSvc } = this.beans;
		const { rowNode } = this.cellCtrl;
		if (!editSvc?.isEditing(this.cellCtrl, { withOpenEditor: true }) && _isRowSelection(gos)) this.beans.selectionSvc?.handleSelectionEvent(event, rowNode, "spaceKey");
		event.preventDefault();
	}
};
function _areEventsNear(e1, e2, pixelCount) {
	if (pixelCount === 0) return false;
	const diffX = Math.abs(e1.clientX - e2.clientX);
	const diffY = Math.abs(e1.clientY - e2.clientY);
	return Math.max(diffX, diffY) <= pixelCount;
}
function _interpretAsRightClick({ gos }, event) {
	return event.button === 2 || event.ctrlKey && gos.get("allowContextMenuWithControlKey");
}
var CellMouseListenerFeature = class extends BeanStub {
	constructor(cellCtrl, beans, column) {
		super();
		this.cellCtrl = cellCtrl;
		this.column = column;
		this.beans = beans;
	}
	onMouseEvent(eventName, mouseEvent) {
		if (_isStopPropagationForAgGrid(mouseEvent)) return;
		switch (eventName) {
			case "click":
				this.onCellClicked(mouseEvent);
				break;
			case "mousedown":
			case "touchstart":
				this.onMouseDown(mouseEvent);
				break;
			case "dblclick":
				this.onCellDoubleClicked(mouseEvent);
				break;
			case "mouseout":
				this.onMouseOut(mouseEvent);
				break;
			case "mouseover":
				this.onMouseOver(mouseEvent);
				break;
		}
	}
	onCellClicked(event) {
		if (this.beans.touchSvc?.handleCellDoubleClick(this, event)) return;
		const { eventSvc, rangeSvc, editSvc, editModelSvc, frameworkOverrides } = this.beans;
		const isMultiKey = event.ctrlKey || event.metaKey;
		const { cellCtrl } = this;
		const { column, cellPosition } = cellCtrl;
		if (rangeSvc && isMultiKey) {
			if (rangeSvc.getCellRangeCount(cellPosition) > 1) rangeSvc.intersectLastRange(true);
		}
		const cellClickedEvent = cellCtrl.createEvent(event, "cellClicked");
		eventSvc.dispatchEvent(cellClickedEvent);
		const colDef = column.getColDef();
		if (colDef.onCellClicked) window.setTimeout(() => {
			frameworkOverrides.wrapOutgoing(() => {
				colDef.onCellClicked(cellClickedEvent);
			});
		}, 0);
		if (editModelSvc?.getState(cellCtrl) !== "editing") {
			const editing = editSvc?.isEditing();
			const cellValidations = editModelSvc?.getCellValidationModel().getCellValidationMap().size ?? 0;
			const rowValidations = editModelSvc?.getRowValidationModel().getRowValidationMap().size ?? 0;
			if (editing && (cellValidations > 0 || rowValidations > 0)) return;
			if (editSvc?.shouldStartEditing(cellCtrl, event)) editSvc?.startEditing(cellCtrl, { event });
			else if (editSvc?.shouldStopEditing(cellCtrl, event)) editSvc?.stopEditing(cellCtrl);
		}
	}
	onCellDoubleClicked(event) {
		const { column, beans, cellCtrl } = this;
		const { eventSvc, frameworkOverrides, editSvc, editModelSvc } = beans;
		const colDef = column.getColDef();
		const cellDoubleClickedEvent = cellCtrl.createEvent(event, "cellDoubleClicked");
		eventSvc.dispatchEvent(cellDoubleClickedEvent);
		if (typeof colDef.onCellDoubleClicked === "function") window.setTimeout(() => {
			frameworkOverrides.wrapOutgoing(() => {
				colDef.onCellDoubleClicked(cellDoubleClickedEvent);
			});
		}, 0);
		if (editSvc?.shouldStartEditing(this.cellCtrl, event) && this.beans.editModelSvc?.getState(this.cellCtrl) !== "editing") {
			const editing = editSvc?.isEditing();
			const cellValidations = editModelSvc?.getCellValidationModel().getCellValidationMap().size ?? 0;
			const rowValidations = editModelSvc?.getRowValidationModel().getRowValidationMap().size ?? 0;
			if (editing && (cellValidations > 0 || rowValidations > 0)) return;
			editSvc?.startEditing(cellCtrl, { event });
		}
	}
	onMouseDown(mouseEvent) {
		const { ctrlKey, metaKey, shiftKey } = mouseEvent;
		const target = mouseEvent.target;
		const { cellCtrl, beans } = this;
		const { eventSvc, rangeSvc, rowNumbersSvc, focusSvc, gos, editSvc } = beans;
		if (this.isRightClickInExistingRange(mouseEvent)) return;
		const hasRanges = rangeSvc && !rangeSvc.isEmpty();
		const containsWidget = this.containsWidget(target);
		const { cellPosition, column } = cellCtrl;
		const isRowNumberColumn = isRowNumberCol(column);
		if (rowNumbersSvc && isRowNumberColumn && !rowNumbersSvc.handleMouseDownOnCell(cellPosition, mouseEvent)) {
			if (rangeSvc) mouseEvent.preventDefault();
			mouseEvent.stopImmediatePropagation();
			return;
		}
		if (!shiftKey || !hasRanges) {
			const editing = editSvc?.isEditing(cellCtrl);
			const shouldFocus = gos.get("enableCellTextSelection") && mouseEvent.defaultPrevented;
			const forceBrowserFocus = (_isBrowserSafari() || shouldFocus) && !editing && !_isFocusableFormField(target) && !containsWidget;
			cellCtrl.focusCell(forceBrowserFocus, mouseEvent);
		}
		if (shiftKey && hasRanges && !focusSvc.isCellFocused(cellPosition)) {
			mouseEvent.preventDefault();
			const focusedCell = focusSvc.getFocusedCell();
			if (focusedCell) {
				const { column: column2, rowIndex, rowPinned } = focusedCell;
				if (editSvc?.isEditing(focusedCell)) editSvc?.stopEditing(focusedCell);
				focusSvc.setFocusedCell({
					column: column2,
					rowIndex,
					rowPinned,
					forceBrowserFocus: true,
					preventScrollOnBrowserFocus: true,
					sourceEvent: mouseEvent
				});
			}
		}
		if (containsWidget) return;
		if (rangeSvc) {
			if (isRowNumberColumn) mouseEvent.preventDefault();
			const hasRightClickedOnRowNumber = _interpretAsRightClick(this.beans, mouseEvent) && isRowNumberColumn;
			if (shiftKey) rangeSvc.extendLatestRangeToCell(cellPosition);
			else if (!hasRightClickedOnRowNumber) {
				const isMultiKey = ctrlKey || metaKey;
				rangeSvc.setRangeToCell(cellPosition, isMultiKey);
			}
		}
		eventSvc.dispatchEvent(this.cellCtrl.createEvent(mouseEvent, "cellMouseDown"));
	}
	isRightClickInExistingRange(mouseEvent) {
		const { rangeSvc } = this.beans;
		if (rangeSvc) {
			const cellInRange = rangeSvc.isCellInAnyRange(this.cellCtrl.cellPosition);
			const isRightClick = _interpretAsRightClick(this.beans, mouseEvent);
			if (cellInRange && isRightClick) return true;
		}
		return false;
	}
	containsWidget(target) {
		return _isElementChildOfClass(target, "ag-selection-checkbox", 3) || _isElementChildOfClass(target, "ag-drag-handle", 3);
	}
	onMouseOut(mouseEvent) {
		if (this.mouseStayingInsideCell(mouseEvent)) return;
		const { eventSvc, colHover } = this.beans;
		eventSvc.dispatchEvent(this.cellCtrl.createEvent(mouseEvent, "cellMouseOut"));
		colHover?.clearMouseOver();
	}
	onMouseOver(mouseEvent) {
		if (this.mouseStayingInsideCell(mouseEvent)) return;
		const { eventSvc, colHover } = this.beans;
		eventSvc.dispatchEvent(this.cellCtrl.createEvent(mouseEvent, "cellMouseOver"));
		colHover?.setMouseOver([this.column]);
	}
	mouseStayingInsideCell(e) {
		if (!e.target || !e.relatedTarget) return false;
		const eCell = this.cellCtrl.eGui;
		const cellContainsTarget = eCell.contains(e.target);
		const cellContainsRelatedTarget = eCell.contains(e.relatedTarget);
		return cellContainsTarget && cellContainsRelatedTarget;
	}
};
var CellPositionFeature = class extends BeanStub {
	constructor(cellCtrl, beans) {
		super();
		this.cellCtrl = cellCtrl;
		this.beans = beans;
		this.column = cellCtrl.column;
		this.rowNode = cellCtrl.rowNode;
	}
	setupRowSpan() {
		this.rowSpan = this.column.getRowSpan(this.rowNode);
		this.addManagedListeners(this.beans.eventSvc, { newColumnsLoaded: () => this.onNewColumnsLoaded() });
	}
	init() {
		this.eSetLeft = this.cellCtrl.getRootElement();
		this.eContent = this.cellCtrl.eGui;
		const cellSpan = this.cellCtrl.getCellSpan();
		if (!cellSpan) {
			this.setupColSpan();
			this.setupRowSpan();
		}
		this.onLeftChanged();
		this.onWidthChanged();
		if (!cellSpan) this._legacyApplyRowSpan();
		if (cellSpan) {
			const refreshSpanHeight = this.refreshSpanHeight.bind(this, cellSpan);
			refreshSpanHeight();
			this.addManagedListeners(this.beans.eventSvc, {
				paginationChanged: refreshSpanHeight,
				recalculateRowBounds: refreshSpanHeight,
				pinnedHeightChanged: refreshSpanHeight
			});
		}
	}
	refreshSpanHeight(cellSpan) {
		const spanHeight = cellSpan.getCellHeight();
		if (spanHeight != null) this.eContent.style.height = `${spanHeight}px`;
	}
	onNewColumnsLoaded() {
		const rowSpan = this.column.getRowSpan(this.rowNode);
		if (this.rowSpan === rowSpan) return;
		this.rowSpan = rowSpan;
		this._legacyApplyRowSpan(true);
	}
	onDisplayColumnsChanged() {
		const colsSpanning = this.getColSpanningList();
		if (!_areEqual(this.colsSpanning, colsSpanning)) {
			this.colsSpanning = colsSpanning;
			this.onWidthChanged();
			this.onLeftChanged();
		}
	}
	setupColSpan() {
		if (this.column.getColDef().colSpan == null) return;
		this.colsSpanning = this.getColSpanningList();
		this.addManagedListeners(this.beans.eventSvc, {
			displayedColumnsChanged: this.onDisplayColumnsChanged.bind(this),
			displayedColumnsWidthChanged: this.onWidthChanged.bind(this)
		});
	}
	onWidthChanged() {
		if (!this.eContent) return;
		const width = this.getCellWidth();
		this.eContent.style.width = `${width}px`;
	}
	getCellWidth() {
		if (!this.colsSpanning) return this.column.getActualWidth();
		return this.colsSpanning.reduce((width, col) => width + col.getActualWidth(), 0);
	}
	getColSpanningList() {
		const { column, rowNode } = this;
		const colSpan = column.getColSpan(rowNode);
		const colsSpanning = [];
		if (colSpan === 1) colsSpanning.push(column);
		else {
			let pointer = column;
			const pinned = column.getPinned();
			for (let i = 0; pointer && i < colSpan; i++) {
				colsSpanning.push(pointer);
				pointer = this.beans.visibleCols.getColAfter(pointer);
				if (!pointer || _missing(pointer)) break;
				if (pinned !== pointer.getPinned()) break;
			}
		}
		return colsSpanning;
	}
	onLeftChanged() {
		if (!this.eSetLeft) return;
		const left = this.modifyLeftForPrintLayout(this.getCellLeft());
		this.eSetLeft.style.left = left + "px";
	}
	getCellLeft() {
		let mostLeftCol;
		if (this.beans.gos.get("enableRtl") && this.colsSpanning) mostLeftCol = _last(this.colsSpanning);
		else mostLeftCol = this.column;
		return mostLeftCol.getLeft();
	}
	modifyLeftForPrintLayout(leftPosition) {
		if (!this.cellCtrl.printLayout || this.column.getPinned() === "left") return leftPosition;
		const { visibleCols } = this.beans;
		const leftWidth = visibleCols.getColsLeftWidth();
		if (this.column.getPinned() === "right") return leftWidth + visibleCols.bodyWidth + (leftPosition || 0);
		return leftWidth + (leftPosition || 0);
	}
	_legacyApplyRowSpan(force) {
		if (this.rowSpan === 1 && !force) return;
		const totalRowHeight = _getRowHeightAsNumber(this.beans) * this.rowSpan;
		this.eContent.style.height = `${totalRowHeight}px`;
		this.eContent.style.zIndex = "1";
	}
	destroy() {
		super.destroy();
	}
};
var CSS_CELL = "ag-cell";
var CSS_AUTO_HEIGHT = "ag-cell-auto-height";
var CSS_NORMAL_HEIGHT = "ag-cell-normal-height";
var CSS_CELL_FOCUS = "ag-cell-focus";
var CSS_CELL_FIRST_RIGHT_PINNED = "ag-cell-first-right-pinned";
var CSS_CELL_LAST_LEFT_PINNED = "ag-cell-last-left-pinned";
var CSS_CELL_NOT_INLINE_EDITING = "ag-cell-not-inline-editing";
var CSS_CELL_WRAP_TEXT = "ag-cell-wrap-text";
var DOM_DATA_KEY_CELL_CTRL = "cellCtrl";
function _getCellCtrlForEventTarget(gos, eventTarget) {
	return _getCtrlForEventTarget(gos, eventTarget, DOM_DATA_KEY_CELL_CTRL);
}
var instanceIdSequence2 = 0;
var CellCtrl = class extends BeanStub {
	constructor(column, rowNode, beans, rowCtrl) {
		super();
		this.column = column;
		this.rowNode = rowNode;
		this.rowCtrl = rowCtrl;
		this.rangeFeature = void 0;
		this.rowResizeFeature = void 0;
		this.positionFeature = void 0;
		this.customStyleFeature = void 0;
		this.editStyleFeature = void 0;
		this.mouseListener = void 0;
		this.keyboardListener = void 0;
		this.suppressRefreshCell = false;
		this.onCompAttachedFuncs = [];
		this.onEditorAttachedFuncs = [];
		this.focusEventWhileNotReady = null;
		this.hasBeenFocused = false;
		this.hasEdit = false;
		this.tooltipFeature = void 0;
		this.editorTooltipFeature = void 0;
		this.beans = beans;
		this.gos = beans.gos;
		this.editSvc = beans.editSvc;
		this.hasEdit = !!beans.editSvc;
		const { colId } = column;
		this.instanceId = colId + "-" + instanceIdSequence2++;
		this.createCellPosition();
		this.updateAndFormatValue(false);
	}
	addFeatures() {
		const { beans } = this;
		this.positionFeature = new CellPositionFeature(this, beans);
		this.customStyleFeature = beans.cellStyles?.createCellCustomStyleFeature(this, beans);
		this.editStyleFeature = beans.editSvc?.createCellStyleFeature(this, beans);
		this.mouseListener = new CellMouseListenerFeature(this, beans, this.column);
		this.keyboardListener = new CellKeyboardListenerFeature(this, beans, this.rowNode, this.rowCtrl);
		this.enableTooltipFeature();
		const { rangeSvc } = beans;
		if (rangeSvc && _isCellSelectionEnabled(beans.gos)) this.rangeFeature = rangeSvc.createCellRangeFeature(beans, this);
		if (isRowNumberCol(this.column)) this.rowResizeFeature = this.beans.rowNumbersSvc.createRowNumbersRowResizerFeature(beans, this);
	}
	isCellSpanning() {
		return false;
	}
	getCellSpan() {}
	removeFeatures() {
		const context = this.beans.context;
		this.positionFeature = context.destroyBean(this.positionFeature);
		this.editorTooltipFeature = context.destroyBean(this.editorTooltipFeature);
		this.customStyleFeature = context.destroyBean(this.customStyleFeature);
		this.editStyleFeature = context.destroyBean(this.editStyleFeature);
		this.mouseListener = context.destroyBean(this.mouseListener);
		this.keyboardListener = context.destroyBean(this.keyboardListener);
		this.rangeFeature = context.destroyBean(this.rangeFeature);
		this.rowResizeFeature = context.destroyBean(this.rowResizeFeature);
		this.disableTooltipFeature();
	}
	enableTooltipFeature(value, shouldDisplayTooltip) {
		this.tooltipFeature = this.beans.tooltipSvc?.enableCellTooltipFeature(this, value, shouldDisplayTooltip);
	}
	disableTooltipFeature() {
		this.tooltipFeature = this.beans.context.destroyBean(this.tooltipFeature);
	}
	enableEditorTooltipFeature(editor) {
		if (this.editorTooltipFeature) this.disableEditorTooltipFeature();
		this.editorTooltipFeature = this.beans.tooltipSvc?.setupCellEditorTooltip(this, editor);
		_populateModelValidationErrors(this.beans);
	}
	disableEditorTooltipFeature() {
		this.editorTooltipFeature = this.beans.context.destroyBean(this.editorTooltipFeature);
	}
	setComp(comp, eCell, _eWrapper, eCellWrapper, printLayout, startEditing, compBean) {
		this.comp = comp;
		this.eGui = eCell;
		this.printLayout = printLayout;
		compBean ?? (compBean = this);
		this.addDomData(compBean);
		this.addFeatures();
		compBean.addDestroyFunc(() => this.removeFeatures());
		this.onSuppressCellFocusChanged(this.beans.gos.get("suppressCellFocus"));
		this.setupFocus();
		this.applyStaticCssClasses();
		this.setWrapText();
		this.onFirstRightPinnedChanged();
		this.onLastLeftPinnedChanged();
		this.onColumnHover();
		this.setupControlComps();
		this.setupAutoHeight(eCellWrapper, compBean);
		this.refreshFirstAndLastStyles();
		this.refreshAriaColIndex();
		this.positionFeature?.init();
		this.customStyleFeature?.setComp(comp);
		this.editStyleFeature?.setComp(comp);
		this.tooltipFeature?.refreshTooltip();
		this.keyboardListener?.init();
		this.rangeFeature?.setComp(comp);
		this.rowResizeFeature?.refreshRowResizer();
		if (startEditing && this.isCellEditable()) this.editSvc?.startEditing(this, {
			startedEdit: true,
			source: "api"
		});
		else this.showValue(false, true);
		if (this.onCompAttachedFuncs.length) {
			this.onCompAttachedFuncs.forEach((func) => func());
			this.onCompAttachedFuncs = [];
		}
	}
	setupAutoHeight(eCellWrapper, compBean) {
		this.isAutoHeight = this.beans.rowAutoHeight?.setupCellAutoHeight(this, eCellWrapper, compBean) ?? false;
	}
	getCellAriaRole() {
		return this.column.getColDef().cellAriaRole ?? "gridcell";
	}
	isCellRenderer() {
		const colDef = this.column.getColDef();
		return colDef.cellRenderer != null || colDef.cellRendererSelector != null;
	}
	getValueToDisplay() {
		return this.valueFormatted ?? this.value;
	}
	getDeferLoadingCellRenderer() {
		const { beans, column } = this;
		const { userCompFactory, ctrlsSvc, eventSvc } = beans;
		const colDef = column.getColDef();
		const params = this.createCellRendererParams();
		params.deferRender = true;
		const loadingDetails = _getLoadingCellRendererDetails(userCompFactory, colDef, params);
		if (ctrlsSvc.getGridBodyCtrl()?.scrollFeature?.isScrolling()) {
			let resolver;
			const onReady = new AgPromise((resolve) => {
				resolver = resolve;
			});
			this.addManagedListeners(eventSvc, { bodyScrollEnd: () => resolver() });
			return {
				loadingComp: loadingDetails,
				onReady
			};
		}
		return {
			loadingComp: loadingDetails,
			onReady: AgPromise.resolve()
		};
	}
	showValue(forceNewCellRendererInstance, skipRangeHandleRefresh) {
		const { beans, column, rowNode, rangeFeature } = this;
		const { userCompFactory } = beans;
		let valueToDisplay = this.getValueToDisplay();
		let compDetails;
		const isSsrmLoading = rowNode.stub && rowNode.groupData?.[column.getId()] == null;
		const colDef = column.getColDef();
		if (isSsrmLoading || this.isCellRenderer()) {
			const params = this.createCellRendererParams();
			if (!isSsrmLoading || isRowNumberCol(column)) compDetails = _getCellRendererDetails(userCompFactory, colDef, params);
			else compDetails = _getLoadingCellRendererDetails(userCompFactory, colDef, params);
		}
		if (!compDetails && !isSsrmLoading && beans.findSvc?.isMatch(rowNode, column)) {
			const params = this.createCellRendererParams();
			compDetails = _getCellRendererDetails(userCompFactory, {
				...column.getColDef(),
				cellRenderer: "agFindCellRenderer"
			}, params);
		}
		if (this.hasEdit && this.editSvc.isBatchEditing() && this.editSvc.isRowEditing(rowNode, { checkSiblings: true })) {
			const result = this.editSvc.prepDetailsDuringBatch(this, {
				compDetails,
				valueToDisplay
			});
			if (result) {
				if (result.compDetails) compDetails = result.compDetails;
				else if (result.valueToDisplay) valueToDisplay = result.valueToDisplay;
			}
		}
		this.comp.setRenderDetails(compDetails, valueToDisplay, forceNewCellRendererInstance);
		if (!skipRangeHandleRefresh && rangeFeature) _requestAnimationFrame(beans, () => rangeFeature?.refreshHandle());
		this.rowResizeFeature?.refreshRowResizer();
	}
	setupControlComps() {
		const colDef = this.column.getColDef();
		this.includeSelection = this.isIncludeControl(this.isCheckboxSelection(colDef), true);
		this.includeRowDrag = this.isIncludeControl(colDef.rowDrag);
		this.includeDndSource = this.isIncludeControl(colDef.dndSource);
		this.comp.setIncludeSelection(this.includeSelection);
		this.comp.setIncludeDndSource(this.includeDndSource);
		this.comp.setIncludeRowDrag(this.includeRowDrag);
	}
	isForceWrapper() {
		return this.beans.gos.get("enableCellTextSelection") || this.column.isAutoHeight();
	}
	isIncludeControl(value, allowManuallyPinned = false) {
		return (this.rowNode.rowPinned == null || allowManuallyPinned && _isManualPinnedRow(this.rowNode)) && !!value;
	}
	isCheckboxSelection(colDef) {
		const { rowSelection, groupDisplayType } = this.beans.gridOptions;
		const checkboxLocation = _getCheckboxLocation(rowSelection);
		const isSelectionColumn = isColumnSelectionCol(this.column);
		if (groupDisplayType === "custom" && checkboxLocation !== "selectionColumn" && isSelectionColumn) return false;
		return colDef.checkboxSelection || isSelectionColumn && typeof rowSelection === "object" && _getCheckboxes(rowSelection);
	}
	refreshShouldDestroy() {
		const colDef = this.column.getColDef();
		const selectionChanged = this.includeSelection != this.isIncludeControl(this.isCheckboxSelection(colDef), true);
		const rowDragChanged = this.includeRowDrag != this.isIncludeControl(colDef.rowDrag);
		const dndSourceChanged = this.includeDndSource != this.isIncludeControl(colDef.dndSource);
		const autoHeightChanged = this.isAutoHeight != this.column.isAutoHeight();
		return selectionChanged || rowDragChanged || dndSourceChanged || autoHeightChanged;
	}
	onPopupEditorClosed() {
		const { editSvc } = this.beans;
		if (!editSvc?.isEditing(this, { withOpenEditor: true })) return;
		editSvc?.stopEditing(this, { source: editSvc?.isBatchEditing() ? "ui" : "api" });
	}
	stopEditing(cancel = false) {
		const { editSvc } = this.beans;
		return editSvc?.stopEditing(this, {
			cancel,
			source: editSvc?.isBatchEditing() ? "ui" : "api"
		}) ?? false;
	}
	createCellRendererParams() {
		const { value, valueFormatted, column, rowNode, comp, eGui, beans: { valueSvc, gos, editSvc } } = this;
		return _addGridCommonParams(gos, {
			value,
			valueFormatted,
			getValue: () => valueSvc.getValueForDisplay(column, rowNode).value,
			setValue: (value2) => editSvc?.setDataValue({
				rowNode,
				column
			}, value2) || valueSvc.setValue(rowNode, column, value2),
			formatValue: this.formatValue.bind(this),
			data: rowNode.data,
			node: rowNode,
			pinned: column.getPinned(),
			colDef: column.getColDef(),
			column,
			refreshCell: this.refreshCell.bind(this),
			eGridCell: eGui,
			eParentOfValue: comp.getParentOfValue(),
			registerRowDragger: (rowDraggerElement, dragStartPixels, value2, suppressVisibilityChange) => this.registerRowDragger(rowDraggerElement, dragStartPixels, suppressVisibilityChange),
			setTooltip: (value2, shouldDisplayTooltip) => {
				gos.assertModuleRegistered("Tooltip", 3);
				if (this.tooltipFeature) this.disableTooltipFeature();
				this.enableTooltipFeature(value2, shouldDisplayTooltip);
				this.tooltipFeature?.refreshTooltip();
			}
		});
	}
	onCellChanged(event) {
		if (event.column === this.column) this.refreshCell({});
	}
	refreshOrDestroyCell(params) {
		if (this.refreshShouldDestroy()) this.rowCtrl?.recreateCell(this);
		else this.refreshCell(params);
	}
	refreshCell({ force, suppressFlash, newData } = {}) {
		if (this.suppressRefreshCell) return;
		const colDef = this.column.getColDef();
		const noValueProvided = colDef.field == null && colDef.valueGetter == null && colDef.showRowGroup == null;
		const forceRefresh = force || noValueProvided || newData;
		const isCellCompReady = !!this.comp;
		const valuesDifferent = this.updateAndFormatValue(isCellCompReady);
		const dataNeedsUpdating = forceRefresh || valuesDifferent;
		if (!isCellCompReady) return;
		if (dataNeedsUpdating) {
			this.showValue(!!newData, false);
			const processingFilterChange = this.beans.filterManager?.isSuppressFlashingCellsBecauseFiltering();
			if (!suppressFlash && !processingFilterChange && colDef.enableCellChangeFlash) this.beans.cellFlashSvc?.flashCell(this);
			this.editStyleFeature?.applyCellStyles?.();
			this.customStyleFeature?.applyUserStyles();
			this.customStyleFeature?.applyClassesFromColDef();
		}
		this.tooltipFeature?.refreshTooltip();
		this.customStyleFeature?.applyCellClassRules();
	}
	isCellEditable() {
		return this.column.isCellEditable(this.rowNode);
	}
	formatValue(value) {
		return this.callValueFormatter(value) ?? value;
	}
	callValueFormatter(value) {
		return this.beans.valueSvc.formatValue(this.column, this.rowNode, value);
	}
	updateAndFormatValue(compareValues) {
		const oldValue = this.value;
		const oldValueFormatted = this.valueFormatted;
		const { value, valueFormatted } = this.beans.valueSvc.getValueForDisplay(this.column, this.rowNode, true);
		this.value = value;
		this.valueFormatted = valueFormatted;
		if (compareValues) return !this.valuesAreEqual(oldValue, this.value) || this.valueFormatted != oldValueFormatted;
		return true;
	}
	valuesAreEqual(val1, val2) {
		const colDef = this.column.getColDef();
		return colDef.equals ? colDef.equals(val1, val2) : val1 === val2;
	}
	addDomData(compBean) {
		const element = this.eGui;
		_setDomData(this.beans.gos, element, DOM_DATA_KEY_CELL_CTRL, this);
		compBean.addDestroyFunc(() => _setDomData(this.beans.gos, element, DOM_DATA_KEY_CELL_CTRL, null));
	}
	createEvent(domEvent, eventType) {
		const { rowNode, column, value, beans } = this;
		return _createCellEvent(beans, domEvent, eventType, {
			rowNode,
			column
		}, value);
	}
	processCharacter(event) {
		this.keyboardListener?.processCharacter(event);
	}
	onKeyDown(event) {
		this.keyboardListener?.onKeyDown(event);
	}
	onMouseEvent(eventName, mouseEvent) {
		this.mouseListener?.onMouseEvent(eventName, mouseEvent);
	}
	getColSpanningList() {
		return this.positionFeature?.getColSpanningList() ?? [];
	}
	onLeftChanged() {
		if (!this.comp) return;
		this.positionFeature?.onLeftChanged();
	}
	onDisplayedColumnsChanged() {
		if (!this.eGui) return;
		this.refreshAriaColIndex();
		this.refreshFirstAndLastStyles();
	}
	refreshFirstAndLastStyles() {
		const { comp, column, beans } = this;
		refreshFirstAndLastStyles(comp, column, beans.visibleCols);
	}
	refreshAriaColIndex() {
		const colIdx = this.beans.visibleCols.getAriaColIndex(this.column);
		_setAriaColIndex(this.eGui, colIdx);
	}
	onWidthChanged() {
		return this.positionFeature?.onWidthChanged();
	}
	getRowPosition() {
		const { rowIndex, rowPinned } = this.cellPosition;
		return {
			rowIndex,
			rowPinned
		};
	}
	updateRangeBordersIfRangeCount() {
		if (!this.comp) return;
		this.rangeFeature?.updateRangeBordersIfRangeCount();
	}
	onCellSelectionChanged() {
		if (!this.comp) return;
		this.rangeFeature?.onCellSelectionChanged();
	}
	isRangeSelectionEnabled() {
		return this.rangeFeature != null;
	}
	focusCell(forceBrowserFocus = false, sourceEvent) {
		const allowedTarget = this.editSvc?.allowedFocusTargetOnValidation(this);
		if (allowedTarget && allowedTarget !== this) return;
		this.beans.focusSvc.setFocusedCell({
			...this.getFocusedCellPosition(),
			forceBrowserFocus,
			sourceEvent
		});
	}
	restoreFocus(waitForRender = false) {
		const { beans: { editSvc, focusSvc }, comp } = this;
		if (!comp || editSvc?.isEditing(this) || !this.isCellFocused() || !focusSvc.shouldTakeFocus()) return;
		const focus = () => {
			if (!this.isAlive()) return;
			const focusableElement = comp.getFocusableElement();
			if (this.isCellFocused()) focusableElement.focus({ preventScroll: true });
		};
		if (waitForRender) {
			setTimeout(focus, 0);
			return;
		}
		focus();
	}
	onRowIndexChanged() {
		this.createCellPosition();
		this.onCellFocused();
		this.restoreFocus();
		this.rangeFeature?.onCellSelectionChanged();
		this.rowResizeFeature?.refreshRowResizer();
	}
	onSuppressCellFocusChanged(suppressCellFocus) {
		const element = this.eGui;
		if (!element) return;
		if (isRowNumberCol(this.column)) suppressCellFocus = true;
		_addOrRemoveAttribute(element, "tabindex", suppressCellFocus ? void 0 : -1);
	}
	onFirstRightPinnedChanged() {
		if (!this.comp) return;
		const firstRightPinned = this.column.isFirstRightPinned();
		this.comp.toggleCss(CSS_CELL_FIRST_RIGHT_PINNED, firstRightPinned);
	}
	onLastLeftPinnedChanged() {
		if (!this.comp) return;
		const lastLeftPinned = this.column.isLastLeftPinned();
		this.comp.toggleCss(CSS_CELL_LAST_LEFT_PINNED, lastLeftPinned);
	}
	checkCellFocused() {
		return this.beans.focusSvc.isCellFocused(this.cellPosition);
	}
	isCellFocused() {
		const isFocused = this.checkCellFocused();
		this.hasBeenFocused || (this.hasBeenFocused = isFocused);
		return isFocused;
	}
	setupFocus() {
		this.restoreFocus(true);
		this.onCellFocused(this.focusEventWhileNotReady ?? void 0);
	}
	onCellFocused(event) {
		const { beans } = this;
		if (_isCellFocusSuppressed(beans)) return;
		if (!this.comp) {
			if (event) this.focusEventWhileNotReady = event;
			return;
		}
		const cellFocused = this.isCellFocused();
		const editing = beans.editSvc?.isEditing(this) ?? false;
		this.comp.toggleCss(CSS_CELL_FOCUS, cellFocused);
		if (cellFocused && event && event.forceBrowserFocus) {
			let focusEl = this.comp.getFocusableElement();
			if (editing) {
				const focusableEls = _findFocusableElements(focusEl, null, true);
				if (focusableEls.length) focusEl = focusableEls[0];
			}
			focusEl.focus({ preventScroll: !!event.preventScrollOnBrowserFocus });
		}
		if (cellFocused) this.rowCtrl.announceDescription();
	}
	createCellPosition() {
		const { rowIndex, rowPinned } = this.rowNode;
		this.cellPosition = {
			rowIndex,
			rowPinned: _makeNull(rowPinned),
			column: this.column
		};
	}
	applyStaticCssClasses() {
		const { comp } = this;
		comp.toggleCss(CSS_CELL, true);
		comp.toggleCss(CSS_CELL_NOT_INLINE_EDITING, true);
		const autoHeight = this.column.isAutoHeight() == true;
		comp.toggleCss(CSS_AUTO_HEIGHT, autoHeight);
		comp.toggleCss(CSS_NORMAL_HEIGHT, !autoHeight);
	}
	onColumnHover() {
		this.beans.colHover?.onCellColumnHover(this.column, this.comp);
	}
	onColDefChanged() {
		if (!this.comp) return;
		if (this.column.isTooltipEnabled()) {
			this.disableTooltipFeature();
			this.enableTooltipFeature();
		} else this.disableTooltipFeature();
		this.setWrapText();
		if (this.editSvc?.isEditing(this)) this.editSvc?.handleColDefChanged(this);
		else this.refreshOrDestroyCell({
			force: true,
			suppressFlash: true
		});
	}
	setWrapText() {
		const value = this.column.getColDef().wrapText == true;
		this.comp.toggleCss(CSS_CELL_WRAP_TEXT, value);
	}
	dispatchCellContextMenuEvent(event) {
		const colDef = this.column.getColDef();
		const cellContextMenuEvent = this.createEvent(event, "cellContextMenu");
		const { beans } = this;
		beans.eventSvc.dispatchEvent(cellContextMenuEvent);
		if (colDef.onCellContextMenu) window.setTimeout(() => {
			beans.frameworkOverrides.wrapOutgoing(() => {
				colDef.onCellContextMenu(cellContextMenuEvent);
			});
		}, 0);
	}
	getCellRenderer() {
		return this.comp?.getCellRenderer() ?? null;
	}
	destroy() {
		this.onCompAttachedFuncs = [];
		this.onEditorAttachedFuncs = [];
		if (this.isCellFocused() && this.hasBrowserFocus()) this.beans.focusSvc.attemptToRecoverFocus();
		super.destroy();
	}
	hasBrowserFocus() {
		return this.eGui?.contains(_getActiveDomElement(this.beans)) ?? false;
	}
	createSelectionCheckbox() {
		const cbSelectionComponent = this.beans.selectionSvc?.createCheckboxSelectionComponent();
		if (!cbSelectionComponent) return;
		this.beans.context.createBean(cbSelectionComponent);
		cbSelectionComponent.init({
			rowNode: this.rowNode,
			column: this.column
		});
		return cbSelectionComponent;
	}
	createDndSource() {
		const dndSourceComp = this.beans.registry.createDynamicBean("dndSourceComp", false, this.rowNode, this.column, this.eGui);
		if (dndSourceComp) this.beans.context.createBean(dndSourceComp);
		return dndSourceComp;
	}
	registerRowDragger(customElement, dragStartPixels, suppressVisibilityChange) {
		if (this.customRowDragComp) {
			this.customRowDragComp.setDragElement(customElement, dragStartPixels);
			return;
		}
		const newComp = this.createRowDragComp(customElement, dragStartPixels, suppressVisibilityChange);
		if (newComp) {
			this.customRowDragComp = newComp;
			this.addDestroyFunc(() => {
				this.beans.context.destroyBean(newComp);
				this.customRowDragComp = null;
			});
		}
	}
	createRowDragComp(customElement, dragStartPixels, suppressVisibilityChange) {
		const rowDragComp = this.beans.rowDragSvc?.createRowDragCompForCell(this.rowNode, this.column, () => this.value, customElement, dragStartPixels, suppressVisibilityChange);
		if (!rowDragComp) return;
		this.beans.context.createBean(rowDragComp);
		return rowDragComp;
	}
	cellEditorAttached() {
		this.onEditorAttachedFuncs.forEach((func) => func());
		this.onEditorAttachedFuncs = [];
	}
	setFocusedCellPosition(_cellPosition) {}
	getFocusedCellPosition() {
		return this.cellPosition;
	}
	refreshAriaRowIndex() {}
	getRootElement() {
		return this.eGui;
	}
};
var GRID_DOM_KEY = "__ag_grid_instance";
function _stampTopLevelGridCompWithGridInstance(gos, eGridDiv) {
	eGridDiv[GRID_DOM_KEY] = gos.gridInstanceId;
}
function _isEventFromThisGrid(gos, event) {
	return _isElementInThisGrid(gos, event.target);
}
function _isElementInThisGrid(gos, element) {
	let pointer = element;
	while (pointer) {
		const instanceId = pointer[GRID_DOM_KEY];
		if (_exists(instanceId)) return instanceId === gos.gridInstanceId;
		pointer = pointer.parentElement;
	}
	return false;
}
function _getCellPositionForEvent(gos, event) {
	return _getCellCtrlForEventTarget(gos, event.target)?.getFocusedCellPosition() ?? null;
}
var DragAndDropService = class extends BeanStub {
	constructor() {
		super(...arguments);
		this.beanName = "dragAndDrop";
		this.dragSourceAndParamsList = [];
		this.dropTargets = [];
	}
	wireBeans(beans) {
		this.ctrlsSvc = beans.ctrlsSvc;
		this.dragSvc = beans.dragSvc;
		this.environment = beans.environment;
		this.userCompFactory = beans.userCompFactory;
	}
	addDragSource(dragSource, allowTouch = false) {
		const params = {
			eElement: dragSource.eElement,
			dragStartPixels: dragSource.dragStartPixels,
			onDragStart: this.onDragStart.bind(this, dragSource),
			onDragStop: this.onDragStop.bind(this),
			onDragging: this.onDragging.bind(this),
			onDragCancel: this.onDragCancel.bind(this),
			includeTouch: allowTouch
		};
		this.dragSourceAndParamsList.push({
			params,
			dragSource
		});
		this.dragSvc.addDragSource(params);
	}
	getDragAndDropImageComponent() {
		const { dragAndDropImageComp } = this;
		if (!dragAndDropImageComp || !dragAndDropImageComp.comp) return null;
		return dragAndDropImageComp.comp;
	}
	removeDragSource(dragSource) {
		const { dragSourceAndParamsList, dragSvc } = this;
		const sourceAndParams = dragSourceAndParamsList.find((item) => item.dragSource === dragSource);
		if (sourceAndParams) {
			dragSvc.removeDragSource(sourceAndParams.params);
			_removeFromArray(dragSourceAndParamsList, sourceAndParams);
		}
	}
	destroy() {
		const { dragSourceAndParamsList, dragSvc, dropTargets } = this;
		dragSourceAndParamsList.forEach((sourceAndParams) => dragSvc.removeDragSource(sourceAndParams.params));
		dragSourceAndParamsList.length = 0;
		dropTargets.length = 0;
		this.clearDragAndDropProperties();
		super.destroy();
	}
	nudge() {
		if (this.dragging) this.onDragging(this.eventLastTime, true);
	}
	onDragStart(dragSource, mouseEvent) {
		this.dragging = true;
		this.dragSource = dragSource;
		this.eventLastTime = mouseEvent;
		this.dragItem = dragSource.getDragItem();
		dragSource.onDragStarted?.();
		this.createDragAndDropImageComponent();
	}
	onDragStop(mouseEvent) {
		this.dragSource?.onDragStopped?.();
		const { lastDropTarget } = this;
		if (lastDropTarget?.onDragStop) {
			const draggingEvent = this.createDropTargetEvent(lastDropTarget, mouseEvent, null, null, false);
			lastDropTarget.onDragStop(draggingEvent);
		}
		this.clearDragAndDropProperties();
	}
	onDragCancel() {
		const { dragSource, lastDropTarget } = this;
		dragSource?.onDragCancelled?.();
		if (lastDropTarget?.onDragCancel) lastDropTarget.onDragCancel(this.createDropTargetEvent(lastDropTarget, this.eventLastTime, null, null, false));
		this.clearDragAndDropProperties();
	}
	clearDragAndDropProperties() {
		this.eventLastTime = null;
		this.dragging = false;
		this.lastDropTarget = void 0;
		this.dragItem = null;
		this.dragSource = null;
		this.removeDragAndDropImageComponent();
	}
	onDragging(mouseEvent, fromNudge = false) {
		const hDirection = this.getHorizontalDirection(mouseEvent);
		const vDirection = this.getVerticalDirection(mouseEvent);
		this.eventLastTime = mouseEvent;
		this.positionDragAndDropImageComp(mouseEvent);
		const validDropTargets = this.dropTargets.filter((target) => this.isMouseOnDropTarget(mouseEvent, target));
		const dropTarget = this.findCurrentDropTarget(mouseEvent, validDropTargets);
		const { lastDropTarget, dragSource, dragAndDropImageComp, dragItem } = this;
		if (dropTarget !== lastDropTarget) {
			this.leaveLastTargetIfExists(mouseEvent, hDirection, vDirection, fromNudge);
			if (lastDropTarget !== null && dropTarget === null) dragSource?.onGridExit?.(dragItem);
			if (lastDropTarget === null && dropTarget !== null) dragSource?.onGridEnter?.(dragItem);
			this.enterDragTargetIfExists(dropTarget, mouseEvent, hDirection, vDirection, fromNudge);
			if (dropTarget && dragAndDropImageComp) {
				const { comp, promise } = dragAndDropImageComp;
				if (comp) comp.setIcon(dropTarget.getIconName ? dropTarget.getIconName() : null, false);
				else promise.then((resolvedComponent) => {
					if (resolvedComponent) resolvedComponent.setIcon(dropTarget.getIconName ? dropTarget.getIconName() : null, false);
				});
			}
			this.lastDropTarget = dropTarget;
		} else if (dropTarget && dropTarget.onDragging) {
			const draggingEvent = this.createDropTargetEvent(dropTarget, mouseEvent, hDirection, vDirection, fromNudge);
			dropTarget.onDragging(draggingEvent);
		}
	}
	getAllContainersFromDropTarget(dropTarget) {
		const secondaryContainers = dropTarget.getSecondaryContainers ? dropTarget.getSecondaryContainers() : null;
		const containers = [[dropTarget.getContainer()]];
		return secondaryContainers ? containers.concat(secondaryContainers) : containers;
	}
	isMouseOnDropTarget(mouseEvent, dropTarget) {
		const allContainersFromDropTarget = this.getAllContainersFromDropTarget(dropTarget);
		let mouseOverTarget = false;
		const allContainersIntersect = (mouseEvent2, containers) => {
			for (const container of containers) {
				const { width, height, left, right, top, bottom } = container.getBoundingClientRect();
				if (width === 0 || height === 0) return false;
				const horizontalFit = mouseEvent2.clientX >= left && mouseEvent2.clientX < right;
				const verticalFit = mouseEvent2.clientY >= top && mouseEvent2.clientY < bottom;
				if (!horizontalFit || !verticalFit) return false;
			}
			return true;
		};
		for (const currentContainers of allContainersFromDropTarget) if (allContainersIntersect(mouseEvent, currentContainers)) {
			mouseOverTarget = true;
			break;
		}
		const { eElement, type } = this.dragSource;
		if (dropTarget.targetContainsSource && !dropTarget.getContainer().contains(eElement)) return false;
		return mouseOverTarget && dropTarget.isInterestedIn(type, eElement);
	}
	findCurrentDropTarget(mouseEvent, validDropTargets) {
		const len = validDropTargets.length;
		if (len === 0) return null;
		if (len === 1) return validDropTargets[0];
		const elementStack = _getRootNode(this.beans).elementsFromPoint(mouseEvent.clientX, mouseEvent.clientY);
		for (const el of elementStack) for (const dropTarget of validDropTargets) if (this.getAllContainersFromDropTarget(dropTarget).flatMap((a) => a).indexOf(el) !== -1) return dropTarget;
		return null;
	}
	enterDragTargetIfExists(dropTarget, mouseEvent, hDirection, vDirection, fromNudge) {
		if (!dropTarget) return;
		if (dropTarget.onDragEnter) {
			const dragEnterEvent = this.createDropTargetEvent(dropTarget, mouseEvent, hDirection, vDirection, fromNudge);
			dropTarget.onDragEnter(dragEnterEvent);
		}
	}
	leaveLastTargetIfExists(mouseEvent, hDirection, vDirection, fromNudge) {
		const { lastDropTarget } = this;
		if (!lastDropTarget) return;
		if (lastDropTarget.onDragLeave) {
			const dragLeaveEvent = this.createDropTargetEvent(lastDropTarget, mouseEvent, hDirection, vDirection, fromNudge);
			lastDropTarget.onDragLeave(dragLeaveEvent);
		}
		const dragAndDropImageComponent = this.getDragAndDropImageComponent();
		if (dragAndDropImageComponent) dragAndDropImageComponent.setIcon(null, false);
	}
	addDropTarget(dropTarget) {
		this.dropTargets.push(dropTarget);
	}
	removeDropTarget(dropTarget) {
		this.dropTargets = this.dropTargets.filter((target) => target.getContainer() !== dropTarget.getContainer());
	}
	hasExternalDropZones() {
		return this.dropTargets.some((zones) => zones.external);
	}
	findExternalZone(params) {
		return this.dropTargets.filter((target) => target.external).find((zone) => zone.getContainer() === params.getContainer()) || null;
	}
	isDropZoneWithinThisGrid(draggingEvent) {
		const gridGui = this.ctrlsSvc.getGridBodyCtrl().eGridBody;
		const { dropZoneTarget } = draggingEvent;
		return gridGui.contains(dropZoneTarget);
	}
	getHorizontalDirection(event) {
		const clientX = this.eventLastTime?.clientX;
		const eClientX = event.clientX;
		if (clientX === eClientX) return null;
		return clientX > eClientX ? "left" : "right";
	}
	getVerticalDirection(event) {
		const clientY = this.eventLastTime?.clientY;
		const eClientY = event.clientY;
		if (clientY === eClientY) return null;
		return clientY > eClientY ? "up" : "down";
	}
	createDropTargetEvent(dropTarget, event, hDirection, vDirection, fromNudge) {
		const dropZoneTarget = dropTarget.getContainer();
		const rect = dropZoneTarget.getBoundingClientRect();
		const { dragItem, dragSource, gos } = this;
		return _addGridCommonParams(gos, {
			event,
			x: event.clientX - rect.left,
			y: event.clientY - rect.top,
			vDirection,
			hDirection,
			dragSource,
			fromNudge,
			dragItem,
			dropZoneTarget
		});
	}
	positionDragAndDropImageComp(event) {
		const dragAndDropImageComponent = this.getDragAndDropImageComponent();
		if (!dragAndDropImageComponent) return;
		_anchorElementToMouseMoveEvent(dragAndDropImageComponent.getGui(), event, this.beans);
	}
	removeDragAndDropImageComponent() {
		const { dragAndDropImageComp } = this;
		if (dragAndDropImageComp) {
			const { comp } = dragAndDropImageComp;
			if (comp) {
				const eGui = comp.getGui();
				this.dragAndDropImageParent?.removeChild(eGui);
				this.destroyBean(comp);
			}
		}
		this.dragAndDropImageComp = null;
	}
	createDragAndDropImageComponent() {
		const { dragSource, gos, userCompFactory } = this;
		if (!dragSource) return;
		const userCompDetails = _getDragAndDropImageCompDetails(userCompFactory, _addGridCommonParams(gos, { dragSource }));
		if (!userCompDetails) return;
		const promise = userCompDetails.newAgStackInstance();
		this.dragAndDropImageComp = { promise };
		promise.then((comp) => {
			if (!comp || !this.isAlive()) return;
			this.processDragAndDropImageComponent(comp);
			this.dragAndDropImageComp.comp = comp;
		});
	}
	processDragAndDropImageComponent(dragAndDropImageComponent) {
		const { dragSource, environment } = this;
		if (!dragSource) return;
		const eGui = dragAndDropImageComponent.getGui();
		eGui.style.setProperty("position", "absolute");
		eGui.style.setProperty("z-index", "9999");
		_stampTopLevelGridCompWithGridInstance(this.gos, eGui);
		environment.applyThemeClasses(eGui);
		dragAndDropImageComponent.setIcon(null, false);
		let { dragItemName } = dragSource;
		if (typeof dragItemName === "function") dragItemName = dragItemName();
		dragAndDropImageComponent.setLabel(dragItemName || "");
		eGui.style.top = "20px";
		eGui.style.left = "20px";
		const targetEl = _getPageBody(this.beans);
		this.dragAndDropImageParent = targetEl;
		if (!targetEl) _warn(54);
		else targetEl.appendChild(eGui);
	}
	registerGridDropTarget(elementFn, ctrl) {
		const dropTarget = {
			getContainer: elementFn,
			isInterestedIn: (type) => type === 1 || type === 0,
			getIconName: () => "notAllowed"
		};
		this.addDropTarget(dropTarget);
		ctrl.addDestroyFunc(() => this.removeDropTarget(dropTarget));
	}
};
var DragService = class extends BeanStub {
	constructor() {
		super(...arguments);
		this.beanName = "dragSvc";
		this.dragEndFunctions = [];
		this.dragSources = [];
	}
	destroy() {
		const { dragSources } = this;
		dragSources.forEach(this.removeListener.bind(this));
		dragSources.length = 0;
		super.destroy();
	}
	removeListener(dragSourceAndListener) {
		const element = dragSourceAndListener.dragSource.eElement;
		const mouseDownListener = dragSourceAndListener.mouseDownListener;
		element.removeEventListener("mousedown", mouseDownListener);
		if (dragSourceAndListener.touchEnabled) {
			const touchStartListener = dragSourceAndListener.touchStartListener;
			element.removeEventListener("touchstart", touchStartListener, { passive: true });
		}
	}
	removeDragSource(params) {
		const { dragSources } = this;
		const dragSourceAndListener = dragSources.find((item) => item.dragSource === params);
		if (!dragSourceAndListener) return;
		this.removeListener(dragSourceAndListener);
		_removeFromArray(dragSources, dragSourceAndListener);
	}
	addDragSource(params) {
		const mouseListener = this.onMouseDown.bind(this, params);
		const { eElement, includeTouch, stopPropagationForTouch } = params;
		eElement.addEventListener("mousedown", mouseListener);
		let touchListener = null;
		const suppressTouch = this.gos.get("suppressTouch");
		if (includeTouch && !suppressTouch) {
			touchListener = (touchEvent) => {
				if (_isFocusableFormField(touchEvent.target)) return;
				if (stopPropagationForTouch) touchEvent.stopPropagation();
				this.onTouchStart(params, touchEvent);
			};
			eElement.addEventListener("touchstart", touchListener, { passive: false });
		}
		this.dragSources.push({
			dragSource: params,
			mouseDownListener: mouseListener,
			touchStartListener: touchListener,
			touchEnabled: !!includeTouch
		});
	}
	onTouchStart(params, touchEvent) {
		this.currentDragParams = params;
		this.dragging = false;
		const touch = touchEvent.touches[0];
		this.touchLastTime = touch;
		this.touchStart = touch;
		const touchMoveEvent = (e) => this.onTouchMove(e, params.eElement);
		const touchEndEvent = (e) => this.onTouchUp(e, params.eElement);
		const documentTouchMove = (e) => {
			if (e.cancelable) e.preventDefault();
		};
		const target = touchEvent.target;
		const events = [
			{
				target: _getRootNode(this.beans),
				type: "touchmove",
				listener: documentTouchMove,
				options: { passive: false }
			},
			{
				target,
				type: "touchmove",
				listener: touchMoveEvent,
				options: { passive: true }
			},
			{
				target,
				type: "touchend",
				listener: touchEndEvent,
				options: { passive: true }
			},
			{
				target,
				type: "touchcancel",
				listener: touchEndEvent,
				options: { passive: true }
			}
		];
		this.addTemporaryEvents(events);
		if (params.dragStartPixels === 0) this.onCommonMove(touch, this.touchStart, params.eElement);
	}
	onMouseDown(params, mouseEvent) {
		const e = mouseEvent;
		if (params.skipMouseEvent && params.skipMouseEvent(mouseEvent)) return;
		if (e._alreadyProcessedByDragService) return;
		e._alreadyProcessedByDragService = true;
		if (mouseEvent.button !== 0) return;
		if (this.shouldPreventMouseEvent(mouseEvent)) mouseEvent.preventDefault();
		this.currentDragParams = params;
		this.dragging = false;
		this.mouseStartEvent = mouseEvent;
		this.startTarget = mouseEvent.target;
		const mouseMoveEvent = (event) => this.onMouseMove(event, params.eElement);
		const mouseUpEvent = (event) => this.onMouseUp(event, params.eElement);
		const contextEvent = (event) => event.preventDefault();
		const keydownEvent = (event) => {
			if (event.key === KeyCode.ESCAPE) this.cancelDrag(params.eElement);
		};
		const target = _getRootNode(this.beans);
		const events = [
			{
				target,
				type: "mousemove",
				listener: mouseMoveEvent
			},
			{
				target,
				type: "mouseup",
				listener: mouseUpEvent
			},
			{
				target,
				type: "contextmenu",
				listener: contextEvent
			},
			{
				target,
				type: "keydown",
				listener: keydownEvent
			}
		];
		this.addTemporaryEvents(events);
		if (params.dragStartPixels === 0) this.onMouseMove(mouseEvent, params.eElement);
	}
	addTemporaryEvents(events) {
		events.forEach((currentEvent) => {
			const { target, type, listener, options } = currentEvent;
			target.addEventListener(type, listener, options);
		});
		this.dragEndFunctions.push(() => {
			events.forEach((currentEvent) => {
				const { target, type, listener, options } = currentEvent;
				target.removeEventListener(type, listener, options);
			});
		});
	}
	isEventNearStartEvent(currentEvent, startEvent) {
		const { dragStartPixels } = this.currentDragParams;
		return _areEventsNear(currentEvent, startEvent, _exists(dragStartPixels) ? dragStartPixels : 4);
	}
	getFirstActiveTouch(touchList) {
		for (let i = 0; i < touchList.length; i++) if (touchList[i].identifier === this.touchStart.identifier) return touchList[i];
		return null;
	}
	onCommonMove(currentEvent, startEvent, el) {
		if (!this.dragging) {
			if (this.isEventNearStartEvent(currentEvent, startEvent)) return;
			this.dragging = true;
			this.eventSvc.dispatchEvent({
				type: "dragStarted",
				target: el
			});
			this.currentDragParams.onDragStart(startEvent);
			if (!this.currentDragParams) {
				this.dragging = false;
				return;
			}
			this.currentDragParams.onDragging(startEvent);
		}
		this.currentDragParams?.onDragging(currentEvent);
	}
	onTouchMove(touchEvent, el) {
		const touch = this.getFirstActiveTouch(touchEvent.touches);
		if (!touch) return;
		this.onCommonMove(touch, this.touchStart, el);
	}
	onMouseMove(mouseEvent, el) {
		if (_isBrowserSafari()) _getDocument(this.beans).getSelection()?.removeAllRanges();
		if (this.shouldPreventMouseEvent(mouseEvent)) mouseEvent.preventDefault();
		this.onCommonMove(mouseEvent, this.mouseStartEvent, el);
	}
	shouldPreventMouseEvent(mouseEvent) {
		const { gos } = this;
		const isEnableCellTextSelect = gos.get("enableCellTextSelection");
		const isMouseMove = mouseEvent.type === "mousemove";
		const isOverFormFieldElement = (mouseEvent2) => {
			return !!(mouseEvent2.target?.tagName.toLocaleLowerCase())?.match("^a$|textarea|input|select|button");
		};
		return isEnableCellTextSelect && isMouseMove && mouseEvent.cancelable && _isEventFromThisGrid(gos, mouseEvent) && !isOverFormFieldElement(mouseEvent);
	}
	onTouchUp(touchEvent, el) {
		let touch = this.getFirstActiveTouch(touchEvent.changedTouches);
		if (!touch) touch = this.touchLastTime;
		this.onUpCommon(touch, el);
	}
	onMouseUp(mouseEvent, el) {
		this.onUpCommon(mouseEvent, el);
	}
	onUpCommon(eventOrTouch, el) {
		if (this.dragging) {
			this.dragging = false;
			this.currentDragParams.onDragStop(eventOrTouch);
			this.eventSvc.dispatchEvent({
				type: "dragStopped",
				target: el
			});
		}
		this.resetDragProperties();
	}
	cancelDrag(el) {
		this.eventSvc.dispatchEvent({
			type: "dragCancelled",
			target: el
		});
		this.currentDragParams?.onDragCancel?.();
		this.resetDragProperties();
	}
	resetDragProperties() {
		this.mouseStartEvent = null;
		this.startTarget = null;
		this.touchStart = null;
		this.touchLastTime = null;
		this.currentDragParams = null;
		const { dragEndFunctions } = this;
		dragEndFunctions.forEach((func) => func());
		dragEndFunctions.length = 0;
	}
};
function createUniqueColumnGroupId(groupId, instanceId) {
	return groupId + "_" + instanceId;
}
function isColumnGroup(col) {
	return col instanceof AgColumnGroup;
}
var AgColumnGroup = class extends BeanStub {
	constructor(providedColumnGroup, groupId, partId, pinned) {
		super();
		this.providedColumnGroup = providedColumnGroup;
		this.groupId = groupId;
		this.partId = partId;
		this.pinned = pinned;
		this.isColumn = false;
		this.displayedChildren = [];
		this.autoHeaderHeight = null;
		this.parent = null;
	}
	reset() {
		this.parent = null;
		this.children = null;
		this.displayedChildren = null;
	}
	getParent() {
		return this.parent;
	}
	getUniqueId() {
		return createUniqueColumnGroupId(this.groupId, this.partId);
	}
	isEmptyGroup() {
		return this.displayedChildren.length === 0;
	}
	isMoving() {
		const allLeafColumns = this.getProvidedColumnGroup().getLeafColumns();
		if (!allLeafColumns || allLeafColumns.length === 0) return false;
		return allLeafColumns.every((col) => col.isMoving());
	}
	checkLeft() {
		this.displayedChildren.forEach((child) => {
			if (isColumnGroup(child)) child.checkLeft();
		});
		if (this.displayedChildren.length > 0) if (this.gos.get("enableRtl")) {
			const lastChildLeft = _last(this.displayedChildren).getLeft();
			this.setLeft(lastChildLeft);
		} else {
			const firstChildLeft = this.displayedChildren[0].getLeft();
			this.setLeft(firstChildLeft);
		}
		else this.setLeft(null);
	}
	getLeft() {
		return this.left;
	}
	getOldLeft() {
		return this.oldLeft;
	}
	setLeft(left) {
		this.oldLeft = this.left;
		if (this.left !== left) {
			this.left = left;
			this.dispatchLocalEvent({ type: "leftChanged" });
		}
	}
	getPinned() {
		return this.pinned;
	}
	getGroupId() {
		return this.groupId;
	}
	getPartId() {
		return this.partId;
	}
	getActualWidth() {
		let groupActualWidth = 0;
		this.displayedChildren?.forEach((child) => {
			groupActualWidth += child.getActualWidth();
		});
		return groupActualWidth;
	}
	isResizable() {
		if (!this.displayedChildren) return false;
		let result = false;
		this.displayedChildren.forEach((child) => {
			if (child.isResizable()) result = true;
		});
		return result;
	}
	getMinWidth() {
		let result = 0;
		this.displayedChildren.forEach((groupChild) => {
			result += groupChild.getMinWidth();
		});
		return result;
	}
	addChild(child) {
		if (!this.children) this.children = [];
		this.children.push(child);
	}
	getDisplayedChildren() {
		return this.displayedChildren;
	}
	getLeafColumns() {
		const result = [];
		this.addLeafColumns(result);
		return result;
	}
	getDisplayedLeafColumns() {
		const result = [];
		this.addDisplayedLeafColumns(result);
		return result;
	}
	getDefinition() {
		return this.providedColumnGroup.getColGroupDef();
	}
	getColGroupDef() {
		return this.providedColumnGroup.getColGroupDef();
	}
	isPadding() {
		return this.providedColumnGroup.isPadding();
	}
	isExpandable() {
		return this.providedColumnGroup.isExpandable();
	}
	isExpanded() {
		return this.providedColumnGroup.isExpanded();
	}
	setExpanded(expanded) {
		this.providedColumnGroup.setExpanded(expanded);
	}
	isAutoHeaderHeight() {
		return !!this.getColGroupDef()?.autoHeaderHeight;
	}
	getAutoHeaderHeight() {
		return this.autoHeaderHeight;
	}
	setAutoHeaderHeight(height) {
		const changed = height !== this.autoHeaderHeight;
		this.autoHeaderHeight = height;
		return changed;
	}
	addDisplayedLeafColumns(leafColumns) {
		this.displayedChildren.forEach((child) => {
			if (isColumn(child)) leafColumns.push(child);
			else if (isColumnGroup(child)) child.addDisplayedLeafColumns(leafColumns);
		});
	}
	addLeafColumns(leafColumns) {
		this.children.forEach((child) => {
			if (isColumn(child)) leafColumns.push(child);
			else if (isColumnGroup(child)) child.addLeafColumns(leafColumns);
		});
	}
	getChildren() {
		return this.children;
	}
	getColumnGroupShow() {
		return this.providedColumnGroup.getColumnGroupShow();
	}
	getProvidedColumnGroup() {
		return this.providedColumnGroup;
	}
	getPaddingLevel() {
		const parent = this.getParent();
		if (!this.isPadding() || !parent || !parent.isPadding()) return 0;
		return 1 + parent.getPaddingLevel();
	}
	calculateDisplayedColumns() {
		this.displayedChildren = [];
		let parentWithExpansion = this;
		while (parentWithExpansion != null && parentWithExpansion.isPadding()) parentWithExpansion = parentWithExpansion.getParent();
		if (!(parentWithExpansion ? parentWithExpansion.getProvidedColumnGroup().isExpandable() : false)) {
			this.displayedChildren = this.children;
			this.dispatchLocalEvent({ type: "displayedChildrenChanged" });
			return;
		}
		this.children.forEach((child) => {
			if (isColumnGroup(child) && !child.displayedChildren?.length) return;
			switch (child.getColumnGroupShow()) {
				case "open":
					if (parentWithExpansion.getProvidedColumnGroup().isExpanded()) this.displayedChildren.push(child);
					break;
				case "closed":
					if (!parentWithExpansion.getProvidedColumnGroup().isExpanded()) this.displayedChildren.push(child);
					break;
				default:
					this.displayedChildren.push(child);
					break;
			}
		});
		this.dispatchLocalEvent({ type: "displayedChildrenChanged" });
	}
};
var ROW_ID_PREFIX_ROW_GROUP = "row-group-";
var OBJECT_ID_SEQUENCE = 0;
var RowNode = class {
	constructor(beans) {
		this.master = false;
		this.detail = void 0;
		this.rowIndex = null;
		this.key = null;
		this.sourceRowIndex = -1;
		this.childrenMapped = null;
		this.treeParent = null;
		this.treeNodeFlags = 0;
		this.displayed = false;
		this.rowTop = null;
		this.oldRowTop = null;
		this.selectable = true;
		this.__objectId = OBJECT_ID_SEQUENCE++;
		this.alreadyRendered = false;
		this.hovered = false;
		this.__selected = false;
		this.beans = beans;
	}
	setData(data) {
		this.setDataCommon(data, false);
	}
	updateData(data) {
		this.setDataCommon(data, true);
	}
	setDataCommon(data, update) {
		const { valueCache, eventSvc } = this.beans;
		const oldData = this.data;
		this.data = data;
		valueCache?.onDataChanged();
		this.updateDataOnDetailNode();
		this.resetQuickFilterAggregateText();
		const event = this.createDataChangedEvent(data, oldData, update);
		this.__localEventService?.dispatchEvent(event);
		if (this.sibling) {
			this.sibling.data = data;
			const event2 = this.sibling.createDataChangedEvent(data, oldData, update);
			this.sibling.__localEventService?.dispatchEvent(event2);
		}
		eventSvc.dispatchEvent({
			type: "rowNodeDataChanged",
			node: this
		});
		const pinnedSibling = this.pinnedSibling;
		if (pinnedSibling) {
			pinnedSibling.data = data;
			pinnedSibling.__localEventService?.dispatchEvent(pinnedSibling.createDataChangedEvent(data, oldData, update));
			eventSvc.dispatchEvent({
				type: "rowNodeDataChanged",
				node: pinnedSibling
			});
		}
	}
	updateDataOnDetailNode() {
		if (this.detailNode) this.detailNode.data = this.data;
	}
	createDataChangedEvent(newData, oldData, update) {
		return {
			type: "dataChanged",
			node: this,
			oldData,
			newData,
			update
		};
	}
	getRowIndexString() {
		if (this.rowIndex == null) {
			_error(13);
			return null;
		}
		if (this.rowPinned === "top") return "t-" + this.rowIndex;
		if (this.rowPinned === "bottom") return "b-" + this.rowIndex;
		return this.rowIndex.toString();
	}
	setDataAndId(data, id) {
		const { selectionSvc } = this.beans;
		const oldNode = selectionSvc?.createDaemonNode?.(this);
		const oldData = this.data;
		this.data = data;
		this.updateDataOnDetailNode();
		this.setId(id);
		if (selectionSvc) {
			selectionSvc.updateRowSelectable(this);
			selectionSvc.syncInRowNode(this, oldNode);
		}
		const event = this.createDataChangedEvent(data, oldData, false);
		this.__localEventService?.dispatchEvent(event);
	}
	setId(id) {
		const getRowIdFunc = _getRowIdCallback(this.beans.gos);
		if (getRowIdFunc) if (this.data) {
			const parentKeys = this.parent?.getRoute() ?? [];
			this.id = getRowIdFunc({
				data: this.data,
				parentKeys: parentKeys.length > 0 ? parentKeys : void 0,
				level: this.level,
				rowPinned: this.rowPinned
			});
			if (this.id.startsWith("row-group-")) _error(14, { groupPrefix: ROW_ID_PREFIX_ROW_GROUP });
		} else this.id = void 0;
		else this.id = id;
	}
	setRowTop(rowTop) {
		this.oldRowTop = this.rowTop;
		if (this.rowTop === rowTop) return;
		this.rowTop = rowTop;
		this.dispatchRowEvent("topChanged");
		this.setDisplayed(rowTop !== null);
	}
	clearRowTopAndRowIndex() {
		this.oldRowTop = null;
		this.setRowTop(null);
		this.setRowIndex(null);
	}
	setHovered(hovered) {
		this.hovered = hovered;
	}
	isHovered() {
		return this.hovered;
	}
	setRowHeight(rowHeight, estimated = false) {
		this.rowHeight = rowHeight;
		this.rowHeightEstimated = estimated;
		this.dispatchRowEvent("heightChanged");
	}
	setExpanded(expanded, e, forceSync) {
		this.beans.expansionSvc?.setExpanded(this, expanded, e, forceSync);
	}
	setDataValue(colKey, newValue, eventSource) {
		const { colModel, valueSvc, gos, editSvc } = this.beans;
		const column = typeof colKey !== "string" ? colKey : colModel.getCol(colKey) ?? colModel.getColDefCol(colKey);
		if (!column) return false;
		const oldValue = valueSvc.getValueForDisplay(column, this, void 0, void 0, "api").value;
		if (gos.get("readOnlyEdit")) {
			const { beans: { eventSvc }, data, rowIndex, rowPinned } = this;
			eventSvc.dispatchEvent({
				type: "cellEditRequest",
				event: null,
				rowIndex,
				rowPinned,
				column,
				colDef: column.colDef,
				data,
				node: this,
				oldValue,
				newValue,
				value: newValue,
				source: eventSource
			});
			return false;
		}
		if (editSvc) {
			const result = editSvc.setDataValue({
				rowNode: this,
				column
			}, newValue, eventSource);
			if (result != null) return result;
		}
		const valueChanged = valueSvc.setValue(this, column, newValue, eventSource);
		this.dispatchCellChangedEvent(column, newValue, oldValue);
		const pinnedSibling = this.pinnedSibling;
		if (pinnedSibling) {
			if (valueChanged) pinnedSibling.dispatchCellChangedEvent(column, newValue, oldValue);
		}
		return valueChanged;
	}
	updateHasChildren() {
		let newValue = this.group && !this.footer || this.childrenAfterGroup && this.childrenAfterGroup.length > 0;
		const { rowChildrenSvc } = this.beans;
		if (rowChildrenSvc) newValue = rowChildrenSvc.getHasChildrenValue(this);
		if (newValue !== this.__hasChildren) {
			this.__hasChildren = !!newValue;
			this.dispatchRowEvent("hasChildrenChanged");
		}
	}
	hasChildren() {
		if (this.__hasChildren == null) this.updateHasChildren();
		return this.__hasChildren;
	}
	dispatchCellChangedEvent(column, newValue, oldValue) {
		const cellChangedEvent = {
			type: "cellChanged",
			node: this,
			column,
			newValue,
			oldValue
		};
		this.__localEventService?.dispatchEvent(cellChangedEvent);
	}
	resetQuickFilterAggregateText() {
		this.quickFilterAggregateText = null;
	}
	isExpandable() {
		return this.beans.expansionSvc?.isExpandable(this) ?? false;
	}
	isSelected() {
		if (this.footer) return this.sibling.isSelected();
		if (this.rowPinned && this.pinnedSibling) return this.pinnedSibling.isSelected();
		return this.__selected;
	}
	depthFirstSearch(callback) {
		this.childrenAfterGroup?.forEach((child) => child.depthFirstSearch(callback));
		callback(this);
	}
	dispatchRowEvent(type) {
		this.__localEventService?.dispatchEvent({
			type,
			node: this
		});
	}
	setSelected(newValue, clearSelection = false, source = "api") {
		this.beans.selectionSvc?.setNodesSelected({
			nodes: [this],
			newValue,
			clearSelection,
			source
		});
	}
	isRowPinned() {
		return !!this.rowPinned;
	}
	__addEventListener(eventType, listener) {
		if (!this.__localEventService) this.__localEventService = new LocalEventService();
		this.__localEventService.addEventListener(eventType, listener);
	}
	__removeEventListener(eventType, listener) {
		this.removeLocalListener(eventType, listener);
	}
	addEventListener(eventType, userListener) {
		this.beans.validation?.checkRowEvents(eventType);
		if (!this.__localEventService) this.__localEventService = new LocalEventService();
		this.frameworkEventListenerService = this.beans.frameworkOverrides.createLocalEventListenerWrapper?.(this.frameworkEventListenerService, this.__localEventService);
		const listener = this.frameworkEventListenerService?.wrap(eventType, userListener) ?? userListener;
		this.__localEventService.addEventListener(eventType, listener);
	}
	removeEventListener(eventType, userListener) {
		const listener = this.frameworkEventListenerService?.unwrap(eventType, userListener) ?? userListener;
		this.removeLocalListener(eventType, listener);
	}
	removeLocalListener(eventType, listener) {
		this.__localEventService?.removeEventListener(eventType, listener);
		if (this.__localEventService?.noRegisteredListenersExist()) this.__localEventService = null;
	}
	isFullWidthCell() {
		_warn(61);
		if (this.detail) return true;
		const isFullWidthCellFunc = this.beans.gos.getCallback("isFullWidthRow");
		return isFullWidthCellFunc ? isFullWidthCellFunc({ rowNode: this }) : false;
	}
	getRoute() {
		if (this.level === -1) return [];
		if (this.key == null) return;
		const res = [];
		let pointer = this;
		while (pointer && pointer.key != null) {
			res.push(pointer.key);
			pointer = pointer.parent;
		}
		return res.reverse();
	}
	setFirstChild(firstChild) {
		if (this.firstChild !== firstChild) {
			this.firstChild = firstChild;
			this.dispatchRowEvent("firstChildChanged");
		}
	}
	setDisplayed(displayed) {
		if (this.displayed !== displayed) {
			this.displayed = displayed;
			this.dispatchRowEvent("displayedChanged");
		}
	}
	setRowIndex(rowIndex) {
		if (this.rowIndex !== rowIndex) {
			this.rowIndex = rowIndex;
			this.dispatchRowEvent("rowIndexChanged");
		}
	}
	setAllChildrenCount(allChildrenCount) {
		if (this.allChildrenCount !== allChildrenCount) {
			this.allChildrenCount = allChildrenCount;
			this.dispatchRowEvent("allChildrenCountChanged");
		}
	}
	setUiLevel(uiLevel) {
		if (this.uiLevel !== uiLevel) {
			this.uiLevel = uiLevel;
			this.dispatchRowEvent("uiLevelChanged");
		}
	}
	getFirstChild() {
		if (this.childStore) return this.childStore.getFirstNode();
		return this.childrenAfterSort?.[0] ?? null;
	}
};
function _createGlobalRowEvent(rowNode, gos, type) {
	return _addGridCommonParams(gos, {
		type,
		node: rowNode,
		data: rowNode.data,
		rowIndex: rowNode.rowIndex,
		rowPinned: rowNode.rowPinned
	});
}
var IGNORED_SIBLING_PROPERTIES = /* @__PURE__ */ new Set([
	"__localEventService",
	"__objectId",
	"sticky",
	"__autoHeights",
	"__checkAutoHeightsDebounced",
	"childStore"
]);
function _createRowNodeSibling(rowNode, beans) {
	const sibling = new RowNode(beans);
	Object.keys(rowNode).forEach((key) => {
		if (IGNORED_SIBLING_PROPERTIES.has(key)) return;
		sibling[key] = rowNode[key];
	});
	sibling.oldRowTop = null;
	return sibling;
}
var FILTER_HANDLER_MAP = {
	agSetColumnFilter: "agSetColumnFilterHandler",
	agMultiColumnFilter: "agMultiColumnFilterHandler",
	agGroupColumnFilter: "agGroupColumnFilterHandler",
	agNumberColumnFilter: "agNumberColumnFilterHandler",
	agDateColumnFilter: "agDateColumnFilterHandler",
	agTextColumnFilter: "agTextColumnFilterHandler"
};
var FILTER_HANDLERS = new Set(Object.values(FILTER_HANDLER_MAP));
function getFilterUiFromWrapper(filterWrapper, skipCreate) {
	const filterUi = filterWrapper.filterUi;
	if (!filterUi) return null;
	if (filterUi.created) return filterUi.promise;
	if (skipCreate) return null;
	const promise = filterUi.create(filterUi.refreshed);
	const createdFilterUi = filterUi;
	createdFilterUi.created = true;
	createdFilterUi.promise = promise;
	return promise;
}
function _refreshHandlerAndUi(getFilterUi, handler, handlerParams, model, state, source) {
	handler.refresh?.({
		...handlerParams,
		model,
		source
	});
	return getFilterUi().then((filterUi) => {
		if (filterUi) {
			const { filter, filterParams } = filterUi;
			_refreshFilterUi(filter, filterParams, model, state, source);
		}
	});
}
function _refreshFilterUi(filter, filterParams, model, state, source) {
	filter?.refresh?.({
		...filterParams,
		model,
		state,
		source
	});
}
function getAndRefreshFilterUi(getFilterUi, getModel, getState2) {
	const filterUi = getFilterUi();
	if (filterUi?.created) filterUi.promise.then((filter) => {
		const model = getModel();
		_refreshFilterUi(filter, filterUi.filterParams, model, getState2() ?? { model }, "ui");
	});
}
function _updateFilterModel(action, getFilterUi, getModel, getState2, updateState, updateModel) {
	let state;
	let shouldUpdateModel = false;
	let model;
	switch (action) {
		case "apply": {
			const oldState = getState2();
			model = oldState?.model ?? null;
			state = {
				state: oldState?.state,
				model
			};
			shouldUpdateModel = true;
			break;
		}
		case "clear":
			state = { model: null };
			break;
		case "reset":
			state = { model: null };
			shouldUpdateModel = true;
			model = null;
			break;
		case "cancel":
			state = { model: getModel() };
			break;
	}
	updateState(state);
	if (shouldUpdateModel) updateModel(model);
	else getAndRefreshFilterUi(getFilterUi, getModel, getState2);
}
function _getFilterModel(model, colId) {
	return model[colId] ?? null;
}
function getElement(className) {
	return {
		tag: "div",
		cls: className
	};
}
var FilterButtonComp = class extends Component {
	constructor(config) {
		const { className = "ag-filter-apply-panel" } = config ?? {};
		super(getElement(className));
		this.listeners = [];
		this.validationMessage = null;
		this.className = className;
	}
	updateButtons(buttons, useForm) {
		const oldButtons = this.buttons;
		this.buttons = buttons;
		if (oldButtons === buttons) return;
		const eGui = this.getGui();
		_clearElement(eGui);
		let eApplyButton;
		this.destroyListeners();
		const fragment = document.createDocumentFragment();
		const className = this.className;
		const addButton = ({ type, label }) => {
			const clickListener = (event) => {
				this.dispatchLocalEvent({
					type,
					event
				});
			};
			if (![
				"apply",
				"clear",
				"reset",
				"cancel"
			].includes(type)) _warn(75);
			const isApply = type === "apply";
			const button = _createElement({
				tag: "button",
				attrs: { type: isApply && useForm ? "submit" : "button" },
				ref: `${type}FilterButton`,
				cls: `ag-button ag-standard-button ${className}-button${isApply ? " " + className + "-apply-button" : ""}`,
				children: label
			});
			this.activateTabIndex([button]);
			if (isApply) eApplyButton = button;
			const keydownListener = (event) => {
				if (event.key === KeyCode.ENTER) {
					event.preventDefault();
					clickListener(event);
				}
			};
			const listeners = this.listeners;
			button.addEventListener("click", clickListener);
			listeners.push(() => button.removeEventListener("click", clickListener));
			button.addEventListener("keydown", keydownListener);
			listeners.push(() => button.removeEventListener("keydown", keydownListener));
			fragment.append(button);
		};
		buttons.forEach((button) => addButton(button));
		this.eApply = eApplyButton;
		const tooltip = this.validationTooltipFeature;
		if (eApplyButton && !tooltip) this.validationTooltipFeature = this.createOptionalManagedBean(this.beans.registry.createDynamicBean("tooltipFeature", false, {
			getGui: () => this.eApply,
			getLocation: () => "advancedFilter",
			getTooltipShowDelayOverride: () => 1e3
		}));
		else if (!eApplyButton && tooltip) this.validationTooltipFeature = this.destroyBean(tooltip);
		eGui.append(fragment);
	}
	getApplyButton() {
		return this.eApply;
	}
	updateValidity(valid, message = null) {
		const eApplyButton = this.eApply;
		if (!eApplyButton) return;
		_setDisabled(eApplyButton, valid === false);
		this.validationMessage = message ?? null;
		this.validationTooltipFeature?.setTooltipAndRefresh(this.validationMessage);
	}
	destroyListeners() {
		this.listeners.forEach((destroyFunc) => destroyFunc());
		this.listeners = [];
	}
	destroy() {
		this.destroyListeners();
		super.destroy();
	}
};
var FILTER_LOCALE_TEXT = {
	applyFilter: "Apply",
	clearFilter: "Clear",
	resetFilter: "Reset",
	cancelFilter: "Cancel",
	textFilter: "Text Filter",
	numberFilter: "Number Filter",
	dateFilter: "Date Filter",
	setFilter: "Set Filter",
	filterOoo: "Filter...",
	empty: "Choose one",
	equals: "Equals",
	notEqual: "Does not equal",
	lessThan: "Less than",
	greaterThan: "Greater than",
	inRange: "Between",
	inRangeStart: "From",
	inRangeEnd: "To",
	lessThanOrEqual: "Less than or equal to",
	greaterThanOrEqual: "Greater than or equal to",
	contains: "Contains",
	notContains: "Does not contain",
	startsWith: "Begins with",
	endsWith: "Ends with",
	blank: "Blank",
	notBlank: "Not blank",
	before: "Before",
	after: "After",
	andCondition: "AND",
	orCondition: "OR",
	dateFormatOoo: "yyyy-mm-dd",
	filterSummaryInactive: "is (All)",
	filterSummaryContains: "contains",
	filterSummaryNotContains: "does not contain",
	filterSummaryTextEquals: "equals",
	filterSummaryTextNotEqual: "does not equal",
	filterSummaryStartsWith: "begins with",
	filterSummaryEndsWith: "ends with",
	filterSummaryBlank: "is blank",
	filterSummaryNotBlank: "is not blank",
	filterSummaryEquals: "=",
	filterSummaryNotEqual: "!=",
	filterSummaryGreaterThan: ">",
	filterSummaryGreaterThanOrEqual: ">=",
	filterSummaryLessThan: "<",
	filterSummaryLessThanOrEqual: "<=",
	filterSummaryInRange: "between",
	filterSummaryInRangeValues: (variableValues) => `(${variableValues[0]}, ${variableValues[1]})`,
	filterSummaryTextQuote: (variableValues) => `"${variableValues[0]}"`
};
function translateForFilter(bean, key, variableValues) {
	return _translate(bean, FILTER_LOCALE_TEXT, key, variableValues);
}
function getDebounceMs(params, debounceDefault) {
	const { debounceMs } = params;
	if (_isUseApplyButton(params)) {
		if (debounceMs != null) _warn(71);
		return 0;
	}
	return debounceMs ?? debounceDefault;
}
function _isUseApplyButton(params) {
	return (params.buttons?.indexOf("apply") ?? -1) >= 0;
}
var FilterWrapperComp = class extends Component {
	constructor(column, wrapper$1, eventParent, updateModel, isGlobalButtons, enableGlobalButtonCheck) {
		super();
		this.column = column;
		this.wrapper = wrapper$1;
		this.eventParent = eventParent;
		this.updateModel = updateModel;
		this.isGlobalButtons = isGlobalButtons;
		this.enableGlobalButtonCheck = enableGlobalButtonCheck;
		this.hidePopup = null;
		this.applyActive = false;
	}
	postConstruct() {
		const { comp, params: originalParams } = this.wrapper;
		const params = originalParams;
		const useForm = params.useForm;
		const tag = useForm ? "form" : "div";
		this.setTemplate({
			tag,
			cls: "ag-filter-wrapper"
		});
		if (useForm) this.addManagedElementListeners(this.getGui(), {
			submit: (e) => {
				e?.preventDefault();
			},
			keydown: this.handleKeyDown.bind(this)
		});
		this.appendChild(comp.getGui());
		this.params = params;
		this.resetButtonsPanel(params);
		this.addManagedListeners(this.eventParent, {
			filterParamsChanged: ({ column, params: eventParams }) => {
				if (column === this.column) this.resetButtonsPanel(eventParams, this.params);
			},
			filterStateChanged: ({ column, state }) => {
				if (column === this.column) this.eButtons?.updateValidity(state.valid !== false);
			},
			filterAction: ({ column, action, event: keyboardEvent }) => {
				if (column === this.column) this.afterAction(action, keyboardEvent);
			},
			...this.enableGlobalButtonCheck ? { filterGlobalButtons: ({ isGlobal }) => {
				if (isGlobal !== this.isGlobalButtons) {
					this.isGlobalButtons = isGlobal;
					const currentParams = this.params;
					this.resetButtonsPanel(currentParams, currentParams, true);
				}
			} } : void 0
		});
	}
	afterGuiAttached(params) {
		if (params) this.hidePopup = params.hidePopup;
	}
	resetButtonsPanel(newParams, oldParams, forceUpdate) {
		const { buttons: oldButtons, readOnly: oldReadOnly } = oldParams ?? {};
		const { buttons: newButtons, readOnly, useForm } = newParams;
		if (!forceUpdate && oldReadOnly === readOnly && _jsonEquals(oldButtons, newButtons)) return;
		const hasButtons = newButtons && newButtons.length > 0 && !newParams.readOnly && !this.isGlobalButtons;
		let eButtonsPanel = this.eButtons;
		if (hasButtons) {
			const buttons = newButtons.map((type) => {
				const localeKey = `${type}Filter`;
				return {
					type,
					label: translateForFilter(this, localeKey)
				};
			});
			this.applyActive = _isUseApplyButton(this.params);
			if (!eButtonsPanel) {
				eButtonsPanel = this.createBean(new FilterButtonComp());
				this.appendChild(eButtonsPanel.getGui());
				const column = this.column;
				const getListener = (action) => ({ event }) => {
					this.updateModel(column, action);
					this.afterAction(action, event);
				};
				eButtonsPanel?.addManagedListeners(eButtonsPanel, {
					apply: getListener("apply"),
					clear: getListener("clear"),
					reset: getListener("reset"),
					cancel: getListener("cancel")
				});
				this.eButtons = eButtonsPanel;
			}
			eButtonsPanel.updateButtons(buttons, useForm);
		} else {
			this.applyActive = false;
			if (eButtonsPanel) {
				_removeFromParent(eButtonsPanel.getGui());
				this.eButtons = this.destroyBean(eButtonsPanel);
			}
		}
	}
	close(e) {
		const hidePopup = this.hidePopup;
		if (!hidePopup) return;
		const keyboardEvent = e;
		const key = keyboardEvent && keyboardEvent.key;
		let params;
		if (key === KeyCode.ENTER || key === KeyCode.SPACE) params = { keyboardEvent };
		hidePopup(params);
		this.hidePopup = null;
	}
	afterAction(action, event) {
		const { params, applyActive } = this;
		const closeOnApply = params?.closeOnApply;
		switch (action) {
			case "apply":
				event?.preventDefault();
				if (closeOnApply && applyActive) this.close(event);
				break;
			case "reset":
				if (closeOnApply && applyActive) this.close();
				break;
			case "cancel":
				if (closeOnApply) this.close(event);
				break;
		}
	}
	handleKeyDown(event) {
		if (!event.defaultPrevented && event.key === KeyCode.ENTER && this.applyActive) {
			this.updateModel(this.column, "apply");
			this.afterAction("apply", event);
		}
	}
	destroy() {
		this.hidePopup = null;
		this.eButtons = this.destroyBean(this.eButtons);
	}
};
var FilterElement = {
	tag: "div",
	cls: "ag-filter"
};
var FilterComp = class extends Component {
	constructor(column, source, enableGlobalButtonCheck) {
		super(FilterElement);
		this.column = column;
		this.source = source;
		this.enableGlobalButtonCheck = enableGlobalButtonCheck;
		this.wrapper = null;
	}
	postConstruct() {
		this.beans.colFilter?.activeFilterComps.add(this);
		this.createFilter(true);
		this.addManagedEventListeners({ filterDestroyed: this.onFilterDestroyed.bind(this) });
	}
	hasFilter() {
		return this.wrapper != null;
	}
	getFilter() {
		return this.wrapper?.then((wrapper$1) => wrapper$1.comp) ?? null;
	}
	afterInit() {
		return this.wrapper?.then(() => {}) ?? AgPromise.resolve();
	}
	afterGuiAttached(params) {
		this.afterGuiAttachedParams = params;
		this.wrapper?.then((wrapper$1) => {
			this.comp?.afterGuiAttached(params);
			wrapper$1?.comp?.afterGuiAttached?.(params);
		});
	}
	afterGuiDetached() {
		this.wrapper?.then((wrapper$1) => {
			wrapper$1?.comp?.afterGuiDetached?.();
		});
	}
	createFilter(init) {
		const { column, source, beans: { colFilter } } = this;
		const filterPromise = colFilter.getFilterUiForDisplay(column) ?? null;
		this.wrapper = filterPromise;
		filterPromise?.then((wrapper$1) => {
			if (!wrapper$1) return;
			const { isHandler, comp } = wrapper$1;
			let filterGui;
			if (isHandler) {
				const enableGlobalButtonCheck = !!this.enableGlobalButtonCheck;
				const displayComp = this.createBean(new FilterWrapperComp(column, wrapper$1, colFilter, colFilter.updateModel.bind(colFilter), enableGlobalButtonCheck && colFilter.isGlobalButtons, enableGlobalButtonCheck));
				this.comp = displayComp;
				filterGui = displayComp.getGui();
			} else {
				filterGui = comp.getGui();
				if (!_exists(filterGui)) _warn(69, { guiFromFilter: filterGui });
			}
			this.appendChild(filterGui);
			if (init) this.eventSvc.dispatchEvent({
				type: "filterOpened",
				column,
				source,
				eGui: this.getGui()
			});
			else comp.afterGuiAttached?.(this.afterGuiAttachedParams);
		});
	}
	onFilterDestroyed(event) {
		const { source, column } = event;
		if ((source === "api" || source === "paramsUpdated") && column.getId() === this.column.getId() && this.beans.colModel.getColDefCol(this.column)) {
			_clearElement(this.getGui());
			this.comp = this.destroyBean(this.comp);
			this.createFilter();
		}
	}
	destroy() {
		this.beans.colFilter?.activeFilterComps.delete(this);
		this.eventSvc.dispatchEvent({
			type: "filterClosed",
			column: this.column
		});
		this.wrapper = null;
		this.comp = this.destroyBean(this.comp);
		this.afterGuiAttachedParams = void 0;
		super.destroy();
	}
};
var DATE_TIME_SEPARATOR = "T";
var DATE_TIME_REGEXP = /* @__PURE__ */ new RegExp(`^\\d{4}-\\d{2}-\\d{2}(${DATE_TIME_SEPARATOR}\\d{2}:\\d{2}:\\d{2}\\D?)?`);
function _padStartWidthZeros(value, totalStringSize) {
	return value.toString().padStart(totalStringSize, "0");
}
function _serialiseDate(date, includeTime = true, separator$1 = "-") {
	if (!date) return null;
	let serialised = [
		date.getFullYear(),
		date.getMonth() + 1,
		date.getDate()
	].map((part) => _padStartWidthZeros(part, 2)).join(separator$1);
	if (includeTime) serialised += DATE_TIME_SEPARATOR + [
		date.getHours(),
		date.getMinutes(),
		date.getSeconds()
	].map((part) => _padStartWidthZeros(part, 2)).join(":");
	return serialised;
}
function _getDateParts(d, includeTime = true) {
	if (!d) return null;
	if (includeTime) return [
		String(d.getFullYear()),
		String(d.getMonth() + 1),
		_padStartWidthZeros(d.getDate(), 2),
		_padStartWidthZeros(d.getHours(), 2),
		`:${_padStartWidthZeros(d.getMinutes(), 2)}`,
		`:${_padStartWidthZeros(d.getSeconds(), 2)}`
	];
	return [
		d.getFullYear(),
		d.getMonth() + 1,
		_padStartWidthZeros(d.getDate(), 2)
	].map(String);
}
var calculateOrdinal = (value) => {
	if (value > 3 && value < 21) return "th";
	switch (value % 10) {
		case 1: return "st";
		case 2: return "nd";
		case 3: return "rd";
	}
	return "th";
};
function _dateToFormattedString(date, format) {
	if (format == null) return _serialiseDate(date, false);
	const fullYear = _padStartWidthZeros(date.getFullYear(), 4);
	const months = [
		"January",
		"February",
		"March",
		"April",
		"May",
		"June",
		"July",
		"August",
		"September",
		"October",
		"November",
		"December"
	];
	const days = [
		"Sunday",
		"Monday",
		"Tuesday",
		"Wednesday",
		"Thursday",
		"Friday",
		"Saturday"
	];
	const replace = {
		YYYY: () => fullYear.slice(fullYear.length - 4, fullYear.length),
		YY: () => fullYear.slice(fullYear.length - 2, fullYear.length),
		Y: () => `${date.getFullYear()}`,
		MMMM: () => months[date.getMonth()],
		MMM: () => months[date.getMonth()].slice(0, 3),
		MM: () => _padStartWidthZeros(date.getMonth() + 1, 2),
		Mo: () => `${date.getMonth() + 1}${calculateOrdinal(date.getMonth() + 1)}`,
		M: () => `${date.getMonth() + 1}`,
		Do: () => `${date.getDate()}${calculateOrdinal(date.getDate())}`,
		DD: () => _padStartWidthZeros(date.getDate(), 2),
		D: () => `${date.getDate()}`,
		dddd: () => days[date.getDay()],
		ddd: () => days[date.getDay()].slice(0, 3),
		dd: () => days[date.getDay()].slice(0, 2),
		do: () => `${date.getDay()}${calculateOrdinal(date.getDay())}`,
		d: () => `${date.getDay()}`
	};
	const regexp = new RegExp(Object.keys(replace).join("|"), "g");
	return format.replace(regexp, (match) => {
		if (match in replace) return replace[match]();
		return match;
	});
}
function _isValidDate(value, bailIfInvalidTime = false) {
	return !!_parseDateTimeFromString(value, bailIfInvalidTime);
}
function _isValidDateTime(value) {
	return _isValidDate(value, true);
}
function _parseDateTimeFromString(value, bailIfInvalidTime = false) {
	if (!value) return null;
	if (!DATE_TIME_REGEXP.test(value)) return null;
	const [dateStr, timeStr] = value.split(DATE_TIME_SEPARATOR);
	if (!dateStr) return null;
	const fields = dateStr.split("-").map((f) => parseInt(f, 10));
	if (fields.filter((f) => !isNaN(f)).length !== 3) return null;
	const [year, month, day] = fields;
	const date = new Date(year, month - 1, day);
	if (date.getFullYear() !== year || date.getMonth() !== month - 1 || date.getDate() !== day) return null;
	if (!timeStr && bailIfInvalidTime) return null;
	if (!timeStr || timeStr === "00:00:00") return date;
	const [hours, minutes, seconds] = timeStr.split(":").map((part) => parseInt(part, 10));
	if (hours >= 0 && hours < 24) date.setHours(hours);
	else if (bailIfInvalidTime) return null;
	if (minutes >= 0 && minutes < 60) date.setMinutes(minutes);
	else if (bailIfInvalidTime) return null;
	if (seconds >= 0 && seconds < 60) date.setSeconds(seconds);
	else if (bailIfInvalidTime) return null;
	return date;
}
var MONTH_LOCALE_TEXT = {
	january: "January",
	february: "February",
	march: "March",
	april: "April",
	may: "May",
	june: "June",
	july: "July",
	august: "August",
	september: "September",
	october: "October",
	november: "November",
	december: "December"
};
var MONTH_KEYS = [
	"january",
	"february",
	"march",
	"april",
	"may",
	"june",
	"july",
	"august",
	"september",
	"october",
	"november",
	"december"
];
function setFilterNumberComparator(a, b) {
	if (a == null) return -1;
	if (b == null) return 1;
	return parseFloat(a) - parseFloat(b);
}
function isValidDate(value) {
	return value instanceof Date && !isNaN(value.getTime());
}
var filterParamsForEachDataType = {
	number: () => void 0,
	boolean: () => ({
		maxNumConditions: 1,
		debounceMs: 0,
		filterOptions: [
			"empty",
			{
				displayKey: "true",
				displayName: "True",
				predicate: (_filterValues, cellValue) => cellValue,
				numberOfInputs: 0
			},
			{
				displayKey: "false",
				displayName: "False",
				predicate: (_filterValues, cellValue) => cellValue === false,
				numberOfInputs: 0
			}
		]
	}),
	date: () => ({ isValidDate }),
	dateString: ({ dataTypeDefinition }) => ({
		comparator: (filterDate, cellValue) => {
			const cellAsDate = dataTypeDefinition.dateParser(cellValue);
			if (cellValue == null || cellAsDate < filterDate) return -1;
			if (cellAsDate > filterDate) return 1;
			return 0;
		},
		isValidDate: (value) => typeof value === "string" && isValidDate(dataTypeDefinition.dateParser(value))
	}),
	dateTime: (args) => filterParamsForEachDataType.date(args),
	dateTimeString: (args) => filterParamsForEachDataType.dateString(args),
	object: () => void 0,
	text: () => void 0
};
var setFilterParamsForEachDataType = {
	number: () => ({ comparator: setFilterNumberComparator }),
	boolean: ({ t }) => ({ valueFormatter: (params) => _exists(params.value) ? t(String(params.value), params.value ? "True" : "False") : t("blanks", "(Blanks)") }),
	date: ({ formatValue, t }) => ({
		valueFormatter: (params) => {
			const valueFormatted = formatValue(params);
			return _exists(valueFormatted) ? valueFormatted : t("blanks", "(Blanks)");
		},
		treeList: true,
		treeListFormatter: (pathKey, level) => {
			if (pathKey === "NaN") return t("invalidDate", "Invalid Date");
			if (level === 1 && pathKey != null) {
				const monthKey = MONTH_KEYS[Number(pathKey) - 1];
				return t(monthKey, MONTH_LOCALE_TEXT[monthKey]);
			}
			return pathKey ?? t("blanks", "(Blanks)");
		},
		treeListPathGetter: (date) => _getDateParts(date, false)
	}),
	dateString: ({ formatValue, dataTypeDefinition, t }) => ({
		valueFormatter: (params) => {
			const valueFormatted = formatValue(params);
			return _exists(valueFormatted) ? valueFormatted : t("blanks", "(Blanks)");
		},
		treeList: true,
		treeListPathGetter: (value) => _getDateParts(dataTypeDefinition.dateParser(value ?? void 0), false),
		treeListFormatter: (pathKey, level) => {
			if (level === 1 && pathKey != null) {
				const monthKey = MONTH_KEYS[Number(pathKey) - 1];
				return t(monthKey, MONTH_LOCALE_TEXT[monthKey]);
			}
			return pathKey ?? t("blanks", "(Blanks)");
		}
	}),
	dateTime: (args) => {
		const params = setFilterParamsForEachDataType.date(args);
		params.treeListPathGetter = _getDateParts;
		return params;
	},
	dateTimeString(args) {
		const convertToDate = args.dataTypeDefinition.dateParser;
		const params = setFilterParamsForEachDataType.dateString(args);
		params.treeListPathGetter = (value) => _getDateParts(convertToDate(value ?? void 0));
		return params;
	},
	object: ({ formatValue, t }) => ({ valueFormatter: (params) => {
		const valueFormatted = formatValue(params);
		return _exists(valueFormatted) ? valueFormatted : t("blanks", "(Blanks)");
	} }),
	text: () => void 0
};
function _getFilterParamsForDataType(filter, existingFilterParams, existingFilterValueGetter, dataTypeDefinition, formatValue, beans, translate) {
	let filterParams = existingFilterParams;
	let filterValueGetter = existingFilterValueGetter;
	const usingSetFilter = filter === "agSetColumnFilter";
	if (!filterValueGetter && dataTypeDefinition.baseDataType === "object" && !usingSetFilter) filterValueGetter = ({ column, node }) => formatValue({
		column,
		node,
		value: beans.valueSvc.getValue(column, node)
	});
	const filterParamsGetter = (usingSetFilter ? setFilterParamsForEachDataType : filterParamsForEachDataType)[dataTypeDefinition.baseDataType];
	const newFilterParams = filterParamsGetter({
		dataTypeDefinition,
		formatValue,
		t: translate
	});
	filterParams = typeof existingFilterParams === "object" ? {
		...newFilterParams,
		...existingFilterParams
	} : newFilterParams;
	return {
		filterParams,
		filterValueGetter
	};
}
var defaultFilters = {
	boolean: "agTextColumnFilter",
	date: "agDateColumnFilter",
	dateString: "agDateColumnFilter",
	dateTime: "agDateColumnFilter",
	dateTimeString: "agDateColumnFilter",
	number: "agNumberColumnFilter",
	object: "agTextColumnFilter",
	text: "agTextColumnFilter"
};
var defaultFloatingFilters = {
	boolean: "agTextColumnFloatingFilter",
	date: "agDateColumnFloatingFilter",
	dateString: "agDateColumnFloatingFilter",
	dateTime: "agDateColumnFloatingFilter",
	dateTimeString: "agDateColumnFloatingFilter",
	number: "agNumberColumnFloatingFilter",
	object: "agTextColumnFloatingFilter",
	text: "agTextColumnFloatingFilter"
};
function _getDefaultSimpleFilter(cellDataType, isFloating = false) {
	return (isFloating ? defaultFloatingFilters : defaultFilters)[cellDataType ?? "text"];
}
var RESIZE_CONTAINER_STYLE = "ag-resizer-wrapper";
var makeDiv = (dataRefPrefix, classSuffix) => ({
	tag: "div",
	ref: `${dataRefPrefix}Resizer`,
	cls: `ag-resizer ag-resizer-${classSuffix}`
});
var RESIZE_TEMPLATE = {
	tag: "div",
	cls: RESIZE_CONTAINER_STYLE,
	children: [
		makeDiv("eTopLeft", "topLeft"),
		makeDiv("eTop", "top"),
		makeDiv("eTopRight", "topRight"),
		makeDiv("eRight", "right"),
		makeDiv("eBottomRight", "bottomRight"),
		makeDiv("eBottom", "bottom"),
		makeDiv("eBottomLeft", "bottomLeft"),
		makeDiv("eLeft", "left")
	]
};
var PositionableFeature = class extends BeanStub {
	constructor(element, config) {
		super();
		this.element = element;
		this.dragStartPosition = {
			x: 0,
			y: 0
		};
		this.position = {
			x: 0,
			y: 0
		};
		this.lastSize = {
			width: -1,
			height: -1
		};
		this.positioned = false;
		this.resizersAdded = false;
		this.resizeListeners = [];
		this.boundaryEl = null;
		this.isResizing = false;
		this.isMoving = false;
		this.resizable = {};
		this.movable = false;
		this.currentResizer = null;
		this.config = Object.assign({}, { popup: false }, config);
	}
	wireBeans(beans) {
		this.popupSvc = beans.popupSvc;
		this.dragSvc = beans.dragSvc;
	}
	center(postProcessCallback) {
		const { clientHeight, clientWidth } = this.offsetParent;
		const x = clientWidth / 2 - this.getWidth() / 2;
		const y = clientHeight / 2 - this.getHeight() / 2;
		this.offsetElement(x, y, postProcessCallback);
	}
	initialisePosition(postProcessCallback) {
		if (this.positioned) return;
		const { centered, forcePopupParentAsOffsetParent, minWidth, width, minHeight, height, x, y } = this.config;
		if (!this.offsetParent) this.setOffsetParent();
		let computedMinHeight = 0;
		let computedMinWidth = 0;
		const isElementVisible = _isVisible(this.element);
		if (isElementVisible) {
			const boundaryEl = this.findBoundaryElement();
			const offsetParentComputedStyles = window.getComputedStyle(boundaryEl);
			if (offsetParentComputedStyles.minWidth != null) {
				const paddingWidth = boundaryEl.offsetWidth - this.element.offsetWidth;
				computedMinWidth = parseInt(offsetParentComputedStyles.minWidth, 10) - paddingWidth;
			}
			if (offsetParentComputedStyles.minHeight != null) {
				const paddingHeight = boundaryEl.offsetHeight - this.element.offsetHeight;
				computedMinHeight = parseInt(offsetParentComputedStyles.minHeight, 10) - paddingHeight;
			}
		}
		this.minHeight = minHeight || computedMinHeight;
		this.minWidth = minWidth || computedMinWidth;
		if (width) this.setWidth(width);
		if (height) this.setHeight(height);
		if (!width || !height) this.refreshSize();
		if (centered) this.center(postProcessCallback);
		else if (x || y) this.offsetElement(x, y, postProcessCallback);
		else if (isElementVisible && forcePopupParentAsOffsetParent) {
			let boundaryEl = this.boundaryEl;
			let initialisedDuringPositioning = true;
			if (!boundaryEl) {
				boundaryEl = this.findBoundaryElement();
				initialisedDuringPositioning = false;
			}
			if (boundaryEl) {
				const top = parseFloat(boundaryEl.style.top);
				const left = parseFloat(boundaryEl.style.left);
				if (initialisedDuringPositioning) this.offsetElement(isNaN(left) ? 0 : left, isNaN(top) ? 0 : top, postProcessCallback);
				else this.setPosition(left, top);
			}
		}
		this.positioned = !!this.offsetParent;
	}
	isPositioned() {
		return this.positioned;
	}
	getPosition() {
		return this.position;
	}
	setMovable(movable, moveElement) {
		if (!this.config.popup || movable === this.movable) return;
		this.movable = movable;
		const params = this.moveElementDragListener || {
			eElement: moveElement,
			onDragStart: this.onMoveStart.bind(this),
			onDragging: this.onMove.bind(this),
			onDragStop: this.onMoveEnd.bind(this)
		};
		if (movable) {
			this.dragSvc?.addDragSource(params);
			this.moveElementDragListener = params;
		} else {
			this.dragSvc?.removeDragSource(params);
			this.moveElementDragListener = void 0;
		}
	}
	setResizable(resizable) {
		this.clearResizeListeners();
		if (resizable) this.addResizers();
		else this.removeResizers();
		if (typeof resizable === "boolean") {
			if (resizable === false) return;
			resizable = {
				topLeft: resizable,
				top: resizable,
				topRight: resizable,
				right: resizable,
				bottomRight: resizable,
				bottom: resizable,
				bottomLeft: resizable,
				left: resizable
			};
		}
		Object.keys(resizable).forEach((side) => {
			const isSideResizable = !!resizable[side];
			const resizerEl = this.getResizerElement(side);
			const params = {
				dragStartPixels: 0,
				eElement: resizerEl,
				onDragStart: (e) => this.onResizeStart(e, side),
				onDragging: this.onResize.bind(this),
				onDragStop: (e) => this.onResizeEnd(e, side)
			};
			if (isSideResizable || !this.isAlive() && !isSideResizable) {
				if (isSideResizable) {
					this.dragSvc?.addDragSource(params);
					this.resizeListeners.push(params);
					resizerEl.style.pointerEvents = "all";
				} else resizerEl.style.pointerEvents = "none";
				this.resizable[side] = isSideResizable;
			}
		});
	}
	removeSizeFromEl() {
		this.element.style.removeProperty("height");
		this.element.style.removeProperty("width");
		this.element.style.removeProperty("flex");
	}
	restoreLastSize() {
		this.element.style.flex = "0 0 auto";
		const { height, width } = this.lastSize;
		if (width !== -1) this.element.style.width = `${width}px`;
		if (height !== -1) this.element.style.height = `${height}px`;
	}
	getHeight() {
		return this.element.offsetHeight;
	}
	setHeight(height) {
		const { popup } = this.config;
		const eGui = this.element;
		let isPercent = false;
		if (typeof height === "string" && height.indexOf("%") !== -1) {
			_setFixedHeight(eGui, height);
			height = _getAbsoluteHeight(eGui);
			isPercent = true;
		} else {
			height = Math.max(this.minHeight, height);
			if (this.positioned) {
				const availableHeight = this.getAvailableHeight();
				if (availableHeight && height > availableHeight) height = availableHeight;
			}
		}
		if (this.getHeight() === height) return;
		if (!isPercent) if (popup) _setFixedHeight(eGui, height);
		else {
			eGui.style.height = `${height}px`;
			eGui.style.flex = "0 0 auto";
			this.lastSize.height = typeof height === "number" ? height : parseFloat(height);
		}
		else {
			eGui.style.maxHeight = "unset";
			eGui.style.minHeight = "unset";
		}
	}
	getAvailableHeight() {
		const { popup, forcePopupParentAsOffsetParent } = this.config;
		if (!this.positioned) this.initialisePosition();
		const { clientHeight } = this.offsetParent;
		if (!clientHeight) return null;
		const elRect = this.element.getBoundingClientRect();
		const offsetParentRect = this.offsetParent.getBoundingClientRect();
		const yPosition = popup ? this.position.y : elRect.top;
		const parentTop = popup ? 0 : offsetParentRect.top;
		let additionalHeight = 0;
		if (forcePopupParentAsOffsetParent) {
			const parentEl = this.element.parentElement;
			if (parentEl) {
				const { bottom } = parentEl.getBoundingClientRect();
				additionalHeight = bottom - elRect.bottom;
			}
		}
		return clientHeight + parentTop - yPosition - additionalHeight;
	}
	getWidth() {
		return this.element.offsetWidth;
	}
	setWidth(width) {
		const eGui = this.element;
		const { popup } = this.config;
		let isPercent = false;
		if (typeof width === "string" && width.indexOf("%") !== -1) {
			_setFixedWidth(eGui, width);
			width = _getAbsoluteWidth(eGui);
			isPercent = true;
		} else if (this.positioned) {
			width = Math.max(this.minWidth, width);
			const { clientWidth } = this.offsetParent;
			const xPosition = popup ? this.position.x : this.element.getBoundingClientRect().left;
			if (clientWidth && width + xPosition > clientWidth) width = clientWidth - xPosition;
		}
		if (this.getWidth() === width) return;
		if (!isPercent) if (this.config.popup) _setFixedWidth(eGui, width);
		else {
			eGui.style.width = `${width}px`;
			eGui.style.flex = " unset";
			this.lastSize.width = typeof width === "number" ? width : parseFloat(width);
		}
		else {
			eGui.style.maxWidth = "unset";
			eGui.style.minWidth = "unset";
		}
	}
	offsetElement(x = 0, y = 0, postProcessCallback) {
		const { forcePopupParentAsOffsetParent } = this.config;
		const ePopup = forcePopupParentAsOffsetParent ? this.boundaryEl : this.element;
		if (!ePopup) return;
		this.popupSvc?.positionPopup({
			ePopup,
			keepWithinBounds: true,
			skipObserver: this.movable || this.isResizable(),
			updatePosition: () => ({
				x,
				y
			}),
			postProcessCallback
		});
		this.setPosition(parseFloat(ePopup.style.left), parseFloat(ePopup.style.top));
	}
	constrainSizeToAvailableHeight(constrain) {
		if (!this.config.forcePopupParentAsOffsetParent) return;
		const applyMaxHeightToElement = () => {
			const availableHeight = this.getAvailableHeight();
			this.element.style.setProperty("max-height", `${availableHeight}px`);
		};
		if (constrain && this.popupSvc) {
			this.resizeObserverSubscriber?.();
			this.resizeObserverSubscriber = _observeResize(this.beans, this.popupSvc?.getPopupParent(), applyMaxHeightToElement);
		} else {
			this.element.style.removeProperty("max-height");
			if (this.resizeObserverSubscriber) {
				this.resizeObserverSubscriber();
				this.resizeObserverSubscriber = void 0;
			}
		}
	}
	setPosition(x, y) {
		this.position.x = x;
		this.position.y = y;
	}
	updateDragStartPosition(x, y) {
		this.dragStartPosition = {
			x,
			y
		};
	}
	calculateMouseMovement(params) {
		const { e, isLeft, isTop, anywhereWithin, topBuffer } = params;
		const xDiff = e.clientX - this.dragStartPosition.x;
		const yDiff = e.clientY - this.dragStartPosition.y;
		return {
			movementX: this.shouldSkipX(e, !!isLeft, !!anywhereWithin, xDiff) ? 0 : xDiff,
			movementY: this.shouldSkipY(e, !!isTop, topBuffer, yDiff) ? 0 : yDiff
		};
	}
	shouldSkipX(e, isLeft, anywhereWithin, diff) {
		const elRect = this.element.getBoundingClientRect();
		const parentRect = this.offsetParent.getBoundingClientRect();
		const boundaryElRect = this.boundaryEl.getBoundingClientRect();
		const xPosition = this.config.popup ? this.position.x : elRect.left;
		let skipX = xPosition <= 0 && parentRect.left >= e.clientX || parentRect.right <= e.clientX && parentRect.right <= boundaryElRect.right;
		if (skipX) return true;
		if (isLeft) skipX = diff < 0 && e.clientX > xPosition + parentRect.left || diff > 0 && e.clientX < xPosition + parentRect.left;
		else if (anywhereWithin) skipX = diff < 0 && e.clientX > boundaryElRect.right || diff > 0 && e.clientX < xPosition + parentRect.left;
		else skipX = diff < 0 && e.clientX > boundaryElRect.right || diff > 0 && e.clientX < boundaryElRect.right;
		return skipX;
	}
	shouldSkipY(e, isTop, topBuffer = 0, diff) {
		const elRect = this.element.getBoundingClientRect();
		const parentRect = this.offsetParent.getBoundingClientRect();
		const boundaryElRect = this.boundaryEl.getBoundingClientRect();
		const yPosition = this.config.popup ? this.position.y : elRect.top;
		let skipY = yPosition <= 0 && parentRect.top >= e.clientY || parentRect.bottom <= e.clientY && parentRect.bottom <= boundaryElRect.bottom;
		if (skipY) return true;
		if (isTop) skipY = diff < 0 && e.clientY > yPosition + parentRect.top + topBuffer || diff > 0 && e.clientY < yPosition + parentRect.top;
		else skipY = diff < 0 && e.clientY > boundaryElRect.bottom || diff > 0 && e.clientY < boundaryElRect.bottom;
		return skipY;
	}
	createResizeMap() {
		const getElement2 = (ref$1) => ({ element: this.element.querySelector(`[data-ref=${ref$1}Resizer]`) });
		this.resizerMap = {
			topLeft: getElement2("eTopLeft"),
			top: getElement2("eTop"),
			topRight: getElement2("eTopRight"),
			right: getElement2("eRight"),
			bottomRight: getElement2("eBottomRight"),
			bottom: getElement2("eBottom"),
			bottomLeft: getElement2("eBottomLeft"),
			left: getElement2("eLeft")
		};
	}
	addResizers() {
		if (this.resizersAdded) return;
		const eGui = this.element;
		if (!eGui) return;
		eGui.appendChild(_createElement(RESIZE_TEMPLATE));
		this.createResizeMap();
		this.resizersAdded = true;
	}
	removeResizers() {
		this.resizerMap = void 0;
		const resizerEl = this.element.querySelector(`.${RESIZE_CONTAINER_STYLE}`);
		if (resizerEl) this.element.removeChild(resizerEl);
		this.resizersAdded = false;
	}
	getResizerElement(side) {
		return this.resizerMap[side].element;
	}
	onResizeStart(e, side) {
		this.boundaryEl = this.findBoundaryElement();
		if (!this.positioned) this.initialisePosition();
		this.currentResizer = {
			isTop: !!side.match(/top/i),
			isRight: !!side.match(/right/i),
			isBottom: !!side.match(/bottom/i),
			isLeft: !!side.match(/left/i)
		};
		this.element.classList.add("ag-resizing");
		this.resizerMap[side].element.classList.add("ag-active");
		const { popup, forcePopupParentAsOffsetParent } = this.config;
		if (!popup && !forcePopupParentAsOffsetParent) this.applySizeToSiblings(this.currentResizer.isBottom || this.currentResizer.isTop);
		this.isResizing = true;
		this.updateDragStartPosition(e.clientX, e.clientY);
	}
	getSiblings() {
		const parent = this.element.parentElement;
		if (!parent) return null;
		return Array.prototype.slice.call(parent.children).filter((el) => !el.classList.contains("ag-hidden"));
	}
	getMinSizeOfSiblings() {
		const siblings = this.getSiblings() || [];
		let height = 0;
		let width = 0;
		for (let i = 0; i < siblings.length; i++) {
			const currentEl = siblings[i];
			const isFlex = !!currentEl.style.flex && currentEl.style.flex !== "0 0 auto";
			if (currentEl === this.element) continue;
			let nextHeight = this.minHeight || 0;
			let nextWidth = this.minWidth || 0;
			if (isFlex) {
				const computedStyle = window.getComputedStyle(currentEl);
				if (computedStyle.minHeight) nextHeight = parseInt(computedStyle.minHeight, 10);
				if (computedStyle.minWidth) nextWidth = parseInt(computedStyle.minWidth, 10);
			} else {
				nextHeight = currentEl.offsetHeight;
				nextWidth = currentEl.offsetWidth;
			}
			height += nextHeight;
			width += nextWidth;
		}
		return {
			height,
			width
		};
	}
	applySizeToSiblings(vertical) {
		let containerToFlex = null;
		const siblings = this.getSiblings();
		if (!siblings) return;
		for (let i = 0; i < siblings.length; i++) {
			const el = siblings[i];
			if (el === containerToFlex) continue;
			if (vertical) el.style.height = `${el.offsetHeight}px`;
			else el.style.width = `${el.offsetWidth}px`;
			el.style.flex = "0 0 auto";
			if (el === this.element) containerToFlex = siblings[i + 1];
		}
		if (containerToFlex) {
			containerToFlex.style.removeProperty("height");
			containerToFlex.style.removeProperty("min-height");
			containerToFlex.style.removeProperty("max-height");
			containerToFlex.style.flex = "1 1 auto";
		}
	}
	isResizable() {
		return Object.values(this.resizable).some((value) => value);
	}
	onResize(e) {
		if (!this.isResizing || !this.currentResizer) return;
		const { popup, forcePopupParentAsOffsetParent } = this.config;
		const { isTop, isRight, isBottom, isLeft } = this.currentResizer;
		const isHorizontal = isRight || isLeft;
		const isVertical = isBottom || isTop;
		const { movementX, movementY } = this.calculateMouseMovement({
			e,
			isLeft,
			isTop
		});
		const xPosition = this.position.x;
		const yPosition = this.position.y;
		let offsetLeft = 0;
		let offsetTop = 0;
		if (isHorizontal && movementX) {
			const direction = isLeft ? -1 : 1;
			const oldWidth = this.getWidth();
			const newWidth = oldWidth + movementX * direction;
			let skipWidth = false;
			if (isLeft) {
				offsetLeft = oldWidth - newWidth;
				if (xPosition + offsetLeft <= 0 || newWidth <= this.minWidth) {
					skipWidth = true;
					offsetLeft = 0;
				}
			}
			if (!skipWidth) this.setWidth(newWidth);
		}
		if (isVertical && movementY) {
			const direction = isTop ? -1 : 1;
			const oldHeight = this.getHeight();
			const newHeight = oldHeight + movementY * direction;
			let skipHeight = false;
			if (isTop) {
				offsetTop = oldHeight - newHeight;
				if (yPosition + offsetTop <= 0 || newHeight <= this.minHeight) {
					skipHeight = true;
					offsetTop = 0;
				}
			} else if (!this.config.popup && !this.config.forcePopupParentAsOffsetParent && oldHeight < newHeight && this.getMinSizeOfSiblings().height + newHeight > this.element.parentElement.offsetHeight) skipHeight = true;
			if (!skipHeight) this.setHeight(newHeight);
		}
		this.updateDragStartPosition(e.clientX, e.clientY);
		if ((popup || forcePopupParentAsOffsetParent) && offsetLeft || offsetTop) this.offsetElement(xPosition + offsetLeft, yPosition + offsetTop);
	}
	onResizeEnd(e, side) {
		this.isResizing = false;
		this.currentResizer = null;
		this.boundaryEl = null;
		this.element.classList.remove("ag-resizing");
		this.resizerMap[side].element.classList.remove("ag-active");
		this.dispatchLocalEvent({ type: "resize" });
	}
	refreshSize() {
		const eGui = this.element;
		if (this.config.popup) {
			if (!this.config.width) this.setWidth(eGui.offsetWidth);
			if (!this.config.height) this.setHeight(eGui.offsetHeight);
		}
	}
	onMoveStart(e) {
		this.boundaryEl = this.findBoundaryElement();
		if (!this.positioned) this.initialisePosition();
		this.isMoving = true;
		this.element.classList.add("ag-moving");
		this.updateDragStartPosition(e.clientX, e.clientY);
	}
	onMove(e) {
		if (!this.isMoving) return;
		const { x, y } = this.position;
		let topBuffer;
		if (this.config.calculateTopBuffer) topBuffer = this.config.calculateTopBuffer();
		const { movementX, movementY } = this.calculateMouseMovement({
			e,
			isTop: true,
			anywhereWithin: true,
			topBuffer
		});
		this.offsetElement(x + movementX, y + movementY);
		this.updateDragStartPosition(e.clientX, e.clientY);
	}
	onMoveEnd() {
		this.isMoving = false;
		this.boundaryEl = null;
		this.element.classList.remove("ag-moving");
	}
	setOffsetParent() {
		if (this.config.forcePopupParentAsOffsetParent && this.popupSvc) this.offsetParent = this.popupSvc.getPopupParent();
		else this.offsetParent = this.element.offsetParent;
	}
	findBoundaryElement() {
		let el = this.element;
		while (el) {
			if (window.getComputedStyle(el).position !== "static") return el;
			el = el.parentElement;
		}
		return this.element;
	}
	clearResizeListeners() {
		while (this.resizeListeners.length) {
			const params = this.resizeListeners.pop();
			this.dragSvc?.removeDragSource(params);
		}
	}
	destroy() {
		super.destroy();
		if (this.moveElementDragListener) this.dragSvc?.removeDragSource(this.moveElementDragListener);
		this.constrainSizeToAvailableHeight(false);
		this.clearResizeListeners();
		this.removeResizers();
	}
};
var FOCUS_MANAGED_CLASS = "ag-focus-managed";
var ManagedFocusFeature = class extends BeanStub {
	constructor(eFocusable, callbacks = {}) {
		super();
		this.eFocusable = eFocusable;
		this.callbacks = callbacks;
		this.callbacks = {
			shouldStopEventPropagation: () => false,
			onTabKeyDown: (e) => {
				if (e.defaultPrevented) return;
				const nextRoot = _findNextFocusableElement(this.beans, this.eFocusable, false, e.shiftKey);
				if (!nextRoot) return;
				nextRoot.focus();
				e.preventDefault();
			},
			...callbacks
		};
	}
	postConstruct() {
		const { eFocusable, callbacks: { onFocusIn, onFocusOut } } = this;
		eFocusable.classList.add(FOCUS_MANAGED_CLASS);
		this.addKeyDownListeners(eFocusable);
		if (onFocusIn) this.addManagedElementListeners(eFocusable, { focusin: onFocusIn });
		if (onFocusOut) this.addManagedElementListeners(eFocusable, { focusout: onFocusOut });
	}
	addKeyDownListeners(eGui) {
		this.addManagedElementListeners(eGui, { keydown: (e) => {
			if (e.defaultPrevented || _isStopPropagationForAgGrid(e)) return;
			const { callbacks } = this;
			if (callbacks.shouldStopEventPropagation(e)) {
				_stopPropagationForAgGrid(e);
				return;
			}
			if (e.key === KeyCode.TAB) callbacks.onTabKeyDown(e);
			else if (callbacks.handleKeyDown) callbacks.handleKeyDown(e);
		} });
	}
};
var ProvidedFilter = class extends Component {
	constructor(filterNameKey, cssIdentifier) {
		super();
		this.filterNameKey = filterNameKey;
		this.cssIdentifier = cssIdentifier;
		this.applyActive = false;
		this.debouncePending = false;
		this.defaultDebounceMs = 0;
	}
	postConstruct() {
		const element = {
			tag: "div",
			cls: `ag-filter-body-wrapper ag-${this.cssIdentifier}-body-wrapper`,
			children: [this.createBodyTemplate()]
		};
		this.setTemplate(element, this.getAgComponents());
		this.createManagedBean(new ManagedFocusFeature(this.getFocusableElement(), { handleKeyDown: this.handleKeyDown.bind(this) }));
		this.positionableFeature = this.createBean(new PositionableFeature(this.getPositionableElement(), { forcePopupParentAsOffsetParent: true }));
	}
	handleKeyDown(_e) {}
	init(legacyParams) {
		const params = legacyParams;
		this.setParams(params);
		this.setModelIntoUi(params.state.model, true).then(() => this.updateUiVisibility());
	}
	refresh(legacyNewParams) {
		const newParams = legacyNewParams;
		const oldParams = this.params;
		this.params = newParams;
		if (newParams.source === "colDef") this.updateParams(newParams, oldParams);
		const newState = newParams.state;
		const oldState = this.state;
		this.state = newState;
		if (newState.model !== oldState.model || newState.state !== oldState.state) this.setModelIntoUi(newState.model);
		return true;
	}
	setParams(params) {
		this.params = params;
		this.state = params.state;
		this.commonUpdateParams(params);
	}
	updateParams(newParams, oldParams) {
		this.commonUpdateParams(newParams, oldParams);
	}
	commonUpdateParams(newParams, _oldParams) {
		this.applyActive = _isUseApplyButton(newParams);
		this.setupApplyDebounced();
	}
	doesFilterPass(params) {
		_warn(283);
		const { getHandler, model, column } = this.params;
		return getHandler().doesFilterPass({
			...params,
			model,
			handlerParams: this.beans.colFilter.getHandlerParams(column)
		});
	}
	getFilterTitle() {
		return this.translate(this.filterNameKey);
	}
	isFilterActive() {
		_warn(284);
		return this.params.model != null;
	}
	setupApplyDebounced() {
		const debounceMs = getDebounceMs(this.params, this.defaultDebounceMs);
		const debounceFunc = _debounce(this, this.checkApplyDebounce.bind(this), debounceMs);
		this.applyDebounced = () => {
			this.debouncePending = true;
			debounceFunc();
		};
	}
	checkApplyDebounce() {
		if (this.debouncePending) {
			this.debouncePending = false;
			this.doApplyModel();
		}
	}
	getModel() {
		_warn(285);
		return this.params.model;
	}
	setModel(model) {
		_warn(286);
		const { beans, params } = this;
		return beans.colFilter.setModelForColumnLegacy(params.column, model);
	}
	applyModel(_source = "api") {
		return this.doApplyModel();
	}
	canApply(_model) {
		return true;
	}
	doApplyModel(additionalEventAttributes) {
		const { params, state } = this;
		const changed = !this.areModelsEqual(params.model, state.model);
		if (changed) params.onAction("apply", additionalEventAttributes);
		return changed;
	}
	onNewRowsLoaded() {}
	onUiChanged(apply, afterFloatingFilter = false) {
		this.updateUiVisibility();
		const model = this.getModelFromUi();
		const state = {
			model,
			state: this.getState(),
			valid: this.canApply(model)
		};
		this.state = state;
		const params = this.params;
		params.onStateChange(state);
		params.onUiChange(this.getUiChangeEventParams());
		if (!this.gos.get("enableFilterHandlers")) this.eventSvc.dispatchEvent({
			type: "filterModified",
			column: params.column,
			filterInstance: this
		});
		apply ?? (apply = this.applyActive ? void 0 : "debounce");
		if (apply === "immediately") this.doApplyModel({
			afterFloatingFilter,
			afterDataChange: false
		});
		else if (apply === "debounce") this.applyDebounced();
	}
	getState() {}
	getUiChangeEventParams() {}
	afterGuiAttached(params) {
		this.lastContainerType = params?.container;
		this.refreshFilterResizer(params?.container);
	}
	refreshFilterResizer(containerType) {
		const { positionableFeature, gos } = this;
		if (!positionableFeature) return;
		const isResizable = containerType === "floatingFilter" || containerType === "columnFilter";
		if (isResizable) {
			positionableFeature.restoreLastSize();
			positionableFeature.setResizable(gos.get("enableRtl") ? {
				bottom: true,
				bottomLeft: true,
				left: true
			} : {
				bottom: true,
				bottomRight: true,
				right: true
			});
		} else {
			positionableFeature.removeSizeFromEl();
			positionableFeature.setResizable(false);
		}
		positionableFeature.constrainSizeToAvailableHeight(isResizable);
	}
	afterGuiDetached() {
		this.checkApplyDebounce();
		this.positionableFeature?.constrainSizeToAvailableHeight(false);
	}
	destroy() {
		this.positionableFeature = this.destroyBean(this.positionableFeature);
		super.destroy();
	}
	translate(key) {
		return translateForFilter(this, key);
	}
	getPositionableElement() {
		return this.getGui();
	}
	areModelsEqual(a, b) {
		if (a === b || a == null && b == null) return true;
		if (a == null || b == null) return false;
		return this.areNonNullModelsEqual(a, b);
	}
};
function isCombinedFilterModel(model) {
	return !!model.operator;
}
function _getDefaultFloatingFilterType(frameworkOverrides, def, getFromDefault) {
	if (def == null) return null;
	let defaultFloatingFilterType = null;
	const { compName, jsComp, fwComp } = _getFilterCompKeys(frameworkOverrides, def);
	if (compName) defaultFloatingFilterType = {
		agSetColumnFilter: "agSetColumnFloatingFilter",
		agMultiColumnFilter: "agMultiColumnFloatingFilter",
		agGroupColumnFilter: "agGroupColumnFloatingFilter",
		agNumberColumnFilter: "agNumberColumnFloatingFilter",
		agDateColumnFilter: "agDateColumnFloatingFilter",
		agTextColumnFilter: "agTextColumnFloatingFilter"
	}[compName];
	else if (jsComp == null && fwComp == null && def.filter === true) defaultFloatingFilterType = getFromDefault();
	return defaultFloatingFilterType;
}
var LayoutCssClasses = {
	AUTO_HEIGHT: "ag-layout-auto-height",
	NORMAL: "ag-layout-normal",
	PRINT: "ag-layout-print"
};
var LayoutFeature = class extends BeanStub {
	constructor(view) {
		super();
		this.view = view;
	}
	postConstruct() {
		this.addManagedPropertyListener("domLayout", this.updateLayoutClasses.bind(this));
		this.updateLayoutClasses();
	}
	updateLayoutClasses() {
		const domLayout = this.gos.get("domLayout");
		const params = {
			autoHeight: domLayout === "autoHeight",
			normal: domLayout === "normal",
			print: domLayout === "print"
		};
		const cssClass = params.autoHeight ? LayoutCssClasses.AUTO_HEIGHT : params.print ? LayoutCssClasses.PRINT : LayoutCssClasses.NORMAL;
		this.view.updateLayoutClasses(cssClass, params);
	}
};
var VIEWPORT = "Viewport";
var FAKE_V_SCROLLBAR = "fakeVScrollComp";
var HORIZONTAL_SOURCES = [
	"fakeHScrollComp",
	"centerHeader",
	"topCenter",
	"bottomCenter",
	"stickyTopCenter",
	"stickyBottomCenter"
];
var SCROLL_DEBOUNCE_TIMEOUT = 100;
var SCROLL_END_TIMEOUT = 150;
var GridBodyScrollFeature = class extends BeanStub {
	constructor(eBodyViewport) {
		super();
		this.clearRetryListenerFncs = [];
		this.lastScrollSource = [null, null];
		this.scrollLeft = -1;
		this.nextScrollTop = -1;
		this.scrollTop = -1;
		this.lastOffsetHeight = -1;
		this.lastScrollTop = -1;
		this.lastIsHorizontalScrollShowing = false;
		this.scrollTimer = 0;
		this.isScrollActive = false;
		this.isVerticalPositionInvalidated = true;
		this.isHorizontalPositionInvalidated = true;
		this.eBodyViewport = eBodyViewport;
		this.resetLastHScrollDebounced = _debounce(this, () => this.lastScrollSource[1] = null, SCROLL_END_TIMEOUT);
		this.resetLastVScrollDebounced = _debounce(this, () => this.lastScrollSource[0] = null, SCROLL_END_TIMEOUT);
	}
	wireBeans(beans) {
		this.ctrlsSvc = beans.ctrlsSvc;
		this.animationFrameSvc = beans.animationFrameSvc;
		this.visibleCols = beans.visibleCols;
	}
	destroy() {
		super.destroy();
		this.clearRetryListenerFncs = [];
		window.clearTimeout(this.scrollTimer);
	}
	postConstruct() {
		this.enableRtl = this.gos.get("enableRtl");
		const invalidateVerticalScroll = this.invalidateVerticalScroll.bind(this);
		const invalidateHorizontalScroll = this.invalidateHorizontalScroll.bind(this);
		this.addManagedEventListeners({
			displayedColumnsWidthChanged: this.onDisplayedColumnsWidthChanged.bind(this),
			gridSizeChanged: invalidateVerticalScroll,
			scrollGapChanged: invalidateHorizontalScroll
		});
		this.addManagedElementListeners(this.eBodyViewport, { scroll: invalidateVerticalScroll });
		this.ctrlsSvc.whenReady(this, (p) => {
			this.centerRowsCtrl = p.center;
			this.onDisplayedColumnsWidthChanged();
			this.addScrollListener();
		});
	}
	invalidateHorizontalScroll() {
		this.isHorizontalPositionInvalidated = true;
	}
	invalidateVerticalScroll() {
		this.isVerticalPositionInvalidated = true;
	}
	addScrollListener() {
		this.addHorizontalScrollListeners();
		this.addVerticalScrollListeners();
	}
	addHorizontalScrollListeners() {
		this.addManagedElementListeners(this.centerRowsCtrl.eViewport, { scroll: this.onHScroll.bind(this, VIEWPORT) });
		for (const source of HORIZONTAL_SOURCES) {
			const scrollPartner = this.ctrlsSvc.get(source);
			this.registerScrollPartner(scrollPartner, this.onHScroll.bind(this, source));
		}
	}
	addVerticalScrollListeners() {
		const fakeVScrollComp = this.ctrlsSvc.get("fakeVScrollComp");
		const isDebounce = this.gos.get("debounceVerticalScrollbar");
		const onVScroll = isDebounce ? _debounce(this, this.onVScroll.bind(this, VIEWPORT), SCROLL_DEBOUNCE_TIMEOUT) : this.onVScroll.bind(this, VIEWPORT);
		const onFakeVScroll = isDebounce ? _debounce(this, this.onVScroll.bind(this, FAKE_V_SCROLLBAR), SCROLL_DEBOUNCE_TIMEOUT) : this.onVScroll.bind(this, FAKE_V_SCROLLBAR);
		this.addManagedElementListeners(this.eBodyViewport, { scroll: onVScroll });
		this.registerScrollPartner(fakeVScrollComp, onFakeVScroll);
	}
	registerScrollPartner(comp, callback) {
		comp.onScrollCallback(callback);
	}
	onDisplayedColumnsWidthChanged() {
		if (this.enableRtl) this.horizontallyScrollHeaderCenterAndFloatingCenter();
	}
	horizontallyScrollHeaderCenterAndFloatingCenter(scrollLeft) {
		if (this.centerRowsCtrl == null) return;
		if (scrollLeft === void 0) scrollLeft = this.centerRowsCtrl.getCenterViewportScrollLeft();
		this.setScrollLeftForAllContainersExceptCurrent(Math.abs(scrollLeft));
	}
	setScrollLeftForAllContainersExceptCurrent(scrollLeft) {
		for (const container of [...HORIZONTAL_SOURCES, VIEWPORT]) {
			if (this.lastScrollSource[1] === container) continue;
			_setScrollLeft(this.getViewportForSource(container), scrollLeft, this.enableRtl);
		}
	}
	getViewportForSource(source) {
		if (source === VIEWPORT) return this.centerRowsCtrl.eViewport;
		return this.ctrlsSvc.get(source).eViewport;
	}
	isControllingScroll(source, direction) {
		if (this.lastScrollSource[direction] == null) {
			if (direction === 0) this.lastScrollSource[0] = source;
			else this.lastScrollSource[1] = source;
			return true;
		}
		return this.lastScrollSource[direction] === source;
	}
	onHScroll(source) {
		if (!this.isControllingScroll(source, 1)) return;
		const { scrollLeft } = this.centerRowsCtrl.eViewport;
		if (this.shouldBlockScrollUpdate(1, scrollLeft, true)) return;
		const newScrollLeft = _getScrollLeft(this.getViewportForSource(source), this.enableRtl);
		this.doHorizontalScroll(newScrollLeft);
		this.resetLastHScrollDebounced();
	}
	onVScroll(source) {
		if (!this.isControllingScroll(source, 0)) return;
		let scrollTop;
		if (source === VIEWPORT) scrollTop = this.eBodyViewport.scrollTop;
		else scrollTop = this.ctrlsSvc.get("fakeVScrollComp").getScrollPosition();
		if (this.shouldBlockScrollUpdate(0, scrollTop, true)) return;
		const { animationFrameSvc } = this;
		animationFrameSvc?.setScrollTop(scrollTop);
		this.nextScrollTop = scrollTop;
		if (source === VIEWPORT) this.ctrlsSvc.get("fakeVScrollComp").setScrollPosition(scrollTop);
		else this.eBodyViewport.scrollTop = scrollTop;
		if (animationFrameSvc?.active) animationFrameSvc.schedule();
		else this.scrollGridIfNeeded(true);
		this.resetLastVScrollDebounced();
	}
	doHorizontalScroll(scrollLeft) {
		const fakeScrollLeft = this.ctrlsSvc.get("fakeHScrollComp").getScrollPosition();
		if (this.scrollLeft === scrollLeft && scrollLeft === fakeScrollLeft) return;
		this.scrollLeft = scrollLeft;
		this.fireScrollEvent(1);
		this.horizontallyScrollHeaderCenterAndFloatingCenter(scrollLeft);
		this.centerRowsCtrl.onHorizontalViewportChanged(true);
	}
	isScrolling() {
		return this.isScrollActive;
	}
	fireScrollEvent(direction) {
		const bodyScrollEvent = {
			type: "bodyScroll",
			direction: direction === 1 ? "horizontal" : "vertical",
			left: this.scrollLeft,
			top: this.scrollTop
		};
		this.isScrollActive = true;
		this.eventSvc.dispatchEvent(bodyScrollEvent);
		window.clearTimeout(this.scrollTimer);
		this.scrollTimer = window.setTimeout(() => {
			this.scrollTimer = 0;
			this.isScrollActive = false;
			this.eventSvc.dispatchEvent({
				...bodyScrollEvent,
				type: "bodyScrollEnd"
			});
		}, SCROLL_END_TIMEOUT);
	}
	shouldBlockScrollUpdate(direction, scrollTo, touchOnly = false) {
		if (touchOnly && !_isIOSUserAgent()) return false;
		if (direction === 0) return this.shouldBlockVerticalScroll(scrollTo);
		return this.shouldBlockHorizontalScroll(scrollTo);
	}
	shouldBlockVerticalScroll(scrollTo) {
		const clientHeight = _getInnerHeight(this.eBodyViewport);
		const { scrollHeight } = this.eBodyViewport;
		if (scrollTo < 0 || scrollTo + clientHeight > scrollHeight) return true;
		return false;
	}
	shouldBlockHorizontalScroll(scrollTo) {
		const clientWidth = this.centerRowsCtrl.getCenterWidth();
		const { scrollWidth } = this.centerRowsCtrl.eViewport;
		if (this.enableRtl) {
			if (scrollTo > 0) return true;
		} else if (scrollTo < 0) return true;
		if (Math.abs(scrollTo) + clientWidth > scrollWidth) return true;
		return false;
	}
	redrawRowsAfterScroll() {
		this.fireScrollEvent(0);
	}
	checkScrollLeft() {
		const scrollLeft = this.scrollLeft;
		let hasHorizontalScrollersOutOfSync = false;
		for (const source of HORIZONTAL_SOURCES) if (this.getViewportForSource(source).scrollLeft !== scrollLeft) {
			hasHorizontalScrollersOutOfSync = true;
			break;
		}
		if (hasHorizontalScrollersOutOfSync) this.onHScroll(VIEWPORT);
	}
	scrollGridIfNeeded(suppressedAnimationFrame = false) {
		const frameNeeded = this.scrollTop != this.nextScrollTop;
		if (frameNeeded) {
			this.scrollTop = this.nextScrollTop;
			if (suppressedAnimationFrame) this.invalidateVerticalScroll();
			this.redrawRowsAfterScroll();
		}
		return frameNeeded;
	}
	setHorizontalScrollPosition(hScrollPosition, fromAlignedGridsService = false) {
		const minScrollLeft = 0;
		const maxScrollLeft = this.centerRowsCtrl.eViewport.scrollWidth - this.centerRowsCtrl.getCenterWidth();
		if (!fromAlignedGridsService && this.shouldBlockScrollUpdate(1, hScrollPosition)) if (this.enableRtl) hScrollPosition = hScrollPosition > 0 ? 0 : maxScrollLeft;
		else hScrollPosition = Math.min(Math.max(hScrollPosition, minScrollLeft), maxScrollLeft);
		_setScrollLeft(this.centerRowsCtrl.eViewport, Math.abs(hScrollPosition), this.enableRtl);
		this.doHorizontalScroll(hScrollPosition);
	}
	setVerticalScrollPosition(vScrollPosition) {
		this.invalidateVerticalScroll();
		this.eBodyViewport.scrollTop = vScrollPosition;
	}
	getVScrollPosition() {
		if (!this.isVerticalPositionInvalidated) {
			const { lastOffsetHeight, lastScrollTop } = this;
			return {
				top: lastScrollTop,
				bottom: lastScrollTop + lastOffsetHeight
			};
		}
		this.isVerticalPositionInvalidated = false;
		const { scrollTop, offsetHeight } = this.eBodyViewport;
		this.lastScrollTop = scrollTop;
		this.lastOffsetHeight = offsetHeight;
		return {
			top: scrollTop,
			bottom: scrollTop + offsetHeight
		};
	}
	getApproximateVScollPosition() {
		if (this.lastScrollTop >= 0 && this.lastOffsetHeight >= 0) return {
			top: this.scrollTop,
			bottom: this.scrollTop + this.lastOffsetHeight
		};
		return this.getVScrollPosition();
	}
	getHScrollPosition() {
		return this.centerRowsCtrl.getHScrollPosition();
	}
	isHorizontalScrollShowing() {
		if (this.isHorizontalPositionInvalidated) {
			this.lastIsHorizontalScrollShowing = this.centerRowsCtrl.isHorizontalScrollShowing();
			this.isHorizontalPositionInvalidated = false;
		}
		return this.lastIsHorizontalScrollShowing;
	}
	scrollHorizontally(pixels) {
		const oldScrollPosition = this.centerRowsCtrl.eViewport.scrollLeft;
		this.setHorizontalScrollPosition(oldScrollPosition + pixels);
		return this.centerRowsCtrl.eViewport.scrollLeft - oldScrollPosition;
	}
	scrollToTop() {
		this.eBodyViewport.scrollTop = 0;
	}
	ensureNodeVisible(comparator, position = null) {
		const { rowModel } = this.beans;
		const rowCount = rowModel.getRowCount();
		let indexToSelect = -1;
		for (let i = 0; i < rowCount; i++) {
			const node = rowModel.getRow(i);
			if (typeof comparator === "function") {
				if (node && comparator(node)) {
					indexToSelect = i;
					break;
				}
			} else if (comparator === node || comparator === node.data) {
				indexToSelect = i;
				break;
			}
		}
		if (indexToSelect >= 0) this.ensureIndexVisible(indexToSelect, position);
	}
	ensureIndexVisible(index, position, retry = 0) {
		if (_isDomLayout(this.gos, "print")) return;
		const { rowModel } = this.beans;
		const rowCount = rowModel.getRowCount();
		if (typeof index !== "number" || index < 0 || index >= rowCount) {
			_warn(88, { index });
			return;
		}
		this.clearRetryListeners();
		const { frameworkOverrides, pageBounds, rowContainerHeight: heightScaler, rowRenderer } = this.beans;
		frameworkOverrides.wrapIncoming(() => {
			const gridBodyCtrl = this.ctrlsSvc.getGridBodyCtrl();
			const rowNode = rowModel.getRow(index);
			let rowGotShiftedDuringOperation;
			let stickyHeightsChanged;
			let attempt = 0;
			this.invalidateVerticalScroll();
			do {
				const { stickyTopHeight, stickyBottomHeight } = gridBodyCtrl;
				const startingRowTop = rowNode.rowTop;
				const startingRowHeight = rowNode.rowHeight;
				const paginationOffset = pageBounds.getPixelOffset();
				const rowTopPixel = rowNode.rowTop - paginationOffset;
				const rowBottomPixel = rowTopPixel + rowNode.rowHeight;
				const scrollPosition = this.getVScrollPosition();
				const heightOffset = heightScaler.divStretchOffset;
				const vScrollTop = scrollPosition.top + heightOffset;
				const vScrollBottom = scrollPosition.bottom + heightOffset;
				const viewportHeight = vScrollBottom - vScrollTop;
				const pxTop = heightScaler.getScrollPositionForPixel(rowTopPixel);
				const pxBottom = heightScaler.getScrollPositionForPixel(rowBottomPixel - viewportHeight);
				const pxMiddle = Math.min((pxTop + pxBottom) / 2, rowTopPixel);
				const rowAboveViewport = vScrollTop + stickyTopHeight > rowTopPixel;
				const rowBelowViewport = vScrollBottom - stickyBottomHeight < rowBottomPixel;
				let newScrollPosition = null;
				if (position === "top") newScrollPosition = pxTop - stickyTopHeight;
				else if (position === "bottom") newScrollPosition = pxBottom + stickyBottomHeight;
				else if (position === "middle") newScrollPosition = pxMiddle;
				else if (rowAboveViewport) newScrollPosition = pxTop - stickyTopHeight;
				else if (rowBelowViewport) if (pxBottom - pxTop > viewportHeight) newScrollPosition = pxTop - stickyTopHeight;
				else newScrollPosition = pxBottom + stickyBottomHeight;
				if (newScrollPosition !== null) {
					this.setVerticalScrollPosition(newScrollPosition);
					rowRenderer.redraw({ afterScroll: true });
				}
				rowGotShiftedDuringOperation = startingRowTop !== rowNode.rowTop || startingRowHeight !== rowNode.rowHeight;
				stickyHeightsChanged = stickyTopHeight !== gridBodyCtrl.stickyTopHeight || stickyBottomHeight !== gridBodyCtrl.stickyBottomHeight;
				attempt++;
			} while ((rowGotShiftedDuringOperation || stickyHeightsChanged) && attempt < 10);
			this.animationFrameSvc?.flushAllFrames();
			if (retry < 10 && (rowNode?.stub || !this.beans.rowAutoHeight?.areRowsMeasured())) {
				const scrollTop = this.getVScrollPosition().top;
				this.clearRetryListenerFncs = this.addManagedEventListeners({
					bodyScroll: () => {
						if (scrollTop === this.getVScrollPosition().top) return;
						this.clearRetryListeners();
					},
					modelUpdated: () => {
						this.clearRetryListeners();
						if (index >= rowModel.getRowCount()) return;
						this.ensureIndexVisible(index, position, retry + 1);
					}
				});
			}
		});
	}
	clearRetryListeners() {
		this.clearRetryListenerFncs.forEach((callback) => callback());
		this.clearRetryListenerFncs = [];
	}
	ensureColumnVisible(key, position = "auto") {
		const { colModel, frameworkOverrides } = this.beans;
		const column = colModel.getCol(key);
		if (!column) return;
		if (column.isPinned()) return;
		if (!this.visibleCols.isColDisplayed(column)) return;
		const newHorizontalScroll = this.getPositionedHorizontalScroll(column, position);
		frameworkOverrides.wrapIncoming(() => {
			if (newHorizontalScroll !== null) this.centerRowsCtrl.setCenterViewportScrollLeft(newHorizontalScroll);
			this.centerRowsCtrl.onHorizontalViewportChanged();
			this.animationFrameSvc?.flushAllFrames();
		});
	}
	getPositionedHorizontalScroll(column, position) {
		const { columnBeforeStart, columnAfterEnd } = this.isColumnOutsideViewport(column);
		const viewportTooSmallForColumn = this.centerRowsCtrl.getCenterWidth() < column.getActualWidth();
		const viewportWidth = this.centerRowsCtrl.getCenterWidth();
		const isRtl = this.enableRtl;
		let alignColToStart = (isRtl ? columnBeforeStart : columnAfterEnd) || viewportTooSmallForColumn;
		let alignColToEnd = isRtl ? columnAfterEnd : columnBeforeStart;
		if (position !== "auto") {
			alignColToStart = position === "start";
			alignColToEnd = position === "end";
		}
		const isMiddle = position === "middle";
		if (alignColToStart || alignColToEnd || isMiddle) {
			const { colLeft, colMiddle, colRight } = this.getColumnBounds(column);
			if (isMiddle) return colMiddle - viewportWidth / 2;
			if (alignColToStart) return isRtl ? colRight : colLeft;
			return isRtl ? colLeft - viewportWidth : colRight - viewportWidth;
		}
		return null;
	}
	isColumnOutsideViewport(column) {
		const { start: viewportStart, end: viewportEnd } = this.getViewportBounds();
		const { colLeft, colRight } = this.getColumnBounds(column);
		const isRtl = this.enableRtl;
		return {
			columnBeforeStart: isRtl ? viewportStart > colRight : viewportEnd < colRight,
			columnAfterEnd: isRtl ? viewportEnd < colLeft : viewportStart > colLeft
		};
	}
	getColumnBounds(column) {
		const isRtl = this.enableRtl;
		const bodyWidth = this.visibleCols.bodyWidth;
		const colWidth = column.getActualWidth();
		const colLeft = column.getLeft();
		const multiplier = isRtl ? -1 : 1;
		const colLeftPixel = isRtl ? bodyWidth - colLeft : colLeft;
		const colRightPixel = colLeftPixel + colWidth * multiplier;
		return {
			colLeft: colLeftPixel,
			colMiddle: colLeftPixel + colWidth / 2 * multiplier,
			colRight: colRightPixel
		};
	}
	getViewportBounds() {
		const viewportWidth = this.centerRowsCtrl.getCenterWidth();
		const scrollPosition = this.centerRowsCtrl.getCenterViewportScrollLeft();
		return {
			start: scrollPosition,
			end: viewportWidth + scrollPosition,
			width: viewportWidth
		};
	}
};
var CenterWidthFeature = class extends BeanStub {
	constructor(callback, addSpacer = false) {
		super();
		this.callback = callback;
		this.addSpacer = addSpacer;
	}
	postConstruct() {
		const listener = this.setWidth.bind(this);
		this.addManagedPropertyListener("domLayout", listener);
		this.addManagedEventListeners({
			columnContainerWidthChanged: listener,
			displayedColumnsChanged: listener,
			leftPinnedWidthChanged: listener
		});
		if (this.addSpacer) this.addManagedEventListeners({
			rightPinnedWidthChanged: listener,
			scrollVisibilityChanged: listener,
			scrollbarWidthChanged: listener
		});
		this.setWidth();
	}
	setWidth() {
		const printLayout = _isDomLayout(this.gos, "print");
		const { visibleCols, scrollVisibleSvc } = this.beans;
		const centerWidth = visibleCols.bodyWidth;
		const leftWidth = visibleCols.getColsLeftWidth();
		const rightWidth = visibleCols.getDisplayedColumnsRightWidth();
		let totalWidth;
		if (printLayout) totalWidth = centerWidth + leftWidth + rightWidth;
		else {
			totalWidth = centerWidth;
			if (this.addSpacer) {
				if ((this.gos.get("enableRtl") ? leftWidth : rightWidth) === 0 && scrollVisibleSvc.verticalScrollShowing) totalWidth += scrollVisibleSvc.getScrollbarWidth();
			}
		}
		this.callback(totalWidth);
	}
};
var ViewportSizeFeature = class extends BeanStub {
	constructor(centerContainerCtrl) {
		super();
		this.centerContainerCtrl = centerContainerCtrl;
	}
	wireBeans(beans) {
		this.scrollVisibleSvc = beans.scrollVisibleSvc;
	}
	postConstruct() {
		this.beans.ctrlsSvc.whenReady(this, (p) => {
			this.gridBodyCtrl = p.gridBodyCtrl;
			this.listenForResize();
		});
		this.addManagedEventListeners({ scrollbarWidthChanged: this.onScrollbarWidthChanged.bind(this) });
		this.addManagedPropertyListeners(["alwaysShowHorizontalScroll", "alwaysShowVerticalScroll"], () => {
			this.checkViewportAndScrolls();
		});
	}
	listenForResize() {
		const { beans, centerContainerCtrl, gridBodyCtrl } = this;
		const listener = () => {
			_requestAnimationFrame(beans, () => {
				this.onCenterViewportResized();
			});
		};
		centerContainerCtrl.registerViewportResizeListener(listener);
		gridBodyCtrl.registerBodyViewportResizeListener(listener);
	}
	onScrollbarWidthChanged() {
		this.checkViewportAndScrolls();
	}
	onCenterViewportResized() {
		this.scrollVisibleSvc.updateScrollGap();
		if (this.centerContainerCtrl.isViewportInTheDOMTree()) {
			const { pinnedCols, colFlex } = this.beans;
			pinnedCols?.keepPinnedColumnsNarrowerThanViewport();
			this.checkViewportAndScrolls();
			const newWidth = this.centerContainerCtrl.getCenterWidth();
			if (newWidth !== this.centerWidth) {
				this.centerWidth = newWidth;
				colFlex?.refreshFlexedColumns({
					viewportWidth: this.centerWidth,
					updateBodyWidths: true,
					fireResizedEvent: true
				});
			}
		} else this.bodyHeight = 0;
	}
	checkViewportAndScrolls() {
		this.updateScrollVisibleService();
		this.checkBodyHeight();
		this.onHorizontalViewportChanged();
		this.gridBodyCtrl.scrollFeature.checkScrollLeft();
	}
	getBodyHeight() {
		return this.bodyHeight;
	}
	checkBodyHeight() {
		const eBodyViewport = this.gridBodyCtrl.eBodyViewport;
		const bodyHeight = _getInnerHeight(eBodyViewport);
		if (this.bodyHeight !== bodyHeight) {
			this.bodyHeight = bodyHeight;
			this.eventSvc.dispatchEvent({ type: "bodyHeightChanged" });
		}
	}
	updateScrollVisibleService() {
		this.updateScrollVisibleServiceImpl();
		setTimeout(this.updateScrollVisibleServiceImpl.bind(this), 500);
	}
	updateScrollVisibleServiceImpl() {
		const params = {
			horizontalScrollShowing: this.centerContainerCtrl.isHorizontalScrollShowing(),
			verticalScrollShowing: this.gridBodyCtrl.isVerticalScrollShowing()
		};
		this.scrollVisibleSvc.setScrollsVisible(params);
	}
	onHorizontalViewportChanged() {
		const scrollWidth = this.centerContainerCtrl.getCenterWidth();
		const scrollPosition = this.centerContainerCtrl.getViewportScrollLeft();
		this.beans.colViewport.setScrollPosition(scrollWidth, scrollPosition);
	}
};
function processClassRules(expressionSvc, previousClassRules, classRules, params, onApplicableClass, onNotApplicableClass) {
	if (classRules == null && previousClassRules == null) return;
	const classesToApply = {};
	const classesToRemove = {};
	const forEachSingleClass = (className, callback) => {
		className.split(" ").forEach((singleClass) => {
			if (singleClass.trim() == "") return;
			callback(singleClass);
		});
	};
	if (classRules) {
		const classNames = Object.keys(classRules);
		for (let i = 0; i < classNames.length; i++) {
			const className = classNames[i];
			const rule = classRules[className];
			let resultOfRule;
			if (typeof rule === "string") resultOfRule = expressionSvc ? expressionSvc.evaluate(rule, params) : true;
			else if (typeof rule === "function") resultOfRule = rule(params);
			forEachSingleClass(className, (singleClass) => {
				resultOfRule ? classesToApply[singleClass] = true : classesToRemove[singleClass] = true;
			});
		}
	}
	if (previousClassRules && onNotApplicableClass) Object.keys(previousClassRules).forEach((className) => forEachSingleClass(className, (singleClass) => {
		if (!classesToApply[singleClass]) classesToRemove[singleClass] = true;
	}));
	if (onNotApplicableClass) Object.keys(classesToRemove).forEach(onNotApplicableClass);
	Object.keys(classesToApply).forEach(onApplicableClass);
}
function calculateRowLevel(rowNode) {
	if (rowNode.group) return rowNode.level;
	const parent = rowNode.parent;
	return parent ? parent.level + 1 : 0;
}
var instanceIdSequence3 = 0;
var DOM_DATA_KEY_ROW_CTRL = "renderedRow";
var RowCtrl = class extends BeanStub {
	constructor(rowNode, beans, animateIn, useAnimationFrameForCreate, printLayout) {
		super();
		this.rowNode = rowNode;
		this.useAnimationFrameForCreate = useAnimationFrameForCreate;
		this.printLayout = printLayout;
		this.allRowGuis = [];
		this.active = true;
		this.centerCellCtrls = {
			list: [],
			map: {}
		};
		this.leftCellCtrls = {
			list: [],
			map: {}
		};
		this.rightCellCtrls = {
			list: [],
			map: {}
		};
		this.slideInAnimation = {
			left: false,
			center: false,
			right: false,
			fullWidth: false
		};
		this.fadeInAnimation = {
			left: false,
			center: false,
			right: false,
			fullWidth: false
		};
		this.rowDragComps = [];
		this.lastMouseDownOnDragger = false;
		this.emptyStyle = {};
		this.updateColumnListsPending = false;
		this.rowId = null;
		this.businessKey = null;
		this.beans = beans;
		this.gos = beans.gos;
		this.paginationPage = beans.pagination?.getCurrentPage() ?? 0;
		this.suppressRowTransform = this.gos.get("suppressRowTransform");
		this.instanceId = rowNode.id + "-" + instanceIdSequence3++;
		this.rowId = _escapeString(rowNode.id);
		this.initRowBusinessKey();
		this.rowFocused = beans.focusSvc.isRowFocused(this.rowNode.rowIndex, this.rowNode.rowPinned);
		this.rowLevel = calculateRowLevel(this.rowNode);
		this.setRowType();
		this.setAnimateFlags(animateIn);
		this.rowStyles = this.processStylesFromGridOptions();
		this.rowEditStyleFeature = beans.editSvc?.createRowStyleFeature(this, beans);
		this.addListeners();
	}
	initRowBusinessKey() {
		this.businessKeyForNodeFunc = this.gos.get("getBusinessKeyForNode");
		this.updateRowBusinessKey();
	}
	updateRowBusinessKey() {
		if (typeof this.businessKeyForNodeFunc !== "function") return;
		this.businessKey = _escapeString(this.businessKeyForNodeFunc(this.rowNode));
	}
	updateGui(containerType, gui) {
		if (containerType === "left") this.leftGui = gui;
		else if (containerType === "right") this.rightGui = gui;
		else if (containerType === "fullWidth") this.fullWidthGui = gui;
		else this.centerGui = gui;
	}
	setComp(rowComp, element, containerType, compBean) {
		const { context, focusSvc } = this.beans;
		compBean = setupCompBean(this, context, compBean);
		const gui = {
			rowComp,
			element,
			containerType,
			compBean
		};
		this.allRowGuis.push(gui);
		this.updateGui(containerType, gui);
		this.initialiseRowComp(gui);
		const rowNode = this.rowNode;
		const isSsrmLoadingRow = this.rowType === "FullWidthLoading" || rowNode.stub;
		const isIrmLoadingRow = !rowNode.data && this.beans.rowModel.getType() === "infinite";
		if (!isSsrmLoadingRow && !isIrmLoadingRow && !rowNode.rowPinned) this.beans.rowRenderer.dispatchFirstDataRenderedEvent();
		const focusableElement = this.fullWidthGui?.element;
		if (focusableElement) {
			if (!this.beans.editSvc?.isEditing(this) && focusSvc.isRowFocused(rowNode.rowIndex, rowNode.rowPinned) && focusSvc.shouldTakeFocus()) setTimeout(() => focusableElement.focus({ preventScroll: true }), 0);
		}
	}
	unsetComp(containerType) {
		this.allRowGuis = this.allRowGuis.filter((rowGui) => rowGui.containerType !== containerType);
		this.updateGui(containerType, void 0);
	}
	isCacheable() {
		return this.rowType === "FullWidthDetail" && this.gos.get("keepDetailRows");
	}
	setCached(cached) {
		const displayValue = cached ? "none" : "";
		this.allRowGuis.forEach((rg) => rg.element.style.display = displayValue);
	}
	initialiseRowComp(gui) {
		const gos = this.gos;
		this.onSuppressCellFocusChanged(this.beans.gos.get("suppressCellFocus"));
		this.listenOnDomOrder(gui);
		this.onRowHeightChanged(gui);
		this.updateRowIndexes(gui);
		this.setFocusedClasses(gui);
		this.setStylesFromGridOptions(false, gui);
		if (_isRowSelection(gos) && this.rowNode.selectable) this.onRowSelected(gui);
		this.updateColumnLists(!this.useAnimationFrameForCreate);
		const comp = gui.rowComp;
		this.getInitialRowClasses(gui.containerType).forEach((name) => comp.toggleCss(name, true));
		this.executeSlideAndFadeAnimations(gui);
		if (this.rowNode.group) _setAriaExpanded(gui.element, this.rowNode.expanded == true);
		this.setRowCompRowId(comp);
		this.setRowCompRowBusinessKey(comp);
		_setDomData(gos, gui.element, DOM_DATA_KEY_ROW_CTRL, this);
		gui.compBean.addDestroyFunc(() => _setDomData(gos, gui.element, DOM_DATA_KEY_ROW_CTRL, null));
		if (this.useAnimationFrameForCreate) this.beans.animationFrameSvc.createTask(this.addHoverFunctionality.bind(this, gui), this.rowNode.rowIndex, "p2", false);
		else this.addHoverFunctionality(gui);
		if (this.isFullWidth()) this.setupFullWidth(gui);
		if (gos.get("rowDragEntireRow")) this.addRowDraggerToRow(gui);
		if (this.useAnimationFrameForCreate) this.beans.animationFrameSvc.addDestroyTask(() => {
			if (!this.isAlive()) return;
			gui.rowComp.toggleCss("ag-after-created", true);
		});
		this.executeProcessRowPostCreateFunc();
	}
	setRowCompRowBusinessKey(comp) {
		if (this.businessKey == null) return;
		comp.setRowBusinessKey(this.businessKey);
	}
	setRowCompRowId(comp) {
		const rowId = _escapeString(this.rowNode.id);
		this.rowId = rowId;
		if (rowId == null) return;
		comp.setRowId(rowId);
	}
	executeSlideAndFadeAnimations(gui) {
		const { containerType } = gui;
		if (this.slideInAnimation[containerType]) {
			_batchCall(() => {
				this.onTopChanged();
			});
			this.slideInAnimation[containerType] = false;
		}
		if (this.fadeInAnimation[containerType]) {
			_batchCall(() => {
				gui.rowComp.toggleCss("ag-opacity-zero", false);
			});
			this.fadeInAnimation[containerType] = false;
		}
	}
	addRowDraggerToRow(gui) {
		const rowDragComp = this.beans.rowDragSvc?.createRowDragCompForRow(this.rowNode, gui.element);
		if (!rowDragComp) return;
		const rowDragBean = this.createBean(rowDragComp, this.beans.context);
		this.rowDragComps.push(rowDragBean);
		gui.compBean.addDestroyFunc(() => {
			this.rowDragComps = this.rowDragComps.filter((r) => r !== rowDragBean);
			this.rowEditStyleFeature = this.destroyBean(this.rowEditStyleFeature, this.beans.context);
			this.destroyBean(rowDragBean, this.beans.context);
		});
	}
	setupFullWidth(gui) {
		const pinned = this.getPinnedForContainer(gui.containerType);
		const compDetails = this.createFullWidthCompDetails(gui.element, pinned);
		gui.rowComp.showFullWidth(compDetails);
	}
	getFullWidthCellRenderers() {
		if (this.gos.get("embedFullWidthRows")) return this.allRowGuis.map((gui) => gui?.rowComp?.getFullWidthCellRenderer());
		return [this.fullWidthGui?.rowComp?.getFullWidthCellRenderer()];
	}
	executeProcessRowPostCreateFunc() {
		const func = this.gos.getCallback("processRowPostCreate");
		if (!func || !this.areAllContainersReady()) return;
		func({
			eRow: this.centerGui.element,
			ePinnedLeftRow: this.leftGui ? this.leftGui.element : void 0,
			ePinnedRightRow: this.rightGui ? this.rightGui.element : void 0,
			node: this.rowNode,
			rowIndex: this.rowNode.rowIndex,
			addRenderedRowListener: this.addEventListener.bind(this)
		});
	}
	areAllContainersReady() {
		const { leftGui, centerGui, rightGui, beans: { visibleCols } } = this;
		const isLeftReady = !!leftGui || !visibleCols.isPinningLeft();
		const isCenterReady = !!centerGui;
		const isRightReady = !!rightGui || !visibleCols.isPinningRight();
		return isLeftReady && isCenterReady && isRightReady;
	}
	isNodeFullWidthCell() {
		if (this.rowNode.detail) return true;
		const isFullWidthCellFunc = this.beans.gos.getCallback("isFullWidthRow");
		return isFullWidthCellFunc ? isFullWidthCellFunc({ rowNode: this.rowNode }) : false;
	}
	setRowType() {
		const isStub = this.rowNode.stub && !this.gos.get("suppressServerSideFullWidthLoadingRow") && !this.gos.get("groupHideOpenParents");
		const isFullWidthCell = this.isNodeFullWidthCell();
		const isDetailCell = this.gos.get("masterDetail") && this.rowNode.detail;
		const pivotMode = this.beans.colModel.isPivotMode();
		const isFullWidthGroup = _isFullWidthGroupRow(this.gos, this.rowNode, pivotMode);
		if (isStub) this.rowType = "FullWidthLoading";
		else if (isDetailCell) this.rowType = "FullWidthDetail";
		else if (isFullWidthCell) this.rowType = "FullWidth";
		else if (isFullWidthGroup) this.rowType = "FullWidthGroup";
		else this.rowType = "Normal";
	}
	updateColumnLists(suppressAnimationFrame = false, useFlushSync = false) {
		if (this.isFullWidth()) return;
		const { animationFrameSvc } = this.beans;
		if (!animationFrameSvc?.active || suppressAnimationFrame || this.printLayout) {
			this.updateColumnListsImpl(useFlushSync);
			return;
		}
		if (this.updateColumnListsPending) return;
		animationFrameSvc.createTask(() => {
			if (!this.active) return;
			this.updateColumnListsImpl(true);
		}, this.rowNode.rowIndex, "p1", false);
		this.updateColumnListsPending = true;
	}
	getNewCellCtrl(col) {
		if (this.beans.rowSpanSvc?.isCellSpanning(col, this.rowNode)) return;
		return new CellCtrl(col, this.rowNode, this.beans, this);
	}
	isCorrectCtrlForSpan(cell) {
		return !this.beans.rowSpanSvc?.isCellSpanning(cell.column, this.rowNode);
	}
	createCellCtrls(prev, cols, pinned = null) {
		const res = {
			list: [],
			map: {}
		};
		const addCell = (colInstanceId, cellCtrl, index) => {
			if (index != null) res.list.splice(index, 0, cellCtrl);
			else res.list.push(cellCtrl);
			res.map[colInstanceId] = cellCtrl;
		};
		const colsFromPrev = [];
		for (const col of cols) {
			const colInstanceId = col.getInstanceId();
			let cellCtrl = prev.map[colInstanceId];
			if (cellCtrl && !this.isCorrectCtrlForSpan(cellCtrl)) {
				cellCtrl.destroy();
				cellCtrl = void 0;
			}
			if (!cellCtrl) cellCtrl = this.getNewCellCtrl(col);
			if (!cellCtrl) continue;
			addCell(colInstanceId, cellCtrl);
		}
		for (const prevCellCtrl of prev.list) {
			const colInstanceId = prevCellCtrl.column.getInstanceId();
			if (res.map[colInstanceId] != null) continue;
			if (!this.isCellEligibleToBeRemoved(prevCellCtrl, pinned)) colsFromPrev.push([colInstanceId, prevCellCtrl]);
			else prevCellCtrl.destroy();
		}
		if (colsFromPrev.length) for (const [colInstanceId, cellCtrl] of colsFromPrev) {
			const index = res.list.findIndex((ctrl) => ctrl.column.getLeft() > cellCtrl.column.getLeft());
			addCell(colInstanceId, cellCtrl, index === -1 ? void 0 : Math.max(index - 1, 0));
		}
		const { focusSvc, visibleCols } = this.beans;
		const focusedCell = focusSvc.getFocusedCell();
		if (focusedCell && focusedCell.column.getPinned() == pinned) {
			const focusedColInstanceId = focusedCell.column.getInstanceId();
			if (!res.map[focusedColInstanceId] && visibleCols.allCols.includes(focusedCell.column)) {
				const cellCtrl = this.createFocusedCellCtrl();
				if (cellCtrl) {
					const index = res.list.findIndex((ctrl) => ctrl.column.getLeft() > cellCtrl.column.getLeft());
					addCell(focusedColInstanceId, cellCtrl, index === -1 ? void 0 : Math.max(index - 1, 0));
				}
			}
		}
		return res;
	}
	createFocusedCellCtrl() {
		const { focusSvc, rowSpanSvc } = this.beans;
		const focusedCell = focusSvc.getFocusedCell();
		if (!focusedCell) return;
		const focusedSpan = rowSpanSvc?.getCellSpan(focusedCell.column, this.rowNode);
		if (focusedSpan) {
			if (focusedSpan.firstNode !== this.rowNode || !focusedSpan.doesSpanContain(focusedCell)) return;
		} else if (!focusSvc.isRowFocused(this.rowNode.rowIndex, this.rowNode.rowPinned)) return;
		return this.getNewCellCtrl(focusedCell.column);
	}
	updateColumnListsImpl(useFlushSync) {
		this.updateColumnListsPending = false;
		this.createAllCellCtrls();
		this.setCellCtrls(useFlushSync);
	}
	setCellCtrls(useFlushSync) {
		this.allRowGuis.forEach((item) => {
			const cellControls = this.getCellCtrlsForContainer(item.containerType);
			item.rowComp.setCellCtrls(cellControls, useFlushSync);
		});
	}
	getCellCtrlsForContainer(containerType) {
		switch (containerType) {
			case "left": return this.leftCellCtrls.list;
			case "right": return this.rightCellCtrls.list;
			case "fullWidth": return [];
			case "center": return this.centerCellCtrls.list;
		}
	}
	createAllCellCtrls() {
		const colViewport = this.beans.colViewport;
		const presentedColsService = this.beans.visibleCols;
		if (this.printLayout) {
			this.centerCellCtrls = this.createCellCtrls(this.centerCellCtrls, presentedColsService.allCols);
			this.leftCellCtrls = {
				list: [],
				map: {}
			};
			this.rightCellCtrls = {
				list: [],
				map: {}
			};
		} else {
			const centerCols = colViewport.getColsWithinViewport(this.rowNode);
			this.centerCellCtrls = this.createCellCtrls(this.centerCellCtrls, centerCols);
			const leftCols = presentedColsService.getLeftColsForRow(this.rowNode);
			this.leftCellCtrls = this.createCellCtrls(this.leftCellCtrls, leftCols, "left");
			const rightCols = presentedColsService.getRightColsForRow(this.rowNode);
			this.rightCellCtrls = this.createCellCtrls(this.rightCellCtrls, rightCols, "right");
		}
	}
	isCellEligibleToBeRemoved(cellCtrl, nextContainerPinned) {
		const REMOVE_CELL = true;
		const KEEP_CELL = false;
		const { column } = cellCtrl;
		if (column.getPinned() != nextContainerPinned) return REMOVE_CELL;
		if (!this.isCorrectCtrlForSpan(cellCtrl)) return REMOVE_CELL;
		const { visibleCols, editSvc } = this.beans;
		const editing = editSvc?.isEditing(cellCtrl);
		const focused = cellCtrl.isCellFocused();
		if (editing || focused) return visibleCols.allCols.indexOf(column) >= 0 ? KEEP_CELL : REMOVE_CELL;
		return REMOVE_CELL;
	}
	getDomOrder() {
		return this.gos.get("ensureDomOrder") || _isDomLayout(this.gos, "print");
	}
	listenOnDomOrder(gui) {
		const listener = () => {
			gui.rowComp.setDomOrder(this.getDomOrder());
		};
		gui.compBean.addManagedPropertyListeners(["domLayout", "ensureDomOrder"], listener);
	}
	setAnimateFlags(animateIn) {
		if (this.rowNode.sticky || !animateIn) return;
		const oldRowTopExists = _exists(this.rowNode.oldRowTop);
		const { visibleCols } = this.beans;
		const pinningLeft = visibleCols.isPinningLeft();
		const pinningRight = visibleCols.isPinningRight();
		if (oldRowTopExists) {
			const { slideInAnimation } = this;
			if (this.isFullWidth() && !this.gos.get("embedFullWidthRows")) {
				slideInAnimation.fullWidth = true;
				return;
			}
			slideInAnimation.center = true;
			slideInAnimation.left = pinningLeft;
			slideInAnimation.right = pinningRight;
		} else {
			const { fadeInAnimation } = this;
			if (this.isFullWidth() && !this.gos.get("embedFullWidthRows")) {
				fadeInAnimation.fullWidth = true;
				return;
			}
			fadeInAnimation.center = true;
			fadeInAnimation.left = pinningLeft;
			fadeInAnimation.right = pinningRight;
		}
	}
	isFullWidth() {
		return this.rowType !== "Normal";
	}
	refreshFullWidth() {
		const tryRefresh = (gui, pinned) => {
			if (!gui) return true;
			return gui.rowComp.refreshFullWidth(() => {
				return this.createFullWidthCompDetails(gui.element, pinned).params;
			});
		};
		const fullWidthSuccess = tryRefresh(this.fullWidthGui, null);
		const centerSuccess = tryRefresh(this.centerGui, null);
		const leftSuccess = tryRefresh(this.leftGui, "left");
		const rightSuccess = tryRefresh(this.rightGui, "right");
		return fullWidthSuccess && centerSuccess && leftSuccess && rightSuccess;
	}
	addListeners() {
		const { beans, gos, rowNode } = this;
		const { expansionSvc, eventSvc, context, rowSpanSvc } = beans;
		this.addManagedListeners(this.rowNode, {
			heightChanged: () => this.onRowHeightChanged(),
			rowSelected: () => this.onRowSelected(),
			rowIndexChanged: this.onRowIndexChanged.bind(this),
			topChanged: this.onTopChanged.bind(this),
			...expansionSvc?.getRowExpandedListeners(this) ?? {}
		});
		if (rowNode.detail) this.addManagedListeners(rowNode.parent, { dataChanged: this.onRowNodeDataChanged.bind(this) });
		this.addManagedListeners(rowNode, {
			dataChanged: this.onRowNodeDataChanged.bind(this),
			cellChanged: this.postProcessCss.bind(this),
			rowHighlightChanged: this.onRowNodeHighlightChanged.bind(this),
			draggingChanged: this.postProcessRowDragging.bind(this),
			uiLevelChanged: this.onUiLevelChanged.bind(this),
			rowPinned: this.onRowPinned.bind(this)
		});
		this.addManagedListeners(eventSvc, {
			paginationPixelOffsetChanged: this.onPaginationPixelOffsetChanged.bind(this),
			heightScaleChanged: this.onTopChanged.bind(this),
			displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this),
			virtualColumnsChanged: this.onVirtualColumnsChanged.bind(this),
			cellFocused: this.onCellFocusChanged.bind(this),
			cellFocusCleared: this.onCellFocusChanged.bind(this),
			paginationChanged: this.onPaginationChanged.bind(this),
			modelUpdated: this.refreshFirstAndLastRowStyles.bind(this),
			columnMoved: () => this.updateColumnLists()
		});
		if (rowSpanSvc) this.addManagedListeners(rowSpanSvc, { spannedCellsUpdated: ({ pinned }) => {
			if (pinned && !rowNode.rowPinned) return;
			this.updateColumnLists();
		} });
		this.addDestroyFunc(() => {
			this.rowDragComps = this.destroyBeans(this.rowDragComps, context);
			this.tooltipFeature = this.destroyBean(this.tooltipFeature, context);
			this.rowEditStyleFeature = this.destroyBean(this.rowEditStyleFeature, context);
		});
		this.addManagedPropertyListeners([
			"rowStyle",
			"getRowStyle",
			"rowClass",
			"getRowClass",
			"rowClassRules"
		], this.postProcessCss.bind(this));
		this.addManagedPropertyListener("rowDragEntireRow", () => {
			if (gos.get("rowDragEntireRow")) {
				this.allRowGuis.forEach((gui) => {
					this.addRowDraggerToRow(gui);
				});
				return;
			}
			this.rowDragComps = this.destroyBeans(this.rowDragComps, context);
		});
		this.addListenersForCellComps();
	}
	addListenersForCellComps() {
		this.addManagedListeners(this.rowNode, {
			rowIndexChanged: () => this.getAllCellCtrls().forEach((cellCtrl) => cellCtrl.onRowIndexChanged()),
			cellChanged: (event) => this.getAllCellCtrls().forEach((cellCtrl) => cellCtrl.onCellChanged(event))
		});
	}
	onRowPinned() {
		for (const gui of this.allRowGuis) gui.rowComp.toggleCss("ag-row-pinned-source", !!this.rowNode.pinnedSibling);
	}
	onRowNodeDataChanged(event) {
		this.refreshRow({
			suppressFlash: !event.update,
			newData: !event.update
		});
	}
	refreshRow(params) {
		if (this.isFullWidth() !== !!this.isNodeFullWidthCell()) {
			this.beans.rowRenderer.redrawRow(this.rowNode);
			return;
		}
		if (this.isFullWidth()) {
			if (!this.refreshFullWidth()) this.beans.rowRenderer.redrawRow(this.rowNode);
			return;
		}
		this.getAllCellCtrls().forEach((cellCtrl) => cellCtrl.refreshCell(params));
		this.allRowGuis.forEach((gui) => {
			this.setRowCompRowId(gui.rowComp);
			this.updateRowBusinessKey();
			this.setRowCompRowBusinessKey(gui.rowComp);
		});
		this.onRowSelected();
		this.postProcessCss();
	}
	postProcessCss() {
		this.setStylesFromGridOptions(true);
		this.postProcessClassesFromGridOptions();
		this.postProcessRowClassRules();
		this.rowEditStyleFeature?.applyRowStyles();
		this.postProcessRowDragging();
	}
	onRowNodeHighlightChanged() {
		const rowDropHighlightSvc = this.beans.rowDropHighlightSvc;
		const highlighted = rowDropHighlightSvc?.row === this.rowNode ? rowDropHighlightSvc.position : "none";
		const aboveOn = highlighted === "above";
		const insideOn = highlighted === "inside";
		const belowOn = highlighted === "below";
		const indented = this.gos.get("treeData") && (belowOn || aboveOn);
		const uiLevel = this.rowNode.uiLevel.toString();
		this.allRowGuis.forEach((gui) => {
			const rowComp = gui.rowComp;
			rowComp.toggleCss("ag-row-highlight-above", aboveOn);
			rowComp.toggleCss("ag-row-highlight-inside", insideOn);
			rowComp.toggleCss("ag-row-highlight-below", belowOn);
			rowComp.toggleCss("ag-row-highlight-indent", indented);
			if (indented) gui.element.style.setProperty("--ag-row-highlight-level", uiLevel);
			else gui.element.style.removeProperty("--ag-row-highlight-level");
		});
	}
	postProcessRowDragging() {
		const dragging = this.rowNode.dragging;
		this.allRowGuis.forEach((gui) => gui.rowComp.toggleCss("ag-row-dragging", dragging));
	}
	onDisplayedColumnsChanged() {
		this.updateColumnLists(true);
		this.beans.rowAutoHeight?.requestCheckAutoHeight();
	}
	onVirtualColumnsChanged() {
		this.updateColumnLists(false, true);
	}
	getRowPosition() {
		return {
			rowPinned: _makeNull(this.rowNode.rowPinned),
			rowIndex: this.rowNode.rowIndex
		};
	}
	onKeyboardNavigate(keyboardEvent) {
		const groupInfo = this.findFullWidthInfoForEvent(keyboardEvent);
		if (!groupInfo) return;
		const { rowGui, column } = groupInfo;
		if (!(rowGui.element === keyboardEvent.target)) return;
		const node = this.rowNode;
		const { focusSvc, navigation } = this.beans;
		const lastFocusedCell = focusSvc.getFocusedCell();
		const cellPosition = {
			rowIndex: node.rowIndex,
			rowPinned: node.rowPinned,
			column: lastFocusedCell?.column ?? column
		};
		navigation?.navigateToNextCell(keyboardEvent, keyboardEvent.key, cellPosition, true);
		keyboardEvent.preventDefault();
	}
	onTabKeyDown(keyboardEvent) {
		if (keyboardEvent.defaultPrevented || _isStopPropagationForAgGrid(keyboardEvent)) return;
		const currentFullWidthComp = this.allRowGuis.find((c) => c.element.contains(keyboardEvent.target));
		const currentFullWidthContainer = currentFullWidthComp ? currentFullWidthComp.element : null;
		const isFullWidthContainerFocused = currentFullWidthContainer === keyboardEvent.target;
		const activeEl = _getActiveDomElement(this.beans);
		let isDetailGridCellFocused = false;
		if (currentFullWidthContainer && activeEl) isDetailGridCellFocused = currentFullWidthContainer.contains(activeEl) && activeEl.classList.contains("ag-cell");
		let nextEl = null;
		if (!isFullWidthContainerFocused && !isDetailGridCellFocused) nextEl = _findNextFocusableElement(this.beans, currentFullWidthContainer, false, keyboardEvent.shiftKey);
		if (this.isFullWidth() && isFullWidthContainerFocused || !nextEl) this.beans.navigation?.onTabKeyDown(this, keyboardEvent);
	}
	getFullWidthElement() {
		if (this.fullWidthGui) return this.fullWidthGui.element;
		return null;
	}
	getRowYPosition() {
		const displayedEl = this.allRowGuis.find((el) => _isVisible(el.element))?.element;
		if (displayedEl) return displayedEl.getBoundingClientRect().top;
		return 0;
	}
	onSuppressCellFocusChanged(suppressCellFocus) {
		const tabIndex = this.isFullWidth() && suppressCellFocus ? void 0 : -1;
		this.allRowGuis.forEach((gui) => {
			_addOrRemoveAttribute(gui.element, "tabindex", tabIndex);
		});
	}
	onFullWidthRowFocused(event) {
		const node = this.rowNode;
		const isFocused = !event ? false : this.isFullWidth() && event.rowIndex === node.rowIndex && event.rowPinned == node.rowPinned;
		let element;
		if (this.fullWidthGui) element = this.fullWidthGui.element;
		else {
			const pinned = this.beans.colModel.getCol(event?.column)?.pinned;
			if (pinned) element = pinned === "right" ? this.rightGui?.element : this.leftGui?.element;
			else element = this.centerGui?.element;
		}
		if (!element) return;
		element.classList.toggle("ag-full-width-focus", isFocused);
		if (isFocused && event?.forceBrowserFocus) element.focus({ preventScroll: true });
	}
	recreateCell(cellCtrl) {
		this.centerCellCtrls = this.removeCellCtrl(this.centerCellCtrls, cellCtrl);
		this.leftCellCtrls = this.removeCellCtrl(this.leftCellCtrls, cellCtrl);
		this.rightCellCtrls = this.removeCellCtrl(this.rightCellCtrls, cellCtrl);
		cellCtrl.destroy();
		this.updateColumnLists();
	}
	removeCellCtrl(prev, cellCtrlToRemove) {
		const res = {
			list: [],
			map: {}
		};
		prev.list.forEach((cellCtrl) => {
			if (cellCtrl === cellCtrlToRemove) return;
			res.list.push(cellCtrl);
			res.map[cellCtrl.column.getInstanceId()] = cellCtrl;
		});
		return res;
	}
	onMouseEvent(eventName, mouseEvent) {
		switch (eventName) {
			case "dblclick":
				this.onRowDblClick(mouseEvent);
				break;
			case "click":
				this.onRowClick(mouseEvent);
				break;
			case "touchstart":
			case "mousedown":
				this.onRowMouseDown(mouseEvent);
				break;
		}
	}
	createRowEvent(type, domEvent) {
		const { rowNode } = this;
		return _addGridCommonParams(this.gos, {
			type,
			node: rowNode,
			data: rowNode.data,
			rowIndex: rowNode.rowIndex,
			rowPinned: rowNode.rowPinned,
			event: domEvent
		});
	}
	createRowEventWithSource(type, domEvent) {
		const event = this.createRowEvent(type, domEvent);
		event.source = this;
		return event;
	}
	onRowDblClick(mouseEvent) {
		if (_isStopPropagationForAgGrid(mouseEvent)) return;
		this.beans.eventSvc.dispatchEvent(this.createRowEventWithSource("rowDoubleClicked", mouseEvent));
	}
	findFullWidthInfoForEvent(event) {
		if (!event) return;
		const rowGui = this.findFullWidthRowGui(event.target);
		const column = this.getColumnForFullWidth(rowGui);
		if (!rowGui || !column) return;
		return {
			rowGui,
			column
		};
	}
	findFullWidthRowGui(target) {
		return this.allRowGuis.find((c) => c.element.contains(target));
	}
	getColumnForFullWidth(fullWidthRowGui) {
		const { visibleCols } = this.beans;
		switch (fullWidthRowGui?.containerType) {
			case "center": return visibleCols.centerCols[0];
			case "left": return visibleCols.leftCols[0];
			case "right": return visibleCols.rightCols[0];
			default: return visibleCols.allCols[0];
		}
	}
	onRowMouseDown(mouseEvent) {
		this.lastMouseDownOnDragger = _isElementChildOfClass(mouseEvent.target, "ag-row-drag", 3);
		if (!this.isFullWidth()) return;
		const node = this.rowNode;
		const { rangeSvc, focusSvc } = this.beans;
		rangeSvc?.removeAllCellRanges();
		const groupInfo = this.findFullWidthInfoForEvent(mouseEvent);
		if (!groupInfo) return;
		const { rowGui, column } = groupInfo;
		const element = rowGui.element;
		const target = mouseEvent.target;
		let forceBrowserFocus = mouseEvent.defaultPrevented || _isBrowserSafari();
		if (element && element.contains(target) && _isFocusableFormField(target)) forceBrowserFocus = false;
		focusSvc.setFocusedCell({
			rowIndex: node.rowIndex,
			column,
			rowPinned: node.rowPinned,
			forceBrowserFocus
		});
	}
	onRowClick(mouseEvent) {
		if (_isStopPropagationForAgGrid(mouseEvent) || this.lastMouseDownOnDragger) return;
		const { eventSvc, selectionSvc } = this.beans;
		eventSvc.dispatchEvent(this.createRowEventWithSource("rowClicked", mouseEvent));
		selectionSvc?.handleSelectionEvent(mouseEvent, this.rowNode, "rowClicked");
	}
	setupDetailRowAutoHeight(eDetailGui) {
		if (this.rowType !== "FullWidthDetail") return;
		this.beans.masterDetailSvc?.setupDetailRowAutoHeight(this, eDetailGui);
	}
	createFullWidthCompDetails(eRow, pinned) {
		const { gos, rowNode } = this;
		const params = _addGridCommonParams(gos, {
			fullWidth: true,
			data: rowNode.data,
			node: rowNode,
			value: rowNode.key,
			valueFormatted: rowNode.key,
			eGridCell: eRow,
			eParentOfValue: eRow,
			pinned,
			addRenderedRowListener: this.addEventListener.bind(this),
			registerRowDragger: (rowDraggerElement, dragStartPixels, value, suppressVisibilityChange) => this.addFullWidthRowDragging(rowDraggerElement, dragStartPixels, value, suppressVisibilityChange),
			setTooltip: (value, shouldDisplayTooltip) => {
				gos.assertModuleRegistered("Tooltip", 3);
				this.setupFullWidthRowTooltip(value, shouldDisplayTooltip);
			}
		});
		const compFactory = this.beans.userCompFactory;
		switch (this.rowType) {
			case "FullWidthDetail": return _getFullWidthDetailCellRendererDetails(compFactory, params);
			case "FullWidthGroup": {
				const { value, valueFormatted } = this.beans.valueSvc.getValueForDisplay(void 0, this.rowNode, true);
				params.value = value;
				params.valueFormatted = valueFormatted;
				return _getFullWidthGroupCellRendererDetails(compFactory, params);
			}
			case "FullWidthLoading": return _getFullWidthLoadingCellRendererDetails(compFactory, params);
			default: return _getFullWidthCellRendererDetails(compFactory, params);
		}
	}
	setupFullWidthRowTooltip(value, shouldDisplayTooltip) {
		if (!this.fullWidthGui) return;
		this.tooltipFeature = this.beans.tooltipSvc?.setupFullWidthRowTooltip(this.tooltipFeature, this, value, shouldDisplayTooltip);
	}
	addFullWidthRowDragging(rowDraggerElement, dragStartPixels, value = "", suppressVisibilityChange) {
		const { rowDragSvc, context } = this.beans;
		if (!rowDragSvc || !this.isFullWidth()) return;
		const rowDragComp = rowDragSvc.createRowDragComp(() => value, this.rowNode, void 0, rowDraggerElement, dragStartPixels, suppressVisibilityChange);
		this.createBean(rowDragComp, context);
		this.addDestroyFunc(() => {
			this.destroyBean(rowDragComp, context);
		});
	}
	onUiLevelChanged() {
		const newLevel = calculateRowLevel(this.rowNode);
		if (this.rowLevel != newLevel) {
			const classToAdd = "ag-row-level-" + newLevel;
			const classToRemove = "ag-row-level-" + this.rowLevel;
			this.allRowGuis.forEach((gui) => {
				gui.rowComp.toggleCss(classToAdd, true);
				gui.rowComp.toggleCss(classToRemove, false);
			});
		}
		this.rowLevel = newLevel;
	}
	isFirstRowOnPage() {
		return this.rowNode.rowIndex === this.beans.pageBounds.getFirstRow();
	}
	isLastRowOnPage() {
		return this.rowNode.rowIndex === this.beans.pageBounds.getLastRow();
	}
	refreshFirstAndLastRowStyles() {
		const newFirst = this.isFirstRowOnPage();
		const newLast = this.isLastRowOnPage();
		if (this.firstRowOnPage !== newFirst) {
			this.firstRowOnPage = newFirst;
			this.allRowGuis.forEach((gui) => gui.rowComp.toggleCss("ag-row-first", newFirst));
		}
		if (this.lastRowOnPage !== newLast) {
			this.lastRowOnPage = newLast;
			this.allRowGuis.forEach((gui) => gui.rowComp.toggleCss("ag-row-last", newLast));
		}
	}
	getAllCellCtrls() {
		if (this.leftCellCtrls.list.length === 0 && this.rightCellCtrls.list.length === 0) return this.centerCellCtrls.list;
		return [
			...this.centerCellCtrls.list,
			...this.leftCellCtrls.list,
			...this.rightCellCtrls.list
		];
	}
	postProcessClassesFromGridOptions() {
		const cssClasses = [];
		this.beans.rowStyleSvc?.processClassesFromGridOptions(cssClasses, this.rowNode);
		if (!cssClasses.length) return;
		cssClasses.forEach((classStr) => {
			this.allRowGuis.forEach((c) => c.rowComp.toggleCss(classStr, true));
		});
	}
	postProcessRowClassRules() {
		this.beans.rowStyleSvc?.processRowClassRules(this.rowNode, (className) => {
			this.allRowGuis.forEach((gui) => gui.rowComp.toggleCss(className, true));
		}, (className) => {
			this.allRowGuis.forEach((gui) => gui.rowComp.toggleCss(className, false));
		});
	}
	setStylesFromGridOptions(updateStyles, gui) {
		if (updateStyles) this.rowStyles = this.processStylesFromGridOptions();
		this.forEachGui(gui, (gui2) => gui2.rowComp.setUserStyles(this.rowStyles));
	}
	getPinnedForContainer(rowContainerType) {
		if (rowContainerType === "left" || rowContainerType === "right") return rowContainerType;
		return null;
	}
	getInitialRowClasses(rowContainerType) {
		const pinned = this.getPinnedForContainer(rowContainerType);
		const fullWidthRow = this.isFullWidth();
		const { rowNode, beans } = this;
		const classes = [];
		classes.push("ag-row");
		classes.push(this.rowFocused ? "ag-row-focus" : "ag-row-no-focus");
		if (this.fadeInAnimation[rowContainerType]) classes.push("ag-opacity-zero");
		classes.push(rowNode.rowIndex % 2 === 0 ? "ag-row-even" : "ag-row-odd");
		if (rowNode.isRowPinned()) {
			classes.push("ag-row-pinned");
			if (beans.pinnedRowModel?.isManual()) classes.push("ag-row-pinned-manual");
		}
		if (!rowNode.isRowPinned() && rowNode.pinnedSibling) classes.push("ag-row-pinned-source");
		if (rowNode.isSelected()) classes.push("ag-row-selected");
		if (rowNode.footer) classes.push("ag-row-footer");
		classes.push("ag-row-level-" + this.rowLevel);
		if (rowNode.stub) classes.push("ag-row-loading");
		if (fullWidthRow) classes.push("ag-full-width-row");
		beans.expansionSvc?.addExpandedCss(classes, rowNode);
		if (rowNode.dragging) classes.push("ag-row-dragging");
		const { rowStyleSvc } = beans;
		if (rowStyleSvc) {
			rowStyleSvc.processClassesFromGridOptions(classes, rowNode);
			rowStyleSvc.preProcessRowClassRules(classes, rowNode);
		}
		classes.push(this.printLayout ? "ag-row-position-relative" : "ag-row-position-absolute");
		if (this.isFirstRowOnPage()) classes.push("ag-row-first");
		if (this.isLastRowOnPage()) classes.push("ag-row-last");
		if (fullWidthRow) {
			if (pinned === "left") classes.push("ag-cell-last-left-pinned");
			if (pinned === "right") classes.push("ag-cell-first-right-pinned");
		}
		return classes;
	}
	processStylesFromGridOptions() {
		return this.beans.rowStyleSvc?.processStylesFromGridOptions(this.rowNode) ?? this.emptyStyle;
	}
	onRowSelected(gui) {
		this.beans.selectionSvc?.onRowCtrlSelected(this, (gui2) => {
			if (gui2 === this.centerGui || gui2 === this.fullWidthGui) this.announceDescription();
		}, gui);
	}
	announceDescription() {
		this.beans.selectionSvc?.announceAriaRowSelection(this.rowNode);
	}
	addHoverFunctionality(eGui) {
		if (!this.active) return;
		const { element, compBean } = eGui;
		const { rowNode, beans, gos } = this;
		compBean.addManagedListeners(element, {
			pointerenter: (e) => {
				if (e.pointerType === "mouse") rowNode.dispatchRowEvent("mouseEnter");
			},
			pointerleave: (e) => {
				if (e.pointerType === "mouse") rowNode.dispatchRowEvent("mouseLeave");
			}
		});
		compBean.addManagedListeners(rowNode, {
			mouseEnter: () => {
				if (!beans.dragSvc?.dragging && !gos.get("suppressRowHoverHighlight")) {
					element.classList.add("ag-row-hover");
					rowNode.setHovered(true);
				}
			},
			mouseLeave: () => {
				this.resetHoveredStatus(element);
			}
		});
	}
	resetHoveredStatus(el) {
		const elements = el ? [el] : this.allRowGuis.map((gui) => gui.element);
		for (const element of elements) element.classList.remove("ag-row-hover");
		this.rowNode.setHovered(false);
	}
	roundRowTopToBounds(rowTop) {
		const range = this.beans.ctrlsSvc.getScrollFeature().getApproximateVScollPosition();
		const minPixel = this.applyPaginationOffset(range.top, true) - 100;
		const maxPixel = this.applyPaginationOffset(range.bottom, true) + 100;
		return Math.min(Math.max(minPixel, rowTop), maxPixel);
	}
	forEachGui(gui, callback) {
		if (gui) callback(gui);
		else this.allRowGuis.forEach(callback);
	}
	isRowRendered() {
		return this.allRowGuis.length > 0;
	}
	onRowHeightChanged(gui) {
		if (this.rowNode.rowHeight == null) return;
		const rowHeight = this.rowNode.rowHeight;
		const defaultRowHeight = this.beans.environment.getDefaultRowHeight();
		const heightFromFunc = _isGetRowHeightFunction(this.gos) ? _getRowHeightForNode(this.beans, this.rowNode).height : void 0;
		const lineHeight = heightFromFunc ? `${Math.min(defaultRowHeight, heightFromFunc) - 2}px` : void 0;
		this.forEachGui(gui, (gui2) => {
			gui2.element.style.height = `${rowHeight}px`;
			if (lineHeight) gui2.element.style.setProperty("--ag-line-height", lineHeight);
		});
	}
	destroyFirstPass(suppressAnimation = false) {
		this.active = false;
		const { rowNode } = this;
		if (!suppressAnimation && _isAnimateRows(this.gos) && !rowNode.sticky) if (rowNode.rowTop != null) {
			const rowTop = this.roundRowTopToBounds(rowNode.rowTop);
			this.setRowTop(rowTop);
		} else this.allRowGuis.forEach((gui) => gui.rowComp.toggleCss("ag-opacity-zero", true));
		if (this.fullWidthGui?.element.contains(_getActiveDomElement(this.beans))) this.beans.focusSvc.attemptToRecoverFocus();
		rowNode.setHovered(false);
		const event = this.createRowEvent("virtualRowRemoved");
		this.dispatchLocalEvent(event);
		this.beans.eventSvc.dispatchEvent(event);
		super.destroy();
	}
	destroySecondPass() {
		this.allRowGuis.length = 0;
		const destroyCellCtrls = (ctrls) => {
			ctrls.list.forEach((c) => c.destroy());
			return {
				list: [],
				map: {}
			};
		};
		this.centerCellCtrls = destroyCellCtrls(this.centerCellCtrls);
		this.leftCellCtrls = destroyCellCtrls(this.leftCellCtrls);
		this.rightCellCtrls = destroyCellCtrls(this.rightCellCtrls);
	}
	setFocusedClasses(gui) {
		this.forEachGui(gui, (gui2) => {
			gui2.rowComp.toggleCss("ag-row-focus", this.rowFocused);
			gui2.rowComp.toggleCss("ag-row-no-focus", !this.rowFocused);
		});
	}
	onCellFocusChanged() {
		const { focusSvc } = this.beans;
		const rowFocused = focusSvc.isRowFocused(this.rowNode.rowIndex, this.rowNode.rowPinned);
		if (rowFocused !== this.rowFocused) {
			this.rowFocused = rowFocused;
			this.setFocusedClasses();
		}
	}
	onPaginationChanged() {
		const currentPage = this.beans.pagination?.getCurrentPage() ?? 0;
		if (this.paginationPage !== currentPage) {
			this.paginationPage = currentPage;
			this.onTopChanged();
		}
		this.refreshFirstAndLastRowStyles();
	}
	onTopChanged() {
		this.setRowTop(this.rowNode.rowTop);
	}
	onPaginationPixelOffsetChanged() {
		this.onTopChanged();
	}
	applyPaginationOffset(topPx, reverse = false) {
		if (this.rowNode.isRowPinned() || this.rowNode.sticky) return topPx;
		return topPx + this.beans.pageBounds.getPixelOffset() * (reverse ? 1 : -1);
	}
	setRowTop(pixels) {
		if (this.printLayout) return;
		if (_exists(pixels)) {
			const afterPaginationPixels = this.applyPaginationOffset(pixels);
			const topPx = `${this.rowNode.isRowPinned() || this.rowNode.sticky ? afterPaginationPixels : this.beans.rowContainerHeight.getRealPixelPosition(afterPaginationPixels)}px`;
			this.setRowTopStyle(topPx);
		}
	}
	getInitialRowTop(rowContainerType) {
		return this.suppressRowTransform ? this.getInitialRowTopShared(rowContainerType) : void 0;
	}
	getInitialTransform(rowContainerType) {
		return this.suppressRowTransform ? void 0 : `translateY(${this.getInitialRowTopShared(rowContainerType)})`;
	}
	getInitialRowTopShared(rowContainerType) {
		if (this.printLayout) return "";
		const rowNode = this.rowNode;
		let rowTop;
		if (rowNode.sticky) rowTop = rowNode.stickyRowTop;
		else {
			const pixels = this.slideInAnimation[rowContainerType] ? this.roundRowTopToBounds(rowNode.oldRowTop) : rowNode.rowTop;
			const afterPaginationPixels = this.applyPaginationOffset(pixels);
			rowTop = rowNode.isRowPinned() ? afterPaginationPixels : this.beans.rowContainerHeight.getRealPixelPosition(afterPaginationPixels);
		}
		return rowTop + "px";
	}
	setRowTopStyle(topPx) {
		this.allRowGuis.forEach((gui) => this.suppressRowTransform ? gui.rowComp.setTop(topPx) : gui.rowComp.setTransform(`translateY(${topPx})`));
	}
	getCellCtrl(column, skipColSpanSearch = false) {
		let res = null;
		this.getAllCellCtrls().forEach((cellCtrl) => {
			if (cellCtrl.column == column) res = cellCtrl;
		});
		if (res != null || skipColSpanSearch) return res;
		this.getAllCellCtrls().forEach((cellCtrl) => {
			if (cellCtrl?.getColSpanningList().indexOf(column) >= 0) res = cellCtrl;
		});
		return res;
	}
	onRowIndexChanged() {
		if (this.rowNode.rowIndex != null) {
			this.onCellFocusChanged();
			this.updateRowIndexes();
			this.postProcessCss();
		}
	}
	updateRowIndexes(gui) {
		const rowIndexStr = this.rowNode.getRowIndexString();
		if (rowIndexStr === null) return;
		const headerRowCount = (this.beans.ctrlsSvc.getHeaderRowContainerCtrl()?.getRowCount() ?? 0) + (this.beans.filterManager?.getHeaderRowCount() ?? 0);
		const rowIsEven = this.rowNode.rowIndex % 2 === 0;
		const ariaRowIndex = headerRowCount + this.rowNode.rowIndex + 1;
		this.forEachGui(gui, (c) => {
			c.rowComp.setRowIndex(rowIndexStr);
			c.rowComp.toggleCss("ag-row-even", rowIsEven);
			c.rowComp.toggleCss("ag-row-odd", !rowIsEven);
			_setAriaRowIndex(c.element, ariaRowIndex);
		});
	}
};
function _isEventFromPrintableCharacter(event) {
	if (event.altKey || event.ctrlKey || event.metaKey) return false;
	return event.key?.length === 1;
}
function _isUserSuppressingKeyboardEvent(gos, keyboardEvent, rowNode, column, editing) {
	const colDefFunc = column ? column.getColDef().suppressKeyboardEvent : void 0;
	if (!colDefFunc) return false;
	const params = _addGridCommonParams(gos, {
		event: keyboardEvent,
		editing,
		column,
		node: rowNode,
		data: rowNode.data,
		colDef: column.getColDef()
	});
	if (colDefFunc) {
		if (colDefFunc(params)) return true;
	}
	return false;
}
function _selectAllCells(beans) {
	const { pinnedRowModel, rowModel } = beans;
	const [isEmptyPinnedTop, isEmptyPinnedBottom] = [pinnedRowModel?.isEmpty("top") ?? true, pinnedRowModel?.isEmpty("bottom") ?? true];
	const floatingStart = isEmptyPinnedTop ? null : "top";
	let floatingEnd;
	let rowEnd;
	if (isEmptyPinnedBottom) {
		floatingEnd = null;
		rowEnd = rowModel.getRowCount() - 1;
	} else {
		floatingEnd = "bottom";
		rowEnd = pinnedRowModel?.getPinnedBottomRowCount() ?? -1;
	}
	const { visibleCols, rangeSvc } = beans;
	const allDisplayedColumns = visibleCols.allCols;
	if (!rangeSvc || !allDisplayedColumns?.length) return;
	rangeSvc.setCellRange({
		rowStartIndex: 0,
		rowStartPinned: floatingStart,
		rowEndIndex: rowEnd,
		rowEndPinned: floatingEnd
	});
}
var A_KEYCODE = 65;
var C_KEYCODE = 67;
var V_KEYCODE = 86;
var D_KEYCODE = 68;
var Z_KEYCODE = 90;
var Y_KEYCODE = 89;
function _normaliseQwertyAzerty(keyboardEvent) {
	const { keyCode } = keyboardEvent;
	let code;
	switch (keyCode) {
		case A_KEYCODE:
			code = KeyCode.A;
			break;
		case C_KEYCODE:
			code = KeyCode.C;
			break;
		case V_KEYCODE:
			code = KeyCode.V;
			break;
		case D_KEYCODE:
			code = KeyCode.D;
			break;
		case Z_KEYCODE:
			code = KeyCode.Z;
			break;
		case Y_KEYCODE:
			code = KeyCode.Y;
			break;
		default: code = keyboardEvent.code;
	}
	return code;
}
var RowContainerEventsFeature = class extends BeanStub {
	constructor(element) {
		super();
		this.element = element;
	}
	postConstruct() {
		this.addKeyboardListeners();
		this.addMouseListeners();
		this.beans.touchSvc?.mockRowContextMenu(this);
		this.editSvc = this.beans.editSvc;
	}
	addKeyboardListeners() {
		const eventName = "keydown";
		const listener = this.processKeyboardEvent.bind(this, eventName);
		this.addManagedElementListeners(this.element, { [eventName]: listener });
	}
	addMouseListeners() {
		[
			"dblclick",
			"contextmenu",
			"mouseover",
			"mouseout",
			"click",
			_isEventSupported("touchstart") ? "touchstart" : "mousedown"
		].forEach((eventName) => {
			const listener = this.processMouseEvent.bind(this, eventName);
			this.addManagedElementListeners(this.element, { [eventName]: listener });
		});
	}
	processMouseEvent(eventName, mouseEvent) {
		if (!_isEventFromThisGrid(this.gos, mouseEvent) || _isStopPropagationForAgGrid(mouseEvent)) return;
		const { cellCtrl, rowCtrl } = this.getControlsForEventTarget(mouseEvent.target);
		if (eventName === "contextmenu") {
			if (cellCtrl?.column) cellCtrl.dispatchCellContextMenuEvent(mouseEvent);
			this.beans.contextMenuSvc?.handleContextMenuMouseEvent(mouseEvent, void 0, rowCtrl, cellCtrl);
		} else {
			if (cellCtrl) cellCtrl.onMouseEvent(eventName, mouseEvent);
			if (rowCtrl) rowCtrl.onMouseEvent(eventName, mouseEvent);
		}
	}
	getControlsForEventTarget(target) {
		const { gos } = this;
		return {
			cellCtrl: _getCellCtrlForEventTarget(gos, target),
			rowCtrl: _getCtrlForEventTarget(gos, target, DOM_DATA_KEY_ROW_CTRL)
		};
	}
	processKeyboardEvent(eventName, keyboardEvent) {
		const { cellCtrl, rowCtrl } = this.getControlsForEventTarget(keyboardEvent.target);
		if (keyboardEvent.defaultPrevented) return;
		if (cellCtrl) this.processCellKeyboardEvent(cellCtrl, eventName, keyboardEvent);
		else if (rowCtrl?.isFullWidth()) this.processFullWidthRowKeyboardEvent(rowCtrl, eventName, keyboardEvent);
	}
	processCellKeyboardEvent(cellCtrl, eventName, keyboardEvent) {
		const editing = this.editSvc?.isEditing(cellCtrl, { withOpenEditor: true }) ?? false;
		if (!_isUserSuppressingKeyboardEvent(this.gos, keyboardEvent, cellCtrl.rowNode, cellCtrl.column, editing)) {
			if (eventName === "keydown") {
				if (!(!editing && this.beans.navigation?.handlePageScrollingKey(keyboardEvent))) cellCtrl.onKeyDown(keyboardEvent);
				this.doGridOperations(keyboardEvent, editing);
				if (_isEventFromPrintableCharacter(keyboardEvent)) cellCtrl.processCharacter(keyboardEvent);
			}
		}
		if (eventName === "keydown") this.eventSvc.dispatchEvent(cellCtrl.createEvent(keyboardEvent, "cellKeyDown"));
	}
	processFullWidthRowKeyboardEvent(rowCtrl, eventName, keyboardEvent) {
		const { rowNode } = rowCtrl;
		const { focusSvc, navigation } = this.beans;
		const column = focusSvc.getFocusedCell()?.column;
		if (!_isUserSuppressingKeyboardEvent(this.gos, keyboardEvent, rowNode, column, false)) {
			const key = keyboardEvent.key;
			if (eventName === "keydown") switch (key) {
				case KeyCode.PAGE_HOME:
				case KeyCode.PAGE_END:
				case KeyCode.PAGE_UP:
				case KeyCode.PAGE_DOWN:
					navigation?.handlePageScrollingKey(keyboardEvent, true);
					break;
				case KeyCode.LEFT:
				case KeyCode.RIGHT: if (!this.gos.get("embedFullWidthRows")) break;
				case KeyCode.UP:
				case KeyCode.DOWN:
					rowCtrl.onKeyboardNavigate(keyboardEvent);
					break;
				case KeyCode.TAB:
					rowCtrl.onTabKeyDown(keyboardEvent);
					break;
				default:
			}
		}
		if (eventName === "keydown") this.eventSvc.dispatchEvent(rowCtrl.createRowEvent("cellKeyDown", keyboardEvent));
	}
	doGridOperations(keyboardEvent, editing) {
		if (!keyboardEvent.ctrlKey && !keyboardEvent.metaKey) return;
		if (editing) return;
		if (!_isEventFromThisGrid(this.gos, keyboardEvent)) return;
		const keyCode = _normaliseQwertyAzerty(keyboardEvent);
		const { clipboardSvc, undoRedo } = this.beans;
		if (keyCode === KeyCode.A) return this.onCtrlAndA(keyboardEvent);
		if (keyCode === KeyCode.C) return this.onCtrlAndC(clipboardSvc, keyboardEvent);
		if (keyCode === KeyCode.D) return this.onCtrlAndD(clipboardSvc, keyboardEvent);
		if (keyCode === KeyCode.V) return this.onCtrlAndV(clipboardSvc, keyboardEvent);
		if (keyCode === KeyCode.X) return this.onCtrlAndX(clipboardSvc, keyboardEvent);
		if (keyCode === KeyCode.Y) return this.onCtrlAndY(undoRedo);
		if (keyCode === KeyCode.Z) return this.onCtrlAndZ(undoRedo, keyboardEvent);
	}
	onCtrlAndA(event) {
		const { beans: { rowModel, rangeSvc, selectionSvc }, gos } = this;
		if (rangeSvc && _isCellSelectionEnabled(gos) && rowModel.isRowsToRender()) _selectAllCells(this.beans);
		else if (selectionSvc) selectionSvc?.selectAllRowNodes({
			source: "keyboardSelectAll",
			selectAll: _getSelectAll(gos)
		});
		event.preventDefault();
	}
	onCtrlAndC(clipboardSvc, event) {
		if (!clipboardSvc || this.gos.get("enableCellTextSelection")) return;
		const { cellCtrl } = this.getControlsForEventTarget(event.target);
		if (this.editSvc?.isEditing(cellCtrl, { withOpenEditor: true })) return;
		event.preventDefault();
		clipboardSvc.copyToClipboard();
	}
	onCtrlAndX(clipboardSvc, event) {
		if (!clipboardSvc || this.gos.get("enableCellTextSelection") || this.gos.get("suppressCutToClipboard")) return;
		const { cellCtrl } = this.getControlsForEventTarget(event.target);
		if (this.editSvc?.isEditing(cellCtrl, { withOpenEditor: true })) return;
		event.preventDefault();
		clipboardSvc.cutToClipboard(void 0, "ui");
	}
	onCtrlAndV(clipboardSvc, event) {
		const { cellCtrl } = this.getControlsForEventTarget(event.target);
		if (this.editSvc?.isEditing(cellCtrl, { withOpenEditor: true })) return;
		if (clipboardSvc && !this.gos.get("suppressClipboardPaste")) clipboardSvc.pasteFromClipboard();
	}
	onCtrlAndD(clipboardSvc, event) {
		if (clipboardSvc && !this.gos.get("suppressClipboardPaste")) clipboardSvc.copyRangeDown();
		event.preventDefault();
	}
	onCtrlAndZ(undoRedo, event) {
		if (!this.gos.get("undoRedoCellEditing") || !undoRedo) return;
		event.preventDefault();
		if (event.shiftKey) undoRedo.redo("ui");
		else undoRedo.undo("ui");
	}
	onCtrlAndY(undoRedo) {
		undoRedo?.redo("ui");
	}
};
var SetHeightFeature = class extends BeanStub {
	constructor(eContainer, eViewport) {
		super();
		this.eContainer = eContainer;
		this.eViewport = eViewport;
	}
	postConstruct() {
		this.addManagedEventListeners({ rowContainerHeightChanged: this.onHeightChanged.bind(this, this.beans.rowContainerHeight) });
	}
	onHeightChanged(maxDivHeightScaler) {
		const height = maxDivHeightScaler.uiContainerHeight;
		const heightString = height != null ? `${height}px` : ``;
		this.eContainer.style.height = heightString;
		if (this.eViewport) this.eViewport.style.height = heightString;
	}
};
var getTopRowCtrls = (r) => r.topRowCtrls;
var getStickyTopRowCtrls = (r) => r.getStickyTopRowCtrls();
var getStickyBottomRowCtrls = (r) => r.getStickyBottomRowCtrls();
var getBottomRowCtrls = (r) => r.bottomRowCtrls;
var getCentreRowCtrls = (r) => r.allRowCtrls;
var getSpannedTopRowCtrls = (r) => r.getCtrls("top");
var getSpannedCenterRowCtrls = (r) => r.getCtrls("center");
var getSpannedBottomRowCtrls = (r) => r.getCtrls("bottom");
var ContainerCssClasses = {
	center: {
		type: "center",
		name: "center-cols",
		getRowCtrls: getCentreRowCtrls,
		getSpannedRowCtrls: getSpannedCenterRowCtrls
	},
	left: {
		type: "left",
		name: "pinned-left-cols",
		pinnedType: "left",
		getRowCtrls: getCentreRowCtrls,
		getSpannedRowCtrls: getSpannedCenterRowCtrls
	},
	right: {
		type: "right",
		name: "pinned-right-cols",
		pinnedType: "right",
		getRowCtrls: getCentreRowCtrls,
		getSpannedRowCtrls: getSpannedCenterRowCtrls
	},
	fullWidth: {
		type: "fullWidth",
		name: "full-width",
		fullWidth: true,
		getRowCtrls: getCentreRowCtrls
	},
	topCenter: {
		type: "center",
		name: "floating-top",
		getRowCtrls: getTopRowCtrls,
		getSpannedRowCtrls: getSpannedTopRowCtrls
	},
	topLeft: {
		type: "left",
		name: "pinned-left-floating",
		container: "ag-pinned-left-floating-top",
		pinnedType: "left",
		getRowCtrls: getTopRowCtrls,
		getSpannedRowCtrls: getSpannedTopRowCtrls
	},
	topRight: {
		type: "right",
		name: "pinned-right-floating",
		container: "ag-pinned-right-floating-top",
		pinnedType: "right",
		getRowCtrls: getTopRowCtrls,
		getSpannedRowCtrls: getSpannedTopRowCtrls
	},
	topFullWidth: {
		type: "fullWidth",
		name: "floating-top-full-width",
		fullWidth: true,
		getRowCtrls: getTopRowCtrls
	},
	stickyTopCenter: {
		type: "center",
		name: "sticky-top",
		getRowCtrls: getStickyTopRowCtrls
	},
	stickyTopLeft: {
		type: "left",
		name: "pinned-left-sticky-top",
		container: "ag-pinned-left-sticky-top",
		pinnedType: "left",
		getRowCtrls: getStickyTopRowCtrls
	},
	stickyTopRight: {
		type: "right",
		name: "pinned-right-sticky-top",
		container: "ag-pinned-right-sticky-top",
		pinnedType: "right",
		getRowCtrls: getStickyTopRowCtrls
	},
	stickyTopFullWidth: {
		type: "fullWidth",
		name: "sticky-top-full-width",
		fullWidth: true,
		getRowCtrls: getStickyTopRowCtrls
	},
	stickyBottomCenter: {
		type: "center",
		name: "sticky-bottom",
		getRowCtrls: getStickyBottomRowCtrls
	},
	stickyBottomLeft: {
		type: "left",
		name: "pinned-left-sticky-bottom",
		container: "ag-pinned-left-sticky-bottom",
		pinnedType: "left",
		getRowCtrls: getStickyBottomRowCtrls
	},
	stickyBottomRight: {
		type: "right",
		name: "pinned-right-sticky-bottom",
		container: "ag-pinned-right-sticky-bottom",
		pinnedType: "right",
		getRowCtrls: getStickyBottomRowCtrls
	},
	stickyBottomFullWidth: {
		type: "fullWidth",
		name: "sticky-bottom-full-width",
		fullWidth: true,
		getRowCtrls: getStickyBottomRowCtrls
	},
	bottomCenter: {
		type: "center",
		name: "floating-bottom",
		getRowCtrls: getBottomRowCtrls,
		getSpannedRowCtrls: getSpannedBottomRowCtrls
	},
	bottomLeft: {
		type: "left",
		name: "pinned-left-floating-bottom",
		container: "ag-pinned-left-floating-bottom",
		pinnedType: "left",
		getRowCtrls: getBottomRowCtrls,
		getSpannedRowCtrls: getSpannedBottomRowCtrls
	},
	bottomRight: {
		type: "right",
		name: "pinned-right-floating-bottom",
		container: "ag-pinned-right-floating-bottom",
		pinnedType: "right",
		getRowCtrls: getBottomRowCtrls,
		getSpannedRowCtrls: getSpannedBottomRowCtrls
	},
	bottomFullWidth: {
		type: "fullWidth",
		name: "floating-bottom-full-width",
		fullWidth: true,
		getRowCtrls: getBottomRowCtrls
	}
};
function _getRowViewportClass(name) {
	return `ag-${_getRowContainerOptions(name).name}-viewport`;
}
function _getRowContainerClass(name) {
	const options = _getRowContainerOptions(name);
	return options.container ?? `ag-${options.name}-container`;
}
function _getRowSpanContainerClass(name) {
	return `ag-${_getRowContainerOptions(name).name}-spanned-cells-container`;
}
function _getRowContainerOptions(name) {
	return ContainerCssClasses[name];
}
var allTopNoFW = [
	"topCenter",
	"topLeft",
	"topRight"
];
var allBottomNoFW = [
	"bottomCenter",
	"bottomLeft",
	"bottomRight"
];
var allMiddleNoFW = [
	"center",
	"left",
	"right"
];
var allMiddle = [
	"center",
	"left",
	"right",
	"fullWidth"
];
var allCenter = [
	"stickyTopCenter",
	"stickyBottomCenter",
	"center",
	"topCenter",
	"bottomCenter"
];
var allLeft = [
	"left",
	"bottomLeft",
	"topLeft",
	"stickyTopLeft",
	"stickyBottomLeft"
];
var allRight = [
	"right",
	"bottomRight",
	"topRight",
	"stickyTopRight",
	"stickyBottomRight"
];
var allStickyTopNoFW = [
	"stickyTopCenter",
	"stickyTopLeft",
	"stickyTopRight"
];
var allStickyBottomNoFW = [
	"stickyBottomCenter",
	"stickyBottomLeft",
	"stickyBottomRight"
];
var allStickyContainers = [
	...allStickyTopNoFW,
	"stickyTopFullWidth",
	...allStickyBottomNoFW,
	"stickyBottomFullWidth"
];
var allNoFW = [
	...allTopNoFW,
	...allBottomNoFW,
	...allMiddleNoFW,
	...allStickyTopNoFW,
	...allStickyBottomNoFW
];
var RowContainerCtrl = class extends BeanStub {
	constructor(name) {
		super();
		this.name = name;
		this.visible = true;
		this.EMPTY_CTRLS = [];
		this.options = _getRowContainerOptions(name);
	}
	postConstruct() {
		this.enableRtl = this.gos.get("enableRtl");
		this.forContainers(["center"], () => {
			this.viewportSizeFeature = this.createManagedBean(new ViewportSizeFeature(this));
			this.addManagedEventListeners({ stickyTopOffsetChanged: this.onStickyTopOffsetChanged.bind(this) });
		});
	}
	onStickyTopOffsetChanged(event) {
		this.comp.setOffsetTop(`${event.offset}px`);
	}
	registerWithCtrlsService() {
		if (this.options.fullWidth) return;
		this.beans.ctrlsSvc.register(this.name, this);
	}
	forContainers(names, callback) {
		if (names.indexOf(this.name) >= 0) callback();
	}
	setComp(view, eContainer, eSpannedContainer, eViewport) {
		this.comp = view;
		this.eContainer = eContainer;
		this.eSpannedContainer = eSpannedContainer;
		this.eViewport = eViewport;
		this.createManagedBean(new RowContainerEventsFeature(this.eViewport ?? this.eContainer));
		this.addPreventScrollWhileDragging();
		this.listenOnDomOrder();
		const { pinnedCols, rangeSvc } = this.beans;
		const pinnedWidthChanged = () => this.onPinnedWidthChanged();
		this.forContainers(allLeft, () => {
			this.pinnedWidthFeature = this.createOptionalManagedBean(pinnedCols?.createPinnedWidthFeature(true, this.eContainer, this.eSpannedContainer));
			this.addManagedEventListeners({ leftPinnedWidthChanged: pinnedWidthChanged });
		});
		this.forContainers(allRight, () => {
			this.pinnedWidthFeature = this.createOptionalManagedBean(pinnedCols?.createPinnedWidthFeature(false, this.eContainer, this.eSpannedContainer));
			this.addManagedEventListeners({ rightPinnedWidthChanged: pinnedWidthChanged });
		});
		this.forContainers(allMiddle, () => this.createManagedBean(new SetHeightFeature(this.eContainer, this.name === "center" ? eViewport : void 0)));
		if (rangeSvc) this.forContainers(allNoFW, () => this.createManagedBean(rangeSvc.createDragListenerFeature(this.eContainer)));
		this.forContainers(allCenter, () => this.createManagedBean(new CenterWidthFeature((width) => this.comp.setContainerWidth(`${width}px`))));
		this.visible = this.isContainerVisible();
		this.addListeners();
		this.registerWithCtrlsService();
	}
	onScrollCallback(fn) {
		this.addManagedElementListeners(this.eViewport, { scroll: fn });
	}
	addListeners() {
		const { spannedRowRenderer, gos } = this.beans;
		const onDisplayedColumnsChanged = this.onDisplayedColumnsChanged.bind(this);
		this.addManagedEventListeners({
			displayedColumnsChanged: onDisplayedColumnsChanged,
			displayedColumnsWidthChanged: onDisplayedColumnsChanged,
			displayedRowsChanged: (params) => this.onDisplayedRowsChanged(params.afterScroll)
		});
		onDisplayedColumnsChanged();
		this.onDisplayedRowsChanged();
		if (spannedRowRenderer && this.options.getSpannedRowCtrls && gos.get("enableCellSpan")) this.addManagedListeners(spannedRowRenderer, { spannedRowsUpdated: () => {
			const spannedCtrls = this.options.getSpannedRowCtrls(spannedRowRenderer);
			if (!spannedCtrls) return;
			this.comp.setSpannedRowCtrls(spannedCtrls, false);
		} });
	}
	listenOnDomOrder() {
		if (allStickyContainers.indexOf(this.name) >= 0) {
			this.comp.setDomOrder(true);
			return;
		}
		const listener = () => {
			const isEnsureDomOrder = this.gos.get("ensureDomOrder");
			const isPrintLayout = _isDomLayout(this.gos, "print");
			this.comp.setDomOrder(isEnsureDomOrder || isPrintLayout);
		};
		this.addManagedPropertyListener("domLayout", listener);
		listener();
	}
	onDisplayedColumnsChanged() {
		this.forContainers(["center"], () => this.onHorizontalViewportChanged());
	}
	addPreventScrollWhileDragging() {
		const { dragSvc } = this.beans;
		if (!dragSvc) return;
		const preventScroll = (e) => {
			if (dragSvc.dragging) {
				if (e.cancelable) e.preventDefault();
			}
		};
		this.eContainer.addEventListener("touchmove", preventScroll, { passive: false });
		this.addDestroyFunc(() => this.eContainer.removeEventListener("touchmove", preventScroll));
	}
	onHorizontalViewportChanged(afterScroll = false) {
		const scrollWidth = this.getCenterWidth();
		const scrollPosition = this.getCenterViewportScrollLeft();
		this.beans.colViewport.setScrollPosition(scrollWidth, scrollPosition, afterScroll);
	}
	hasHorizontalScrollGap() {
		return this.eContainer.clientWidth - this.eViewport.clientWidth < 0;
	}
	hasVerticalScrollGap() {
		return this.eContainer.clientHeight - this.eViewport.clientHeight < 0;
	}
	getCenterWidth() {
		return _getInnerWidth(this.eViewport);
	}
	getCenterViewportScrollLeft() {
		return _getScrollLeft(this.eViewport, this.enableRtl);
	}
	registerViewportResizeListener(listener) {
		const unsubscribeFromResize = _observeResize(this.beans, this.eViewport, listener);
		this.addDestroyFunc(() => unsubscribeFromResize());
	}
	isViewportInTheDOMTree() {
		return _isInDOM(this.eViewport);
	}
	getViewportScrollLeft() {
		return _getScrollLeft(this.eViewport, this.enableRtl);
	}
	isHorizontalScrollShowing() {
		return this.gos.get("alwaysShowHorizontalScroll") || _isHorizontalScrollShowing(this.eViewport);
	}
	setHorizontalScroll(offset) {
		this.comp.setHorizontalScroll(offset);
	}
	getHScrollPosition() {
		return {
			left: this.eViewport.scrollLeft,
			right: this.eViewport.scrollLeft + this.eViewport.offsetWidth
		};
	}
	setCenterViewportScrollLeft(value) {
		_setScrollLeft(this.eViewport, value, this.enableRtl);
	}
	isContainerVisible() {
		return !(this.options.pinnedType != null) || !!this.pinnedWidthFeature && this.pinnedWidthFeature.getWidth() > 0;
	}
	onPinnedWidthChanged() {
		const visible = this.isContainerVisible();
		if (this.visible != visible) {
			this.visible = visible;
			this.onDisplayedRowsChanged();
		}
	}
	onDisplayedRowsChanged(afterScroll = false) {
		const rows = this.options.getRowCtrls(this.beans.rowRenderer);
		if (!this.visible || rows.length === 0) {
			this.comp.setRowCtrls({ rowCtrls: this.EMPTY_CTRLS });
			return;
		}
		const printLayout = _isDomLayout(this.gos, "print");
		const embedFW = this.gos.get("embedFullWidthRows") || printLayout;
		const rowsThisContainer = rows.filter((rowCtrl) => {
			const fullWidthRow = rowCtrl.isFullWidth();
			return this.options.fullWidth ? !embedFW && fullWidthRow : embedFW || !fullWidthRow;
		});
		this.comp.setRowCtrls({
			rowCtrls: rowsThisContainer,
			useFlushSync: afterScroll
		});
	}
};
var CSS_CLASS_FORCE_VERTICAL_SCROLL = "ag-force-vertical-scroll";
var CSS_CLASS_CELL_SELECTABLE = "ag-selectable";
var CSS_CLASS_COLUMN_MOVING = "ag-column-moving";
var GridBodyCtrl = class extends BeanStub {
	constructor() {
		super(...arguments);
		this.stickyTopHeight = 0;
		this.stickyBottomHeight = 0;
	}
	wireBeans(beans) {
		this.ctrlsSvc = beans.ctrlsSvc;
		this.colModel = beans.colModel;
		this.scrollVisibleSvc = beans.scrollVisibleSvc;
		this.pinnedRowModel = beans.pinnedRowModel;
		this.filterManager = beans.filterManager;
		this.rowGroupColsSvc = beans.rowGroupColsSvc;
	}
	setComp(comp, eGridBody, eBodyViewport, eTop, eBottom, eStickyTop, eStickyBottom) {
		this.comp = comp;
		this.eGridBody = eGridBody;
		this.eBodyViewport = eBodyViewport;
		this.eTop = eTop;
		this.eBottom = eBottom;
		this.eStickyTop = eStickyTop;
		this.eStickyBottom = eStickyBottom;
		this.eCenterColsViewport = eBodyViewport.querySelector(`.${_getRowViewportClass("center")}`);
		this.eFullWidthContainer = eBodyViewport.querySelector(`.${_getRowContainerClass("fullWidth")}`);
		this.eStickyTopFullWidthContainer = eStickyTop.querySelector(`.${_getRowContainerClass("stickyTopFullWidth")}`);
		this.eStickyBottomFullWidthContainer = eStickyBottom.querySelector(`.${_getRowContainerClass("stickyBottomFullWidth")}`);
		this.setCellTextSelection(this.gos.get("enableCellTextSelection"));
		this.addManagedPropertyListener("enableCellTextSelection", (props) => this.setCellTextSelection(props.currentValue));
		this.createManagedBean(new LayoutFeature(this.comp));
		this.scrollFeature = this.createManagedBean(new GridBodyScrollFeature(eBodyViewport));
		this.beans.rowDragSvc?.setupRowDrag(eBodyViewport, this);
		this.setupRowAnimationCssClass();
		this.addEventListeners();
		this.addFocusListeners([
			eTop,
			eBodyViewport,
			eBottom,
			eStickyTop,
			eStickyBottom
		]);
		this.setGridRootRole();
		this.onGridColumnsChanged();
		this.addBodyViewportListener();
		this.setFloatingHeights();
		this.disableBrowserDragging();
		this.addStopEditingWhenGridLosesFocus();
		this.updateScrollingClasses();
		this.filterManager?.setupAdvFilterHeaderComp(eTop);
		this.ctrlsSvc.register("gridBodyCtrl", this);
	}
	addEventListeners() {
		const setFloatingHeights = this.setFloatingHeights.bind(this);
		const setGridRootRole = this.setGridRootRole.bind(this);
		const toggleRowResizeStyle = this.toggleRowResizeStyles.bind(this);
		this.addManagedEventListeners({
			gridColumnsChanged: this.onGridColumnsChanged.bind(this),
			scrollVisibilityChanged: this.onScrollVisibilityChanged.bind(this),
			scrollGapChanged: this.updateScrollingClasses.bind(this),
			pinnedRowDataChanged: setFloatingHeights,
			pinnedHeightChanged: setFloatingHeights,
			pinnedRowsChanged: setFloatingHeights,
			headerHeightChanged: this.setStickyTopOffsetTop.bind(this),
			columnRowGroupChanged: setGridRootRole,
			columnPivotChanged: setGridRootRole,
			rowResizeStarted: toggleRowResizeStyle,
			rowResizeEnded: toggleRowResizeStyle
		});
		this.addManagedPropertyListener("treeData", setGridRootRole);
	}
	toggleRowResizeStyles(params) {
		const isResizingRow = params.type === "rowResizeStarted";
		this.eBodyViewport.classList.toggle("ag-prevent-animation", isResizingRow);
	}
	onGridColumnsChanged() {
		const columns = this.beans.colModel.getCols();
		this.comp.setColumnCount(columns.length);
	}
	onScrollVisibilityChanged() {
		const { scrollVisibleSvc } = this;
		const visible = scrollVisibleSvc.verticalScrollShowing;
		this.setVerticalScrollPaddingVisible(visible);
		this.setStickyWidth(visible);
		this.setStickyBottomOffsetBottom();
		const width = `calc(100% + ${(visible ? scrollVisibleSvc.getScrollbarWidth() || 0 : 0) + (_isInvisibleScrollbar() ? 16 : 0)}px)`;
		_requestAnimationFrame(this.beans, () => this.comp.setBodyViewportWidth(width));
		this.updateScrollingClasses();
	}
	setGridRootRole() {
		const { rowGroupColsSvc, colModel } = this;
		let isTreeGrid = this.gos.get("treeData");
		if (!isTreeGrid) {
			const isPivotActive = colModel.isPivotMode();
			isTreeGrid = (!rowGroupColsSvc ? 0 : rowGroupColsSvc.columns.length) >= (isPivotActive ? 2 : 1);
		}
		this.comp.setGridRootRole(isTreeGrid ? "treegrid" : "grid");
	}
	addFocusListeners(elements) {
		elements.forEach((element) => {
			this.addManagedElementListeners(element, {
				focusin: (e) => {
					const { target } = e;
					const isFocusedElementNested = _isElementChildOfClass(target, "ag-root", element);
					element.classList.toggle("ag-has-focus", !isFocusedElementNested);
				},
				focusout: (e) => {
					const { target, relatedTarget } = e;
					const gridContainRelatedTarget = element.contains(relatedTarget);
					const isNestedRelatedTarget = _isElementChildOfClass(relatedTarget, "ag-root", element);
					if (_isElementChildOfClass(target, "ag-root", element)) return;
					if (!gridContainRelatedTarget || isNestedRelatedTarget) element.classList.remove("ag-has-focus");
				}
			});
		});
	}
	setColumnMovingCss(moving) {
		this.comp.setColumnMovingCss(CSS_CLASS_COLUMN_MOVING, moving);
	}
	setCellTextSelection(selectable = false) {
		this.comp.setCellSelectableCss(CSS_CLASS_CELL_SELECTABLE, selectable);
	}
	updateScrollingClasses() {
		const { eGridBody: { classList }, scrollVisibleSvc } = this;
		classList.toggle("ag-body-vertical-content-no-gap", !scrollVisibleSvc.verticalScrollGap);
		classList.toggle("ag-body-horizontal-content-no-gap", !scrollVisibleSvc.horizontalScrollGap);
	}
	disableBrowserDragging() {
		this.addManagedElementListeners(this.eGridBody, { dragstart: (event) => {
			if (event.target instanceof HTMLImageElement) {
				event.preventDefault();
				return false;
			}
		} });
	}
	addStopEditingWhenGridLosesFocus() {
		this.beans.editSvc?.addStopEditingWhenGridLosesFocus([
			this.eBodyViewport,
			this.eBottom,
			this.eTop,
			this.eStickyTop,
			this.eStickyBottom
		]);
	}
	updateRowCount() {
		const headerCount = (this.ctrlsSvc.getHeaderRowContainerCtrl()?.getRowCount() ?? 0) + (this.filterManager?.getHeaderRowCount() ?? 0);
		const { rowModel } = this.beans;
		const rowCount = rowModel.isLastRowIndexKnown() ? rowModel.getRowCount() : -1;
		const total = rowCount === -1 ? -1 : headerCount + rowCount;
		this.comp.setRowCount(total);
	}
	registerBodyViewportResizeListener(listener) {
		this.comp.registerBodyViewportResizeListener(listener);
	}
	setVerticalScrollPaddingVisible(visible) {
		const overflowY = visible ? "scroll" : "hidden";
		this.comp.setPinnedTopBottomOverflowY(overflowY);
	}
	isVerticalScrollShowing() {
		const show = this.gos.get("alwaysShowVerticalScroll");
		const cssClass = show ? CSS_CLASS_FORCE_VERTICAL_SCROLL : null;
		const allowVerticalScroll = _isDomLayout(this.gos, "normal");
		this.comp.setAlwaysVerticalScrollClass(cssClass, show);
		return show || allowVerticalScroll && _isVerticalScrollShowing(this.eBodyViewport);
	}
	setupRowAnimationCssClass() {
		const { rowContainerHeight, environment } = this.beans;
		let initialSizeMeasurementComplete = environment.sizesMeasured;
		const updateAnimationClass = () => {
			const animateRows = initialSizeMeasurementComplete && _isAnimateRows(this.gos) && !rowContainerHeight.stretching;
			const animateRowsCssClass = animateRows ? "ag-row-animation" : "ag-row-no-animation";
			this.comp.setRowAnimationCssOnBodyViewport(animateRowsCssClass, animateRows);
		};
		updateAnimationClass();
		this.addManagedEventListeners({ heightScaleChanged: updateAnimationClass });
		this.addManagedPropertyListener("animateRows", updateAnimationClass);
		this.addManagedEventListeners({ gridStylesChanged: () => {
			if (!initialSizeMeasurementComplete && environment.sizesMeasured) {
				initialSizeMeasurementComplete = true;
				updateAnimationClass();
			}
		} });
	}
	addBodyViewportListener() {
		const { eBodyViewport, eStickyTop, eStickyBottom, eTop, eBottom, beans: { popupSvc, touchSvc } } = this;
		const listener = this.onBodyViewportContextMenu.bind(this);
		this.addManagedElementListeners(eBodyViewport, { contextmenu: listener });
		touchSvc?.mockBodyContextMenu(this, listener);
		this.addManagedElementListeners(eBodyViewport, { wheel: this.onBodyViewportWheel.bind(this, popupSvc) });
		const onStickyWheel = this.onStickyWheel.bind(this);
		for (const container of [
			eStickyTop,
			eStickyBottom,
			eTop,
			eBottom
		]) this.addManagedElementListeners(container, { wheel: onStickyWheel });
		const onHorizontalWheel = this.onHorizontalWheel.bind(this);
		for (const container of [
			"left",
			"right",
			"topLeft",
			"topRight",
			"bottomLeft",
			"bottomRight"
		]) this.addManagedElementListeners(this.ctrlsSvc.get(container).eContainer, { wheel: onHorizontalWheel });
		this.addFullWidthContainerWheelListener();
	}
	addFullWidthContainerWheelListener() {
		this.addManagedElementListeners(this.eFullWidthContainer, { wheel: (e) => this.onFullWidthContainerWheel(e) });
	}
	onFullWidthContainerWheel(e) {
		const { deltaX, deltaY, shiftKey } = e;
		if ((shiftKey || Math.abs(deltaX) > Math.abs(deltaY)) && _isEventFromThisGrid(this.gos, e)) this.scrollGridBodyToMatchEvent(e);
	}
	onStickyWheel(e) {
		const { deltaY } = e;
		if (this.scrollVertically(deltaY) > 0) e.preventDefault();
	}
	onHorizontalWheel(e) {
		const { deltaX, deltaY, shiftKey } = e;
		if (!(shiftKey || Math.abs(deltaX) > Math.abs(deltaY))) return;
		this.scrollGridBodyToMatchEvent(e);
	}
	scrollGridBodyToMatchEvent(e) {
		const { deltaX, deltaY } = e;
		e.preventDefault();
		this.eCenterColsViewport.scrollBy({ left: deltaX || deltaY });
	}
	onBodyViewportContextMenu(mouseEvent, touch, touchEvent) {
		if (!mouseEvent && !touchEvent) return;
		if (this.gos.get("preventDefaultOnContextMenu")) (mouseEvent || touchEvent).preventDefault();
		const { target } = mouseEvent || touch;
		if (target === this.eBodyViewport || target === this.ctrlsSvc.get("center").eViewport) this.beans.contextMenuSvc?.showContextMenu({
			mouseEvent,
			touchEvent,
			value: null,
			anchorToElement: this.eGridBody,
			source: "ui"
		});
	}
	onBodyViewportWheel(popupSvc, e) {
		if (!this.gos.get("suppressScrollWhenPopupsAreOpen")) return;
		if (popupSvc?.hasAnchoredPopup()) e.preventDefault();
	}
	scrollVertically(pixels) {
		const oldScrollPosition = this.eBodyViewport.scrollTop;
		this.scrollFeature.setVerticalScrollPosition(oldScrollPosition + pixels);
		return this.eBodyViewport.scrollTop - oldScrollPosition;
	}
	setFloatingHeights() {
		const { pinnedRowModel, beans: { environment } } = this;
		const floatingTopHeight = pinnedRowModel?.getPinnedTopTotalHeight();
		const floatingBottomHeight = pinnedRowModel?.getPinnedBottomTotalHeight();
		const additionalHeight = environment.getPinnedRowBorderWidth() - environment.getRowBorderWidth();
		const normalisedFloatingTopHeight = !floatingTopHeight ? 0 : additionalHeight + floatingTopHeight;
		const normalisedFloatingBottomHeight = !floatingBottomHeight ? 0 : additionalHeight + floatingBottomHeight;
		this.comp.setTopHeight(normalisedFloatingTopHeight);
		this.comp.setBottomHeight(normalisedFloatingBottomHeight);
		this.comp.setTopInvisible(normalisedFloatingTopHeight <= 0);
		this.comp.setBottomInvisible(normalisedFloatingBottomHeight <= 0);
		this.setStickyTopOffsetTop();
		this.setStickyBottomOffsetBottom();
	}
	setStickyTopHeight(height = 0) {
		this.comp.setStickyTopHeight(`${height}px`);
		this.stickyTopHeight = height;
	}
	setStickyBottomHeight(height = 0) {
		this.comp.setStickyBottomHeight(`${height}px`);
		this.stickyBottomHeight = height;
	}
	setStickyWidth(vScrollVisible) {
		if (!vScrollVisible) {
			this.comp.setStickyTopWidth("100%");
			this.comp.setStickyBottomWidth("100%");
		} else {
			const scrollbarWidth = this.scrollVisibleSvc.getScrollbarWidth();
			this.comp.setStickyTopWidth(`calc(100% - ${scrollbarWidth}px)`);
			this.comp.setStickyBottomWidth(`calc(100% - ${scrollbarWidth}px)`);
		}
	}
	setStickyTopOffsetTop() {
		const headerHeight = this.ctrlsSvc.get("gridHeaderCtrl").headerHeight + (this.filterManager?.getHeaderHeight() ?? 0);
		const pinnedTopHeight = this.pinnedRowModel?.getPinnedTopTotalHeight() ?? 0;
		let height = 0;
		if (headerHeight > 0) height += headerHeight;
		if (pinnedTopHeight > 0) height += pinnedTopHeight;
		if (height > 0) height += 1;
		this.comp.setStickyTopTop(`${height}px`);
	}
	setStickyBottomOffsetBottom() {
		const { pinnedRowModel, scrollVisibleSvc, comp } = this;
		const height = (pinnedRowModel?.getPinnedBottomTotalHeight() ?? 0) + (scrollVisibleSvc.horizontalScrollShowing ? scrollVisibleSvc.getScrollbarWidth() || 0 : 0);
		comp.setStickyBottomBottom(`${height}px`);
	}
};
var AbstractFakeScrollComp = class extends Component {
	constructor(template, direction) {
		super();
		this.direction = direction;
		this.eViewport = null;
		this.eContainer = null;
		this.hideTimeout = 0;
		this.setTemplate(template);
	}
	postConstruct() {
		this.addManagedEventListeners({ scrollVisibilityChanged: this.onScrollVisibilityChanged.bind(this) });
		this.onScrollVisibilityChanged();
		this.toggleCss("ag-apple-scrollbar", _isMacOsUserAgent() || _isIOSUserAgent());
	}
	destroy() {
		super.destroy();
		window.clearTimeout(this.hideTimeout);
	}
	initialiseInvisibleScrollbar() {
		if (this.invisibleScrollbar !== void 0) return;
		this.invisibleScrollbar = _isInvisibleScrollbar();
		if (this.invisibleScrollbar) {
			this.hideAndShowInvisibleScrollAsNeeded();
			this.addActiveListenerToggles();
		}
	}
	addActiveListenerToggles() {
		const eGui = this.getGui();
		const onActivate = () => this.toggleCss("ag-scrollbar-active", true);
		const onDeactivate = () => this.toggleCss("ag-scrollbar-active", false);
		this.addManagedListeners(eGui, {
			mouseenter: onActivate,
			mousedown: onActivate,
			touchstart: onActivate,
			mouseleave: onDeactivate,
			touchend: onDeactivate
		});
	}
	onScrollVisibilityChanged() {
		if (this.invisibleScrollbar === void 0) this.initialiseInvisibleScrollbar();
		_requestAnimationFrame(this.beans, () => this.setScrollVisible());
	}
	hideAndShowInvisibleScrollAsNeeded() {
		this.addManagedEventListeners({
			bodyScroll: (params) => {
				if (params.direction === this.direction) {
					if (this.hideTimeout) {
						window.clearTimeout(this.hideTimeout);
						this.hideTimeout = 0;
					}
					this.toggleCss("ag-scrollbar-scrolling", true);
				}
			},
			bodyScrollEnd: () => {
				this.hideTimeout = window.setTimeout(() => {
					this.toggleCss("ag-scrollbar-scrolling", false);
					this.hideTimeout = 0;
				}, 400);
			}
		});
	}
	attemptSettingScrollPosition(value) {
		const viewport = this.eViewport;
		_waitUntil(() => _isVisible(viewport), () => this.setScrollPosition(value), 100);
	}
	onScrollCallback(fn) {
		this.addManagedElementListeners(this.eViewport, { scroll: fn });
	}
};
var FakeHScrollElement = {
	tag: "div",
	cls: "ag-body-horizontal-scroll",
	attrs: { "aria-hidden": "true" },
	children: [
		{
			tag: "div",
			ref: "eLeftSpacer",
			cls: "ag-horizontal-left-spacer"
		},
		{
			tag: "div",
			ref: "eViewport",
			cls: "ag-body-horizontal-scroll-viewport",
			children: [{
				tag: "div",
				ref: "eContainer",
				cls: "ag-body-horizontal-scroll-container"
			}]
		},
		{
			tag: "div",
			ref: "eRightSpacer",
			cls: "ag-horizontal-right-spacer"
		}
	]
};
var FakeHScrollComp = class extends AbstractFakeScrollComp {
	constructor() {
		super(FakeHScrollElement, "horizontal");
		this.eLeftSpacer = null;
		this.eRightSpacer = null;
		this.setScrollVisibleDebounce = 0;
	}
	wireBeans(beans) {
		this.visibleCols = beans.visibleCols;
		this.scrollVisibleSvc = beans.scrollVisibleSvc;
	}
	postConstruct() {
		super.postConstruct();
		const spacerWidthsListener = this.setFakeHScrollSpacerWidths.bind(this);
		this.addManagedEventListeners({
			displayedColumnsChanged: spacerWidthsListener,
			displayedColumnsWidthChanged: spacerWidthsListener,
			pinnedRowDataChanged: this.refreshCompBottom.bind(this)
		});
		this.addManagedPropertyListener("domLayout", spacerWidthsListener);
		this.beans.ctrlsSvc.register("fakeHScrollComp", this);
		this.createManagedBean(new CenterWidthFeature((width) => this.eContainer.style.width = `${width}px`));
		this.addManagedPropertyListeners(["suppressHorizontalScroll"], this.onScrollVisibilityChanged.bind(this));
	}
	destroy() {
		window.clearTimeout(this.setScrollVisibleDebounce);
		super.destroy();
	}
	initialiseInvisibleScrollbar() {
		if (this.invisibleScrollbar !== void 0) return;
		this.enableRtl = this.gos.get("enableRtl");
		super.initialiseInvisibleScrollbar();
		if (this.invisibleScrollbar) this.refreshCompBottom();
	}
	refreshCompBottom() {
		if (!this.invisibleScrollbar) return;
		const bottomPinnedHeight = this.beans.pinnedRowModel?.getPinnedBottomTotalHeight() ?? 0;
		this.getGui().style.bottom = `${bottomPinnedHeight}px`;
	}
	onScrollVisibilityChanged() {
		super.onScrollVisibilityChanged();
		this.setFakeHScrollSpacerWidths();
	}
	setFakeHScrollSpacerWidths() {
		const vScrollShowing = this.scrollVisibleSvc.verticalScrollShowing;
		let rightSpacing = this.visibleCols.getDisplayedColumnsRightWidth();
		const scrollOnRight = !this.enableRtl && vScrollShowing;
		const scrollbarWidth = this.scrollVisibleSvc.getScrollbarWidth();
		if (scrollOnRight) rightSpacing += scrollbarWidth;
		_setFixedWidth(this.eRightSpacer, rightSpacing);
		this.eRightSpacer.classList.toggle("ag-scroller-corner", rightSpacing <= scrollbarWidth);
		let leftSpacing = this.visibleCols.getColsLeftWidth();
		if (this.enableRtl && vScrollShowing) leftSpacing += scrollbarWidth;
		_setFixedWidth(this.eLeftSpacer, leftSpacing);
		this.eLeftSpacer.classList.toggle("ag-scroller-corner", leftSpacing <= scrollbarWidth);
	}
	setScrollVisible() {
		const hScrollShowing = this.scrollVisibleSvc.horizontalScrollShowing;
		const invisibleScrollbar2 = this.invisibleScrollbar;
		const isSuppressHorizontalScroll = this.gos.get("suppressHorizontalScroll");
		const scrollbarWidth = hScrollShowing ? this.scrollVisibleSvc.getScrollbarWidth() || 0 : 0;
		const scrollContainerSize = !isSuppressHorizontalScroll ? scrollbarWidth === 0 && invisibleScrollbar2 ? 16 : scrollbarWidth : 0;
		const apply = () => {
			this.setScrollVisibleDebounce = 0;
			this.toggleCss("ag-scrollbar-invisible", invisibleScrollbar2);
			_setFixedHeight(this.getGui(), scrollContainerSize);
			_setFixedHeight(this.eViewport, scrollContainerSize);
			_setFixedHeight(this.eContainer, scrollContainerSize);
			if (!scrollContainerSize) this.eContainer.style.setProperty("min-height", "1px");
			this.setVisible(hScrollShowing, { skipAriaHidden: true });
		};
		window.clearTimeout(this.setScrollVisibleDebounce);
		if (!hScrollShowing) apply();
		else this.setScrollVisibleDebounce = window.setTimeout(apply, 100);
	}
	getScrollPosition() {
		return _getScrollLeft(this.eViewport, this.enableRtl);
	}
	setScrollPosition(value) {
		if (!_isVisible(this.eViewport)) this.attemptSettingScrollPosition(value);
		_setScrollLeft(this.eViewport, value, this.enableRtl);
	}
};
var FakeHScrollSelector = {
	selector: "AG-FAKE-HORIZONTAL-SCROLL",
	component: FakeHScrollComp
};
var FakeVScrollElement = {
	tag: "div",
	cls: "ag-body-vertical-scroll",
	attrs: { "aria-hidden": "true" },
	children: [{
		tag: "div",
		ref: "eViewport",
		cls: "ag-body-vertical-scroll-viewport",
		children: [{
			tag: "div",
			ref: "eContainer",
			cls: "ag-body-vertical-scroll-container"
		}]
	}]
};
var FakeVScrollComp = class extends AbstractFakeScrollComp {
	constructor() {
		super(FakeVScrollElement, "vertical");
	}
	postConstruct() {
		super.postConstruct();
		this.createManagedBean(new SetHeightFeature(this.eContainer));
		const { ctrlsSvc } = this.beans;
		ctrlsSvc.register("fakeVScrollComp", this);
		this.addManagedEventListeners({ rowContainerHeightChanged: this.onRowContainerHeightChanged.bind(this, ctrlsSvc) });
	}
	setScrollVisible() {
		const { scrollVisibleSvc } = this.beans;
		const vScrollShowing = scrollVisibleSvc.verticalScrollShowing;
		const invisibleScrollbar2 = this.invisibleScrollbar;
		const scrollbarWidth = vScrollShowing ? scrollVisibleSvc.getScrollbarWidth() || 0 : 0;
		const adjustedScrollbarWidth = scrollbarWidth === 0 && invisibleScrollbar2 ? 16 : scrollbarWidth;
		this.toggleCss("ag-scrollbar-invisible", invisibleScrollbar2);
		_setFixedWidth(this.getGui(), adjustedScrollbarWidth);
		_setFixedWidth(this.eViewport, adjustedScrollbarWidth);
		_setFixedWidth(this.eContainer, adjustedScrollbarWidth);
		this.setDisplayed(vScrollShowing, { skipAriaHidden: true });
	}
	onRowContainerHeightChanged(ctrlsSvc) {
		const gridBodyViewportEl = ctrlsSvc.getGridBodyCtrl().eBodyViewport;
		const eViewportScrollTop = this.getScrollPosition();
		const gridBodyViewportScrollTop = gridBodyViewportEl.scrollTop;
		if (eViewportScrollTop != gridBodyViewportScrollTop) this.setScrollPosition(gridBodyViewportScrollTop, true);
	}
	getScrollPosition() {
		return this.eViewport.scrollTop;
	}
	setScrollPosition(value, force) {
		if (!force && !_isVisible(this.eViewport)) this.attemptSettingScrollPosition(value);
		this.eViewport.scrollTop = value;
	}
};
var FakeVScrollSelector = {
	selector: "AG-FAKE-VERTICAL-SCROLL",
	component: FakeVScrollComp
};
function getFocusHeaderRowCount(beans) {
	return beans.ctrlsSvc.getHeaderRowContainerCtrl()?.getRowCount() ?? 0;
}
function getGroupRowsHeight(beans) {
	const heights = [];
	const headerRowContainerCtrls = beans.ctrlsSvc.getHeaderRowContainerCtrls();
	for (const headerRowContainerCtrl of headerRowContainerCtrls) {
		if (!headerRowContainerCtrl) continue;
		const groupRowCount = headerRowContainerCtrl.getGroupRowCount() || 0;
		for (let i = 0; i < groupRowCount; i++) {
			const headerRowCtrl = headerRowContainerCtrl.getGroupRowCtrlAtIndex(i);
			const currentHeightAtPos = heights[i];
			if (headerRowCtrl) {
				const newHeight = getColumnGroupHeaderRowHeight(beans, headerRowCtrl);
				if (currentHeightAtPos == null || newHeight > currentHeightAtPos) heights[i] = newHeight;
			}
		}
	}
	return heights;
}
function getColumnGroupHeaderRowHeight(beans, headerRowCtrl) {
	let maxDisplayedHeight = beans.colModel.isPivotMode() ? getPivotGroupHeaderHeight(beans) : getGroupHeaderHeight(beans);
	const headerRowCellCtrls = headerRowCtrl.getHeaderCellCtrls();
	for (const headerCellCtrl of headerRowCellCtrls) {
		const { column } = headerCellCtrl;
		const height = column.getAutoHeaderHeight();
		if (height != null && height > maxDisplayedHeight && column.isAutoHeaderHeight()) maxDisplayedHeight = height;
	}
	return maxDisplayedHeight;
}
function getColumnHeaderRowHeight(beans) {
	let maxDisplayedHeight = beans.colModel.isPivotMode() ? getPivotHeaderHeight(beans) : getHeaderHeight(beans);
	beans.colModel.forAllCols((col) => {
		const height = col.getAutoHeaderHeight();
		if (height != null && height > maxDisplayedHeight && col.isAutoHeaderHeight()) maxDisplayedHeight = height;
	});
	return maxDisplayedHeight;
}
function getHeaderHeight(beans) {
	return beans.gos.get("headerHeight") ?? beans.environment.getDefaultHeaderHeight();
}
function getFloatingFiltersHeight(beans) {
	return beans.gos.get("floatingFiltersHeight") ?? getHeaderHeight(beans);
}
function getGroupHeaderHeight(beans) {
	return beans.gos.get("groupHeaderHeight") ?? getHeaderHeight(beans);
}
function getPivotHeaderHeight(beans) {
	return beans.gos.get("pivotHeaderHeight") ?? getHeaderHeight(beans);
}
function getPivotGroupHeaderHeight(beans) {
	return beans.gos.get("pivotGroupHeaderHeight") ?? getGroupHeaderHeight(beans);
}
var GridHeaderCtrl = class extends BeanStub {
	setComp(comp, eGui, eFocusableElement) {
		this.comp = comp;
		this.eGui = eGui;
		const { beans } = this;
		const { headerNavigation, touchSvc, ctrlsSvc } = beans;
		if (headerNavigation) this.createManagedBean(new ManagedFocusFeature(eFocusableElement, {
			onTabKeyDown: this.onTabKeyDown.bind(this),
			handleKeyDown: this.handleKeyDown.bind(this),
			onFocusOut: this.onFocusOut.bind(this)
		}));
		this.addManagedEventListeners({
			columnPivotModeChanged: this.onPivotModeChanged.bind(this, beans),
			displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this, beans)
		});
		this.onPivotModeChanged(beans);
		this.setupHeaderHeight();
		const listener = this.onHeaderContextMenu.bind(this);
		this.addManagedElementListeners(this.eGui, { contextmenu: listener });
		touchSvc?.mockHeaderContextMenu(this, listener);
		ctrlsSvc.register("gridHeaderCtrl", this);
	}
	setupHeaderHeight() {
		const listener = this.setHeaderHeight.bind(this);
		listener();
		this.addManagedPropertyListeners([
			"headerHeight",
			"pivotHeaderHeight",
			"groupHeaderHeight",
			"pivotGroupHeaderHeight",
			"floatingFiltersHeight"
		], listener);
		this.addManagedEventListeners({
			headerRowsChanged: listener,
			columnHeaderHeightChanged: listener,
			columnGroupHeaderHeightChanged: () => _requestAnimationFrame(this.beans, () => listener()),
			gridStylesChanged: listener,
			advancedFilterEnabledChanged: listener
		});
	}
	setHeaderHeight() {
		const { beans } = this;
		let totalHeaderHeight = 0;
		const groupHeight = getGroupRowsHeight(beans).reduce((prev, curr) => prev + curr, 0);
		const headerHeight = getColumnHeaderRowHeight(beans);
		if (beans.filterManager?.hasFloatingFilters()) totalHeaderHeight += getFloatingFiltersHeight(beans);
		totalHeaderHeight += groupHeight;
		totalHeaderHeight += headerHeight;
		if (this.headerHeight === totalHeaderHeight) return;
		this.headerHeight = totalHeaderHeight;
		const px = `${totalHeaderHeight + 1}px`;
		this.comp.setHeightAndMinHeight(px);
		this.eventSvc.dispatchEvent({ type: "headerHeightChanged" });
	}
	onPivotModeChanged(beans) {
		const pivotMode = beans.colModel.isPivotMode();
		this.comp.toggleCss("ag-pivot-on", pivotMode);
		this.comp.toggleCss("ag-pivot-off", !pivotMode);
	}
	onDisplayedColumnsChanged(beans) {
		const shouldAllowOverflow = beans.visibleCols.allCols.some((col) => col.isSpanHeaderHeight());
		this.comp.toggleCss("ag-header-allow-overflow", shouldAllowOverflow);
	}
	onTabKeyDown(e) {
		const isRtl = this.gos.get("enableRtl");
		const backwards = e.shiftKey;
		const direction = backwards !== isRtl ? "LEFT" : "RIGHT";
		const { beans } = this;
		const { headerNavigation, focusSvc } = beans;
		if (headerNavigation.navigateHorizontally(direction, true, e) || !backwards && focusSvc.focusOverlay(false) || _focusNextGridCoreContainer(beans, backwards, true)) e.preventDefault();
	}
	handleKeyDown(e) {
		let direction = null;
		const { headerNavigation } = this.beans;
		switch (e.key) {
			case KeyCode.LEFT: direction = "LEFT";
			case KeyCode.RIGHT:
				if (!_exists(direction)) direction = "RIGHT";
				if (headerNavigation.navigateHorizontally(direction, false, e)) e.preventDefault();
				break;
			case KeyCode.UP: direction = "UP";
			case KeyCode.DOWN:
				if (!_exists(direction)) direction = "DOWN";
				if (headerNavigation.navigateVertically(direction, e)) e.preventDefault();
				break;
			default: return;
		}
	}
	onFocusOut(e) {
		const { relatedTarget } = e;
		const { eGui, beans } = this;
		if (!relatedTarget && eGui.contains(_getActiveDomElement(beans))) return;
		if (!eGui.contains(relatedTarget)) beans.focusSvc.focusedHeader = null;
	}
	onHeaderContextMenu(mouseEvent, touch, touchEvent) {
		const { menuSvc, ctrlsSvc } = this.beans;
		if (!mouseEvent && !touchEvent || !menuSvc?.isHeaderContextMenuEnabled()) return;
		const { target } = mouseEvent ?? touch;
		if (target === this.eGui || target === ctrlsSvc.getHeaderRowContainerCtrl()?.eViewport) menuSvc.showHeaderContextMenu(void 0, mouseEvent, touchEvent);
	}
};
var AbstractHeaderCellComp = class extends Component {
	constructor(template, ctrl) {
		super(template);
		this.ctrl = ctrl;
	}
	getCtrl() {
		return this.ctrl;
	}
};
var HeaderCellElement = {
	tag: "div",
	cls: "ag-header-cell",
	role: "columnheader",
	children: [{
		tag: "div",
		ref: "eResize",
		cls: "ag-header-cell-resize",
		role: "presentation"
	}, {
		tag: "div",
		ref: "eHeaderCompWrapper",
		cls: "ag-header-cell-comp-wrapper",
		role: "presentation"
	}]
};
var HeaderCellComp = class extends AbstractHeaderCellComp {
	constructor(ctrl) {
		super(HeaderCellElement, ctrl);
		this.eResize = null;
		this.eHeaderCompWrapper = null;
		this.headerCompVersion = 0;
	}
	postConstruct() {
		const eGui = this.getGui();
		const setAttribute = (name, value) => {
			if (value != null && value != "") eGui.setAttribute(name, value);
			else eGui.removeAttribute(name);
		};
		const refreshSelectAllGui = () => {
			const selectAllGui = this.ctrl.getSelectAllGui();
			if (selectAllGui) {
				this.eResize.insertAdjacentElement("afterend", selectAllGui);
				this.addDestroyFunc(() => selectAllGui.remove());
			}
		};
		setAttribute("col-id", this.ctrl.column.getColId());
		const compProxy = {
			setWidth: (width) => eGui.style.width = width,
			toggleCss: (cssClassName, on) => this.toggleCss(cssClassName, on),
			setUserStyles: (styles) => _addStylesToElement(eGui, styles),
			setAriaSort: (sort) => sort ? _setAriaSort(eGui, sort) : _removeAriaSort(eGui),
			setUserCompDetails: (compDetails) => this.setUserCompDetails(compDetails),
			getUserCompInstance: () => this.headerComp,
			refreshSelectAllGui,
			removeSelectAllGui: () => this.ctrl.getSelectAllGui()?.remove()
		};
		this.ctrl.setComp(compProxy, this.getGui(), this.eResize, this.eHeaderCompWrapper, void 0);
		refreshSelectAllGui();
	}
	destroy() {
		this.destroyHeaderComp();
		super.destroy();
	}
	destroyHeaderComp() {
		if (this.headerComp) {
			this.eHeaderCompWrapper.removeChild(this.headerCompGui);
			this.headerComp = this.destroyBean(this.headerComp);
			this.headerCompGui = void 0;
		}
	}
	setUserCompDetails(compDetails) {
		this.headerCompVersion++;
		const versionCopy = this.headerCompVersion;
		compDetails.newAgStackInstance().then((comp) => this.afterCompCreated(versionCopy, comp));
	}
	afterCompCreated(version, headerComp) {
		if (version != this.headerCompVersion || !this.isAlive()) {
			this.destroyBean(headerComp);
			return;
		}
		this.destroyHeaderComp();
		this.headerComp = headerComp;
		this.headerCompGui = headerComp.getGui();
		this.eHeaderCompWrapper.appendChild(this.headerCompGui);
		this.ctrl.setDragSource(this.getGui());
	}
};
var HeaderGroupCellCompElement = {
	tag: "div",
	cls: "ag-header-group-cell",
	role: "columnheader",
	children: [{
		tag: "div",
		ref: "eHeaderCompWrapper",
		cls: "ag-header-cell-comp-wrapper",
		role: "presentation"
	}, {
		tag: "div",
		ref: "eResize",
		cls: "ag-header-cell-resize",
		role: "presentation"
	}]
};
var HeaderGroupCellComp = class extends AbstractHeaderCellComp {
	constructor(ctrl) {
		super(HeaderGroupCellCompElement, ctrl);
		this.eResize = null;
		this.eHeaderCompWrapper = null;
	}
	postConstruct() {
		const eGui = this.getGui();
		const setAttribute = (key, value) => value != void 0 ? eGui.setAttribute(key, value) : eGui.removeAttribute(key);
		eGui.setAttribute("col-id", this.ctrl.column.getUniqueId());
		this.ctrl.setComp({
			toggleCss: (cssClassName, on) => this.toggleCss(cssClassName, on),
			setUserStyles: (styles) => _addStylesToElement(eGui, styles),
			setHeaderWrapperHidden: (hidden) => {
				if (hidden) this.eHeaderCompWrapper.style.setProperty("display", "none");
				else this.eHeaderCompWrapper.style.removeProperty("display");
			},
			setHeaderWrapperMaxHeight: (value) => {
				if (value != null) this.eHeaderCompWrapper.style.setProperty("max-height", `${value}px`);
				else this.eHeaderCompWrapper.style.removeProperty("max-height");
				this.eHeaderCompWrapper.classList.toggle("ag-header-cell-comp-wrapper-limited-height", value != null);
			},
			setResizableDisplayed: (displayed) => _setDisplayed(this.eResize, displayed),
			setWidth: (width) => eGui.style.width = width,
			setAriaExpanded: (expanded) => setAttribute("aria-expanded", expanded),
			setUserCompDetails: (details) => this.setUserCompDetails(details),
			getUserCompInstance: () => this.headerGroupComp
		}, eGui, this.eResize, this.eHeaderCompWrapper, void 0);
	}
	setUserCompDetails(details) {
		details.newAgStackInstance().then((comp) => this.afterHeaderCompCreated(comp));
	}
	afterHeaderCompCreated(headerGroupComp) {
		const destroyFunc = () => this.destroyBean(headerGroupComp);
		if (!this.isAlive()) {
			destroyFunc();
			return;
		}
		const eGui = this.getGui();
		const eHeaderGroupGui = headerGroupComp.getGui();
		this.eHeaderCompWrapper.appendChild(eHeaderGroupGui);
		this.addDestroyFunc(destroyFunc);
		this.headerGroupComp = headerGroupComp;
		this.ctrl.setDragSource(eGui);
	}
};
var HeaderFilterCellCompElement = {
	tag: "div",
	cls: "ag-header-cell ag-floating-filter",
	role: "gridcell",
	children: [{
		tag: "div",
		ref: "eFloatingFilterBody",
		role: "presentation"
	}, {
		tag: "div",
		ref: "eButtonWrapper",
		cls: "ag-floating-filter-button ag-hidden",
		role: "presentation",
		children: [{
			tag: "button",
			ref: "eButtonShowMainFilter",
			cls: "ag-button ag-floating-filter-button-button",
			attrs: {
				type: "button",
				tabindex: "-1"
			}
		}]
	}]
};
var HeaderFilterCellComp = class extends AbstractHeaderCellComp {
	constructor(ctrl) {
		super(HeaderFilterCellCompElement, ctrl);
		this.eFloatingFilterBody = null;
		this.eButtonWrapper = null;
		this.eButtonShowMainFilter = null;
	}
	postConstruct() {
		const eGui = this.getGui();
		this.ctrl.setComp({
			toggleCss: (cssClassName, on) => this.toggleCss(cssClassName, on),
			setUserStyles: (styles) => _addStylesToElement(eGui, styles),
			addOrRemoveBodyCssClass: (cssClassName, on) => this.eFloatingFilterBody.classList.toggle(cssClassName, on),
			setButtonWrapperDisplayed: (displayed) => _setDisplayed(this.eButtonWrapper, displayed),
			setCompDetails: (compDetails) => this.setCompDetails(compDetails),
			getFloatingFilterComp: () => this.compPromise,
			setWidth: (width) => eGui.style.width = width,
			setMenuIcon: (eIcon) => this.eButtonShowMainFilter.appendChild(eIcon)
		}, eGui, this.eButtonShowMainFilter, this.eFloatingFilterBody, void 0);
	}
	setCompDetails(compDetails) {
		if (!compDetails) {
			this.destroyFloatingFilterComp();
			this.compPromise = null;
			return;
		}
		this.compPromise = compDetails.newAgStackInstance();
		this.compPromise.then((comp) => this.afterCompCreated(comp));
	}
	destroy() {
		this.destroyFloatingFilterComp();
		super.destroy();
	}
	destroyFloatingFilterComp() {
		if (this.floatingFilterComp) {
			this.eFloatingFilterBody.removeChild(this.floatingFilterComp.getGui());
			this.floatingFilterComp = this.destroyBean(this.floatingFilterComp);
		}
	}
	afterCompCreated(comp) {
		if (!comp) return;
		if (!this.isAlive()) {
			this.destroyBean(comp);
			return;
		}
		this.destroyFloatingFilterComp();
		this.floatingFilterComp = comp;
		this.eFloatingFilterBody.appendChild(comp.getGui());
		if (comp.afterGuiAttached) comp.afterGuiAttached();
	}
};
var HeaderRowComp = class extends Component {
	constructor(ctrl) {
		super({
			tag: "div",
			cls: ctrl.headerRowClass,
			role: "row"
		});
		this.ctrl = ctrl;
		this.headerComps = {};
	}
	postConstruct() {
		_setAriaRowIndex(this.getGui(), this.ctrl.getAriaRowIndex());
		this.ctrl.setComp({
			setHeight: (height) => this.getGui().style.height = height,
			setTop: (top) => this.getGui().style.top = top,
			setHeaderCtrls: (ctrls, forceOrder) => this.setHeaderCtrls(ctrls, forceOrder),
			setWidth: (width) => this.getGui().style.width = width,
			setRowIndex: (rowIndex) => _setAriaRowIndex(this.getGui(), rowIndex)
		}, void 0);
	}
	destroy() {
		this.setHeaderCtrls([], false);
		super.destroy();
	}
	setHeaderCtrls(ctrls, forceOrder) {
		if (!this.isAlive()) return;
		const oldComps = this.headerComps;
		this.headerComps = {};
		ctrls.forEach((ctrl) => {
			const id = ctrl.instanceId;
			let comp = oldComps[id];
			delete oldComps[id];
			if (comp == null) {
				comp = this.createHeaderComp(ctrl);
				this.getGui().appendChild(comp.getGui());
			}
			this.headerComps[id] = comp;
		});
		Object.values(oldComps).forEach((comp) => {
			this.getGui().removeChild(comp.getGui());
			this.destroyBean(comp);
		});
		if (forceOrder) {
			const comps = Object.values(this.headerComps);
			comps.sort((a, b) => {
				return a.getCtrl().column.getLeft() - b.getCtrl().column.getLeft();
			});
			const elementsInOrder = comps.map((c) => c.getGui());
			_setDomChildOrder(this.getGui(), elementsInOrder);
		}
	}
	createHeaderComp(headerCtrl) {
		let result;
		switch (this.ctrl.type) {
			case "group":
				result = new HeaderGroupCellComp(headerCtrl);
				break;
			case "filter":
				result = new HeaderFilterCellComp(headerCtrl);
				break;
			default:
				result = new HeaderCellComp(headerCtrl);
				break;
		}
		this.createBean(result);
		result.setParentComponent(this);
		return result;
	}
};
var SetLeftFeature = class extends BeanStub {
	constructor(columnOrGroup, eCell, beans, colsSpanning) {
		super();
		this.columnOrGroup = columnOrGroup;
		this.eCell = eCell;
		this.colsSpanning = colsSpanning;
		this.columnOrGroup = columnOrGroup;
		this.ariaEl = eCell.querySelector("[role=columnheader]") || eCell;
		this.beans = beans;
	}
	setColsSpanning(colsSpanning) {
		this.colsSpanning = colsSpanning;
		this.onLeftChanged();
	}
	getColumnOrGroup() {
		const { beans, colsSpanning } = this;
		if (beans.gos.get("enableRtl") && colsSpanning) return _last(colsSpanning);
		return this.columnOrGroup;
	}
	postConstruct() {
		const onLeftChanged = this.onLeftChanged.bind(this);
		this.addManagedListeners(this.columnOrGroup, { leftChanged: onLeftChanged });
		this.setLeftFirstTime();
		this.addManagedEventListeners({ displayedColumnsWidthChanged: onLeftChanged });
		this.addManagedPropertyListener("domLayout", onLeftChanged);
	}
	setLeftFirstTime() {
		const { gos, colAnimation } = this.beans;
		const suppressMoveAnimation = gos.get("suppressColumnMoveAnimation");
		const oldLeftExists = _exists(this.columnOrGroup.getOldLeft());
		if (colAnimation?.isActive() && oldLeftExists && !suppressMoveAnimation) this.animateInLeft();
		else this.onLeftChanged();
	}
	animateInLeft() {
		const colOrGroup = this.getColumnOrGroup();
		const oldActualLeft = this.modifyLeftForPrintLayout(colOrGroup, colOrGroup.getOldLeft());
		const actualLeft = this.modifyLeftForPrintLayout(colOrGroup, colOrGroup.getLeft());
		this.setLeft(oldActualLeft);
		this.actualLeft = actualLeft;
		this.beans.colAnimation.executeNextVMTurn(() => {
			if (this.actualLeft === actualLeft) this.setLeft(actualLeft);
		});
	}
	onLeftChanged() {
		const colOrGroup = this.getColumnOrGroup();
		const left = colOrGroup.getLeft();
		this.actualLeft = this.modifyLeftForPrintLayout(colOrGroup, left);
		this.setLeft(this.actualLeft);
	}
	modifyLeftForPrintLayout(colOrGroup, leftPosition) {
		const { gos, visibleCols } = this.beans;
		if (!_isDomLayout(gos, "print")) return leftPosition;
		if (colOrGroup.getPinned() === "left") return leftPosition;
		const leftWidth = visibleCols.getColsLeftWidth();
		if (colOrGroup.getPinned() === "right") return leftWidth + visibleCols.bodyWidth + leftPosition;
		return leftWidth + leftPosition;
	}
	setLeft(value) {
		if (_exists(value)) this.eCell.style.left = `${value}px`;
		if (isColumnGroup(this.columnOrGroup)) {
			const children = this.columnOrGroup.getLeafColumns();
			if (!children.length) return;
			if (children.length > 1) _setAriaColSpan(this.ariaEl, children.length);
		}
	}
};
var instanceIdSequence4 = 0;
var DOM_DATA_KEY_HEADER_CTRL = "headerCtrl";
var AbstractHeaderCellCtrl = class extends BeanStub {
	constructor(column, rowCtrl) {
		super();
		this.column = column;
		this.rowCtrl = rowCtrl;
		this.resizeToggleTimeout = 0;
		this.resizeMultiplier = 1;
		this.resizeFeature = null;
		this.lastFocusEvent = null;
		this.dragSource = null;
		this.instanceId = column.getUniqueId() + "-" + instanceIdSequence4++;
	}
	postConstruct() {
		const refreshTabIndex = this.refreshTabIndex.bind(this);
		this.addManagedPropertyListeners(["suppressHeaderFocus"], refreshTabIndex);
		this.addManagedEventListeners({ overlayExclusiveChanged: refreshTabIndex });
	}
	shouldStopEventPropagation(event) {
		const { headerRowIndex, column } = this.beans.focusSvc.focusedHeader;
		const colDef = column.getDefinition();
		const colDefFunc = colDef && colDef.suppressHeaderKeyboardEvent;
		if (!_exists(colDefFunc)) return false;
		return !!colDefFunc(_addGridCommonParams(this.gos, {
			colDef,
			column,
			headerRowIndex,
			event
		}));
	}
	getWrapperHasFocus() {
		return _getActiveDomElement(this.beans) === this.eGui;
	}
	setGui(eGui, compBean) {
		this.eGui = eGui;
		this.addDomData(compBean);
		compBean.addManagedListeners(this.beans.eventSvc, { displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this) });
		compBean.addManagedElementListeners(this.eGui, { focus: this.onGuiFocus.bind(this) });
		this.onDisplayedColumnsChanged();
		this.refreshTabIndex();
	}
	refreshHeaderStyles() {
		const colDef = this.column.getDefinition();
		if (!colDef) return;
		const { headerStyle } = colDef;
		let styles;
		if (typeof headerStyle === "function") styles = headerStyle(this.getHeaderClassParams());
		else styles = headerStyle;
		if (styles) this.comp.setUserStyles(styles);
	}
	onGuiFocus() {
		this.eventSvc.dispatchEvent({
			type: "headerFocused",
			column: this.column
		});
	}
	setupAutoHeight(params) {
		const { wrapperElement, checkMeasuringCallback, compBean } = params;
		const { beans } = this;
		const measureHeight = (timesCalled) => {
			if (!this.isAlive() || !compBean.isAlive()) return;
			const { paddingTop, paddingBottom, borderBottomWidth, borderTopWidth } = _getElementSize(this.eGui);
			const extraHeight = paddingTop + paddingBottom + borderBottomWidth + borderTopWidth;
			const autoHeight = wrapperElement.offsetHeight + extraHeight;
			if (timesCalled < 5) {
				const doc = _getDocument(beans);
				if (!doc || !doc.contains(wrapperElement) || autoHeight == 0) {
					_batchCall(() => measureHeight(timesCalled + 1), "raf", beans);
					return;
				}
			}
			this.setColHeaderHeight(this.column, autoHeight);
		};
		let isMeasuring = false;
		let stopResizeObserver;
		const checkMeasuring = () => {
			const newValue = this.column.isAutoHeaderHeight();
			if (newValue && !isMeasuring) startMeasuring();
			if (!newValue && isMeasuring) stopMeasuring();
		};
		const startMeasuring = () => {
			isMeasuring = true;
			measureHeight(0);
			this.comp.toggleCss("ag-header-cell-auto-height", true);
			stopResizeObserver = _observeResize(this.beans, wrapperElement, () => measureHeight(0));
		};
		const stopMeasuring = () => {
			isMeasuring = false;
			if (stopResizeObserver) stopResizeObserver();
			this.comp.toggleCss("ag-header-cell-auto-height", false);
			stopResizeObserver = void 0;
		};
		checkMeasuring();
		compBean.addDestroyFunc(() => stopMeasuring());
		compBean.addManagedListeners(this.column, { widthChanged: () => isMeasuring && measureHeight(0) });
		compBean.addManagedEventListeners({ sortChanged: () => {
			if (isMeasuring) window.setTimeout(() => measureHeight(0));
		} });
		if (checkMeasuringCallback) checkMeasuringCallback(checkMeasuring);
	}
	onDisplayedColumnsChanged() {
		const { comp, column, beans, eGui } = this;
		if (!comp || !column || !eGui) return;
		refreshFirstAndLastStyles(comp, column, beans.visibleCols);
		_setAriaColIndex(eGui, beans.visibleCols.getAriaColIndex(column));
	}
	addResizeAndMoveKeyboardListeners(compBean) {
		compBean.addManagedListeners(this.eGui, {
			keydown: this.onGuiKeyDown.bind(this),
			keyup: this.onGuiKeyUp.bind(this)
		});
	}
	refreshTabIndex() {
		const suppressHeaderFocus = _isHeaderFocusSuppressed(this.beans);
		if (this.eGui) _addOrRemoveAttribute(this.eGui, "tabindex", suppressHeaderFocus ? null : "-1");
	}
	onGuiKeyDown(e) {
		const activeEl = _getActiveDomElement(this.beans);
		const isLeftOrRight = e.key === KeyCode.LEFT || e.key === KeyCode.RIGHT;
		if (this.isResizing) {
			e.preventDefault();
			e.stopImmediatePropagation();
		}
		if (activeEl !== this.eGui || !e.shiftKey && !e.altKey) return;
		if (this.isResizing || isLeftOrRight) {
			e.preventDefault();
			e.stopImmediatePropagation();
		}
		if (!isLeftOrRight) return;
		const direction = e.key === KeyCode.LEFT !== this.gos.get("enableRtl") ? "left" : "right";
		if (e.altKey) {
			this.isResizing = true;
			this.resizeMultiplier += 1;
			const diff = this.getViewportAdjustedResizeDiff(e);
			this.resizeHeader(diff, e.shiftKey);
			this.resizeFeature?.toggleColumnResizing(true);
		} else this.moveHeader(direction);
	}
	moveHeader(hDirection) {
		this.beans.colMoves?.moveHeader(hDirection, this.eGui, this.column, this.rowCtrl.pinned, this);
	}
	getViewportAdjustedResizeDiff(e) {
		const diff = this.getResizeDiff(e);
		const { pinnedCols } = this.beans;
		return pinnedCols ? pinnedCols.getHeaderResizeDiff(diff, this.column) : diff;
	}
	getResizeDiff(e) {
		const { gos, column } = this;
		let isLeft = e.key === KeyCode.LEFT !== gos.get("enableRtl");
		const pinned = column.getPinned();
		const isRtl = gos.get("enableRtl");
		if (pinned) {
			if (isRtl !== (pinned === "right")) isLeft = !isLeft;
		}
		return (isLeft ? -1 : 1) * this.resizeMultiplier;
	}
	onGuiKeyUp() {
		if (!this.isResizing) return;
		if (this.resizeToggleTimeout) {
			window.clearTimeout(this.resizeToggleTimeout);
			this.resizeToggleTimeout = 0;
		}
		this.isResizing = false;
		this.resizeMultiplier = 1;
		this.resizeToggleTimeout = window.setTimeout(() => {
			this.resizeFeature?.toggleColumnResizing(false);
		}, 150);
	}
	handleKeyDown(e) {
		const wrapperHasFocus = this.getWrapperHasFocus();
		switch (e.key) {
			case KeyCode.PAGE_DOWN:
			case KeyCode.PAGE_UP:
			case KeyCode.PAGE_HOME:
			case KeyCode.PAGE_END: if (wrapperHasFocus) e.preventDefault();
		}
	}
	addDomData(compBean) {
		const key = DOM_DATA_KEY_HEADER_CTRL;
		const { eGui, gos } = this;
		_setDomData(gos, eGui, key, this);
		compBean.addDestroyFunc(() => _setDomData(gos, eGui, key, null));
	}
	focus(event) {
		const { eGui } = this;
		if (!eGui) return false;
		this.lastFocusEvent = event || null;
		eGui.focus();
		return true;
	}
	focusThis() {
		this.beans.focusSvc.focusedHeader = {
			headerRowIndex: this.rowCtrl.rowIndex,
			column: this.column
		};
	}
	removeDragSource() {
		if (this.dragSource) {
			this.beans.dragAndDrop?.removeDragSource(this.dragSource);
			this.dragSource = null;
		}
	}
	handleContextMenuMouseEvent(mouseEvent, touchEvent, column) {
		const event = mouseEvent ?? touchEvent;
		const { menuSvc, gos } = this.beans;
		if (gos.get("preventDefaultOnContextMenu")) event.preventDefault();
		if (menuSvc?.isHeaderContextMenuEnabled(column)) menuSvc.showHeaderContextMenu(column, mouseEvent, touchEvent);
		this.dispatchColumnMouseEvent("columnHeaderContextMenu", column);
	}
	dispatchColumnMouseEvent(eventType, column) {
		this.eventSvc.dispatchEvent({
			type: eventType,
			column
		});
	}
	setColHeaderHeight(col, height) {
		if (!col.setAutoHeaderHeight(height)) return;
		const { eventSvc } = this;
		if (col.isColumn) eventSvc.dispatchEvent({
			type: "columnHeaderHeightChanged",
			column: col,
			columns: [col],
			source: "autosizeColumnHeaderHeight"
		});
		else eventSvc.dispatchEvent({
			type: "columnGroupHeaderHeightChanged",
			columnGroup: col,
			source: "autosizeColumnGroupHeaderHeight"
		});
	}
	clearComponent() {
		this.removeDragSource();
		this.resizeFeature = null;
		this.comp = null;
		this.eGui = null;
	}
	destroy() {
		super.destroy();
		this.column = null;
		this.lastFocusEvent = null;
		this.rowCtrl = null;
	}
};
var HeaderCellCtrl = class extends AbstractHeaderCellCtrl {
	constructor() {
		super(...arguments);
		this.refreshFunctions = {};
		this.userHeaderClasses = /* @__PURE__ */ new Set();
		this.ariaDescriptionProperties = /* @__PURE__ */ new Map();
	}
	setComp(comp, eGui, eResize, eHeaderCompWrapper, compBeanInput) {
		this.comp = comp;
		const { rowCtrl, column, beans } = this;
		const { colResize, context, colHover, rangeSvc } = beans;
		const compBean = setupCompBean(this, context, compBeanInput);
		this.setGui(eGui, compBean);
		this.updateState();
		this.setupWidth(compBean);
		this.setupMovingCss(compBean);
		this.setupMenuClass(compBean);
		this.setupSortableClass(compBean);
		this.setupWrapTextClass();
		this.refreshSpanHeaderHeight();
		this.setupAutoHeight({
			wrapperElement: eHeaderCompWrapper,
			checkMeasuringCallback: (checkMeasuring) => this.setRefreshFunction("measuring", checkMeasuring),
			compBean
		});
		this.addColumnHoverListener(compBean);
		this.setupFilterClass(compBean);
		this.setupStylesFromColDef();
		this.setupClassesFromColDef();
		this.setupTooltip();
		this.addActiveHeaderMouseListeners(compBean);
		this.setupSelectAll(compBean);
		this.setupUserComp();
		this.refreshAria();
		if (colResize) this.resizeFeature = compBean.createManagedBean(colResize.createResizeFeature(rowCtrl.pinned, column, eResize, comp, this));
		else _setDisplayed(eResize, false);
		colHover?.createHoverFeature(compBean, [column], eGui);
		rangeSvc?.createRangeHighlightFeature(compBean, column, comp);
		compBean.createManagedBean(new SetLeftFeature(column, eGui, beans));
		compBean.createManagedBean(new ManagedFocusFeature(eGui, {
			shouldStopEventPropagation: (e) => this.shouldStopEventPropagation(e),
			onTabKeyDown: () => null,
			handleKeyDown: this.handleKeyDown.bind(this),
			onFocusIn: this.onFocusIn.bind(this),
			onFocusOut: this.onFocusOut.bind(this)
		}));
		this.addResizeAndMoveKeyboardListeners(compBean);
		compBean.addManagedPropertyListeners([
			"suppressMovableColumns",
			"suppressMenuHide",
			"suppressAggFuncInHeader",
			"enableAdvancedFilter"
		], () => this.refresh());
		compBean.addManagedListeners(column, { colDefChanged: () => this.refresh() });
		compBean.addManagedListeners(column, { headerHighlightChanged: this.onHeaderHighlightChanged.bind(this) });
		const listener = () => this.checkDisplayName();
		compBean.addManagedEventListeners({
			columnValueChanged: listener,
			columnRowGroupChanged: listener,
			columnPivotChanged: listener,
			headerHeightChanged: this.onHeaderHeightChanged.bind(this)
		});
		compBean.addDestroyFunc(() => {
			this.refreshFunctions = {};
			this.selectAllFeature = null;
			this.dragSourceElement = void 0;
			this.userCompDetails = null;
			this.userHeaderClasses.clear();
			this.ariaDescriptionProperties.clear();
			this.clearComponent();
		});
	}
	resizeHeader(delta, shiftKey) {
		this.beans.colResize?.resizeHeader(this.column, delta, shiftKey);
	}
	getHeaderClassParams() {
		const { column, beans } = this;
		const colDef = column.colDef;
		return _addGridCommonParams(beans.gos, {
			colDef,
			column,
			floatingFilter: false
		});
	}
	setupUserComp() {
		const compDetails = this.lookupUserCompDetails();
		if (compDetails) this.setCompDetails(compDetails);
	}
	setCompDetails(compDetails) {
		this.userCompDetails = compDetails;
		this.comp.setUserCompDetails(compDetails);
	}
	lookupUserCompDetails() {
		const params = this.createParams();
		const colDef = this.column.getColDef();
		return _getHeaderCompDetails(this.beans.userCompFactory, colDef, params);
	}
	createParams() {
		const { menuSvc, sortSvc, colFilter, gos } = this.beans;
		return _addGridCommonParams(gos, {
			column: this.column,
			displayName: this.displayName,
			enableSorting: this.column.isSortable(),
			enableMenu: this.menuEnabled,
			enableFilterButton: this.openFilterEnabled && !!menuSvc?.isHeaderFilterButtonEnabled(this.column),
			enableFilterIcon: !!colFilter && (!this.openFilterEnabled || _isLegacyMenuEnabled(this.gos)),
			showColumnMenu: (buttonElement, onClosedCallback) => {
				menuSvc?.showColumnMenu({
					column: this.column,
					buttonElement,
					positionBy: "button",
					onClosedCallback
				});
			},
			showColumnMenuAfterMouseClick: (mouseEvent, onClosedCallback) => {
				menuSvc?.showColumnMenu({
					column: this.column,
					mouseEvent,
					positionBy: "mouse",
					onClosedCallback
				});
			},
			showFilter: (buttonElement) => {
				menuSvc?.showFilterMenu({
					column: this.column,
					buttonElement,
					containerType: "columnFilter",
					positionBy: "button"
				});
			},
			progressSort: (multiSort) => {
				sortSvc?.progressSort(this.column, !!multiSort, "uiColumnSorted");
			},
			setSort: (sort, multiSort) => {
				sortSvc?.setSortForColumn(this.column, sort, !!multiSort, "uiColumnSorted");
			},
			eGridHeader: this.eGui,
			setTooltip: (value, shouldDisplayTooltip) => {
				gos.assertModuleRegistered("Tooltip", 3);
				this.setupTooltip(value, shouldDisplayTooltip);
			}
		});
	}
	setupSelectAll(compBean) {
		const { selectionSvc } = this.beans;
		if (!selectionSvc) return;
		this.selectAllFeature = compBean.createOptionalManagedBean(selectionSvc.createSelectAllFeature(this.column));
		this.selectAllFeature?.setComp(this);
		compBean.addManagedPropertyListener("rowSelection", () => {
			const selectAllFeature = selectionSvc.createSelectAllFeature(this.column);
			if (selectAllFeature && !this.selectAllFeature) {
				this.selectAllFeature = compBean.createManagedBean(selectAllFeature);
				this.selectAllFeature?.setComp(this);
				this.comp.refreshSelectAllGui();
			} else if (this.selectAllFeature && !selectAllFeature) {
				this.comp.removeSelectAllGui();
				this.selectAllFeature = this.destroyBean(this.selectAllFeature);
			}
		});
	}
	getSelectAllGui() {
		return this.selectAllFeature?.getCheckboxGui();
	}
	handleKeyDown(e) {
		super.handleKeyDown(e);
		if (e.key === KeyCode.SPACE) this.selectAllFeature?.onSpaceKeyDown(e);
		if (e.key === KeyCode.ENTER) this.onEnterKeyDown(e);
		if (e.key === KeyCode.DOWN && e.altKey) this.showMenuOnKeyPress(e, false);
	}
	onEnterKeyDown(e) {
		if (e.ctrlKey || e.metaKey) this.showMenuOnKeyPress(e, true);
		else if (this.sortable) this.beans.sortSvc?.progressSort(this.column, e.shiftKey, "uiColumnSorted");
	}
	showMenuOnKeyPress(e, isFilterShortcut) {
		const headerComp = this.comp.getUserCompInstance();
		if (!isHeaderComp(headerComp)) return;
		if (headerComp.onMenuKeyboardShortcut(isFilterShortcut)) e.preventDefault();
	}
	onFocusIn(e) {
		if (!this.eGui.contains(e.relatedTarget)) {
			this.focusThis();
			this.announceAriaDescription();
		}
		if (_isKeyboardMode()) this.setActiveHeader(true);
	}
	onFocusOut(e) {
		if (this.eGui.contains(e.relatedTarget)) return;
		this.setActiveHeader(false);
	}
	setupTooltip(value, shouldDisplayTooltip) {
		this.tooltipFeature = this.beans.tooltipSvc?.setupHeaderTooltip(this.tooltipFeature, this, value, shouldDisplayTooltip);
	}
	setupStylesFromColDef() {
		this.setRefreshFunction("headerStyles", this.refreshHeaderStyles.bind(this));
		this.refreshHeaderStyles();
	}
	setupClassesFromColDef() {
		const refreshHeaderClasses = () => {
			const classes = _getHeaderClassesFromColDef(this.column.getColDef(), this.gos, this.column, null);
			const oldClasses = this.userHeaderClasses;
			this.userHeaderClasses = new Set(classes);
			classes.forEach((c) => {
				if (oldClasses.has(c)) oldClasses.delete(c);
				else this.comp.toggleCss(c, true);
			});
			oldClasses.forEach((c) => this.comp.toggleCss(c, false));
		};
		this.setRefreshFunction("headerClasses", refreshHeaderClasses);
		refreshHeaderClasses();
	}
	setDragSource(eSource) {
		this.dragSourceElement = eSource;
		this.removeDragSource();
		if (!eSource || !this.draggable) return;
		this.dragSource = this.beans.colMoves?.setDragSourceForHeader(eSource, this.column, this.displayName) ?? null;
	}
	updateState() {
		const { menuSvc } = this.beans;
		this.menuEnabled = !!menuSvc?.isColumnMenuInHeaderEnabled(this.column);
		this.openFilterEnabled = !!menuSvc?.isFilterMenuInHeaderEnabled(this.column);
		this.sortable = this.column.isSortable();
		this.displayName = this.calculateDisplayName();
		this.draggable = this.workOutDraggable();
	}
	setRefreshFunction(name, func) {
		this.refreshFunctions[name] = func;
	}
	refresh() {
		this.updateState();
		this.refreshHeaderComp();
		this.refreshAria();
		Object.values(this.refreshFunctions).forEach((f) => f());
	}
	refreshHeaderComp() {
		const newCompDetails = this.lookupUserCompDetails();
		if (!newCompDetails) return;
		if (this.comp.getUserCompInstance() != null && this.userCompDetails.componentClass == newCompDetails.componentClass ? this.attemptHeaderCompRefresh(newCompDetails.params) : false) this.setDragSource(this.dragSourceElement);
		else this.setCompDetails(newCompDetails);
	}
	attemptHeaderCompRefresh(params) {
		const headerComp = this.comp.getUserCompInstance();
		if (!headerComp) return false;
		if (!headerComp.refresh) return false;
		return headerComp.refresh(params);
	}
	calculateDisplayName() {
		return this.beans.colNames.getDisplayNameForColumn(this.column, "header", true);
	}
	checkDisplayName() {
		if (this.displayName !== this.calculateDisplayName()) this.refresh();
	}
	workOutDraggable() {
		const colDef = this.column.getColDef();
		return !!(!this.gos.get("suppressMovableColumns") && !colDef.suppressMovable && !colDef.lockPosition) || !!colDef.enableRowGroup || !!colDef.enablePivot;
	}
	setupWidth(compBean) {
		const listener = () => {
			const columnWidth = this.column.getActualWidth();
			this.comp.setWidth(`${columnWidth}px`);
		};
		compBean.addManagedListeners(this.column, { widthChanged: listener });
		listener();
	}
	setupMovingCss(compBean) {
		const listener = () => {
			this.comp.toggleCss("ag-header-cell-moving", this.column.isMoving());
		};
		compBean.addManagedListeners(this.column, { movingChanged: listener });
		listener();
	}
	setupMenuClass(compBean) {
		const listener = () => {
			this.comp?.toggleCss("ag-column-menu-visible", this.column.isMenuVisible());
		};
		compBean.addManagedListeners(this.column, { menuVisibleChanged: listener });
		listener();
	}
	setupSortableClass(compBean) {
		const updateSortableCssClass = () => {
			this.comp.toggleCss("ag-header-cell-sortable", !!this.sortable);
		};
		updateSortableCssClass();
		this.setRefreshFunction("updateSortable", updateSortableCssClass);
		compBean.addManagedEventListeners({ sortChanged: this.refreshAriaSort.bind(this) });
	}
	setupFilterClass(compBean) {
		const listener = () => {
			const isFilterActive = this.column.isFilterActive();
			this.comp.toggleCss("ag-header-cell-filtered", isFilterActive);
			this.refreshAria();
		};
		compBean.addManagedListeners(this.column, { filterActiveChanged: listener });
		listener();
	}
	setupWrapTextClass() {
		const listener = () => {
			const wrapText = !!this.column.getColDef().wrapHeaderText;
			this.comp.toggleCss("ag-header-cell-wrap-text", wrapText);
		};
		listener();
		this.setRefreshFunction("wrapText", listener);
	}
	onHeaderHighlightChanged() {
		const highlighted = this.column.getHighlighted();
		const beforeOn = highlighted === 0;
		const afterOn = highlighted === 1;
		this.comp.toggleCss("ag-header-highlight-before", beforeOn);
		this.comp.toggleCss("ag-header-highlight-after", afterOn);
	}
	onDisplayedColumnsChanged() {
		super.onDisplayedColumnsChanged();
		if (!this.isAlive()) return;
		this.onHeaderHeightChanged();
	}
	onHeaderHeightChanged() {
		this.refreshSpanHeaderHeight();
	}
	refreshSpanHeaderHeight() {
		const { eGui, column, comp, beans } = this;
		const groupHeaderHeight = getGroupRowsHeight(this.beans);
		const isZeroGroupHeight = groupHeaderHeight.reduce((total, next) => total += next, 0) === 0;
		comp.toggleCss("ag-header-parent-hidden", isZeroGroupHeight);
		if (!column.isSpanHeaderHeight()) {
			eGui.style.removeProperty("top");
			eGui.style.removeProperty("height");
			comp.toggleCss("ag-header-span-height", false);
			comp.toggleCss("ag-header-span-total", false);
			return;
		}
		const { numberOfParents, isSpanningTotal } = this.column.getColumnGroupPaddingInfo();
		comp.toggleCss("ag-header-span-height", numberOfParents > 0);
		const headerHeight = getColumnHeaderRowHeight(beans);
		if (numberOfParents === 0) {
			comp.toggleCss("ag-header-span-total", false);
			eGui.style.setProperty("top", `0px`);
			eGui.style.setProperty("height", `${headerHeight}px`);
			return;
		}
		comp.toggleCss("ag-header-span-total", isSpanningTotal);
		const indexToStartSpanning = (this.column.getFirstRealParent()?.getLevel() ?? -1) + 1;
		const rowsToSpan = groupHeaderHeight.length - indexToStartSpanning;
		let extraHeight = 0;
		for (let i = 0; i < rowsToSpan; i++) extraHeight += groupHeaderHeight[groupHeaderHeight.length - 1 - i];
		eGui.style.setProperty("top", `${-extraHeight}px`);
		eGui.style.setProperty("height", `${headerHeight + extraHeight}px`);
	}
	refreshAriaSort() {
		if (this.sortable) {
			const translate = this.getLocaleTextFunc();
			const sort = this.beans.sortSvc?.getDisplaySortForColumn(this.column) || null;
			this.comp.setAriaSort(_getAriaSortState(sort));
			this.setAriaDescriptionProperty("sort", translate("ariaSortableColumn", "Press ENTER to sort"));
		} else {
			this.comp.setAriaSort();
			this.setAriaDescriptionProperty("sort", null);
		}
	}
	refreshAriaMenu() {
		if (this.menuEnabled) {
			const translate = this.getLocaleTextFunc();
			this.setAriaDescriptionProperty("menu", translate("ariaMenuColumn", "Press ALT DOWN to open column menu"));
		} else this.setAriaDescriptionProperty("menu", null);
	}
	refreshAriaFilterButton() {
		if (this.openFilterEnabled && !_isLegacyMenuEnabled(this.gos)) {
			const translate = this.getLocaleTextFunc();
			this.setAriaDescriptionProperty("filterButton", translate("ariaFilterColumn", "Press CTRL ENTER to open filter"));
		} else this.setAriaDescriptionProperty("filterButton", null);
	}
	refreshAriaFiltered() {
		const translate = this.getLocaleTextFunc();
		if (this.column.isFilterActive()) this.setAriaDescriptionProperty("filter", translate("ariaColumnFiltered", "Column Filtered"));
		else this.setAriaDescriptionProperty("filter", null);
	}
	setAriaDescriptionProperty(property, value) {
		if (value != null) this.ariaDescriptionProperties.set(property, value);
		else this.ariaDescriptionProperties.delete(property);
	}
	announceAriaDescription() {
		if (!this.eGui.contains(_getActiveDomElement(this.beans))) return;
		const ariaDescription = Array.from(this.ariaDescriptionProperties.keys()).sort((a, b) => a === "filter" ? -1 : b.charCodeAt(0) - a.charCodeAt(0)).map((key) => this.ariaDescriptionProperties.get(key)).join(". ");
		this.beans.ariaAnnounce?.announceValue(ariaDescription, "columnHeader");
	}
	refreshAria() {
		this.refreshAriaSort();
		this.refreshAriaMenu();
		this.refreshAriaFilterButton();
		this.refreshAriaFiltered();
	}
	addColumnHoverListener(compBean) {
		this.beans.colHover?.addHeaderColumnHoverListener(compBean, this.comp, this.column);
	}
	addActiveHeaderMouseListeners(compBean) {
		const listener = (e) => this.handleMouseOverChange(e.type === "mouseenter");
		const clickListener = () => {
			this.setActiveHeader(true);
			this.dispatchColumnMouseEvent("columnHeaderClicked", this.column);
		};
		const contextMenuListener = (event) => this.handleContextMenuMouseEvent(event, void 0, this.column);
		compBean.addManagedListeners(this.eGui, {
			mouseenter: listener,
			mouseleave: listener,
			click: clickListener,
			contextmenu: contextMenuListener
		});
	}
	handleMouseOverChange(isMouseOver) {
		this.setActiveHeader(isMouseOver);
		this.eventSvc.dispatchEvent({
			type: isMouseOver ? "columnHeaderMouseOver" : "columnHeaderMouseLeave",
			column: this.column
		});
	}
	setActiveHeader(active) {
		this.comp.toggleCss("ag-header-active", active);
	}
	getAnchorElementForMenu(isFilter) {
		const headerComp = this.comp.getUserCompInstance();
		if (isHeaderComp(headerComp)) return headerComp.getAnchorElementForMenu(isFilter);
		return this.eGui;
	}
	destroy() {
		this.tooltipFeature = this.destroyBean(this.tooltipFeature);
		super.destroy();
	}
};
function isHeaderComp(headerComp) {
	return typeof headerComp?.getAnchorElementForMenu === "function" && typeof headerComp.onMenuKeyboardShortcut === "function";
}
var instanceIdSequence5 = 0;
var HeaderRowCtrl = class extends BeanStub {
	constructor(rowIndex, pinned, type) {
		super();
		this.rowIndex = rowIndex;
		this.pinned = pinned;
		this.type = type;
		this.instanceId = instanceIdSequence5++;
		this.comp = null;
		this.allCtrls = [];
		let typeClass = "ag-header-row-column";
		if (type === "group") typeClass = "ag-header-row-group";
		else if (type === "filter") typeClass = "ag-header-row-filter";
		this.headerRowClass = `ag-header-row ${typeClass}`;
	}
	setRowIndex(rowIndex) {
		this.rowIndex = rowIndex;
		this.comp?.setRowIndex(this.getAriaRowIndex());
		this.onRowHeightChanged();
	}
	postConstruct() {
		this.isPrintLayout = _isDomLayout(this.gos, "print");
		this.isEnsureDomOrder = this.gos.get("ensureDomOrder");
	}
	areCellsRendered() {
		if (!this.comp) return false;
		return this.allCtrls.every((ctrl) => ctrl.eGui != null);
	}
	setComp(comp, compBean, initCompState = true) {
		this.comp = comp;
		compBean = setupCompBean(this, this.beans.context, compBean);
		if (initCompState) {
			this.setRowIndex(this.rowIndex);
			this.onVirtualColumnsChanged();
		}
		this.setWidth();
		this.addEventListeners(compBean);
	}
	getAriaRowIndex() {
		return this.rowIndex + 1;
	}
	addEventListeners(compBean) {
		const onHeightChanged = this.onRowHeightChanged.bind(this);
		const onDisplayedColumnsChanged = this.onDisplayedColumnsChanged.bind(this);
		compBean.addManagedEventListeners({
			columnResized: this.setWidth.bind(this),
			displayedColumnsChanged: onDisplayedColumnsChanged,
			virtualColumnsChanged: (params) => this.onVirtualColumnsChanged(params.afterScroll),
			columnGroupHeaderHeightChanged: onHeightChanged,
			columnHeaderHeightChanged: onHeightChanged,
			gridStylesChanged: onHeightChanged,
			advancedFilterEnabledChanged: onHeightChanged
		});
		compBean.addManagedPropertyListener("domLayout", onDisplayedColumnsChanged);
		compBean.addManagedPropertyListener("ensureDomOrder", (e) => this.isEnsureDomOrder = e.currentValue);
		compBean.addManagedPropertyListeners([
			"headerHeight",
			"pivotHeaderHeight",
			"groupHeaderHeight",
			"pivotGroupHeaderHeight",
			"floatingFiltersHeight"
		], onHeightChanged);
	}
	onDisplayedColumnsChanged() {
		this.isPrintLayout = _isDomLayout(this.gos, "print");
		this.onVirtualColumnsChanged();
		this.setWidth();
		this.onRowHeightChanged();
	}
	setWidth() {
		if (!this.comp) return;
		const width = this.getWidthForRow();
		this.comp.setWidth(`${width}px`);
	}
	getWidthForRow() {
		const { visibleCols } = this.beans;
		if (this.isPrintLayout) {
			if (this.pinned != null) return 0;
			return visibleCols.getContainerWidth("right") + visibleCols.getContainerWidth("left") + visibleCols.getContainerWidth(null);
		}
		return visibleCols.getContainerWidth(this.pinned);
	}
	onRowHeightChanged() {
		if (!this.comp) return;
		const { topOffset, rowHeight } = this.getTopAndHeight();
		this.comp.setTop(topOffset + "px");
		this.comp.setHeight(rowHeight + "px");
	}
	getTopAndHeight() {
		let topOffset = 0;
		const groupHeadersHeight = getGroupRowsHeight(this.beans);
		for (let i = 0; i < groupHeadersHeight.length; i++) {
			if (i === this.rowIndex && this.type === "group") return {
				topOffset,
				rowHeight: groupHeadersHeight[i]
			};
			topOffset += groupHeadersHeight[i];
		}
		const headerHeight = getColumnHeaderRowHeight(this.beans);
		if (this.type === "column") return {
			topOffset,
			rowHeight: headerHeight
		};
		topOffset += headerHeight;
		const filterHeight = getFloatingFiltersHeight(this.beans);
		return {
			topOffset,
			rowHeight: filterHeight
		};
	}
	onVirtualColumnsChanged(afterScroll = false) {
		if (!this.comp) return;
		const ctrlsToDisplay = this.getUpdatedHeaderCtrls();
		const forceOrder = this.isEnsureDomOrder || this.isPrintLayout;
		this.comp.setHeaderCtrls(ctrlsToDisplay, forceOrder, afterScroll);
	}
	getUpdatedHeaderCtrls() {
		const oldCtrls = this.ctrlsById;
		this.ctrlsById = /* @__PURE__ */ new Map();
		const columns = this.getColumnsInViewport();
		for (const child of columns) this.recycleAndCreateHeaderCtrls(child, this.ctrlsById, oldCtrls);
		const isFocusedAndDisplayed = (ctrl) => {
			const { focusSvc, visibleCols } = this.beans;
			if (!focusSvc.isHeaderWrapperFocused(ctrl)) return false;
			return visibleCols.isVisible(ctrl.column);
		};
		if (oldCtrls) for (const [id, oldCtrl] of oldCtrls) if (isFocusedAndDisplayed(oldCtrl)) this.ctrlsById.set(id, oldCtrl);
		else this.destroyBean(oldCtrl);
		this.allCtrls = Array.from(this.ctrlsById.values());
		return this.allCtrls;
	}
	getHeaderCellCtrls() {
		return this.allCtrls;
	}
	recycleAndCreateHeaderCtrls(headerColumn, currCtrls, oldCtrls) {
		if (headerColumn.isEmptyGroup()) return;
		const idOfChild = headerColumn.getUniqueId();
		let headerCtrl;
		if (oldCtrls) {
			headerCtrl = oldCtrls.get(idOfChild);
			oldCtrls.delete(idOfChild);
		}
		if (headerCtrl && headerCtrl.column != headerColumn) {
			this.destroyBean(headerCtrl);
			headerCtrl = void 0;
		}
		if (headerCtrl == null) switch (this.type) {
			case "filter":
				headerCtrl = this.createBean(this.beans.registry.createDynamicBean("headerFilterCellCtrl", true, headerColumn, this));
				break;
			case "group":
				headerCtrl = this.createBean(this.beans.registry.createDynamicBean("headerGroupCellCtrl", true, headerColumn, this));
				break;
			default:
				headerCtrl = this.createBean(new HeaderCellCtrl(headerColumn, this));
				break;
		}
		currCtrls.set(idOfChild, headerCtrl);
	}
	getColumnsInViewport() {
		if (!this.isPrintLayout) return this.getComponentsToRender();
		if (this.pinned) return [];
		const viewportColumns = [];
		[
			"left",
			null,
			"right"
		].forEach((pinned) => {
			viewportColumns.push(...this.getComponentsToRender(pinned));
		});
		return viewportColumns;
	}
	getComponentsToRender(pinned = this.pinned) {
		if (this.type === "group") return this.beans.colViewport.getHeadersToRender(pinned, this.rowIndex);
		return this.beans.colViewport.getColumnHeadersToRender(pinned);
	}
	focusHeader(column, event) {
		const ctrl = this.allCtrls.find((ctrl2) => ctrl2.column == column);
		if (!ctrl) return false;
		return ctrl.focus(event);
	}
	destroy() {
		this.allCtrls = this.destroyBeans(this.allCtrls);
		this.ctrlsById = void 0;
		this.comp = null;
		super.destroy();
	}
};
var HeaderRowContainerCtrl = class extends BeanStub {
	constructor(pinned) {
		super();
		this.pinned = pinned;
		this.hidden = false;
		this.includeFloatingFilter = false;
		this.groupsRowCtrls = [];
	}
	setComp(comp, eGui) {
		this.comp = comp;
		this.eViewport = eGui;
		const { pinnedCols, ctrlsSvc, colModel, colMoves } = this.beans;
		this.setupCenterWidth();
		pinnedCols?.setupHeaderPinnedWidth(this);
		this.setupDragAndDrop(colMoves, this.eViewport);
		const onDisplayedColsChanged = this.refresh.bind(this, true);
		this.addManagedEventListeners({
			displayedColumnsChanged: onDisplayedColsChanged,
			advancedFilterEnabledChanged: onDisplayedColsChanged
		});
		const headerType = `${typeof this.pinned === "string" ? this.pinned : "center"}Header`;
		ctrlsSvc.register(headerType, this);
		if (colModel.ready) this.refresh();
	}
	getAllCtrls() {
		const res = [...this.groupsRowCtrls];
		if (this.columnsRowCtrl) res.push(this.columnsRowCtrl);
		if (this.filtersRowCtrl) res.push(this.filtersRowCtrl);
		return res;
	}
	refresh(keepColumns = false) {
		const { focusSvc, filterManager, visibleCols } = this.beans;
		let sequence = 0;
		const focusedHeaderPosition = focusSvc.getFocusHeaderToUseAfterRefresh();
		const refreshColumnGroups = () => {
			const groupRowCount = visibleCols.headerGroupRowCount;
			sequence = groupRowCount;
			const currentGroupCount = this.groupsRowCtrls.length;
			if (currentGroupCount === groupRowCount) return;
			if (currentGroupCount > groupRowCount) {
				for (let i = groupRowCount; i < currentGroupCount; i++) this.destroyBean(this.groupsRowCtrls[i]);
				this.groupsRowCtrls.length = groupRowCount;
				return;
			}
			for (let i = currentGroupCount; i < groupRowCount; i++) {
				const ctrl = this.createBean(new HeaderRowCtrl(i, this.pinned, "group"));
				this.groupsRowCtrls.push(ctrl);
			}
		};
		const refreshColumns = () => {
			const rowIndex = sequence++;
			if (this.hidden) {
				this.columnsRowCtrl = this.destroyBean(this.columnsRowCtrl);
				return;
			}
			if (this.columnsRowCtrl == null || !keepColumns) {
				this.columnsRowCtrl = this.destroyBean(this.columnsRowCtrl);
				this.columnsRowCtrl = this.createBean(new HeaderRowCtrl(rowIndex, this.pinned, "column"));
			} else if (this.columnsRowCtrl.rowIndex !== rowIndex) this.columnsRowCtrl.setRowIndex(rowIndex);
		};
		const refreshFilters = () => {
			this.includeFloatingFilter = !!filterManager?.hasFloatingFilters() && !this.hidden;
			const destroyPreviousComp = () => {
				this.filtersRowCtrl = this.destroyBean(this.filtersRowCtrl);
			};
			if (!this.includeFloatingFilter) {
				destroyPreviousComp();
				return;
			}
			if (!keepColumns) destroyPreviousComp();
			const rowIndex = sequence++;
			if (this.filtersRowCtrl) {
				if (this.filtersRowCtrl.rowIndex !== rowIndex) this.filtersRowCtrl.setRowIndex(rowIndex);
			} else this.filtersRowCtrl = this.createBean(new HeaderRowCtrl(rowIndex, this.pinned, "filter"));
		};
		const oldCtrls = this.getAllCtrls();
		refreshColumnGroups();
		refreshColumns();
		refreshFilters();
		const allCtrls = this.getAllCtrls();
		this.comp.setCtrls(allCtrls);
		this.restoreFocusOnHeader(focusSvc, focusedHeaderPosition);
		if (oldCtrls.length !== allCtrls.length) this.beans.eventSvc.dispatchEvent({ type: "headerRowsChanged" });
	}
	getHeaderCtrlForColumn(column) {
		const findCtrl = (ctrl) => ctrl?.getHeaderCellCtrls().find((ctrl2) => ctrl2.column === column);
		if (isColumn(column)) return findCtrl(this.columnsRowCtrl);
		if (this.groupsRowCtrls.length === 0) return;
		for (let i = 0; i < this.groupsRowCtrls.length; i++) {
			const ctrl = findCtrl(this.groupsRowCtrls[i]);
			if (ctrl) return ctrl;
		}
	}
	getHtmlElementForColumnHeader(column) {
		return this.getHeaderCtrlForColumn(column)?.eGui ?? null;
	}
	getRowType(rowIndex) {
		return this.getAllCtrls()[rowIndex]?.type;
	}
	focusHeader(rowIndex, column, event) {
		const ctrl = this.getAllCtrls()[rowIndex];
		if (!ctrl) return false;
		return ctrl.focusHeader(column, event);
	}
	getGroupRowCount() {
		return this.groupsRowCtrls.length;
	}
	getGroupRowCtrlAtIndex(index) {
		return this.groupsRowCtrls[index];
	}
	getRowCount() {
		return this.groupsRowCtrls.length + (this.columnsRowCtrl ? 1 : 0) + (this.filtersRowCtrl ? 1 : 0);
	}
	setHorizontalScroll(offset) {
		this.comp.setViewportScrollLeft(offset);
	}
	onScrollCallback(fn) {
		this.addManagedElementListeners(this.eViewport, { scroll: fn });
	}
	destroy() {
		this.filtersRowCtrl = this.destroyBean(this.filtersRowCtrl);
		this.columnsRowCtrl = this.destroyBean(this.columnsRowCtrl);
		this.groupsRowCtrls = this.destroyBeans(this.groupsRowCtrls);
		super.destroy();
	}
	setupDragAndDrop(colMoves, dropContainer) {
		const bodyDropTarget = colMoves?.createBodyDropTarget(this.pinned, dropContainer);
		if (bodyDropTarget) this.createManagedBean(bodyDropTarget);
	}
	restoreFocusOnHeader(focusSvc, position) {
		if (!position) return;
		const { column } = position;
		if (column.getPinned() != this.pinned) return;
		focusSvc.focusHeaderPosition({ headerPosition: position });
	}
	setupCenterWidth() {
		if (this.pinned != null) return;
		this.createManagedBean(new CenterWidthFeature((width) => this.comp.setCenterWidth(`${width}px`), true));
	}
};
var MenuService = class extends BeanStub {
	constructor() {
		super(...arguments);
		this.beanName = "menuSvc";
	}
	postConstruct() {
		const { enterpriseMenuFactory, filterMenuFactory } = this.beans;
		this.activeMenuFactory = enterpriseMenuFactory ?? filterMenuFactory;
	}
	showColumnMenu(params) {
		this.showColumnMenuCommon(this.activeMenuFactory, params, "columnMenu");
	}
	showFilterMenu(params) {
		this.showColumnMenuCommon(getFilterMenuFactory(this.beans), params, params.containerType, true);
	}
	showHeaderContextMenu(column, mouseEvent, touchEvent) {
		this.activeMenuFactory?.showMenuAfterContextMenuEvent(column, mouseEvent, touchEvent);
	}
	hidePopupMenu() {
		this.beans.contextMenuSvc?.hideActiveMenu();
		this.activeMenuFactory?.hideActiveMenu();
	}
	hideFilterMenu() {
		getFilterMenuFactory(this.beans)?.hideActiveMenu();
	}
	isColumnMenuInHeaderEnabled(column) {
		const { suppressHeaderMenuButton } = column.getColDef();
		return !suppressHeaderMenuButton && !!this.activeMenuFactory?.isMenuEnabled(column) && (_isLegacyMenuEnabled(this.gos) || !!this.beans.enterpriseMenuFactory);
	}
	isFilterMenuInHeaderEnabled(column) {
		return !column.getColDef().suppressHeaderFilterButton && !!this.beans.filterManager?.isFilterAllowed(column);
	}
	isHeaderContextMenuEnabled(column) {
		return !(column && isColumn(column) ? column.getColDef() : column?.getColGroupDef())?.suppressHeaderContextMenu && this.gos.get("columnMenu") === "new";
	}
	isHeaderMenuButtonAlwaysShowEnabled() {
		return this.isSuppressMenuHide();
	}
	isHeaderMenuButtonEnabled() {
		const menuHides = !this.isSuppressMenuHide();
		return !(_isIOSUserAgent() && menuHides);
	}
	isHeaderFilterButtonEnabled(column) {
		return this.isFilterMenuInHeaderEnabled(column) && !_isLegacyMenuEnabled(this.gos) && !this.isFloatingFilterButtonDisplayed(column);
	}
	isFilterMenuItemEnabled(column) {
		return !!this.beans.filterManager?.isFilterAllowed(column) && !_isLegacyMenuEnabled(this.gos) && !this.isFilterMenuInHeaderEnabled(column) && !this.isFloatingFilterButtonDisplayed(column);
	}
	isFloatingFilterButtonEnabled(column) {
		return !column.getColDef().suppressFloatingFilterButton;
	}
	isFloatingFilterButtonDisplayed(column) {
		return !!column.getColDef().floatingFilter && this.isFloatingFilterButtonEnabled(column);
	}
	isSuppressMenuHide() {
		const gos = this.gos;
		const suppressMenuHide = gos.get("suppressMenuHide");
		if (_isLegacyMenuEnabled(gos)) return gos.exists("suppressMenuHide") ? suppressMenuHide : false;
		return suppressMenuHide;
	}
	showColumnMenuCommon(menuFactory, params, containerType, filtersOnly) {
		const { positionBy, onClosedCallback } = params;
		const column = params.column;
		if (positionBy === "button") {
			const { buttonElement } = params;
			menuFactory?.showMenuAfterButtonClick(column, buttonElement, containerType, onClosedCallback, filtersOnly);
		} else if (positionBy === "mouse") {
			const { mouseEvent } = params;
			menuFactory?.showMenuAfterMouseEvent(column, mouseEvent, containerType, onClosedCallback, filtersOnly);
		} else if (column) {
			const beans = this.beans;
			const ctrlsSvc = beans.ctrlsSvc;
			ctrlsSvc.getScrollFeature().ensureColumnVisible(column, "auto");
			_requestAnimationFrame(beans, () => {
				const headerCellCtrl = ctrlsSvc.getHeaderRowContainerCtrl(column.getPinned())?.getHeaderCtrlForColumn(column);
				if (headerCellCtrl) menuFactory?.showMenuAfterButtonClick(column, headerCellCtrl.getAnchorElementForMenu(filtersOnly), containerType, onClosedCallback, filtersOnly);
			});
		}
	}
};
function _setColMenuVisible(column, visible, source) {
	if (column.menuVisible !== visible) {
		column.menuVisible = visible;
		column.dispatchColEvent("menuVisibleChanged", source);
	}
}
function getFilterMenuFactory(beans) {
	const { enterpriseMenuFactory, filterMenuFactory, gos } = beans;
	return enterpriseMenuFactory && _isLegacyMenuEnabled(gos) ? enterpriseMenuFactory : filterMenuFactory;
}
var PopupComponent = class extends Component {
	isPopup() {
		return true;
	}
	setParentComponent(container) {
		container.addCss("ag-has-popup");
		super.setParentComponent(container);
	}
	destroy() {
		const parentComp = this.parentComponent;
		if (parentComp && parentComp.isAlive()) parentComp.getGui().classList.remove("ag-has-popup");
		super.destroy();
	}
};
var AgAbstractCellEditor = class extends PopupComponent {
	constructor() {
		super(...arguments);
		this.errorMessages = null;
	}
	init(params) {
		this.params = params;
		this.initialiseEditor(params);
		this.eEditor.onValueChange(() => params.validate());
	}
	destroy() {
		this.errorMessages = null;
	}
};
var OverlayComponent = class extends Component {
	constructor() {
		super();
	}
};
var LoadingOverlayElement = {
	tag: "span",
	cls: "ag-overlay-loading-center",
	attrs: {
		"aria-live": "polite",
		"aria-atomic": "true"
	}
};
var LoadingOverlayComponent2 = class extends OverlayComponent {
	init() {
		const customTemplate = _makeNull(this.gos.get("overlayLoadingTemplate")?.trim());
		this.setTemplate(customTemplate ?? LoadingOverlayElement);
		if (!customTemplate) {
			const localeTextFunc = this.getLocaleTextFunc();
			setTimeout(() => {
				this.getGui().textContent = localeTextFunc("loadingOoo", "Loading...");
			});
		}
	}
};
var NoRowsOverlayElement = {
	tag: "span",
	cls: "ag-overlay-no-rows-center"
};
var NoRowsOverlayComponent2 = class extends OverlayComponent {
	init() {
		const customTemplate = _makeNull(this.gos.get("overlayNoRowsTemplate")?.trim());
		this.setTemplate(customTemplate ?? NoRowsOverlayElement);
		if (!customTemplate) {
			const localeTextFunc = this.getLocaleTextFunc();
			setTimeout(() => {
				this.getGui().textContent = localeTextFunc("noRowsToShow", "No Rows To Show");
			});
		}
	}
};
function _createIcon(iconName, beans, column) {
	const iconContents = _createIconNoSpan(iconName, beans, column);
	if (iconContents) {
		const { className } = iconContents;
		if (typeof className === "string" && className.indexOf("ag-icon") > -1 || typeof className === "object" && className["ag-icon"]) return iconContents;
	}
	const eResult = _createElement({ tag: "span" });
	eResult.appendChild(iconContents);
	return eResult;
}
function _createIconNoSpan(iconName, beans, column) {
	let userProvidedIcon = null;
	if (iconName === "smallDown") _warn(262);
	else if (iconName === "smallLeft") _warn(263);
	else if (iconName === "smallRight") _warn(264);
	const icons = column && column.getColDef().icons;
	if (icons) userProvidedIcon = icons[iconName];
	if (beans.gos && !userProvidedIcon) {
		const optionsIcons = beans.gos.get("icons");
		if (optionsIcons) userProvidedIcon = optionsIcons[iconName];
	}
	if (userProvidedIcon) {
		let rendererResult;
		if (typeof userProvidedIcon === "function") rendererResult = userProvidedIcon();
		else if (typeof userProvidedIcon === "string") rendererResult = userProvidedIcon;
		else {
			_warn(38, { iconName });
			return;
		}
		if (typeof rendererResult === "string") return _loadTemplate(rendererResult);
		if (_isNodeOrElement(rendererResult)) return rendererResult;
		_warn(133, { iconName });
		return;
	} else {
		const iconValue = beans.registry.getIcon(iconName);
		if (!iconValue) beans.validation?.validateIcon(iconName);
		return _createElement({
			tag: "span",
			cls: `ag-icon ag-icon-${iconValue ?? iconName}`,
			role: "presentation",
			attrs: { unselectable: "on" }
		});
	}
}
var dragAndDropImageComponentCSS = `.ag-dnd-ghost{align-items:center;background-color:var(--ag-drag-and-drop-image-background-color);border:var(--ag-drag-and-drop-image-border);border-radius:var(--ag-border-radius);box-shadow:var(--ag-drag-and-drop-image-shadow);color:var(--ag-text-color);cursor:move;display:flex;font-weight:500;gap:var(--ag-cell-widget-spacing);height:var(--ag-header-height);overflow:hidden;padding-left:var(--ag-cell-horizontal-padding);padding-right:var(--ag-cell-horizontal-padding);text-overflow:ellipsis;transform:translateY(calc(var(--ag-spacing)*2));white-space:nowrap}`;
var DragAndDropElement = {
	tag: "div",
	children: [{
		tag: "div",
		ref: "eGhost",
		cls: "ag-dnd-ghost ag-unselectable",
		children: [{
			tag: "span",
			ref: "eIcon",
			cls: "ag-dnd-ghost-icon ag-shake-left-to-right"
		}, {
			tag: "div",
			ref: "eLabel",
			cls: "ag-dnd-ghost-label"
		}]
	}]
};
var DragAndDropImageComponent2 = class extends Component {
	constructor() {
		super();
		this.dragSource = null;
		this.eIcon = null;
		this.eLabel = null;
		this.eGhost = null;
		this.registerCSS(dragAndDropImageComponentCSS);
	}
	postConstruct() {
		const create = (iconName) => _createIcon(iconName, this.beans, null);
		this.dropIconMap = {
			pinned: create("columnMovePin"),
			hide: create("columnMoveHide"),
			move: create("columnMoveMove"),
			left: create("columnMoveLeft"),
			right: create("columnMoveRight"),
			group: create("columnMoveGroup"),
			aggregate: create("columnMoveValue"),
			pivot: create("columnMovePivot"),
			notAllowed: create("dropNotAllowed")
		};
	}
	init(params) {
		this.dragSource = params.dragSource;
		this.setTemplate(DragAndDropElement);
		this.beans.environment.applyThemeClasses(this.eGhost);
	}
	destroy() {
		this.dragSource = null;
		super.destroy();
	}
	setIcon(iconName, shake) {
		const { eIcon, dragSource, dropIconMap, gos } = this;
		_clearElement(eIcon);
		let eIconChild = null;
		if (!iconName) iconName = dragSource?.getDefaultIconName ? dragSource.getDefaultIconName() : "notAllowed";
		eIconChild = dropIconMap[iconName];
		eIcon.classList.toggle("ag-shake-left-to-right", shake);
		if (eIconChild === dropIconMap["hide"] && gos.get("suppressDragLeaveHidesColumns")) return;
		if (eIconChild) eIcon.appendChild(eIconChild);
	}
	setLabel(label) {
		this.eLabel.textContent = label;
	}
};
var agAbstractLabelCSS = `.ag-label{white-space:nowrap}:where(.ag-ltr) .ag-label{margin-right:var(--ag-spacing)}:where(.ag-rtl) .ag-label{margin-left:var(--ag-spacing)}:where(.ag-label-align-right) .ag-label{order:1}:where(.ag-ltr) :where(.ag-label-align-right) .ag-label{margin-left:var(--ag-spacing)}:where(.ag-rtl) :where(.ag-label-align-right) .ag-label{margin-right:var(--ag-spacing)}.ag-label-align-right>*{flex:none}.ag-label-align-top{align-items:flex-start;flex-direction:column;>*{align-self:stretch}}.ag-label-ellipsis{flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}:where(.ag-label-align-top) .ag-label{margin-bottom:calc(var(--ag-spacing)*.5)}`;
var AgAbstractLabel = class extends Component {
	constructor(config, template, components) {
		super(template, components);
		this.labelSeparator = "";
		this.labelAlignment = "left";
		this.disabled = false;
		this.label = "";
		this.config = config || {};
		this.registerCSS(agAbstractLabelCSS);
	}
	postConstruct() {
		this.addCss("ag-labeled");
		this.eLabel.classList.add("ag-label");
		const { labelSeparator, label, labelWidth, labelAlignment, disabled } = this.config;
		if (disabled != null) this.setDisabled(disabled);
		if (labelSeparator != null) this.setLabelSeparator(labelSeparator);
		if (label != null) this.setLabel(label);
		if (labelWidth != null) this.setLabelWidth(labelWidth);
		this.setLabelAlignment(labelAlignment || this.labelAlignment);
		this.refreshLabel();
	}
	refreshLabel() {
		const { label, eLabel } = this;
		_clearElement(eLabel);
		if (typeof label === "string") eLabel.innerText = label + this.labelSeparator;
		else if (label) eLabel.appendChild(label);
		if (label === "") {
			_setDisplayed(eLabel, false);
			_setAriaRole(eLabel, "presentation");
		} else {
			_setDisplayed(eLabel, true);
			_setAriaRole(eLabel, null);
		}
	}
	setLabelSeparator(labelSeparator) {
		if (this.labelSeparator === labelSeparator) return this;
		this.labelSeparator = labelSeparator;
		if (this.label != null) this.refreshLabel();
		return this;
	}
	getLabelId() {
		const eLabel = this.eLabel;
		eLabel.id = eLabel.id || `ag-${this.getCompId()}-label`;
		return eLabel.id;
	}
	getLabel() {
		return this.label;
	}
	setLabel(label) {
		if (this.label === label) return this;
		this.label = label;
		this.refreshLabel();
		return this;
	}
	setLabelAlignment(alignment) {
		const eGuiClassList = this.getGui().classList;
		eGuiClassList.toggle("ag-label-align-left", alignment === "left");
		eGuiClassList.toggle("ag-label-align-right", alignment === "right");
		eGuiClassList.toggle("ag-label-align-top", alignment === "top");
		return this;
	}
	setLabelEllipsis(hasEllipsis) {
		this.eLabel.classList.toggle("ag-label-ellipsis", hasEllipsis);
		return this;
	}
	setLabelWidth(width) {
		if (this.label == null) return this;
		_setElementWidth(this.eLabel, width);
		return this;
	}
	setDisabled(disabled) {
		disabled = !!disabled;
		const element = this.getGui();
		_setDisabled(element, disabled);
		element.classList.toggle("ag-disabled", disabled);
		this.disabled = disabled;
		return this;
	}
	isDisabled() {
		return !!this.disabled;
	}
};
var AgAbstractField = class extends AgAbstractLabel {
	constructor(config, template, components, className) {
		super(config, template, components);
		this.className = className;
	}
	postConstruct() {
		super.postConstruct();
		const { width, value, onValueChange } = this.config;
		if (width != null) this.setWidth(width);
		if (value != null) this.setValue(value);
		if (onValueChange != null) this.onValueChange(onValueChange);
		if (this.className) this.addCss(this.className);
		this.refreshAriaLabelledBy();
	}
	setLabel(label) {
		super.setLabel(label);
		this.refreshAriaLabelledBy();
		return this;
	}
	refreshAriaLabelledBy() {
		const ariaEl = this.getAriaElement();
		const labelId = this.getLabelId();
		const label = this.getLabel();
		if (label == null || label == "" || _getAriaLabel(ariaEl) !== null) _setAriaLabelledBy(ariaEl, "");
		else _setAriaLabelledBy(ariaEl, labelId ?? "");
	}
	setAriaLabel(label) {
		_setAriaLabel(this.getAriaElement(), label);
		this.refreshAriaLabelledBy();
		return this;
	}
	onValueChange(callbackFn) {
		this.addManagedListeners(this, { fieldValueChanged: () => callbackFn(this.getValue()) });
		return this;
	}
	getWidth() {
		return this.getGui().clientWidth;
	}
	setWidth(width) {
		_setFixedWidth(this.getGui(), width);
		return this;
	}
	getPreviousValue() {
		return this.previousValue;
	}
	getValue() {
		return this.value;
	}
	setValue(value, silent) {
		if (this.value === value) return this;
		this.previousValue = this.value;
		this.value = value;
		if (!silent) this.dispatchLocalEvent({ type: "fieldValueChanged" });
		return this;
	}
};
function buildTemplate(displayFieldTag) {
	return {
		tag: "div",
		role: "presentation",
		children: [{
			tag: "div",
			ref: "eLabel",
			cls: "ag-input-field-label"
		}, {
			tag: "div",
			ref: "eWrapper",
			cls: "ag-wrapper ag-input-wrapper",
			role: "presentation",
			children: [{
				tag: displayFieldTag,
				ref: "eInput",
				cls: "ag-input-field-input"
			}]
		}]
	};
}
var AgAbstractInputField = class extends AgAbstractField {
	constructor(config, className, inputType = "text", displayFieldTag = "input") {
		super(config, config?.template ?? buildTemplate(displayFieldTag), [], className);
		this.inputType = inputType;
		this.displayFieldTag = displayFieldTag;
		this.eLabel = null;
		this.eWrapper = null;
		this.eInput = null;
	}
	postConstruct() {
		super.postConstruct();
		this.setInputType(this.inputType);
		const { eLabel, eWrapper, eInput, className } = this;
		eLabel.classList.add(`${className}-label`);
		eWrapper.classList.add(`${className}-input-wrapper`);
		eInput.classList.add(`${className}-input`);
		this.addCss("ag-input-field");
		eInput.id = eInput.id || `ag-${this.getCompId()}-input`;
		const { inputName, inputWidth } = this.config;
		if (inputName != null) this.setInputName(inputName);
		if (inputWidth != null) this.setInputWidth(inputWidth);
		this.addInputListeners();
		this.activateTabIndex([eInput]);
	}
	addInputListeners() {
		this.addManagedElementListeners(this.eInput, { input: (e) => this.setValue(e.target.value) });
	}
	setInputType(inputType) {
		if (this.displayFieldTag === "input") {
			this.inputType = inputType;
			_addOrRemoveAttribute(this.eInput, "type", inputType);
		}
	}
	getInputElement() {
		return this.eInput;
	}
	setInputWidth(width) {
		_setElementWidth(this.eWrapper, width);
		return this;
	}
	setInputName(name) {
		this.getInputElement().setAttribute("name", name);
		return this;
	}
	getFocusableElement() {
		return this.eInput;
	}
	setMaxLength(length) {
		const eInput = this.eInput;
		eInput.maxLength = length;
		return this;
	}
	setInputPlaceholder(placeholder) {
		_addOrRemoveAttribute(this.eInput, "placeholder", placeholder);
		return this;
	}
	setInputAriaLabel(label) {
		_setAriaLabel(this.eInput, label);
		this.refreshAriaLabelledBy();
		return this;
	}
	setDisabled(disabled) {
		_setDisabled(this.eInput, disabled);
		return super.setDisabled(disabled);
	}
	setAutoComplete(value) {
		if (value === true) _addOrRemoveAttribute(this.eInput, "autocomplete", null);
		else {
			const autoCompleteValue = typeof value === "string" ? value : "off";
			_addOrRemoveAttribute(this.eInput, "autocomplete", autoCompleteValue);
		}
		return this;
	}
};
var AgCheckbox = class extends AgAbstractInputField {
	constructor(config, className = "ag-checkbox", inputType = "checkbox") {
		super(config, className, inputType);
		this.labelAlignment = "right";
		this.selected = false;
		this.readOnly = false;
		this.passive = false;
	}
	postConstruct() {
		super.postConstruct();
		const { readOnly, passive } = this.config;
		if (typeof readOnly === "boolean") this.setReadOnly(readOnly);
		if (typeof passive === "boolean") this.setPassive(passive);
	}
	addInputListeners() {
		this.addManagedElementListeners(this.eInput, { click: this.onCheckboxClick.bind(this) });
		this.addManagedElementListeners(this.eLabel, { click: this.toggle.bind(this) });
	}
	getNextValue() {
		return this.selected === void 0 ? true : !this.selected;
	}
	setPassive(passive) {
		this.passive = passive;
	}
	isReadOnly() {
		return this.readOnly;
	}
	setReadOnly(readOnly) {
		this.eWrapper.classList.toggle("ag-disabled", readOnly);
		this.eInput.disabled = readOnly;
		this.readOnly = readOnly;
	}
	setDisabled(disabled) {
		this.eWrapper.classList.toggle("ag-disabled", disabled);
		return super.setDisabled(disabled);
	}
	toggle() {
		if (this.eInput.disabled) return;
		const previousValue = this.isSelected();
		const nextValue = this.getNextValue();
		if (this.passive) this.dispatchChange(nextValue, previousValue);
		else this.setValue(nextValue);
	}
	getValue() {
		return this.isSelected();
	}
	setValue(value, silent) {
		this.refreshSelectedClass(value);
		this.setSelected(value, silent);
		return this;
	}
	setName(name) {
		const input = this.getInputElement();
		input.name = name;
		return this;
	}
	isSelected() {
		return this.selected;
	}
	setSelected(selected, silent) {
		if (this.isSelected() === selected) return;
		this.previousValue = this.isSelected();
		selected = this.selected = typeof selected === "boolean" ? selected : void 0;
		const eInput = this.eInput;
		eInput.checked = selected;
		eInput.indeterminate = selected === void 0;
		if (!silent) this.dispatchChange(this.selected, this.previousValue);
	}
	dispatchChange(selected, previousValue, event) {
		this.dispatchLocalEvent({
			type: "fieldValueChanged",
			selected,
			previousValue,
			event
		});
		const input = this.getInputElement();
		this.eventSvc.dispatchEvent({
			type: "checkboxChanged",
			id: input.id,
			name: input.name,
			selected,
			previousValue
		});
	}
	onCheckboxClick(e) {
		if (this.passive || this.eInput.disabled) return;
		const previousValue = this.isSelected();
		const selected = this.selected = e.target.checked;
		this.refreshSelectedClass(selected);
		this.dispatchChange(selected, previousValue, e);
	}
	refreshSelectedClass(value) {
		const classList = this.eWrapper.classList;
		classList.toggle("ag-checked", value === true);
		classList.toggle("ag-indeterminate", value == null);
	}
};
var AgCheckboxSelector = {
	selector: "AG-CHECKBOX",
	component: AgCheckbox
};
var checkboxCellRendererCSS = `.ag-checkbox-cell{height:100%}`;
var CheckboxCellRendererElement = {
	tag: "div",
	cls: "ag-cell-wrapper ag-checkbox-cell",
	role: "presentation",
	children: [{
		tag: "ag-checkbox",
		ref: "eCheckbox",
		role: "presentation"
	}]
};
var CheckboxCellRenderer = class extends Component {
	constructor() {
		super(CheckboxCellRendererElement, [AgCheckboxSelector]);
		this.eCheckbox = null;
		this.registerCSS(checkboxCellRendererCSS);
	}
	init(params) {
		this.refresh(params);
		const { eCheckbox, beans } = this;
		const inputEl = eCheckbox.getInputElement();
		inputEl.setAttribute("tabindex", "-1");
		_setAriaLive(inputEl, "polite");
		this.addManagedListeners(inputEl, {
			click: (event) => {
				_stopPropagationForAgGrid(event);
				if (eCheckbox.isDisabled()) return;
				const isSelected = eCheckbox.getValue();
				this.onCheckboxChanged(isSelected);
			},
			dblclick: (event) => {
				_stopPropagationForAgGrid(event);
			}
		});
		this.addManagedElementListeners(params.eGridCell, { keydown: (event) => {
			if (event.key === KeyCode.SPACE && !eCheckbox.isDisabled()) {
				if (params.eGridCell === _getActiveDomElement(beans)) eCheckbox.toggle();
				const isSelected = eCheckbox.getValue();
				this.onCheckboxChanged(isSelected);
				event.preventDefault();
			}
		} });
	}
	refresh(params) {
		this.params = params;
		this.updateCheckbox(params);
		return true;
	}
	updateCheckbox(params) {
		let isSelected;
		let displayed = true;
		const { value, column, node } = params;
		if (node.group && column) if (typeof value === "boolean") isSelected = value;
		else {
			const colId = column.getColId();
			if (colId.startsWith("ag-Grid-AutoColumn")) isSelected = value == null || value === "" ? void 0 : value === "true";
			else if (node.aggData && node.aggData[colId] !== void 0) isSelected = value ?? void 0;
			else displayed = false;
		}
		else isSelected = value ?? void 0;
		const { eCheckbox } = this;
		if (!displayed) {
			eCheckbox.setDisplayed(false);
			return;
		}
		eCheckbox.setValue(isSelected);
		const disabled = params.disabled ?? !column?.isCellEditable(node);
		eCheckbox.setDisabled(disabled);
		const translate = this.getLocaleTextFunc();
		const stateName = _getAriaCheckboxStateName(translate, isSelected);
		const ariaLabel = disabled ? stateName : `${translate("ariaToggleCellValue", "Press SPACE to toggle cell value")} (${stateName})`;
		eCheckbox.setInputAriaLabel(ariaLabel);
	}
	onCheckboxChanged(isSelected) {
		const { params } = this;
		const { column, node, value } = params;
		this.beans?.editSvc?.setEditingCells([{
			column,
			colId: column.getColId(),
			rowIndex: node.rowIndex,
			rowPinned: node.rowPinned,
			state: "changed",
			oldValue: value,
			newValue: value
		}], { update: true });
		const valueChanged = node.setDataValue(column, isSelected, "renderer");
		this.beans.editSvc?.stopEditing({
			rowNode: node,
			column
		}, { source: this.beans.editSvc?.isBatchEditing() ? "ui" : "api" });
		if (!valueChanged) this.updateCheckbox(params);
	}
};
var PinnedRows = class {
	constructor(beans, floating) {
		this.beans = beans;
		this.floating = floating;
		this.all = /* @__PURE__ */ new Set();
		this.visible = /* @__PURE__ */ new Set();
		this.order = [];
		this.queued = /* @__PURE__ */ new Set();
	}
	size() {
		return this.visible.size;
	}
	add(node) {
		const { all, visible, order } = this;
		if (all.has(node)) return;
		all.add(node);
		visible.add(node);
		order.push(node);
		this.sort();
	}
	delete(item) {
		this.all.delete(item);
		this.visible.delete(item);
		this.queued.delete(item.id);
		_removeFromArray(this.order, item);
	}
	has(item) {
		return this.visible.has(item);
	}
	forEach(fn) {
		this.order.forEach(fn);
	}
	getByIndex(i) {
		return this.order[i];
	}
	getById(id) {
		for (const node of this.visible) if (node.id == id) return node;
	}
	clear() {
		const { all, visible, order, queued } = this;
		all.clear();
		queued.clear();
		visible.clear();
		order.length = 0;
	}
	sort() {
		const { sortSvc, rowNodeSorter, gos } = this.beans;
		const sortOptions = sortSvc?.getSortOptions() ?? [];
		const grandTotalNode = _removeGrandTotalRow(this.order);
		this.order.sort((a, b) => (a.pinnedSibling?.rowIndex ?? 0) - (b.pinnedSibling?.rowIndex ?? 0));
		this.order = rowNodeSorter?.doFullSort(this.order, sortOptions) ?? this.order;
		if (!grandTotalNode) return;
		const grandTotalRow = _getGrandTotalRow(gos);
		if (grandTotalRow === "bottom" || grandTotalRow === "pinnedBottom") this.order.push(grandTotalNode);
		else this.order.unshift(grandTotalNode);
	}
	hide(shouldHide) {
		const { all, visible } = this;
		all.forEach((node) => shouldHide(node) ? visible.delete(node) : visible.add(node));
		this.order = Array.from(visible);
		this.sort();
	}
	queue(id) {
		this.queued.add(id);
	}
	unqueue(id) {
		this.queued.delete(id);
	}
	forEachQueued(fn) {
		this.queued.forEach(fn);
	}
};
function _isDisplayedAfterFilterCSRM(node) {
	if (node.level === -1) return true;
	const parent = node.parent;
	if (parent?.childrenAfterSort?.some((child) => child == node)) return _isDisplayedAfterFilterCSRM(parent);
	return false;
}
function _shouldHidePinnedRows(beans, node) {
	const { gos, rowModel, filterManager } = beans;
	if (_isServerSideRowModel(gos, rowModel)) return !rowModel.getRowNode(node.id);
	if (filterManager?.isAnyFilterPresent()) return !_isDisplayedAfterFilterCSRM(node);
	if (gos.get("pivotMode")) return !node.group;
	return false;
}
function _isNodeGrandTotal(node) {
	return !!node.footer && node.level === -1;
}
function _isPinnedNodeGrandTotal(node) {
	return !!node.pinnedSibling && _isNodeGrandTotal(node.pinnedSibling);
}
function _removeGrandTotalRow(order) {
	const index = order.findIndex(_isPinnedNodeGrandTotal);
	if (index > -1) return order.splice(index, 1)?.[0];
}
var ManualPinnedRowModel = class extends BeanStub {
	postConstruct() {
		const { gos, beans } = this;
		this.top = new PinnedRows(beans, "top");
		this.bottom = new PinnedRows(beans, "bottom");
		const shouldHide = (node) => _shouldHidePinnedRows(beans, node.pinnedSibling);
		const runIsRowPinned = () => {
			const isRowPinned = gos.get("isRowPinned");
			if (isRowPinned && gos.get("enableRowPinning")) beans.rowModel.forEachNode((node) => this.pinRow(node, isRowPinned(node)), true);
			this.refreshRowPositions();
			this.dispatchRowPinnedEvents();
		};
		this.addManagedEventListeners({
			gridStylesChanged: this.onGridStylesChanges.bind(this),
			modelUpdated: ({ keepRenderedRows }) => {
				this.tryToEmptyQueues();
				this.pinGrandTotalRow();
				this.forContainers((container) => container.hide(shouldHide));
				this.refreshRowPositions();
				if (!keepRenderedRows) this.dispatchRowPinnedEvents();
			},
			columnRowGroupChanged: () => {
				this.forContainers(removeGroupRows);
				this.refreshRowPositions();
			},
			rowNodeDataChanged: ({ node }) => {
				if (!(gos.get("isRowPinnable")?.(node) ?? true)) this.pinRow(node, null);
			},
			firstDataRendered: runIsRowPinned
		});
		this.addManagedPropertyListener("pivotMode", () => {
			this.forContainers((container) => container.hide(shouldHide));
			this.dispatchRowPinnedEvents();
		});
		this.addManagedPropertyListener("grandTotalRow", ({ currentValue }) => {
			this._grandTotalPinned = currentValue === "pinnedBottom" ? "bottom" : currentValue === "pinnedTop" ? "top" : null;
		});
		this.addManagedPropertyListener("isRowPinned", runIsRowPinned);
	}
	destroy() {
		this.reset(false);
		super.destroy();
	}
	reset(dispatch = true) {
		this.forContainers((container) => {
			const nodesToUnpin = [];
			container.forEach((n) => nodesToUnpin.push(n));
			nodesToUnpin.forEach((n) => this.pinRow(n, null));
			container.clear();
		});
		if (dispatch) this.dispatchRowPinnedEvents();
	}
	pinRow(rowNode, float, column) {
		if (rowNode.footer && rowNode.level > -1) return;
		if (rowNode.footer && rowNode.level === -1) {
			this._grandTotalPinned = float;
			refreshCSRM(this.beans);
			return;
		}
		const currentFloat = rowNode.rowPinned ?? rowNode.pinnedSibling?.rowPinned;
		if (currentFloat != null && float != null && float != currentFloat) {
			const pinned = rowNode.rowPinned ? rowNode : rowNode.pinnedSibling;
			const source = rowNode.rowPinned ? rowNode.pinnedSibling : rowNode;
			this.pinRow(pinned, null, column);
			this.pinRow(source, float, column);
			return;
		}
		const spannedRows = column && getSpannedRows(this.beans, rowNode, column);
		if (spannedRows) {
			spannedRows.forEach((node) => this.pinRow(node, float));
			return;
		}
		if (float == null) {
			const node = rowNode.rowPinned ? rowNode : rowNode.pinnedSibling;
			const found = this.findPinnedRowNode(node);
			if (!found) return;
			found.delete(node);
			const source = node.pinnedSibling;
			_destroyRowNodeSibling(node);
			this.refreshRowPositions(float);
			this.dispatchRowPinnedEvents(source);
		} else {
			const sibling = _createPinnedSibling(this.beans, rowNode, float);
			const container = this.getContainer(float);
			container.add(sibling);
			if (_shouldHidePinnedRows(this.beans, rowNode)) container.hide((node) => _shouldHidePinnedRows(this.beans, node.pinnedSibling));
			this.refreshRowPositions(float);
			this.dispatchRowPinnedEvents(rowNode);
		}
	}
	isManual() {
		return true;
	}
	isEmpty(floating) {
		return this.getContainer(floating).size() === 0;
	}
	isRowsToRender(floating) {
		return !this.isEmpty(floating);
	}
	ensureRowHeightsValid() {
		let anyChange = false;
		let rowTop = 0;
		const updateRowHeight = (rowNode) => {
			if (rowNode.rowHeightEstimated) {
				const rowHeight = _getRowHeightForNode(this.beans, rowNode);
				rowNode.setRowTop(rowTop);
				rowNode.setRowHeight(rowHeight.height);
				rowTop += rowHeight.height;
				anyChange = true;
			}
		};
		this.bottom.forEach(updateRowHeight);
		rowTop = 0;
		this.top.forEach(updateRowHeight);
		this.eventSvc.dispatchEvent({ type: "pinnedHeightChanged" });
		return anyChange;
	}
	getPinnedTopTotalHeight() {
		return getTotalHeight(this.top);
	}
	getPinnedBottomTotalHeight() {
		return getTotalHeight(this.bottom);
	}
	getPinnedTopRowCount() {
		return this.top.size();
	}
	getPinnedBottomRowCount() {
		return this.bottom.size();
	}
	getPinnedTopRow(index) {
		return this.top.getByIndex(index);
	}
	getPinnedBottomRow(index) {
		return this.bottom.getByIndex(index);
	}
	getPinnedRowById(id, floating) {
		return this.getContainer(floating).getById(id);
	}
	forEachPinnedRow(floating, callback) {
		this.getContainer(floating).forEach(callback);
	}
	getPinnedState() {
		const buildState = (floating) => {
			const list = [];
			this.forEachPinnedRow(floating, (node) => list.push(node.pinnedSibling.id));
			return list;
		};
		return {
			top: buildState("top"),
			bottom: buildState("bottom")
		};
	}
	setPinnedState(state) {
		this.forContainers((pinned, floating) => {
			for (const id of state[floating]) {
				const node = this.beans.rowModel.getRowNode(id);
				if (node) this.pinRow(node, floating);
				else pinned.queue(id);
			}
		});
	}
	getGrandTotalPinned() {
		return this._grandTotalPinned;
	}
	setGrandTotalPinned(value) {
		this._grandTotalPinned = value;
	}
	tryToEmptyQueues() {
		this.forContainers((pinned, container) => {
			const nodesToPin = /* @__PURE__ */ new Set();
			pinned.forEachQueued((id) => {
				const node = this.beans.rowModel.getRowNode(id);
				if (node) nodesToPin.add(node);
			});
			for (const node of nodesToPin) {
				pinned.unqueue(node.id);
				this.pinRow(node, container);
			}
		});
	}
	pinGrandTotalRow() {
		const { gos, beans, _grandTotalPinned: float } = this;
		const rowModel = beans.rowModel;
		if (!_isClientSideRowModel(gos, rowModel)) return;
		const sibling = rowModel.rootNode?.sibling;
		if (!sibling) return;
		const pinnedSibling = sibling.pinnedSibling;
		const container = pinnedSibling && this.findPinnedRowNode(pinnedSibling);
		if (!float) {
			if (!container) return;
			container.delete(pinnedSibling);
			_destroyRowNodeSibling(pinnedSibling);
		} else {
			if (container && container.floating !== float) {
				container.delete(pinnedSibling);
				_destroyRowNodeSibling(pinnedSibling);
			}
			if (!container || container.floating !== float) {
				const newPinnedSibling = _createPinnedSibling(beans, sibling, float);
				this.getContainer(float).add(newPinnedSibling);
			}
		}
	}
	onGridStylesChanges(e) {
		if (e.rowHeightChanged) this.forContainers((container) => container.forEach((rowNode) => rowNode.setRowHeight(rowNode.rowHeight, true)));
	}
	getContainer(floating) {
		return floating === "top" ? this.top : this.bottom;
	}
	findPinnedRowNode(node) {
		if (this.top.has(node)) return this.top;
		if (this.bottom.has(node)) return this.bottom;
	}
	refreshRowPositions(floating) {
		const refreshAll = (pinned) => refreshRowPositions(this.beans, pinned);
		return floating == null ? this.forContainers(refreshAll) : refreshAll(this.getContainer(floating));
	}
	forContainers(fn) {
		fn(this.top, "top");
		fn(this.bottom, "bottom");
	}
	dispatchRowPinnedEvents(node) {
		this.eventSvc.dispatchEvent({ type: "pinnedRowsChanged" });
		node?.dispatchRowEvent("rowPinned");
	}
};
function refreshRowPositions(beans, container) {
	let rowTop = 0;
	container.forEach((node, index) => {
		node.setRowTop(rowTop);
		if (node.rowHeightEstimated || node.rowHeight == null) node.setRowHeight(_getRowHeightForNode(beans, node).height);
		node.setRowIndex(index);
		rowTop += node.rowHeight;
	});
}
function _createPinnedSibling(beans, rowNode, floating) {
	if (rowNode.pinnedSibling) return rowNode.pinnedSibling;
	const sibling = _createRowNodeSibling(rowNode, beans);
	sibling.setRowTop(null);
	sibling.setRowIndex(null);
	sibling.rowPinned = floating;
	sibling.id = `${floating === "top" ? "t-" : "b-"}${floating}-${rowNode.id}`;
	sibling.pinnedSibling = rowNode;
	rowNode.pinnedSibling = sibling;
	return sibling;
}
function _destroyRowNodeSibling(rowNode) {
	if (!rowNode.pinnedSibling) return;
	rowNode.rowPinned = null;
	rowNode.setRowTop(null);
	rowNode.setRowIndex(null);
	const mainNode = rowNode.pinnedSibling;
	rowNode.pinnedSibling = void 0;
	if (mainNode) {
		mainNode.pinnedSibling = void 0;
		mainNode.rowPinned = null;
	}
}
function removeGroupRows(set) {
	const rowsToRemove = /* @__PURE__ */ new Set();
	set.forEach((node) => {
		if (node.group) rowsToRemove.add(node);
	});
	rowsToRemove.forEach((node) => set.delete(node));
}
function getSpannedRows(beans, rowNode, column) {
	const { rowSpanSvc } = beans;
	const isCellSpanning = (column && rowSpanSvc?.isCellSpanning(column, rowNode)) ?? false;
	if (column && isCellSpanning) return rowSpanSvc?.getCellSpan(column, rowNode)?.spannedNodes;
}
function getTotalHeight(container) {
	const size = container.size();
	if (size === 0) return 0;
	const node = container.getByIndex(size - 1);
	if (node === void 0) return 0;
	return node.rowTop + node.rowHeight;
}
function refreshCSRM({ gos, rowModel }) {
	if (_isClientSideRowModel(gos, rowModel)) rowModel.refreshModel({ step: "map" });
}
var StaticPinnedRowModel = class extends BeanStub {
	constructor() {
		super(...arguments);
		this.nextId = 0;
		this.pinnedTopRows = {
			cache: {},
			order: []
		};
		this.pinnedBottomRows = {
			cache: {},
			order: []
		};
	}
	postConstruct() {
		const gos = this.gos;
		this.setPinnedRowData(gos.get("pinnedTopRowData"), "top");
		this.setPinnedRowData(gos.get("pinnedBottomRowData"), "bottom");
		this.addManagedPropertyListener("pinnedTopRowData", (e) => this.setPinnedRowData(e.currentValue, "top"));
		this.addManagedPropertyListener("pinnedBottomRowData", (e) => this.setPinnedRowData(e.currentValue, "bottom"));
		this.addManagedEventListeners({ gridStylesChanged: this.onGridStylesChanges.bind(this) });
	}
	reset() {}
	isEmpty(floating) {
		return this.getCache(floating).order.length === 0;
	}
	isRowsToRender(floating) {
		return !this.isEmpty(floating);
	}
	isManual() {
		return false;
	}
	pinRow(_node, _container) {}
	onGridStylesChanges(e) {
		if (e.rowHeightChanged) {
			const estimateRowHeight = (rowNode) => {
				rowNode.setRowHeight(rowNode.rowHeight, true);
			};
			forEach(this.pinnedBottomRows, estimateRowHeight);
			forEach(this.pinnedTopRows, estimateRowHeight);
		}
	}
	ensureRowHeightsValid() {
		let anyChange = false;
		let rowTop = 0;
		const updateRowHeight = (rowNode) => {
			if (rowNode.rowHeightEstimated) {
				const rowHeight = _getRowHeightForNode(this.beans, rowNode);
				rowNode.setRowTop(rowTop);
				rowNode.setRowHeight(rowHeight.height);
				rowTop += rowHeight.height;
				anyChange = true;
			}
		};
		forEach(this.pinnedBottomRows, updateRowHeight);
		rowTop = 0;
		forEach(this.pinnedTopRows, updateRowHeight);
		this.eventSvc.dispatchEvent({ type: "pinnedHeightChanged" });
		return anyChange;
	}
	setPinnedRowData(rowData, floating) {
		this.updateNodesFromRowData(rowData, floating);
		this.eventSvc.dispatchEvent({ type: "pinnedRowDataChanged" });
	}
	updateNodesFromRowData(allData, floating) {
		const nodes = this.getCache(floating);
		if (allData === void 0) {
			nodes.order.length = 0;
			nodes.cache = {};
			return;
		}
		const getRowId = _getRowIdCallback(this.gos);
		const idPrefix = floating === "top" ? "t-" : "b-";
		const nodesToRemove = new Set(nodes.order);
		const newOrder = [];
		const dataIds = /* @__PURE__ */ new Set();
		let nextRowTop = 0;
		let i = -1;
		for (const data of allData) {
			const id = getRowId?.({
				data,
				level: 0,
				rowPinned: floating
			}) ?? idPrefix + this.nextId++;
			if (dataIds.has(id)) {
				_warn(96, {
					id,
					data
				});
				continue;
			}
			i++;
			dataIds.add(id);
			newOrder.push(id);
			const existingNode = getById(nodes, id);
			if (existingNode !== void 0) {
				if (existingNode.data !== data) existingNode.updateData(data);
				nextRowTop += this.setRowTopAndRowIndex(existingNode, nextRowTop, i);
				nodesToRemove.delete(id);
			} else {
				const rowNode = new RowNode(this.beans);
				rowNode.id = id;
				rowNode.data = data;
				rowNode.rowPinned = floating;
				nextRowTop += this.setRowTopAndRowIndex(rowNode, nextRowTop, i);
				nodes.cache[id] = rowNode;
				nodes.order.push(id);
			}
		}
		nodesToRemove.forEach((id) => {
			getById(nodes, id)?.clearRowTopAndRowIndex();
			delete nodes.cache[id];
		});
		nodes.order = newOrder;
	}
	setRowTopAndRowIndex(rowNode, rowTop, rowIndex) {
		rowNode.setRowTop(rowTop);
		rowNode.setRowHeight(_getRowHeightForNode(this.beans, rowNode).height);
		rowNode.setRowIndex(rowIndex);
		return rowNode.rowHeight;
	}
	getPinnedTopTotalHeight() {
		return getTotalHeight2(this.pinnedTopRows);
	}
	getPinnedBottomTotalHeight() {
		return getTotalHeight2(this.pinnedBottomRows);
	}
	getPinnedTopRowCount() {
		return getSize(this.pinnedTopRows);
	}
	getPinnedBottomRowCount() {
		return getSize(this.pinnedBottomRows);
	}
	getPinnedTopRow(index) {
		return getByIndex(this.pinnedTopRows, index);
	}
	getPinnedBottomRow(index) {
		return getByIndex(this.pinnedBottomRows, index);
	}
	getPinnedRowById(id, floating) {
		return getById(this.getCache(floating), id);
	}
	forEachPinnedRow(floating, callback) {
		return forEach(this.getCache(floating), callback);
	}
	getCache(floating) {
		return floating === "top" ? this.pinnedTopRows : this.pinnedBottomRows;
	}
	getPinnedState() {
		return {
			top: [],
			bottom: []
		};
	}
	setPinnedState() {}
	getGrandTotalPinned() {}
	setGrandTotalPinned() {}
};
function getTotalHeight2(rowNodes) {
	const size = getSize(rowNodes);
	if (size === 0) return 0;
	const node = getByIndex(rowNodes, size - 1);
	if (node === void 0) return 0;
	return node.rowTop + node.rowHeight;
}
function getById(cache, id) {
	return cache.cache[id];
}
function getByIndex(cache, i) {
	return getById(cache, cache.order[i]);
}
function forEach(cache, callback) {
	cache.order.forEach((id, index) => {
		const node = getById(cache, id);
		node && callback(node, index);
	});
}
function getSize(cache) {
	return cache.order.length;
}
var PinnedRowModel = class extends BeanStub {
	constructor() {
		super(...arguments);
		this.beanName = "pinnedRowModel";
	}
	postConstruct() {
		const { gos } = this;
		const initialiseRowModel = () => {
			const enableRowPinning = gos.get("enableRowPinning");
			const grandTotalRow = _getGrandTotalRow(gos);
			const useManualPinnedRowModel = !!enableRowPinning || grandTotalRow === "pinnedBottom" || grandTotalRow === "pinnedTop";
			const shouldDestroy = useManualPinnedRowModel ? this.inner instanceof StaticPinnedRowModel : this.inner instanceof ManualPinnedRowModel;
			if (this.inner && shouldDestroy) this.destroyBean(this.inner);
			if (shouldDestroy || !this.inner) this.inner = this.createManagedBean(useManualPinnedRowModel ? new ManualPinnedRowModel() : new StaticPinnedRowModel());
		};
		this.addManagedPropertyListeners(["enableRowPinning", "grandTotalRow"], initialiseRowModel);
		initialiseRowModel();
	}
	reset() {
		return this.inner.reset();
	}
	isEmpty(container) {
		return this.inner.isEmpty(container);
	}
	isManual() {
		return this.inner.isManual();
	}
	isRowsToRender(container) {
		return this.inner.isRowsToRender(container);
	}
	pinRow(node, container, column) {
		return this.inner.pinRow(node, container, column);
	}
	ensureRowHeightsValid() {
		return this.inner.ensureRowHeightsValid();
	}
	getPinnedRowById(id, container) {
		return this.inner.getPinnedRowById(id, container);
	}
	getPinnedTopTotalHeight() {
		return this.inner.getPinnedTopTotalHeight();
	}
	getPinnedBottomTotalHeight() {
		return this.inner.getPinnedBottomTotalHeight();
	}
	getPinnedTopRowCount() {
		return this.inner.getPinnedTopRowCount();
	}
	getPinnedBottomRowCount() {
		return this.inner.getPinnedBottomRowCount();
	}
	getPinnedTopRow(index) {
		return this.inner.getPinnedTopRow(index);
	}
	getPinnedBottomRow(index) {
		return this.inner.getPinnedBottomRow(index);
	}
	forEachPinnedRow(container, callback) {
		return this.inner.forEachPinnedRow(container, callback);
	}
	getPinnedState() {
		return this.inner.getPinnedState();
	}
	setPinnedState(state) {
		return this.inner.setPinnedState(state);
	}
	setGrandTotalPinned(value) {
		return this.inner.setGrandTotalPinned(value);
	}
	getGrandTotalPinned() {
		return this.inner.getGrandTotalPinned();
	}
};
var ROOT_NODE_ID = "ROOT_NODE_ID";
var AbstractClientSideNodeManager = class extends BeanStub {
	constructor() {
		super(...arguments);
		this.nextId = 0;
		this.allNodesMap = {};
		this.rootNode = null;
	}
	getRowNode(id) {
		return this.allNodesMap[id];
	}
	extractRowData() {
		return this.rootNode?.allLeafChildren?.map((node) => node.data);
	}
	activate(rootNode) {
		this.rootNode = rootNode;
		rootNode.group = true;
		rootNode.level = -1;
		rootNode.id = ROOT_NODE_ID;
		rootNode.allLeafChildren = [];
		rootNode.childrenAfterGroup = [];
		rootNode.childrenAfterSort = [];
		rootNode.childrenAfterAggFilter = [];
		rootNode.childrenAfterFilter = [];
		this.updateRootSiblingArrays(rootNode);
	}
	deactivate() {
		if (this.rootNode) {
			this.allNodesMap = {};
			this.rootNode = null;
		}
	}
	destroy() {
		super.destroy();
		this.allNodesMap = {};
		this.rootNode = null;
	}
	setNewRowData(rowData) {
		const rootNode = this.rootNode;
		if (!rootNode) return;
		this.dispatchRowDataUpdateStartedEvent(rowData);
		rootNode.childrenAfterFilter = null;
		rootNode.childrenAfterGroup = null;
		rootNode.childrenAfterAggFilter = null;
		rootNode.childrenAfterSort = null;
		rootNode.childrenMapped = null;
		rootNode.updateHasChildren();
		this.allNodesMap = {};
		this.nextId = 0;
		this.loadNewRowData(rowData);
		this.updateRootSiblingArrays(rootNode);
	}
	updateRootSiblingArrays(rootNode) {
		const sibling = rootNode.sibling;
		if (sibling) {
			sibling.childrenAfterFilter = rootNode.childrenAfterFilter;
			sibling.childrenAfterGroup = rootNode.childrenAfterGroup;
			sibling.childrenAfterAggFilter = rootNode.childrenAfterAggFilter;
			sibling.childrenAfterSort = rootNode.childrenAfterSort;
			sibling.childrenMapped = rootNode.childrenMapped;
			sibling.allLeafChildren = rootNode.allLeafChildren;
		}
	}
	loadNewRowData(rowData) {
		this.rootNode.allLeafChildren = rowData?.map((dataItem, index) => this.createRowNode(dataItem, index)) ?? [];
	}
	setImmutableRowData(params, rowData) {
		const getRowIdFunc = _getRowIdCallback(this.gos);
		const reorder = !this.gos.get("suppressMaintainUnsortedOrder");
		const changedRowNodes = params.changedRowNodes;
		const processedNodes = /* @__PURE__ */ new Set();
		const rootNode = this.rootNode;
		const oldAllLeafChildren = rootNode.allLeafChildren;
		const oldAllLeafChildrenLen = oldAllLeafChildren.length;
		let nodesAdded = false;
		let nodesRemoved = false;
		let nodesUpdated = false;
		let orderChanged = false;
		for (let i = 0, prevSourceRowIndex = -1, len = rowData.length; i < len; i++) {
			const data = rowData[i];
			let node = this.getRowNode(getRowIdFunc({
				data,
				level: 0
			}));
			if (!node) {
				nodesAdded = true;
				node = this.createRowNode(data, -1);
				changedRowNodes.add(node);
			} else {
				if (reorder) {
					const sourceRowIndex = node.sourceRowIndex;
					orderChanged || (orderChanged = sourceRowIndex <= prevSourceRowIndex || nodesAdded);
					prevSourceRowIndex = sourceRowIndex;
				}
				if (node.data !== data) {
					nodesUpdated = true;
					node.updateData(data);
					changedRowNodes.update(node);
				}
			}
			processedNodes.add(node);
		}
		const nodesToUnselect = [];
		for (let i = 0; i < oldAllLeafChildrenLen; i++) {
			const node = oldAllLeafChildren[i];
			if (!processedNodes.has(node)) {
				nodesRemoved = true;
				if (node.isSelected()) nodesToUnselect.push(node);
				if (node.pinnedSibling) this.beans.pinnedRowModel?.pinRow(node.pinnedSibling, null);
				this.rowNodeDeleted(node);
				changedRowNodes.remove(node);
			}
		}
		if (nodesAdded || nodesRemoved || orderChanged) {
			const newAllLeafChildren = new Array(processedNodes.size);
			let writeIdx = 0;
			if (!reorder) for (let i = 0; i < oldAllLeafChildrenLen; ++i) {
				const node = oldAllLeafChildren[i];
				if (processedNodes.delete(node)) {
					node.sourceRowIndex = writeIdx;
					newAllLeafChildren[writeIdx++] = node;
				}
			}
			for (const node of processedNodes) {
				node.sourceRowIndex = writeIdx;
				newAllLeafChildren[writeIdx++] = node;
			}
			rootNode.allLeafChildren = newAllLeafChildren;
			const sibling = rootNode.sibling;
			if (sibling) sibling.allLeafChildren = newAllLeafChildren;
			params.rowNodesOrderChanged || (params.rowNodesOrderChanged = orderChanged);
		}
		if (nodesAdded || nodesRemoved || orderChanged || nodesUpdated) {
			this.deselectNodes(nodesToUnselect);
			params.rowDataUpdated = true;
		}
	}
	rowNodeDeleted(node) {
		node.clearRowTopAndRowIndex();
		const id = node.id;
		const allNodesMap = this.allNodesMap;
		if (allNodesMap[id] === node) delete allNodesMap[id];
	}
	updateRowData(rowDataTran, changedRowNodes) {
		this.dispatchRowDataUpdateStartedEvent(rowDataTran.add);
		const updateRowDataResult = {
			changedRowNodes,
			rowNodeTransaction: {
				remove: [],
				update: [],
				add: []
			},
			rowsInserted: false
		};
		const nodesToUnselect = [];
		const getRowIdFunc = _getRowIdCallback(this.gos);
		this.executeRemove(getRowIdFunc, rowDataTran, updateRowDataResult, nodesToUnselect);
		this.executeUpdate(getRowIdFunc, rowDataTran, updateRowDataResult, nodesToUnselect);
		this.executeAdd(rowDataTran, updateRowDataResult);
		this.deselectNodes(nodesToUnselect);
		return updateRowDataResult;
	}
	executeAdd(rowDataTran, result) {
		const add = rowDataTran.add;
		if (!add?.length) return;
		let allLeafChildren = this.rootNode.allLeafChildren;
		let addIndex = allLeafChildren.length;
		if (typeof rowDataTran.addIndex === "number") {
			addIndex = this.sanitizeAddIndex(rowDataTran.addIndex);
			if (addIndex > 0) {
				if (this.gos.get("treeData") && this.gos.get("getDataPath")) {
					for (let i = 0; i < allLeafChildren.length; i++) if (allLeafChildren[i]?.rowIndex == addIndex - 1) {
						addIndex = i + 1;
						break;
					}
				}
			}
		}
		const addLength = add.length;
		const changedRowNodes = result.changedRowNodes;
		const newNodes = new Array(addLength);
		for (let i = 0; i < addLength; i++) {
			const newNode = this.createRowNode(add[i], addIndex + i);
			changedRowNodes.add(newNode);
			newNodes[i] = newNode;
		}
		const rootNode = this.rootNode;
		if (addIndex < allLeafChildren.length) {
			const nodesBeforeIndex = allLeafChildren.slice(0, addIndex);
			const nodesAfterIndex = allLeafChildren.slice(addIndex, allLeafChildren.length);
			const nodesAfterIndexFirstIndex = nodesBeforeIndex.length + newNodes.length;
			for (let index = 0, length = nodesAfterIndex.length; index < length; ++index) nodesAfterIndex[index].sourceRowIndex = nodesAfterIndexFirstIndex + index;
			allLeafChildren = [
				...nodesBeforeIndex,
				...newNodes,
				...nodesAfterIndex
			];
			result.rowsInserted = true;
		} else allLeafChildren = allLeafChildren.concat(newNodes);
		rootNode.allLeafChildren = allLeafChildren;
		const sibling = rootNode.sibling;
		if (sibling) sibling.allLeafChildren = allLeafChildren;
		result.rowNodeTransaction.add = newNodes;
	}
	executeRemove(getRowIdFunc, rowDataTran, { changedRowNodes, rowNodeTransaction }, nodesToUnselect) {
		const { remove } = rowDataTran;
		if (!remove?.length) return;
		const rowIdsRemoved = {};
		remove.forEach((item) => {
			const rowNode = this.lookupRowNode(getRowIdFunc, item);
			if (!rowNode) return;
			if (rowNode.isSelected()) nodesToUnselect.push(rowNode);
			if (rowNode.pinnedSibling) this.beans.pinnedRowModel?.pinRow(rowNode.pinnedSibling, null);
			rowNode.clearRowTopAndRowIndex();
			rowIdsRemoved[rowNode.id] = true;
			delete this.allNodesMap[rowNode.id];
			rowNodeTransaction.remove.push(rowNode);
			changedRowNodes.remove(rowNode);
		});
		const rootNode = this.rootNode;
		rootNode.allLeafChildren = rootNode.allLeafChildren?.filter((rowNode) => !rowIdsRemoved[rowNode.id]) ?? null;
		rootNode.allLeafChildren?.forEach((node, idx) => {
			node.sourceRowIndex = idx;
		});
		const sibling = rootNode.sibling;
		if (sibling) sibling.allLeafChildren = rootNode.allLeafChildren;
	}
	executeUpdate(getRowIdFunc, rowDataTran, { changedRowNodes, rowNodeTransaction }, nodesToUnselect) {
		const { update } = rowDataTran;
		if (!update?.length) return;
		update.forEach((item) => {
			const rowNode = this.lookupRowNode(getRowIdFunc, item);
			if (!rowNode) return;
			rowNode.updateData(item);
			if (!rowNode.selectable && rowNode.isSelected()) nodesToUnselect.push(rowNode);
			rowNodeTransaction.update.push(rowNode);
			changedRowNodes.update(rowNode);
		});
	}
	dispatchRowDataUpdateStartedEvent(rowData) {
		this.eventSvc.dispatchEvent({
			type: "rowDataUpdateStarted",
			firstRowData: rowData?.length ? rowData[0] : null
		});
	}
	deselectNodes(nodesToUnselect) {
		const source = "rowDataChanged";
		const selectionSvc = this.beans.selectionSvc;
		const selectionChanged = nodesToUnselect.length > 0;
		if (selectionChanged) selectionSvc?.setNodesSelected({
			newValue: false,
			nodes: nodesToUnselect,
			suppressFinishActions: true,
			source
		});
		selectionSvc?.updateGroupsFromChildrenSelections?.(source);
		if (selectionChanged) this.eventSvc.dispatchEvent({
			type: "selectionChanged",
			source,
			selectedNodes: selectionSvc?.getSelectedNodes() ?? null,
			serverSideState: null
		});
	}
	sanitizeAddIndex(addIndex) {
		const allChildrenCount = this.rootNode.allLeafChildren?.length ?? 0;
		if (addIndex < 0 || addIndex >= allChildrenCount || Number.isNaN(addIndex)) return allChildrenCount;
		return Math.ceil(addIndex);
	}
	createRowNode(data, sourceRowIndex) {
		const node = new RowNode(this.beans);
		node.parent = this.rootNode;
		node.level = 0;
		node.group = false;
		node.expanded = false;
		node.sourceRowIndex = sourceRowIndex;
		node.setDataAndId(data, String(this.nextId));
		if (this.allNodesMap[node.id]) _warn(2, { nodeId: node.id });
		this.allNodesMap[node.id] = node;
		this.nextId++;
		return node;
	}
	lookupRowNode(getRowIdFunc, data) {
		let rowNode;
		if (getRowIdFunc) {
			const id = getRowIdFunc({
				data,
				level: 0
			});
			rowNode = this.allNodesMap[id];
			if (!rowNode) {
				_error(4, { id });
				return null;
			}
		} else {
			rowNode = this.rootNode?.allLeafChildren?.find((node) => node.data === data);
			if (!rowNode) {
				_error(5, { data });
				return null;
			}
		}
		return rowNode || null;
	}
};
var CheckboxSelectionComponentElement = {
	tag: "div",
	cls: "ag-selection-checkbox",
	role: "presentation",
	children: [{
		tag: "ag-checkbox",
		ref: "eCheckbox",
		role: "presentation"
	}]
};
var CheckboxSelectionComponent = class extends Component {
	constructor() {
		super(CheckboxSelectionComponentElement, [AgCheckboxSelector]);
		this.eCheckbox = null;
	}
	postConstruct() {
		this.eCheckbox.setPassive(true);
	}
	onDataChanged() {
		this.onSelectionChanged();
	}
	onSelectableChanged() {
		this.showOrHideSelect();
	}
	onSelectionChanged() {
		const translate = this.getLocaleTextFunc();
		const { rowNode, eCheckbox } = this;
		const state = rowNode.isSelected();
		const stateName = _getAriaCheckboxStateName(translate, state);
		const [ariaKey, ariaLabel] = rowNode.selectable ? ["ariaRowToggleSelection", "Press Space to toggle row selection"] : ["ariaRowSelectionDisabled", "Row Selection is disabled for this row"];
		const translatedLabel = translate(ariaKey, ariaLabel);
		eCheckbox.setValue(state, true);
		eCheckbox.setInputAriaLabel(`${translatedLabel} (${stateName})`);
	}
	init(params) {
		this.rowNode = params.rowNode;
		this.column = params.column;
		this.overrides = params.overrides;
		this.onSelectionChanged();
		this.addManagedListeners(this.eCheckbox.getInputElement(), {
			dblclick: _stopPropagationForAgGrid,
			click: (event) => {
				_stopPropagationForAgGrid(event);
				this.beans.selectionSvc?.handleSelectionEvent(event, this.rowNode, "checkboxSelected");
			}
		});
		this.addManagedListeners(this.rowNode, {
			rowSelected: this.onSelectionChanged.bind(this),
			dataChanged: this.onDataChanged.bind(this),
			selectableChanged: this.onSelectableChanged.bind(this)
		});
		this.addManagedPropertyListener("rowSelection", ({ currentValue, previousValue }) => {
			if ((typeof currentValue === "object" ? _getHideDisabledCheckboxes(currentValue) : void 0) !== (typeof previousValue === "object" ? _getHideDisabledCheckboxes(previousValue) : void 0)) this.onSelectableChanged();
		});
		if (_getIsRowSelectable(this.gos) || typeof this.getIsVisible() === "function") {
			const showOrHideSelectListener = this.showOrHideSelect.bind(this);
			this.addManagedEventListeners({ displayedColumnsChanged: showOrHideSelectListener });
			this.addManagedListeners(this.rowNode, {
				dataChanged: showOrHideSelectListener,
				cellChanged: showOrHideSelectListener
			});
			this.showOrHideSelect();
		}
		this.eCheckbox.getInputElement().setAttribute("tabindex", "-1");
	}
	showOrHideSelect() {
		const { column, rowNode, overrides, gos } = this;
		const selectable = rowNode.selectable;
		const isVisible = this.getIsVisible();
		let checkboxes = void 0;
		if (typeof isVisible === "function") {
			const extraParams = overrides?.callbackParams;
			if (!column) checkboxes = isVisible({
				...extraParams,
				node: rowNode,
				data: rowNode.data
			});
			else {
				const params = column.createColumnFunctionCallbackParams(rowNode);
				checkboxes = isVisible({
					...extraParams,
					...params
				});
			}
		} else checkboxes = isVisible ?? false;
		const disabled = selectable && !checkboxes || !selectable && checkboxes;
		const visible = selectable || checkboxes;
		const so = gos.get("rowSelection");
		const showDisabledCheckboxes = so && typeof so !== "string" ? !_getHideDisabledCheckboxes(so) : !!column?.getColDef().showDisabledCheckboxes;
		this.setVisible(visible && (disabled ? showDisabledCheckboxes : true));
		this.setDisplayed(visible && (disabled ? showDisabledCheckboxes : true));
		if (visible) this.eCheckbox.setDisabled(disabled);
		if (overrides?.removeHidden) {
			this.setDisplayed(visible);
			return;
		}
	}
	getIsVisible() {
		const overrides = this.overrides;
		if (overrides) return overrides.isVisible;
		const so = this.gos.get("rowSelection");
		if (so && typeof so !== "string") return _getCheckboxes(so);
		return this.column?.getColDef()?.checkboxSelection;
	}
};
var RowRangeSelectionContext = class {
	constructor(rowModel, pinnedRowModel) {
		this.rowModel = rowModel;
		this.pinnedRowModel = pinnedRowModel;
		this.selectAll = false;
		this.rootId = null;
		this.endId = null;
		this.cachedRange = [];
	}
	reset() {
		this.rootId = null;
		this.endId = null;
		this.cachedRange.length = 0;
	}
	setRoot(node) {
		this.rootId = node.id;
		this.endId = null;
		this.cachedRange.length = 0;
	}
	setEndRange(end) {
		this.endId = end.id;
		this.cachedRange.length = 0;
	}
	getRange() {
		if (this.cachedRange.length === 0) {
			const root = this.getRoot();
			const end = this.getEnd();
			if (root == null || end == null) return this.cachedRange;
			this.cachedRange = this.getNodesInRange(root, end) ?? [];
		}
		return this.cachedRange;
	}
	isInRange(node) {
		if (this.rootId === null) return false;
		return this.getRange().some((nodeInRange) => nodeInRange.id === node.id);
	}
	getRoot(fallback) {
		if (this.rootId) return this.getRowNode(this.rootId);
		if (fallback) {
			this.setRoot(fallback);
			return fallback;
		}
	}
	getEnd() {
		if (this.endId) return this.getRowNode(this.endId);
	}
	getRowNode(id) {
		let node;
		const { rowModel, pinnedRowModel } = this;
		node ?? (node = rowModel.getRowNode(id));
		if (pinnedRowModel?.isManual()) {
			node ?? (node = pinnedRowModel.getPinnedRowById(id, "top"));
			node ?? (node = pinnedRowModel.getPinnedRowById(id, "bottom"));
		}
		return node;
	}
	truncate(node) {
		const range = this.getRange();
		if (range.length === 0) return {
			keep: [],
			discard: []
		};
		const discardAfter = range[0].id === this.rootId;
		const idx = range.findIndex((rowNode) => rowNode.id === node.id);
		if (idx > -1) {
			const above = range.slice(0, idx);
			const below = range.slice(idx + 1);
			this.setEndRange(node);
			return discardAfter ? {
				keep: above,
				discard: below
			} : {
				keep: below,
				discard: above
			};
		} else return {
			keep: range,
			discard: []
		};
	}
	extend(node, groupSelectsChildren = false) {
		const root = this.getRoot();
		if (root == null) {
			const keep = this.getRange().slice();
			if (groupSelectsChildren) node.depthFirstSearch((node2) => !node2.group && keep.push(node2));
			keep.push(node);
			this.setRoot(node);
			return {
				keep,
				discard: []
			};
		}
		const newRange = this.getNodesInRange(root, node);
		if (!newRange) {
			this.setRoot(node);
			return {
				keep: [node],
				discard: []
			};
		}
		if (newRange.find((newRangeNode) => newRangeNode.id === this.endId)) {
			this.setEndRange(node);
			return {
				keep: this.getRange(),
				discard: []
			};
		} else {
			const discard = this.getRange().slice();
			this.setEndRange(node);
			return {
				keep: this.getRange(),
				discard
			};
		}
	}
	getNodesInRange(start, end) {
		const { pinnedRowModel, rowModel } = this;
		if (!pinnedRowModel?.isManual()) return rowModel.getNodesInRangeForSelection(start, end);
		if (start.rowPinned === "top" && !end.rowPinned) return _getNodesInRangeForSelection(pinnedRowModel, "top", start, void 0).concat(rowModel.getNodesInRangeForSelection(rowModel.getRow(0), end) ?? []);
		if (start.rowPinned === "bottom" && !end.rowPinned) {
			const pinnedRange = _getNodesInRangeForSelection(pinnedRowModel, "bottom", void 0, start);
			const count = rowModel.getRowCount();
			const lastMain = rowModel.getRow(count - 1);
			return (rowModel.getNodesInRangeForSelection(end, lastMain) ?? []).concat(pinnedRange);
		}
		if (!start.rowPinned && !end.rowPinned) return rowModel.getNodesInRangeForSelection(start, end);
		if (start.rowPinned === "top" && end.rowPinned === "top") return _getNodesInRangeForSelection(pinnedRowModel, "top", start, end);
		if (start.rowPinned === "bottom" && end.rowPinned === "top") {
			const top = _getNodesInRangeForSelection(pinnedRowModel, "top", end, void 0);
			const bottom = _getNodesInRangeForSelection(pinnedRowModel, "bottom", void 0, start);
			const first = rowModel.getRow(0);
			const last = rowModel.getRow(rowModel.getRowCount() - 1);
			return top.concat(rowModel.getNodesInRangeForSelection(first, last) ?? []).concat(bottom);
		}
		if (!start.rowPinned && end.rowPinned === "top") return _getNodesInRangeForSelection(pinnedRowModel, "top", end, void 0).concat(rowModel.getNodesInRangeForSelection(rowModel.getRow(0), start) ?? []);
		if (start.rowPinned === "top" && end.rowPinned === "bottom") {
			const top = _getNodesInRangeForSelection(pinnedRowModel, "top", start, void 0);
			const bottom = _getNodesInRangeForSelection(pinnedRowModel, "bottom", void 0, end);
			const first = rowModel.getRow(0);
			const last = rowModel.getRow(rowModel.getRowCount() - 1);
			return top.concat(rowModel.getNodesInRangeForSelection(first, last) ?? []).concat(bottom);
		}
		if (start.rowPinned === "bottom" && end.rowPinned === "bottom") return _getNodesInRangeForSelection(pinnedRowModel, "bottom", start, end);
		if (!start.rowPinned && end.rowPinned === "bottom") {
			const pinned = _getNodesInRangeForSelection(pinnedRowModel, "bottom", void 0, end);
			const last = rowModel.getRow(rowModel.getRowCount());
			return (rowModel.getNodesInRangeForSelection(start, last) ?? []).concat(pinned);
		}
		return null;
	}
};
var SelectAllFeature = class extends BeanStub {
	constructor(column) {
		super();
		this.column = column;
		this.cbSelectAllVisible = false;
		this.processingEventFromCheckbox = false;
	}
	onSpaceKeyDown(e) {
		const checkbox = this.cbSelectAll;
		if (checkbox.isDisplayed() && !checkbox.getGui().contains(_getActiveDomElement(this.beans))) {
			e.preventDefault();
			checkbox.setValue(!checkbox.getValue());
		}
	}
	getCheckboxGui() {
		return this.cbSelectAll.getGui();
	}
	setComp(ctrl) {
		this.headerCellCtrl = ctrl;
		const cbSelectAll = this.createManagedBean(new AgCheckbox());
		this.cbSelectAll = cbSelectAll;
		cbSelectAll.addCss("ag-header-select-all");
		_setAriaRole(cbSelectAll.getGui(), "presentation");
		this.showOrHideSelectAll();
		const updateStateOfCheckbox = this.updateStateOfCheckbox.bind(this);
		this.addManagedEventListeners({
			newColumnsLoaded: () => this.showOrHideSelectAll(),
			displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this),
			selectionChanged: updateStateOfCheckbox,
			paginationChanged: updateStateOfCheckbox,
			modelUpdated: updateStateOfCheckbox
		});
		this.addManagedPropertyListener("rowSelection", ({ currentValue, previousValue }) => {
			const getSelectAll = (rowSelection) => typeof rowSelection === "string" || !rowSelection || rowSelection.mode === "singleRow" ? void 0 : rowSelection.selectAll;
			if (getSelectAll(currentValue) !== getSelectAll(previousValue)) this.showOrHideSelectAll();
			this.updateStateOfCheckbox();
		});
		this.addManagedListeners(cbSelectAll, { fieldValueChanged: this.onCbSelectAll.bind(this) });
		cbSelectAll.getInputElement().setAttribute("tabindex", "-1");
		this.refreshSelectAllLabel();
	}
	onDisplayedColumnsChanged(e) {
		if (!this.isAlive()) return;
		this.showOrHideSelectAll(e.source === "uiColumnMoved");
	}
	showOrHideSelectAll(fromColumnMoved = false) {
		const cbSelectAllVisible = this.isCheckboxSelection();
		this.cbSelectAllVisible = cbSelectAllVisible;
		this.cbSelectAll.setDisplayed(cbSelectAllVisible);
		if (cbSelectAllVisible) {
			this.checkRightRowModelType("selectAllCheckbox");
			this.checkSelectionType("selectAllCheckbox");
			this.updateStateOfCheckbox();
		}
		this.refreshSelectAllLabel(fromColumnMoved);
	}
	updateStateOfCheckbox() {
		if (!this.cbSelectAllVisible || this.processingEventFromCheckbox) return;
		this.processingEventFromCheckbox = true;
		const selectAllMode = this.getSelectAllMode();
		const selectionSvc = this.beans.selectionSvc;
		const cbSelectAll = this.cbSelectAll;
		const allSelected = selectionSvc.getSelectAllState(selectAllMode);
		cbSelectAll.setValue(allSelected);
		const hasNodesToSelect = selectionSvc.hasNodesToSelect(selectAllMode);
		cbSelectAll.setDisabled(!hasNodesToSelect);
		this.refreshSelectAllLabel();
		this.processingEventFromCheckbox = false;
	}
	refreshSelectAllLabel(fromColumnMoved = false) {
		const translate = this.getLocaleTextFunc();
		const { headerCellCtrl, cbSelectAll, cbSelectAllVisible } = this;
		const ariaStatus = _getAriaCheckboxStateName(translate, cbSelectAll.getValue());
		const ariaLabel = translate("ariaRowSelectAll", "Press Space to toggle all rows selection");
		headerCellCtrl.setAriaDescriptionProperty("selectAll", cbSelectAllVisible ? `${ariaLabel} (${ariaStatus})` : null);
		cbSelectAll.setInputAriaLabel(translate("ariaHeaderSelection", "Column with Header Selection"));
		if (!fromColumnMoved) headerCellCtrl.announceAriaDescription();
	}
	checkSelectionType(feature) {
		if (!_isMultiRowSelection(this.gos)) {
			_warn(128, { feature });
			return false;
		}
		return true;
	}
	checkRightRowModelType(feature) {
		const { gos, rowModel } = this.beans;
		if (!(_isClientSideRowModel(gos) || _isServerSideRowModel(gos))) {
			_warn(129, {
				feature,
				rowModel: rowModel.getType()
			});
			return false;
		}
		return true;
	}
	onCbSelectAll() {
		if (this.processingEventFromCheckbox) return;
		if (!this.cbSelectAllVisible) return;
		const value = this.cbSelectAll.getValue();
		const selectAll2 = this.getSelectAllMode();
		let source = "uiSelectAll";
		if (selectAll2 === "currentPage") source = "uiSelectAllCurrentPage";
		else if (selectAll2 === "filtered") source = "uiSelectAllFiltered";
		const params = {
			source,
			selectAll: selectAll2
		};
		const selectionSvc = this.beans.selectionSvc;
		if (value) selectionSvc.selectAllRowNodes(params);
		else selectionSvc.deselectAllRowNodes(params);
	}
	isCheckboxSelection() {
		const { column, gos, beans } = this;
		const featureName = typeof gos.get("rowSelection") === "object" ? "headerCheckbox" : "headerCheckboxSelection";
		return isCheckboxSelection(beans, column) && this.checkRightRowModelType(featureName) && this.checkSelectionType(featureName);
	}
	getSelectAllMode() {
		const selectAll2 = _getSelectAll(this.gos, false);
		if (selectAll2) return selectAll2;
		const { headerCheckboxSelectionCurrentPageOnly, headerCheckboxSelectionFilteredOnly } = this.column.getColDef();
		if (headerCheckboxSelectionCurrentPageOnly) return "currentPage";
		if (headerCheckboxSelectionFilteredOnly) return "filtered";
		return "all";
	}
	destroy() {
		super.destroy();
		this.cbSelectAll = void 0;
		this.headerCellCtrl = void 0;
	}
};
function isCheckboxSelection({ gos, selectionColSvc }, column) {
	const rowSelection = gos.get("rowSelection");
	const colDef = column.getColDef();
	const { headerCheckboxSelection } = colDef;
	let result = false;
	if (typeof rowSelection === "object") {
		const isSelectionCol = isColumnSelectionCol(column);
		const isAutoCol = isColumnGroupAutoCol(column);
		if (_getCheckboxLocation(rowSelection) === "autoGroupColumn" && isAutoCol || isSelectionCol && selectionColSvc?.isSelectionColumnEnabled()) result = _getHeaderCheckbox(rowSelection);
	} else if (typeof headerCheckboxSelection === "function") result = headerCheckboxSelection(_addGridCommonParams(gos, {
		column,
		colDef
	}));
	else result = !!headerCheckboxSelection;
	return result;
}
var BaseSelectionService = class extends BeanStub {
	postConstruct() {
		const { gos, beans } = this;
		this.selectionCtx = new RowRangeSelectionContext(beans.rowModel, beans.pinnedRowModel);
		this.addManagedPropertyListeners(["isRowSelectable", "rowSelection"], () => {
			const callback = _getIsRowSelectable(gos);
			if (callback !== this.isRowSelectable) {
				this.isRowSelectable = callback;
				this.updateSelectable();
			}
		});
		this.isRowSelectable = _getIsRowSelectable(gos);
		this.addManagedEventListeners({
			cellValueChanged: (e) => this.updateRowSelectable(e.node),
			rowNodeDataChanged: (e) => this.updateRowSelectable(e.node)
		});
	}
	destroy() {
		super.destroy();
		this.selectionCtx.reset();
	}
	createCheckboxSelectionComponent() {
		return new CheckboxSelectionComponent();
	}
	createSelectAllFeature(column) {
		if (isCheckboxSelection(this.beans, column)) return new SelectAllFeature(column);
	}
	isMultiSelect() {
		return _isMultiRowSelection(this.gos);
	}
	onRowCtrlSelected(rowCtrl, hasFocusFunc, gui) {
		const selected = !!rowCtrl.rowNode.isSelected();
		rowCtrl.forEachGui(gui, (gui2) => {
			gui2.rowComp.toggleCss("ag-row-selected", selected);
			const element = gui2.element;
			_setAriaSelected(element, selected);
			if (element.contains(_getActiveDomElement(this.beans))) hasFocusFunc(gui2);
		});
	}
	announceAriaRowSelection(rowNode) {
		if (this.isRowSelectionBlocked(rowNode)) return;
		const selected = rowNode.isSelected();
		if (!rowNode.selectable) return;
		const label = this.getLocaleTextFunc()(selected ? "ariaRowDeselect" : "ariaRowSelect", `Press SPACE to ${selected ? "deselect" : "select"} this row`);
		this.beans.ariaAnnounce?.announceValue(label, "rowSelection");
	}
	isRowSelectionBlocked(rowNode) {
		return !rowNode.selectable || rowNode.rowPinned && !_isManualPinnedRow(rowNode) || !_isRowSelection(this.gos);
	}
	updateRowSelectable(rowNode, suppressSelectionUpdate) {
		const selectable = rowNode.rowPinned && rowNode.pinnedSibling ? rowNode.pinnedSibling.selectable : this.isRowSelectable?.(rowNode) ?? true;
		this.setRowSelectable(rowNode, selectable, suppressSelectionUpdate);
		return selectable;
	}
	setRowSelectable(rowNode, newVal, suppressSelectionUpdate) {
		if (rowNode.selectable !== newVal) {
			rowNode.selectable = newVal;
			rowNode.dispatchRowEvent("selectableChanged");
			if (suppressSelectionUpdate) return;
			if (_getGroupSelectsDescendants(this.gos)) {
				const selected = this.calculateSelectedFromChildren(rowNode);
				this.setNodesSelected({
					nodes: [rowNode],
					newValue: selected ?? false,
					source: "selectableChanged"
				});
				return;
			}
			if (rowNode.isSelected() && !rowNode.selectable) this.setNodesSelected({
				nodes: [rowNode],
				newValue: false,
				source: "selectableChanged"
			});
		}
	}
	calculateSelectedFromChildren(rowNode) {
		let atLeastOneSelected = false;
		let atLeastOneDeSelected = false;
		if (!rowNode.childrenAfterGroup?.length) return rowNode.selectable ? rowNode.__selected : null;
		for (let i = 0; i < rowNode.childrenAfterGroup.length; i++) {
			const child = rowNode.childrenAfterGroup[i];
			let childState = child.isSelected();
			if (!child.selectable) {
				const selectable = this.calculateSelectedFromChildren(child);
				if (selectable === null) continue;
				childState = selectable;
			}
			switch (childState) {
				case true:
					atLeastOneSelected = true;
					break;
				case false:
					atLeastOneDeSelected = true;
					break;
				default: return;
			}
		}
		if (atLeastOneSelected && atLeastOneDeSelected) return;
		if (atLeastOneSelected) return true;
		if (atLeastOneDeSelected) return false;
		if (!rowNode.selectable) return null;
		return rowNode.__selected;
	}
	selectRowNode(rowNode, newValue, e, source = "api") {
		const selectionNotAllowed = !rowNode.selectable && newValue;
		const selectionNotChanged = rowNode.__selected === newValue;
		if (selectionNotAllowed || selectionNotChanged) return false;
		rowNode.__selected = newValue;
		rowNode.dispatchRowEvent("rowSelected");
		const sibling = rowNode.sibling;
		if (sibling && sibling.footer && sibling.__localEventService) sibling.dispatchRowEvent("rowSelected");
		const pinnedSibling = rowNode.pinnedSibling;
		if (pinnedSibling && pinnedSibling.rowPinned && pinnedSibling.__localEventService) pinnedSibling.dispatchRowEvent("rowSelected");
		this.eventSvc.dispatchEvent({
			..._createGlobalRowEvent(rowNode, this.gos, "rowSelected"),
			event: e || null,
			source
		});
		return true;
	}
	isCellCheckboxSelection(column, rowNode) {
		const so = this.gos.get("rowSelection");
		if (so && typeof so !== "string") {
			const checkbox = isColumnSelectionCol(column) && _getCheckboxes(so);
			return column.isColumnFunc(rowNode, checkbox);
		} else return column.isColumnFunc(rowNode, column.colDef.checkboxSelection);
	}
	inferNodeSelections(node, shiftKey, metaKey, source) {
		const { gos, selectionCtx } = this;
		const currentSelection = node.isSelected();
		const groupSelectsDescendants = _getGroupSelectsDescendants(gos);
		const enableClickSelection = _getEnableSelection(gos);
		const enableDeselection = _getEnableDeselection(gos);
		const isMultiSelect = this.isMultiSelect();
		const isRowClicked = source === "rowClicked";
		if (isRowClicked && !(enableClickSelection || enableDeselection)) return null;
		if (shiftKey && metaKey && isMultiSelect) {
			const root = selectionCtx.getRoot();
			if (!root) return null;
			else if (!root.isSelected()) return {
				select: [],
				deselect: selectionCtx.extend(node, groupSelectsDescendants).keep,
				reset: false
			};
			else {
				const partition = selectionCtx.isInRange(node) ? selectionCtx.truncate(node) : selectionCtx.extend(node, groupSelectsDescendants);
				return {
					deselect: partition.discard,
					select: partition.keep,
					reset: false
				};
			}
		} else if (shiftKey && isMultiSelect) {
			const fallback = selectionCtx.selectAll ? this.beans.rowModel.getRow(0) : void 0;
			const root = selectionCtx.getRoot(fallback);
			const partition = selectionCtx.isInRange(node) ? selectionCtx.truncate(node) : selectionCtx.extend(node, groupSelectsDescendants);
			return {
				select: partition.keep,
				deselect: partition.discard,
				reset: selectionCtx.selectAll || !!(root && !root.isSelected())
			};
		} else if (metaKey) {
			if (isRowClicked) {
				const newValue = !currentSelection;
				if (newValue && !enableClickSelection || !newValue && !enableDeselection) return null;
				selectionCtx.setRoot(node);
				return {
					node,
					newValue,
					clearSelection: false
				};
			}
			selectionCtx.setRoot(node);
			return {
				node,
				newValue: !currentSelection,
				clearSelection: !isMultiSelect
			};
		} else {
			selectionCtx.setRoot(node);
			const enableSelectionWithoutKeys = _getEnableSelectionWithoutKeys(gos);
			const groupSelectsFiltered = _getGroupSelection(gos) === "filteredDescendants";
			const shouldClear = isRowClicked && (!enableSelectionWithoutKeys || !enableClickSelection);
			if (groupSelectsFiltered && currentSelection === void 0 && _isClientSideRowModel(gos)) return {
				node,
				newValue: false,
				clearSelection: !isMultiSelect || shouldClear
			};
			if (isRowClicked) {
				const newValue = currentSelection ? !enableSelectionWithoutKeys : enableClickSelection;
				if (newValue === currentSelection && !shouldClear || newValue && !enableClickSelection || !newValue && !enableDeselection) return null;
				return {
					node,
					newValue,
					clearSelection: !isMultiSelect || shouldClear,
					keepDescendants: node.group && groupSelectsDescendants
				};
			}
			return {
				node,
				newValue: !currentSelection,
				clearSelection: !isMultiSelect || shouldClear
			};
		}
	}
};
var AgRadioButton = class extends AgCheckbox {
	constructor(config) {
		super(config, "ag-radio-button", "radio");
	}
	isSelected() {
		return this.eInput.checked;
	}
	toggle() {
		if (this.eInput.disabled) return;
		if (!this.isSelected()) this.setValue(true);
	}
	addInputListeners() {
		super.addInputListeners();
		this.addManagedEventListeners({ checkboxChanged: this.onChange.bind(this) });
	}
	onChange(event) {
		const eInput = this.eInput;
		if (event.selected && event.name && eInput.name && eInput.name === event.name && event.id && eInput.id !== event.id) this.setValue(false, true);
	}
};
var AgInputTextField = class extends AgAbstractInputField {
	constructor(config, className = "ag-text-field", inputType = "text") {
		super(config, className, inputType);
	}
	postConstruct() {
		super.postConstruct();
		if (this.config.allowedCharPattern) this.preventDisallowedCharacters();
	}
	setValue(value, silent) {
		const eInput = this.eInput;
		if (eInput.value !== value) eInput.value = _exists(value) ? value : "";
		return super.setValue(value, silent);
	}
	setStartValue(value) {
		this.setValue(value, true);
	}
	preventDisallowedCharacters() {
		const pattern = /* @__PURE__ */ new RegExp(`[${this.config.allowedCharPattern}]`);
		const preventCharacters = (event) => {
			if (!_isEventFromPrintableCharacter(event)) return;
			if (event.key && !pattern.test(event.key)) event.preventDefault();
		};
		this.addManagedListeners(this.eInput, {
			keydown: preventCharacters,
			paste: (e) => {
				const text = e.clipboardData?.getData("text");
				if (text && text.split("").some((c) => !pattern.test(c))) e.preventDefault();
			}
		});
	}
};
var AgInputTextFieldSelector = {
	selector: "AG-INPUT-TEXT-FIELD",
	component: AgInputTextField
};
var AgInputTextArea = class extends AgAbstractInputField {
	constructor(config) {
		super(config, "ag-text-area", null, "textarea");
	}
	setValue(value, silent) {
		const ret = super.setValue(value, silent);
		this.eInput.value = value;
		return ret;
	}
	setCols(cols) {
		this.eInput.cols = cols;
		return this;
	}
	setRows(rows) {
		this.eInput.rows = rows;
		return this;
	}
};
var AgInputTextAreaSelector = {
	selector: "AG-INPUT-TEXT-AREA",
	component: AgInputTextArea
};
var AgInputNumberField = class extends AgInputTextField {
	constructor(config) {
		super(config, "ag-number-field", "number");
	}
	postConstruct() {
		super.postConstruct();
		const eInput = this.eInput;
		this.addManagedListeners(eInput, {
			blur: () => {
				const floatedValue = parseFloat(eInput.value);
				const value = isNaN(floatedValue) ? "" : this.normalizeValue(floatedValue.toString());
				if (this.value !== value) this.setValue(value);
			},
			wheel: this.onWheel.bind(this)
		});
		eInput.step = "any";
		const { precision, min, max, step } = this.config;
		if (typeof precision === "number") this.setPrecision(precision);
		if (typeof min === "number") this.setMin(min);
		if (typeof max === "number") this.setMax(max);
		if (typeof step === "number") this.setStep(step);
	}
	onWheel(e) {
		if (_getActiveDomElement(this.beans) === this.eInput) e.preventDefault();
	}
	normalizeValue(value) {
		if (value === "") return "";
		if (this.precision != null) value = this.adjustPrecision(value);
		return value;
	}
	adjustPrecision(value, isScientificNotation) {
		const precision = this.precision;
		if (precision == null) return value;
		if (isScientificNotation) {
			const floatString = parseFloat(value).toFixed(precision);
			return parseFloat(floatString).toString();
		}
		const parts = String(value).split(".");
		if (parts.length > 1) {
			if (parts[1].length <= precision) return value;
			else if (precision > 0) return `${parts[0]}.${parts[1].slice(0, precision)}`;
		}
		return parts[0];
	}
	setMin(min) {
		if (this.min === min) return this;
		this.min = min;
		_addOrRemoveAttribute(this.eInput, "min", min);
		return this;
	}
	setMax(max) {
		if (this.max === max) return this;
		this.max = max;
		_addOrRemoveAttribute(this.eInput, "max", max);
		return this;
	}
	setPrecision(precision) {
		this.precision = precision;
		return this;
	}
	setStep(step) {
		if (this.step === step) return this;
		this.step = step;
		_addOrRemoveAttribute(this.eInput, "step", step);
		return this;
	}
	setValue(value, silent) {
		return this.setValueOrInputValue((v$1) => super.setValue(v$1, silent), () => this, value);
	}
	setStartValue(value) {
		return this.setValueOrInputValue((v$1) => super.setValue(v$1, true), (v$1) => {
			this.eInput.value = v$1;
		}, value);
	}
	setValueOrInputValue(setValueFunc, setInputValueOnlyFunc, value) {
		if (_exists(value)) {
			let setInputValueOnly = this.isScientificNotation(value);
			if (setInputValueOnly && this.eInput.validity.valid) return setValueFunc(value);
			if (!setInputValueOnly) {
				value = this.adjustPrecision(value);
				const normalizedValue = this.normalizeValue(value);
				setInputValueOnly = value != normalizedValue;
			}
			if (setInputValueOnly) return setInputValueOnlyFunc(value);
		}
		return setValueFunc(value);
	}
	getValue() {
		const eInput = this.eInput;
		if (!eInput.validity.valid) return;
		const inputValue = eInput.value;
		if (this.isScientificNotation(inputValue)) return this.adjustPrecision(inputValue, true);
		return super.getValue();
	}
	isScientificNotation(value) {
		return typeof value === "string" && value.includes("e");
	}
};
var AgInputNumberFieldSelector = {
	selector: "AG-INPUT-NUMBER-FIELD",
	component: AgInputNumberField
};
var AgInputDateField = class extends AgInputTextField {
	constructor(config) {
		super(config, "ag-date-field", "date");
	}
	postConstruct() {
		super.postConstruct();
		const usingSafari = _isBrowserSafari();
		this.addManagedListeners(this.eInput, {
			wheel: this.onWheel.bind(this),
			mousedown: () => {
				if (this.isDisabled() || usingSafari) return;
				this.eInput.focus();
			}
		});
		this.eInput.step = "any";
	}
	onWheel(e) {
		if (_getActiveDomElement(this.beans) === this.eInput) e.preventDefault();
	}
	setMin(minDate) {
		const min = minDate instanceof Date ? _serialiseDate(minDate ?? null, !!this.includeTime) ?? void 0 : minDate;
		if (this.min === min) return this;
		this.min = min;
		_addOrRemoveAttribute(this.eInput, "min", min);
		return this;
	}
	setMax(maxDate) {
		const max = maxDate instanceof Date ? _serialiseDate(maxDate ?? null, !!this.includeTime) ?? void 0 : maxDate;
		if (this.max === max) return this;
		this.max = max;
		_addOrRemoveAttribute(this.eInput, "max", max);
		return this;
	}
	setStep(step) {
		if (this.step === step) return this;
		this.step = step;
		_addOrRemoveAttribute(this.eInput, "step", step);
		return this;
	}
	setIncludeTime(includeTime) {
		if (this.includeTime === includeTime) return this;
		this.includeTime = includeTime;
		super.setInputType(includeTime ? "datetime-local" : "date");
		if (includeTime) this.setStep(1);
		return this;
	}
	getDate() {
		if (!this.eInput.validity.valid) return;
		return _parseDateTimeFromString(this.getValue()) ?? void 0;
	}
	setDate(date, silent) {
		this.setValue(_serialiseDate(date ?? null, this.includeTime), silent);
	}
};
var AgInputDateFieldSelector = {
	selector: "AG-INPUT-DATE-FIELD",
	component: AgInputDateField
};
var AgList = class extends Component {
	constructor(cssIdentifier = "default", unFocusable = false) {
		super({
			tag: "div",
			cls: `ag-list ag-${cssIdentifier}-list`
		});
		this.cssIdentifier = cssIdentifier;
		this.unFocusable = unFocusable;
		this.activeClass = "ag-active-item";
		this.options = [];
		this.itemEls = [];
	}
	postConstruct() {
		const eGui = this.getGui();
		this.addManagedElementListeners(eGui, { mouseleave: () => this.clearHighlighted() });
		if (this.unFocusable) return;
		this.addManagedElementListeners(eGui, { keydown: this.handleKeyDown.bind(this) });
	}
	handleKeyDown(e) {
		const key = e.key;
		switch (key) {
			case KeyCode.ENTER:
				if (!this.highlightedEl) this.setValue(this.getValue());
				else {
					const pos = this.itemEls.indexOf(this.highlightedEl);
					this.setValueByIndex(pos);
				}
				break;
			case KeyCode.DOWN:
			case KeyCode.UP:
				e.preventDefault();
				this.navigate(key);
				break;
			case KeyCode.PAGE_DOWN:
			case KeyCode.PAGE_UP:
			case KeyCode.PAGE_HOME:
			case KeyCode.PAGE_END:
				e.preventDefault();
				this.navigateToPage(key);
				break;
		}
	}
	navigate(key) {
		const isDown = key === KeyCode.DOWN;
		let itemToHighlight;
		const { itemEls, highlightedEl } = this;
		if (!highlightedEl) itemToHighlight = itemEls[isDown ? 0 : itemEls.length - 1];
		else {
			let nextPos = itemEls.indexOf(highlightedEl) + (isDown ? 1 : -1);
			nextPos = Math.min(Math.max(nextPos, 0), itemEls.length - 1);
			itemToHighlight = itemEls[nextPos];
		}
		this.highlightItem(itemToHighlight);
	}
	navigateToPage(key) {
		const { itemEls, highlightedEl } = this;
		if (!highlightedEl || itemEls.length === 0) return;
		const currentIdx = itemEls.indexOf(highlightedEl);
		const rowCount = this.options.length - 1;
		const itemHeight = itemEls[0].clientHeight;
		const pageSize = Math.floor(this.getGui().clientHeight / itemHeight);
		let newIndex = -1;
		if (key === KeyCode.PAGE_HOME) newIndex = 0;
		else if (key === KeyCode.PAGE_END) newIndex = rowCount;
		else if (key === KeyCode.PAGE_DOWN) newIndex = Math.min(currentIdx + pageSize, rowCount);
		else if (key === KeyCode.PAGE_UP) newIndex = Math.max(currentIdx - pageSize, 0);
		if (newIndex === -1) return;
		this.highlightItem(itemEls[newIndex]);
	}
	addOptions(listOptions) {
		listOptions.forEach((listOption) => this.addOption(listOption));
		return this;
	}
	addOption(listOption) {
		const { value, text } = listOption;
		const valueToRender = text ?? value;
		this.options.push({
			value,
			text: valueToRender
		});
		this.renderOption(value, valueToRender);
		this.updateIndices();
		return this;
	}
	clearOptions() {
		this.options = [];
		this.reset(true);
		this.itemEls.forEach((itemEl) => {
			_removeFromParent(itemEl);
		});
		this.itemEls = [];
		this.refreshAriaRole();
	}
	refreshAriaRole() {
		_setAriaRole(this.getGui(), this.options.length === 0 ? "presentation" : "listbox");
	}
	updateIndices() {
		const options = this.getGui().querySelectorAll(".ag-list-item");
		this.refreshAriaRole();
		options.forEach((option, idx) => {
			_setAriaPosInSet(option, idx + 1);
			_setAriaSetSize(option, options.length);
		});
	}
	renderOption(value, text) {
		const itemEl = _createElement({
			tag: "div",
			cls: `ag-list-item ag-${this.cssIdentifier}-list-item`,
			attrs: { role: "option" }
		});
		const span = _createElement({
			tag: "span",
			children: text
		});
		itemEl.appendChild(span);
		if (!this.unFocusable) itemEl.tabIndex = -1;
		this.itemEls.push(itemEl);
		this.addManagedListeners(itemEl, {
			mouseover: () => this.highlightItem(itemEl),
			mousedown: (e) => {
				e.preventDefault();
				e.stopPropagation();
				this.setValue(value);
			}
		});
		this.createOptionalManagedBean(this.beans.registry.createDynamicBean("tooltipFeature", false, {
			getTooltipValue: () => text,
			getGui: () => itemEl,
			getLocation: () => "UNKNOWN",
			shouldDisplayTooltip: () => span.scrollWidth > span.clientWidth
		}));
		this.getGui().appendChild(itemEl);
	}
	setValue(value, silent) {
		if (this.value === value) {
			this.fireItemSelected();
			return this;
		}
		if (value == null) {
			this.reset(silent);
			return this;
		}
		const idx = this.options.findIndex((option) => option.value === value);
		if (idx !== -1) {
			const option = this.options[idx];
			this.value = option.value;
			this.displayValue = option.text;
			this.highlightItem(this.itemEls[idx]);
			if (!silent) this.fireChangeEvent();
		}
		return this;
	}
	setValueByIndex(idx) {
		return this.setValue(this.options[idx].value);
	}
	getValue() {
		return this.value;
	}
	getDisplayValue() {
		return this.displayValue;
	}
	refreshHighlighted() {
		this.clearHighlighted();
		const idx = this.options.findIndex((option) => option.value === this.value);
		if (idx !== -1) this.highlightItem(this.itemEls[idx]);
	}
	reset(silent) {
		this.value = null;
		this.displayValue = null;
		this.clearHighlighted();
		if (!silent) this.fireChangeEvent();
	}
	highlightItem(el) {
		if (!_isVisible(el)) return;
		this.clearHighlighted();
		this.highlightedEl = el;
		el.classList.add(this.activeClass);
		_setAriaSelected(el, true);
		const { scrollTop, clientHeight } = this.getGui();
		const { offsetTop, offsetHeight } = el;
		if (offsetTop + offsetHeight > scrollTop + clientHeight || offsetTop < scrollTop) el.scrollIntoView({ block: "nearest" });
		if (!this.unFocusable) el.focus();
	}
	clearHighlighted() {
		const highlightedEl = this.highlightedEl;
		if (!highlightedEl || !_isVisible(highlightedEl)) return;
		highlightedEl.classList.remove(this.activeClass);
		_setAriaSelected(highlightedEl, false);
		this.highlightedEl = null;
	}
	fireChangeEvent() {
		this.dispatchLocalEvent({ type: "fieldValueChanged" });
		this.fireItemSelected();
	}
	fireItemSelected() {
		this.dispatchLocalEvent({ type: "selectedItem" });
	}
};
var agPickerFieldCSS = `.ag-picker-field-display{flex:1 1 auto}.ag-picker-field{align-items:center;display:flex}.ag-picker-field-icon{border:0;cursor:pointer;display:flex;margin:0;padding:0}.ag-picker-field-wrapper{background-color:var(--ag-picker-button-background-color);border:var(--ag-picker-button-border);border-radius:5px;min-height:max(var(--ag-list-item-height),calc(var(--ag-spacing)*4));overflow:hidden;&:where(.ag-picker-has-focus),&:where(:focus-within){background-color:var(--ag-picker-button-focus-background-color);border:var(--ag-picker-button-focus-border);box-shadow:var(--ag-focus-shadow);&:where(.invalid){box-shadow:var(--ag-focus-error-shadow)}}&:where(.invalid){background-color:var(--ag-input-invalid-background-color);border:var(--ag-input-invalid-border);color:var(--ag-input-invalid-text-color)}&:disabled{opacity:.5}}`;
var AgPickerFieldElement = {
	tag: "div",
	cls: "ag-picker-field",
	role: "presentation",
	children: [{
		tag: "div",
		ref: "eLabel"
	}, {
		tag: "div",
		ref: "eWrapper",
		cls: "ag-wrapper ag-picker-field-wrapper ag-picker-collapsed",
		children: [{
			tag: "div",
			ref: "eDisplayField",
			cls: "ag-picker-field-display"
		}, {
			tag: "div",
			ref: "eIcon",
			cls: "ag-picker-field-icon",
			attrs: { "aria-hidden": "true" }
		}]
	}]
};
var AgPickerField = class extends AgAbstractField {
	constructor(config) {
		super(config, config?.template || AgPickerFieldElement, config?.agComponents || [], config?.className);
		this.isPickerDisplayed = false;
		this.skipClick = false;
		this.pickerGap = 4;
		this.hideCurrentPicker = null;
		this.eLabel = null;
		this.eWrapper = null;
		this.eDisplayField = null;
		this.eIcon = null;
		this.registerCSS(agPickerFieldCSS);
		this.ariaRole = config?.ariaRole;
		this.onPickerFocusIn = this.onPickerFocusIn.bind(this);
		this.onPickerFocusOut = this.onPickerFocusOut.bind(this);
		if (!config) return;
		const { pickerGap, maxPickerHeight, variableWidth, minPickerWidth, maxPickerWidth } = config;
		if (pickerGap != null) this.pickerGap = pickerGap;
		this.variableWidth = !!variableWidth;
		if (maxPickerHeight != null) this.setPickerMaxHeight(maxPickerHeight);
		if (minPickerWidth != null) this.setPickerMinWidth(minPickerWidth);
		if (maxPickerWidth != null) this.setPickerMaxWidth(maxPickerWidth);
	}
	postConstruct() {
		super.postConstruct();
		this.setupAria();
		const displayId = `ag-${this.getCompId()}-display`;
		this.eDisplayField.setAttribute("id", displayId);
		const ariaEl = this.getAriaElement();
		this.addManagedElementListeners(ariaEl, { keydown: this.onKeyDown.bind(this) });
		this.addManagedElementListeners(this.eLabel, { mousedown: this.onLabelOrWrapperMouseDown.bind(this) });
		this.addManagedElementListeners(this.eWrapper, { mousedown: this.onLabelOrWrapperMouseDown.bind(this) });
		const { pickerIcon, inputWidth } = this.config;
		if (pickerIcon) {
			const icon = _createIconNoSpan(pickerIcon, this.beans);
			if (icon) this.eIcon.appendChild(icon);
		}
		if (inputWidth != null) this.setInputWidth(inputWidth);
	}
	setupAria() {
		const ariaEl = this.getAriaElement();
		ariaEl.setAttribute("tabindex", this.gos.get("tabIndex").toString());
		_setAriaExpanded(ariaEl, false);
		if (this.ariaRole) _setAriaRole(ariaEl, this.ariaRole);
	}
	onLabelOrWrapperMouseDown(e) {
		if (e) {
			const focusableEl = this.getFocusableElement();
			if (focusableEl !== this.eWrapper && e?.target === focusableEl) return;
			e.preventDefault();
			this.getFocusableElement().focus();
		}
		if (this.skipClick) {
			this.skipClick = false;
			return;
		}
		if (this.isDisabled()) return;
		if (this.isPickerDisplayed) this.hidePicker();
		else this.showPicker();
	}
	onKeyDown(e) {
		switch (e.key) {
			case KeyCode.UP:
			case KeyCode.DOWN:
			case KeyCode.ENTER:
			case KeyCode.SPACE:
				e.preventDefault();
				this.onLabelOrWrapperMouseDown();
				break;
			case KeyCode.ESCAPE:
				if (this.isPickerDisplayed) {
					e.preventDefault();
					e.stopPropagation();
					if (this.hideCurrentPicker) this.hideCurrentPicker();
				}
				break;
		}
	}
	showPicker() {
		this.isPickerDisplayed = true;
		if (!this.pickerComponent) this.pickerComponent = this.createPickerComponent();
		const pickerGui = this.pickerComponent.getGui();
		pickerGui.addEventListener("focusin", this.onPickerFocusIn);
		pickerGui.addEventListener("focusout", this.onPickerFocusOut);
		this.hideCurrentPicker = this.renderAndPositionPicker();
		this.toggleExpandedStyles(true);
	}
	renderAndPositionPicker() {
		const ePicker = this.pickerComponent.getGui();
		if (!this.gos.get("suppressScrollWhenPopupsAreOpen")) [this.destroyMouseWheelFunc] = this.addManagedEventListeners({ bodyScroll: () => {
			this.hidePicker();
		} });
		const translate = this.getLocaleTextFunc();
		const { config: { pickerAriaLabelKey, pickerAriaLabelValue, modalPicker = true }, maxPickerHeight, minPickerWidth, maxPickerWidth, variableWidth, beans, eWrapper } = this;
		const popupParams = {
			modal: modalPicker,
			eChild: ePicker,
			closeOnEsc: true,
			closedCallback: () => {
				const shouldRestoreFocus = _isNothingFocused(beans);
				this.beforeHidePicker();
				if (shouldRestoreFocus && this.isAlive()) this.getFocusableElement().focus();
			},
			ariaLabel: translate(pickerAriaLabelKey, pickerAriaLabelValue),
			anchorToElement: eWrapper
		};
		ePicker.style.position = "absolute";
		const popupSvc = beans.popupSvc;
		const addPopupRes = popupSvc.addPopup(popupParams);
		if (variableWidth) {
			if (minPickerWidth) ePicker.style.minWidth = minPickerWidth;
			ePicker.style.width = _formatSize(_getAbsoluteWidth(eWrapper));
			if (maxPickerWidth) ePicker.style.maxWidth = maxPickerWidth;
		} else _setElementWidth(ePicker, maxPickerWidth ?? _getAbsoluteWidth(eWrapper));
		const maxHeight = maxPickerHeight ?? `${_getInnerHeight(popupSvc.getPopupParent())}px`;
		ePicker.style.setProperty("max-height", maxHeight);
		this.alignPickerToComponent();
		return addPopupRes.hideFunc;
	}
	alignPickerToComponent() {
		if (!this.pickerComponent) return;
		const { pickerGap, config: { pickerType }, beans: { popupSvc, gos }, eWrapper, pickerComponent } = this;
		const alignSide = gos.get("enableRtl") ? "right" : "left";
		popupSvc.positionPopupByComponent({
			type: pickerType,
			eventSource: eWrapper,
			ePopup: pickerComponent.getGui(),
			position: "under",
			alignSide,
			keepWithinBounds: true,
			nudgeY: pickerGap
		});
	}
	beforeHidePicker() {
		if (this.destroyMouseWheelFunc) {
			this.destroyMouseWheelFunc();
			this.destroyMouseWheelFunc = void 0;
		}
		this.toggleExpandedStyles(false);
		const pickerGui = this.pickerComponent.getGui();
		pickerGui.removeEventListener("focusin", this.onPickerFocusIn);
		pickerGui.removeEventListener("focusout", this.onPickerFocusOut);
		this.isPickerDisplayed = false;
		this.pickerComponent = void 0;
		this.hideCurrentPicker = null;
	}
	toggleExpandedStyles(expanded) {
		if (!this.isAlive()) return;
		_setAriaExpanded(this.getAriaElement(), expanded);
		const classList = this.eWrapper.classList;
		classList.toggle("ag-picker-expanded", expanded);
		classList.toggle("ag-picker-collapsed", !expanded);
	}
	onPickerFocusIn() {
		this.togglePickerHasFocus(true);
	}
	onPickerFocusOut(e) {
		if (!this.pickerComponent?.getGui().contains(e.relatedTarget)) this.togglePickerHasFocus(false);
	}
	togglePickerHasFocus(focused) {
		if (!this.pickerComponent) return;
		this.eWrapper.classList.toggle("ag-picker-has-focus", focused);
	}
	hidePicker() {
		if (this.hideCurrentPicker) {
			this.hideCurrentPicker();
			this.dispatchLocalEvent({ type: "pickerHidden" });
		}
	}
	setInputWidth(width) {
		_setElementWidth(this.eWrapper, width);
		return this;
	}
	getFocusableElement() {
		return this.eWrapper;
	}
	setPickerGap(gap) {
		this.pickerGap = gap;
		return this;
	}
	setPickerMinWidth(width) {
		if (typeof width === "number") width = `${width}px`;
		this.minPickerWidth = width == null ? void 0 : width;
		return this;
	}
	setPickerMaxWidth(width) {
		if (typeof width === "number") width = `${width}px`;
		this.maxPickerWidth = width == null ? void 0 : width;
		return this;
	}
	setPickerMaxHeight(height) {
		if (typeof height === "number") height = `${height}px`;
		this.maxPickerHeight = height == null ? void 0 : height;
		return this;
	}
	destroy() {
		this.hidePicker();
		super.destroy();
	}
};
var agSelectCSS = `.ag-select{align-items:center;display:flex;&.ag-disabled{opacity:.5}}:where(.ag-select){.ag-picker-field-wrapper{cursor:default}&.ag-disabled .ag-picker-field-wrapper:focus{box-shadow:none}&:not(.ag-cell-editor,.ag-label-align-top){min-height:var(--ag-list-item-height)}.ag-picker-field-display{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.ag-picker-field-icon{align-items:center;display:flex}}:where(.ag-ltr) :where(.ag-select){.ag-picker-field-wrapper{padding-left:calc(var(--ag-cell-horizontal-padding)/2);padding-right:var(--ag-spacing)}}:where(.ag-rtl) :where(.ag-select){.ag-picker-field-wrapper{padding-left:var(--ag-spacing);padding-right:calc(var(--ag-cell-horizontal-padding)/2)}}`;
var AgSelect = class extends AgPickerField {
	constructor(config) {
		super({
			pickerAriaLabelKey: "ariaLabelSelectField",
			pickerAriaLabelValue: "Select Field",
			pickerType: "ag-list",
			className: "ag-select",
			pickerIcon: "selectOpen",
			ariaRole: "combobox",
			...config
		});
		this.registerCSS(agSelectCSS);
	}
	postConstruct() {
		this.tooltipFeature = this.createOptionalManagedBean(this.beans.registry.createDynamicBean("tooltipFeature", false, {
			shouldDisplayTooltip: _isElementOverflowingCallback(() => this.eDisplayField),
			getGui: () => this.getGui()
		}));
		super.postConstruct();
		this.createListComponent();
		this.eWrapper.tabIndex = this.gos.get("tabIndex");
		const { options, value, placeholder } = this.config;
		if (options != null) this.addOptions(options);
		if (value != null) this.setValue(value, true);
		if (placeholder && value == null) this.eDisplayField.textContent = placeholder;
		this.addManagedElementListeners(this.eWrapper, { focusout: this.onWrapperFocusOut.bind(this) });
	}
	onWrapperFocusOut(e) {
		if (!this.eWrapper.contains(e.relatedTarget)) this.hidePicker();
	}
	createListComponent() {
		const listComponent = this.createBean(new AgList("select", true));
		this.listComponent = listComponent;
		listComponent.setParentComponent(this);
		const eListAriaEl = listComponent.getAriaElement();
		const listId = `ag-select-list-${listComponent.getCompId()}`;
		eListAriaEl.setAttribute("id", listId);
		_setAriaControlsAndLabel(this.getAriaElement(), eListAriaEl);
		listComponent.addManagedElementListeners(listComponent.getGui(), { mousedown: (e) => {
			e?.preventDefault();
		} });
		listComponent.addManagedListeners(listComponent, {
			selectedItem: () => {
				this.hidePicker();
				this.dispatchLocalEvent({ type: "selectedItem" });
			},
			fieldValueChanged: () => {
				if (!this.listComponent) return;
				this.setValue(this.listComponent.getValue(), false, true);
				this.hidePicker();
			}
		});
	}
	createPickerComponent() {
		return this.listComponent;
	}
	onKeyDown(e) {
		const { key } = e;
		if (key === KeyCode.TAB) this.hidePicker();
		switch (key) {
			case KeyCode.ENTER:
			case KeyCode.UP:
			case KeyCode.DOWN:
			case KeyCode.PAGE_UP:
			case KeyCode.PAGE_DOWN:
			case KeyCode.PAGE_HOME:
			case KeyCode.PAGE_END:
				e.preventDefault();
				if (this.isPickerDisplayed) this.listComponent?.handleKeyDown(e);
				else super.onKeyDown(e);
				break;
			case KeyCode.ESCAPE:
				super.onKeyDown(e);
				break;
			case KeyCode.SPACE:
				if (this.isPickerDisplayed) e.preventDefault();
				else super.onKeyDown(e);
				break;
		}
	}
	showPicker() {
		const listComponent = this.listComponent;
		if (!listComponent) return;
		super.showPicker();
		listComponent.refreshHighlighted();
	}
	addOptions(options) {
		options.forEach((option) => this.addOption(option));
		return this;
	}
	addOption(option) {
		this.listComponent.addOption(option);
		return this;
	}
	clearOptions() {
		this.listComponent?.clearOptions();
		this.setValue(void 0, true);
		return this;
	}
	setValue(value, silent, fromPicker) {
		const { listComponent, config: { placeholder }, eDisplayField, tooltipFeature } = this;
		if (this.value === value || !listComponent) return this;
		if (!fromPicker) listComponent.setValue(value, true);
		if (listComponent.getValue() === this.getValue()) return this;
		let displayValue = listComponent.getDisplayValue();
		if (displayValue == null && placeholder) displayValue = placeholder;
		eDisplayField.textContent = displayValue;
		tooltipFeature?.setTooltipAndRefresh(displayValue ?? null);
		return super.setValue(value, silent);
	}
	destroy() {
		this.listComponent = this.destroyBean(this.listComponent);
		super.destroy();
	}
};
var TabGuardClassNames = {
	TAB_GUARD: "ag-tab-guard",
	TAB_GUARD_TOP: "ag-tab-guard-top",
	TAB_GUARD_BOTTOM: "ag-tab-guard-bottom"
};
var TabGuardCtrl = class extends BeanStub {
	constructor(params) {
		super();
		this.skipTabGuardFocus = false;
		this.forcingFocusOut = false;
		this.allowFocus = false;
		const { comp, eTopGuard, eBottomGuard, focusTrapActive, forceFocusOutWhenTabGuardsAreEmpty, isFocusableContainer, focusInnerElement, onFocusIn, onFocusOut, shouldStopEventPropagation, onTabKeyDown, handleKeyDown, isEmpty, eFocusableElement } = params;
		this.comp = comp;
		this.eTopGuard = eTopGuard;
		this.eBottomGuard = eBottomGuard;
		this.providedFocusInnerElement = focusInnerElement;
		this.eFocusableElement = eFocusableElement;
		this.focusTrapActive = !!focusTrapActive;
		this.forceFocusOutWhenTabGuardsAreEmpty = !!forceFocusOutWhenTabGuardsAreEmpty;
		this.isFocusableContainer = !!isFocusableContainer;
		this.providedFocusIn = onFocusIn;
		this.providedFocusOut = onFocusOut;
		this.providedShouldStopEventPropagation = shouldStopEventPropagation;
		this.providedOnTabKeyDown = onTabKeyDown;
		this.providedHandleKeyDown = handleKeyDown;
		this.providedIsEmpty = isEmpty;
	}
	postConstruct() {
		this.createManagedBean(new ManagedFocusFeature(this.eFocusableElement, {
			shouldStopEventPropagation: () => this.shouldStopEventPropagation(),
			onTabKeyDown: (e) => this.onTabKeyDown(e),
			handleKeyDown: (e) => this.handleKeyDown(e),
			onFocusIn: (e) => this.onFocusIn(e),
			onFocusOut: (e) => this.onFocusOut(e)
		}));
		this.activateTabGuards();
		[this.eTopGuard, this.eBottomGuard].forEach((guard) => this.addManagedElementListeners(guard, { focus: this.onFocus.bind(this) }));
	}
	handleKeyDown(e) {
		if (this.providedHandleKeyDown) this.providedHandleKeyDown(e);
	}
	tabGuardsAreActive() {
		return !!this.eTopGuard && this.eTopGuard.hasAttribute("tabIndex");
	}
	shouldStopEventPropagation() {
		if (this.providedShouldStopEventPropagation) return this.providedShouldStopEventPropagation();
		return false;
	}
	activateTabGuards() {
		if (this.forcingFocusOut) return;
		const tabIndex = this.gos.get("tabIndex");
		this.comp.setTabIndex(tabIndex.toString());
	}
	deactivateTabGuards() {
		this.comp.setTabIndex();
	}
	onFocus(e) {
		if (this.isFocusableContainer && !this.eFocusableElement.contains(e.relatedTarget)) {
			if (!this.allowFocus) {
				this.findNextElementOutsideAndFocus(e.target === this.eBottomGuard);
				return;
			}
		}
		if (this.skipTabGuardFocus) {
			this.skipTabGuardFocus = false;
			return;
		}
		if (this.forceFocusOutWhenTabGuardsAreEmpty) {
			if (this.providedIsEmpty ? this.providedIsEmpty() : _findFocusableElements(this.eFocusableElement, ".ag-tab-guard").length === 0) {
				this.findNextElementOutsideAndFocus(e.target === this.eBottomGuard);
				return;
			}
		}
		if (this.isFocusableContainer && this.eFocusableElement.contains(e.relatedTarget)) return;
		const fromBottom = e.target === this.eBottomGuard;
		if (!(this.providedFocusInnerElement ? this.providedFocusInnerElement(fromBottom) : this.focusInnerElement(fromBottom)) && this.forceFocusOutWhenTabGuardsAreEmpty) this.findNextElementOutsideAndFocus(e.target === this.eBottomGuard);
	}
	findNextElementOutsideAndFocus(up) {
		const focusableEls = _findFocusableElements(_getDocument(this.beans).body, null, true);
		const index = focusableEls.indexOf(up ? this.eTopGuard : this.eBottomGuard);
		if (index === -1) return;
		let start;
		let end;
		if (up) {
			start = 0;
			end = index;
		} else {
			start = index + 1;
			end = focusableEls.length;
		}
		const focusableRange = focusableEls.slice(start, end);
		const targetTabIndex = this.gos.get("tabIndex");
		focusableRange.sort((a, b) => {
			const indexA = parseInt(a.getAttribute("tabindex") || "0");
			const indexB = parseInt(b.getAttribute("tabindex") || "0");
			if (indexB === targetTabIndex) return 1;
			if (indexA === targetTabIndex) return -1;
			if (indexA === 0) return 1;
			if (indexB === 0) return -1;
			return indexA - indexB;
		});
		focusableRange[up ? focusableRange.length - 1 : 0]?.focus();
	}
	onFocusIn(e) {
		if (this.focusTrapActive || this.forcingFocusOut) return;
		if (this.providedFocusIn) this.providedFocusIn(e);
		if (!this.isFocusableContainer) this.deactivateTabGuards();
	}
	onFocusOut(e) {
		if (this.focusTrapActive) return;
		if (this.providedFocusOut) this.providedFocusOut(e);
		if (!this.eFocusableElement.contains(e.relatedTarget)) this.activateTabGuards();
	}
	onTabKeyDown(e) {
		if (this.providedOnTabKeyDown) {
			this.providedOnTabKeyDown(e);
			return;
		}
		if (this.focusTrapActive) return;
		if (e.defaultPrevented) return;
		const tabGuardsAreActive = this.tabGuardsAreActive();
		if (tabGuardsAreActive) this.deactivateTabGuards();
		const nextRoot = this.getNextFocusableElement(e.shiftKey);
		if (tabGuardsAreActive) setTimeout(() => this.activateTabGuards(), 0);
		if (!nextRoot) return;
		nextRoot.focus();
		e.preventDefault();
	}
	focusInnerElement(fromBottom = false) {
		const focusable = _findFocusableElements(this.eFocusableElement);
		if (this.tabGuardsAreActive()) {
			focusable.splice(0, 1);
			focusable.splice(focusable.length - 1, 1);
		}
		if (!focusable.length) return false;
		focusable[fromBottom ? focusable.length - 1 : 0].focus({ preventScroll: true });
		return true;
	}
	getNextFocusableElement(backwards) {
		return _findNextFocusableElement(this.beans, this.eFocusableElement, false, backwards);
	}
	forceFocusOutOfContainer(up = false) {
		if (this.forcingFocusOut) return;
		const tabGuardToFocus = up ? this.eTopGuard : this.eBottomGuard;
		this.activateTabGuards();
		this.skipTabGuardFocus = true;
		this.forcingFocusOut = true;
		tabGuardToFocus.focus();
		window.setTimeout(() => {
			this.forcingFocusOut = false;
			this.activateTabGuards();
		});
	}
	isTabGuard(element, bottom) {
		return element === this.eTopGuard && !bottom || element === this.eBottomGuard && (bottom ?? true);
	}
	setAllowFocus(allowFocus) {
		this.allowFocus = allowFocus;
	}
};
var TabGuardFeature = class extends BeanStub {
	constructor(comp) {
		super();
		this.comp = comp;
	}
	initialiseTabGuard(params) {
		this.eTopGuard = this.createTabGuard("top");
		this.eBottomGuard = this.createTabGuard("bottom");
		this.eFocusableElement = this.comp.getFocusableElement();
		const { eTopGuard, eBottomGuard, eFocusableElement } = this;
		const tabGuards = [eTopGuard, eBottomGuard];
		const compProxy = { setTabIndex: (tabIndex) => {
			tabGuards.forEach((tabGuard) => tabIndex != null ? tabGuard.setAttribute("tabindex", tabIndex) : tabGuard.removeAttribute("tabindex"));
		} };
		this.addTabGuards(eTopGuard, eBottomGuard);
		const { focusTrapActive = false, onFocusIn, onFocusOut, focusInnerElement, handleKeyDown, onTabKeyDown, shouldStopEventPropagation, isEmpty, forceFocusOutWhenTabGuardsAreEmpty, isFocusableContainer } = params;
		this.tabGuardCtrl = this.createManagedBean(new TabGuardCtrl({
			comp: compProxy,
			focusTrapActive,
			eTopGuard,
			eBottomGuard,
			eFocusableElement,
			onFocusIn,
			onFocusOut,
			focusInnerElement,
			handleKeyDown,
			onTabKeyDown,
			shouldStopEventPropagation,
			isEmpty,
			forceFocusOutWhenTabGuardsAreEmpty,
			isFocusableContainer
		}));
	}
	getTabGuardCtrl() {
		return this.tabGuardCtrl;
	}
	createTabGuard(side) {
		const tabGuard = _getDocument(this.beans).createElement("div");
		const cls = side === "top" ? TabGuardClassNames.TAB_GUARD_TOP : TabGuardClassNames.TAB_GUARD_BOTTOM;
		tabGuard.classList.add(TabGuardClassNames.TAB_GUARD, cls);
		_setAriaRole(tabGuard, "presentation");
		return tabGuard;
	}
	addTabGuards(topTabGuard, bottomTabGuard) {
		const eFocusableElement = this.eFocusableElement;
		eFocusableElement.insertAdjacentElement("afterbegin", topTabGuard);
		eFocusableElement.insertAdjacentElement("beforeend", bottomTabGuard);
	}
	removeAllChildrenExceptTabGuards() {
		const tabGuards = [this.eTopGuard, this.eBottomGuard];
		_clearElement(this.comp.getFocusableElement());
		this.addTabGuards(...tabGuards);
	}
	forceFocusOutOfContainer(up = false) {
		this.tabGuardCtrl.forceFocusOutOfContainer(up);
	}
	appendChild(appendChild, newChild, container) {
		if (!_isNodeOrElement(newChild)) newChild = newChild.getGui();
		const { eBottomGuard: bottomTabGuard } = this;
		if (bottomTabGuard) bottomTabGuard.insertAdjacentElement("beforebegin", newChild);
		else appendChild(newChild, container);
	}
	destroy() {
		const { eTopGuard, eBottomGuard } = this;
		_removeFromParent(eTopGuard);
		_removeFromParent(eBottomGuard);
		super.destroy();
	}
};
var TabGuardComp = class extends Component {
	initialiseTabGuard(params) {
		this.tabGuardFeature = this.createManagedBean(new TabGuardFeature(this));
		this.tabGuardFeature.initialiseTabGuard(params);
	}
	forceFocusOutOfContainer(up = false) {
		this.tabGuardFeature.forceFocusOutOfContainer(up);
	}
	appendChild(newChild, container) {
		this.tabGuardFeature.appendChild(super.appendChild.bind(this), newChild, container);
	}
};
var TouchListener = class {
	constructor(eElement, preventMouseClick = false) {
		this.DOUBLE_TAP_MILLIS = 500;
		this.destroyFuncs = [];
		this.touching = false;
		this.localEventService = new LocalEventService();
		this.preventMouseClick = preventMouseClick;
		const startListener = this.onTouchStart.bind(this);
		const moveListener = this.onTouchMove.bind(this);
		const endListener = this.onTouchEnd.bind(this);
		eElement.addEventListener("touchstart", startListener, { passive: true });
		eElement.addEventListener("touchmove", moveListener, { passive: true });
		eElement.addEventListener("touchend", endListener, { passive: false });
		this.destroyFuncs.push(() => {
			eElement.removeEventListener("touchstart", startListener, { passive: true });
			eElement.removeEventListener("touchmove", moveListener, { passive: true });
			eElement.removeEventListener("touchend", endListener, { passive: false });
		});
	}
	getActiveTouch(touchList) {
		for (let i = 0; i < touchList.length; i++) if (touchList[i].identifier === this.touchStart.identifier) return touchList[i];
		return null;
	}
	addEventListener(eventType, listener) {
		this.localEventService.addEventListener(eventType, listener);
	}
	removeEventListener(eventType, listener) {
		this.localEventService.removeEventListener(eventType, listener);
	}
	onTouchStart(touchEvent) {
		if (this.touching) return;
		this.touchStart = touchEvent.touches[0];
		this.touching = true;
		this.moved = false;
		const touchStartCopy = this.touchStart;
		window.setTimeout(() => {
			const touchesMatch = this.touchStart === touchStartCopy;
			if (this.touching && touchesMatch && !this.moved) {
				this.moved = true;
				const event = {
					type: "longTap",
					touchStart: this.touchStart,
					touchEvent
				};
				this.localEventService.dispatchEvent(event);
			}
		}, 500);
	}
	onTouchMove(touchEvent) {
		if (!this.touching) return;
		const touch = this.getActiveTouch(touchEvent.touches);
		if (!touch) return;
		if (!_areEventsNear(touch, this.touchStart, 4)) this.moved = true;
	}
	onTouchEnd(touchEvent) {
		if (!this.touching) return;
		if (!this.moved) {
			const event = {
				type: "tap",
				touchStart: this.touchStart
			};
			this.localEventService.dispatchEvent(event);
			this.checkForDoubleTap();
		}
		if (this.preventMouseClick && touchEvent.cancelable) touchEvent.preventDefault();
		this.touching = false;
	}
	checkForDoubleTap() {
		const now = Date.now();
		if (this.lastTapTime && this.lastTapTime > 0) if (now - this.lastTapTime > this.DOUBLE_TAP_MILLIS) {
			const event = {
				type: "doubleTap",
				touchStart: this.touchStart
			};
			this.localEventService.dispatchEvent(event);
			this.lastTapTime = null;
		} else this.lastTapTime = now;
		else this.lastTapTime = now;
	}
	destroy() {
		this.destroyFuncs.forEach((func) => func());
	}
};
var VanillaFrameworkOverrides = class {
	constructor(frameworkName = "javascript") {
		this.frameworkName = frameworkName;
		this.renderingEngine = "vanilla";
		this.batchFrameworkComps = false;
		this.wrapIncoming = (callback) => callback();
		this.wrapOutgoing = (callback) => callback();
		this.baseDocLink = `${BASE_URL}/${this.frameworkName}-data-grid`;
		setValidationDocLink(this.baseDocLink);
	}
	setInterval(action, timeout) {
		return new AgPromise((resolve) => {
			resolve(window.setInterval(action, timeout));
		});
	}
	addEventListener(element, type, listener, options) {
		let eventListenerOptions = {};
		if (typeof options === "object") eventListenerOptions = options;
		else if (typeof options === "boolean") eventListenerOptions = { capture: options };
		if (eventListenerOptions.passive == null) {
			const passive = getPassiveStateForEvent(type);
			if (passive != null) eventListenerOptions.passive = passive;
		}
		element.addEventListener(type, listener, eventListenerOptions);
	}
	frameworkComponent(_) {
		return null;
	}
	isFrameworkComponent(_) {
		return false;
	}
	getDocLink(path) {
		return `${this.baseDocLink}${path ? `/${path}` : ""}`;
	}
};
function createGridApi(context) {
	return {
		beanName: "gridApi",
		bean: context.getBean("apiFunctionSvc").api
	};
}
var beanNamePosition = Object.fromEntries([
	"licenseManager",
	"environment",
	"eventSvc",
	"gos",
	"paginationAutoPageSizeSvc",
	"apiFunctionSvc",
	"gridApi",
	"registry",
	"agCompUtils",
	"userCompFactory",
	"rowContainerHeight",
	"horizontalResizeSvc",
	"localeSvc",
	"pinnedRowModel",
	"dragSvc",
	"colGroupSvc",
	"visibleCols",
	"popupSvc",
	"selectionSvc",
	"colFilter",
	"quickFilter",
	"filterManager",
	"colModel",
	"headerNavigation",
	"pageBounds",
	"pagination",
	"pageBoundsListener",
	"rowSpanSvc",
	"stickyRowSvc",
	"rowRenderer",
	"expressionSvc",
	"alignedGridsSvc",
	"navigation",
	"valueCache",
	"valueSvc",
	"autoWidthCalc",
	"filterMenuFactory",
	"dragAndDrop",
	"focusSvc",
	"cellNavigation",
	"cellStyles",
	"scrollVisibleSvc",
	"sortSvc",
	"colHover",
	"colAnimation",
	"autoColSvc",
	"selectionColSvc",
	"changeDetectionSvc",
	"animationFrameSvc",
	"undoRedo",
	"colDefFactory",
	"rowStyleSvc",
	"rowNodeBlockLoader",
	"rowNodeSorter",
	"ctrlsSvc",
	"pinnedCols",
	"dataTypeSvc",
	"syncSvc",
	"overlays",
	"stateSvc",
	"expansionSvc",
	"apiEventSvc",
	"ariaAnnounce",
	"menuSvc",
	"colMoves",
	"colAutosize",
	"colFlex",
	"colResize",
	"pivotColsSvc",
	"valueColsSvc",
	"rowGroupColsSvc",
	"funcColsSvc",
	"colNames",
	"colViewport",
	"pivotResultCols",
	"showRowGroupCols",
	"validation"
].map((beanName, index) => [beanName, index]));
function gridBeanInitComparator(bean1, bean2) {
	return ((bean1.beanName ? beanNamePosition[bean1.beanName] : void 0) ?? Number.MAX_SAFE_INTEGER) - ((bean2.beanName ? beanNamePosition[bean2.beanName] : void 0) ?? Number.MAX_SAFE_INTEGER);
}
function gridBeanDestroyComparator(bean1, bean2) {
	if (bean1?.beanName === "gridDestroySvc") return -1;
	if (bean2?.beanName === "gridDestroySvc") return 1;
	return 0;
}
var PinnedLeftElement = {
	tag: "div",
	cls: "ag-pinned-left-header",
	role: "rowgroup"
};
var PinnedRightElement = {
	tag: "div",
	cls: "ag-pinned-right-header",
	role: "rowgroup"
};
var CenterElement = {
	tag: "div",
	cls: "ag-header-viewport",
	role: "presentation",
	attrs: { tabindex: "-1" },
	children: [{
		tag: "div",
		ref: "eCenterContainer",
		cls: "ag-header-container",
		role: "rowgroup"
	}]
};
var HeaderRowContainerComp = class extends Component {
	constructor(pinned) {
		super();
		this.eCenterContainer = null;
		this.headerRowComps = {};
		this.rowCompsList = [];
		this.pinned = pinned;
	}
	postConstruct() {
		this.selectAndSetTemplate();
		this.createManagedBean(new HeaderRowContainerCtrl(this.pinned)).setComp({
			setDisplayed: (displayed) => this.setDisplayed(displayed),
			setCtrls: (ctrls) => this.setCtrls(ctrls),
			setCenterWidth: (width) => this.eCenterContainer.style.width = width,
			setViewportScrollLeft: (left) => this.getGui().scrollLeft = left,
			setPinnedContainerWidth: (width) => {
				const eGui = this.getGui();
				eGui.style.width = width;
				eGui.style.maxWidth = width;
				eGui.style.minWidth = width;
			}
		}, this.getGui());
	}
	selectAndSetTemplate() {
		const pinnedLeft = this.pinned == "left";
		const pinnedRight = this.pinned == "right";
		const template = pinnedLeft ? PinnedLeftElement : pinnedRight ? PinnedRightElement : CenterElement;
		this.setTemplate(template);
		this.eRowContainer = this.eCenterContainer !== null ? this.eCenterContainer : this.getGui();
	}
	destroy() {
		this.setCtrls([]);
		super.destroy();
	}
	destroyRowComp(rowComp) {
		this.destroyBean(rowComp);
		this.eRowContainer.removeChild(rowComp.getGui());
	}
	setCtrls(ctrls) {
		const oldRowComps = this.headerRowComps;
		this.headerRowComps = {};
		this.rowCompsList = [];
		let prevGui;
		const appendEnsuringDomOrder = (rowComp) => {
			const eGui = rowComp.getGui();
			if (eGui.parentElement != this.eRowContainer) this.eRowContainer.appendChild(eGui);
			if (prevGui) _ensureDomOrder(this.eRowContainer, eGui, prevGui);
			prevGui = eGui;
		};
		ctrls.forEach((ctrl) => {
			const ctrlId = ctrl.instanceId;
			const existingComp = oldRowComps[ctrlId];
			delete oldRowComps[ctrlId];
			const rowComp = existingComp ? existingComp : this.createBean(new HeaderRowComp(ctrl));
			this.headerRowComps[ctrlId] = rowComp;
			this.rowCompsList.push(rowComp);
			appendEnsuringDomOrder(rowComp);
		});
		Object.values(oldRowComps).forEach((c) => this.destroyRowComp(c));
	}
};
var GridHeaderElement = {
	tag: "div",
	cls: "ag-header",
	role: "presentation"
};
var GridHeaderComp = class extends Component {
	constructor() {
		super(GridHeaderElement);
	}
	postConstruct() {
		this.createManagedBean(new GridHeaderCtrl()).setComp({
			toggleCss: (cssClassName, on) => this.toggleCss(cssClassName, on),
			setHeightAndMinHeight: (height) => {
				this.getGui().style.height = height;
				this.getGui().style.minHeight = height;
			}
		}, this.getGui(), this.getFocusableElement());
		const addContainer = (container) => {
			this.createManagedBean(container);
			this.appendChild(container);
		};
		addContainer(new HeaderRowContainerComp("left"));
		addContainer(new HeaderRowContainerComp(null));
		addContainer(new HeaderRowContainerComp("right"));
	}
};
var GridHeaderSelector = {
	selector: "AG-HEADER-ROOT",
	component: GridHeaderComp
};
var CellComp = class extends Component {
	constructor(beans, cellCtrl, printLayout, eRow, editingCell) {
		super();
		this.cellCtrl = cellCtrl;
		this.rendererVersion = 0;
		this.editorVersion = 0;
		this.beans = beans;
		this.gos = beans.gos;
		this.column = cellCtrl.column;
		this.rowNode = cellCtrl.rowNode;
		this.eRow = eRow;
		const cellDiv = _createElement({
			tag: "div",
			role: cellCtrl.getCellAriaRole(),
			attrs: {
				"comp-id": `${this.getCompId()}`,
				"col-id": cellCtrl.column.colIdSanitised
			}
		});
		this.eCell = cellDiv;
		let wrapperDiv;
		if (cellCtrl.isCellSpanning()) {
			wrapperDiv = _createElement({
				tag: "div",
				cls: "ag-spanned-cell-wrapper",
				role: "presentation"
			});
			wrapperDiv.appendChild(cellDiv);
			this.setTemplateFromElement(wrapperDiv);
		} else this.setTemplateFromElement(cellDiv);
		this.cellCssManager = new CssClassManager(() => cellDiv);
		this.forceWrapper = cellCtrl.isForceWrapper();
		this.refreshWrapper(false);
		cellCtrl.setComp({
			toggleCss: (cssClassName, on) => this.cellCssManager.toggleCss(cssClassName, on),
			setUserStyles: (styles) => _addStylesToElement(cellDiv, styles),
			getFocusableElement: () => cellDiv,
			setIncludeSelection: (include) => this.includeSelection = include,
			setIncludeRowDrag: (include) => this.includeRowDrag = include,
			setIncludeDndSource: (include) => this.includeDndSource = include,
			setRenderDetails: (compDetails, valueToDisplay, force) => this.setRenderDetails(compDetails, valueToDisplay, force),
			setEditDetails: (compDetails, popup, position) => this.setEditDetails(compDetails, popup, position),
			getCellEditor: () => this.cellEditor || null,
			getCellRenderer: () => this.cellRenderer || null,
			getParentOfValue: () => this.getParentOfValue(),
			refreshEditStyles: (editing, isPopup) => this.refreshEditStyles(editing, isPopup)
		}, cellDiv, wrapperDiv, this.eCellWrapper, printLayout, editingCell, void 0);
	}
	getParentOfValue() {
		return this.eCellValue ?? this.eCellWrapper ?? this.eCell;
	}
	setRenderDetails(compDetails, valueToDisplay, forceNewCellRendererInstance) {
		if (this.cellEditor && !this.cellEditorPopupWrapper) return;
		this.firstRender = this.firstRender == null;
		const controlWrapperChanged = this.refreshWrapper(false);
		this.refreshEditStyles(false);
		if (compDetails) {
			if (!(forceNewCellRendererInstance || controlWrapperChanged ? false : this.refreshCellRenderer(compDetails))) {
				this.destroyRenderer();
				this.createCellRendererInstance(compDetails);
			}
		} else {
			this.destroyRenderer();
			this.insertValueWithoutCellRenderer(valueToDisplay);
		}
	}
	setEditDetails(compDetails, popup, position) {
		if (compDetails) this.createCellEditorInstance(compDetails, popup, position);
		else this.destroyEditor();
	}
	removeControls() {
		const context = this.beans.context;
		this.checkboxSelectionComp = context.destroyBean(this.checkboxSelectionComp);
		this.dndSourceComp = context.destroyBean(this.dndSourceComp);
		this.rowDraggingComp = context.destroyBean(this.rowDraggingComp);
	}
	refreshWrapper(editing) {
		const providingControls = this.includeRowDrag || this.includeDndSource || this.includeSelection;
		const usingWrapper = providingControls || this.forceWrapper;
		const putWrapperIn = usingWrapper && this.eCellWrapper == null;
		if (putWrapperIn) {
			this.eCellWrapper = _createElement({
				tag: "div",
				cls: "ag-cell-wrapper",
				role: "presentation"
			});
			this.eCell.appendChild(this.eCellWrapper);
		}
		const takeWrapperOut = !usingWrapper && this.eCellWrapper != null;
		if (takeWrapperOut) {
			_removeFromParent(this.eCellWrapper);
			this.eCellWrapper = void 0;
		}
		this.cellCssManager.toggleCss("ag-cell-value", !usingWrapper);
		const usingCellValue = !editing && usingWrapper;
		const putCellValueIn = usingCellValue && this.eCellValue == null;
		if (putCellValueIn) {
			this.eCellValue = _createElement({
				tag: "span",
				cls: "ag-cell-value",
				role: "presentation"
			});
			this.eCellWrapper.appendChild(this.eCellValue);
		}
		const takeCellValueOut = !usingCellValue && this.eCellValue != null;
		if (takeCellValueOut) {
			_removeFromParent(this.eCellValue);
			this.eCellValue = void 0;
		}
		const templateChanged = putWrapperIn || takeWrapperOut || putCellValueIn || takeCellValueOut;
		if (templateChanged) this.removeControls();
		if (!editing && providingControls) this.addControls();
		return templateChanged;
	}
	addControls() {
		const { cellCtrl, eCellWrapper, eCellValue, includeRowDrag, includeDndSource, includeSelection } = this;
		const insertBefore = (comp) => {
			if (comp) eCellWrapper.insertBefore(comp.getGui(), eCellValue);
		};
		if (includeRowDrag && this.rowDraggingComp == null) {
			this.rowDraggingComp = cellCtrl.createRowDragComp();
			insertBefore(this.rowDraggingComp);
		}
		if (includeDndSource && this.dndSourceComp == null) {
			this.dndSourceComp = cellCtrl.createDndSource();
			insertBefore(this.dndSourceComp);
		}
		if (includeSelection && this.checkboxSelectionComp == null) {
			this.checkboxSelectionComp = cellCtrl.createSelectionCheckbox();
			insertBefore(this.checkboxSelectionComp);
		}
	}
	createCellEditorInstance(compDetails, popup, position) {
		const versionCopy = this.editorVersion;
		const cellEditorPromise = compDetails.newAgStackInstance();
		const { params } = compDetails;
		cellEditorPromise.then((c) => this.afterCellEditorCreated(versionCopy, c, params, popup, position));
		if (_missing(this.cellEditor) && params.cellStartedEdit) this.cellCtrl.focusCell(true);
	}
	insertValueWithoutCellRenderer(valueToDisplay) {
		const eParent = this.getParentOfValue();
		_clearElement(eParent);
		const escapedValue = _toString(valueToDisplay);
		if (escapedValue != null) eParent.textContent = escapedValue;
	}
	destroyRenderer() {
		const { context } = this.beans;
		this.cellRenderer = context.destroyBean(this.cellRenderer);
		_removeFromParent(this.cellRendererGui);
		this.cellRendererGui = null;
		this.rendererVersion++;
	}
	destroyEditor() {
		const { context } = this.beans;
		if (this.cellEditorPopupWrapper?.getGui().contains(_getActiveDomElement(this.beans)) || this.cellCtrl.hasBrowserFocus()) this.eCell.focus({ preventScroll: true });
		this.hideEditorPopup?.();
		this.hideEditorPopup = void 0;
		this.cellEditor = context.destroyBean(this.cellEditor);
		this.cellEditorPopupWrapper = context.destroyBean(this.cellEditorPopupWrapper);
		_removeFromParent(this.cellEditorGui);
		this.cellCtrl.disableEditorTooltipFeature();
		this.cellEditorGui = null;
		this.editorVersion++;
	}
	refreshCellRenderer(compClassAndParams) {
		if (this.cellRenderer?.refresh == null) return false;
		if (this.cellRendererClass !== compClassAndParams.componentClass) return false;
		const result = this.cellRenderer.refresh(compClassAndParams.params);
		return result === true || result === void 0;
	}
	createCellRendererInstance(compDetails) {
		const displayComponentVersionCopy = this.rendererVersion;
		const createCellRendererFunc = (details) => (_) => {
			if (this.rendererVersion !== displayComponentVersionCopy || !this.isAlive()) return;
			const componentPromise = details.newAgStackInstance();
			const callback = this.afterCellRendererCreated.bind(this, displayComponentVersionCopy, details.componentClass);
			componentPromise?.then(callback);
		};
		const { animationFrameSvc } = this.beans;
		let createTask;
		if (animationFrameSvc?.active && this.firstRender) createTask = (details, isDeferred = false) => {
			animationFrameSvc.createTask(createCellRendererFunc(details), this.rowNode.rowIndex, "p2", details.componentFromFramework, isDeferred);
		};
		else createTask = (details) => createCellRendererFunc(details)();
		if (compDetails.params?.deferRender && !this.cellCtrl.rowNode.group) {
			const { loadingComp, onReady } = this.cellCtrl.getDeferLoadingCellRenderer();
			if (loadingComp) {
				createTask(loadingComp);
				onReady.then(() => createTask(compDetails, true));
			}
		} else createTask(compDetails);
	}
	afterCellRendererCreated(cellRendererVersion, cellRendererClass, cellRenderer) {
		if (!this.isAlive() || cellRendererVersion !== this.rendererVersion) {
			this.beans.context.destroyBean(cellRenderer);
			return;
		}
		this.cellRenderer = cellRenderer;
		this.cellRendererClass = cellRendererClass;
		const cellGui = cellRenderer.getGui();
		this.cellRendererGui = cellGui;
		if (cellGui != null) {
			const eParent = this.getParentOfValue();
			_clearElement(eParent);
			eParent.appendChild(cellGui);
		}
	}
	afterCellEditorCreated(requestVersion, cellEditor, params, popup, position) {
		const staleComp = requestVersion !== this.editorVersion;
		const { context } = this.beans;
		if (staleComp) {
			context.destroyBean(cellEditor);
			return;
		}
		if (cellEditor.isCancelBeforeStart && cellEditor.isCancelBeforeStart()) {
			context.destroyBean(cellEditor);
			this.cellCtrl.stopEditing(true);
			return;
		}
		if (!cellEditor.getGui) {
			_warn(97, { colId: this.column.getId() });
			context.destroyBean(cellEditor);
			return;
		}
		this.cellEditor = cellEditor;
		this.cellEditorGui = cellEditor.getGui();
		const cellEditorInPopup = popup || cellEditor.isPopup !== void 0 && cellEditor.isPopup();
		if (cellEditorInPopup) this.addPopupCellEditor(params, position);
		else this.addInCellEditor();
		this.refreshEditStyles(true, cellEditorInPopup);
		cellEditor.afterGuiAttached?.();
		this.cellCtrl.enableEditorTooltipFeature(cellEditor);
		this.cellCtrl.cellEditorAttached();
	}
	refreshEditStyles(editing, isPopup) {
		const { cellCssManager } = this;
		cellCssManager.toggleCss("ag-cell-inline-editing", editing && !isPopup);
		cellCssManager.toggleCss("ag-cell-popup-editing", editing && !!isPopup);
		cellCssManager.toggleCss("ag-cell-not-inline-editing", !editing || !!isPopup);
	}
	addInCellEditor() {
		const { eCell } = this;
		if (eCell.contains(_getActiveDomElement(this.beans))) eCell.focus();
		this.destroyRenderer();
		this.refreshWrapper(true);
		_clearElement(this.getParentOfValue());
		if (this.cellEditorGui) this.getParentOfValue().appendChild(this.cellEditorGui);
	}
	addPopupCellEditor(params, position) {
		const { gos, context, popupSvc, editSvc } = this.beans;
		if (gos.get("editType") === "fullRow") _warn(98);
		const cellEditorPopupWrapper = this.cellEditorPopupWrapper = context.createBean(editSvc.createPopupEditorWrapper(params));
		const { cellEditor, cellEditorGui, eCell, rowNode, column, cellCtrl } = this;
		const ePopupGui = cellEditorPopupWrapper.getGui();
		if (cellEditorGui) ePopupGui.appendChild(cellEditorGui);
		const useModelPopup = gos.get("stopEditingWhenCellsLoseFocus");
		const positionParams = {
			ePopup: ePopupGui,
			column,
			rowNode,
			type: "popupCellEditor",
			eventSource: eCell,
			position: position != null ? position : cellEditor.getPopupPosition?.() ?? "over",
			alignSide: gos.get("enableRtl") ? "right" : "left",
			keepWithinBounds: true
		};
		const positionCallback = popupSvc.positionPopupByComponent.bind(popupSvc, positionParams);
		const addPopupRes = popupSvc.addPopup({
			modal: useModelPopup,
			eChild: ePopupGui,
			closeOnEsc: true,
			closedCallback: () => {
				cellCtrl.onPopupEditorClosed();
			},
			anchorToElement: eCell,
			positionCallback,
			ariaOwns: eCell
		});
		if (addPopupRes) this.hideEditorPopup = addPopupRes.hideFunc;
	}
	detach() {
		this.eRow.removeChild(this.getGui());
	}
	destroy() {
		this.destroyRenderer();
		this.destroyEditor();
		this.removeControls();
		super.destroy();
	}
};
var RowComp = class extends Component {
	constructor(ctrl, beans, containerType) {
		super();
		this.cellComps = /* @__PURE__ */ new Map();
		this.beans = beans;
		this.rowCtrl = ctrl;
		const rowDiv = _createElement({
			tag: "div",
			role: "row",
			attrs: { "comp-id": `${this.getCompId()}` }
		});
		this.setInitialStyle(rowDiv, containerType);
		this.setTemplateFromElement(rowDiv);
		const style = rowDiv.style;
		this.domOrder = this.rowCtrl.getDomOrder();
		ctrl.setComp({
			setDomOrder: (domOrder) => this.domOrder = domOrder,
			setCellCtrls: (cellCtrls) => this.setCellCtrls(cellCtrls),
			showFullWidth: (compDetails) => this.showFullWidth(compDetails),
			getFullWidthCellRenderer: () => this.fullWidthCellRenderer,
			toggleCss: (name, on) => this.toggleCss(name, on),
			setUserStyles: (styles) => _addStylesToElement(rowDiv, styles),
			setTop: (top) => style.top = top,
			setTransform: (transform) => style.transform = transform,
			setRowIndex: (rowIndex) => rowDiv.setAttribute("row-index", rowIndex),
			setRowId: (rowId) => rowDiv.setAttribute("row-id", rowId),
			setRowBusinessKey: (businessKey) => rowDiv.setAttribute("row-business-key", businessKey),
			refreshFullWidth: (getUpdatedParams) => this.fullWidthCellRenderer?.refresh?.(getUpdatedParams()) ?? false
		}, this.getGui(), containerType, void 0);
		this.addDestroyFunc(() => {
			ctrl.unsetComp(containerType);
		});
	}
	setInitialStyle(container, containerType) {
		const transform = this.rowCtrl.getInitialTransform(containerType);
		if (transform) container.style.setProperty("transform", transform);
		else {
			const top = this.rowCtrl.getInitialRowTop(containerType);
			if (top) container.style.setProperty("top", top);
		}
	}
	showFullWidth(compDetails) {
		const callback = (cellRenderer) => {
			if (this.isAlive()) {
				const eGui = cellRenderer.getGui();
				this.getGui().appendChild(eGui);
				this.rowCtrl.setupDetailRowAutoHeight(eGui);
				this.setFullWidthRowComp(cellRenderer);
			} else this.beans.context.destroyBean(cellRenderer);
		};
		compDetails.newAgStackInstance().then(callback);
	}
	setCellCtrls(cellCtrls) {
		const cellsToRemove = new Map(this.cellComps);
		for (const cellCtrl of cellCtrls) {
			const key = cellCtrl.instanceId;
			if (!this.cellComps.has(key)) this.newCellComp(cellCtrl);
			else cellsToRemove.delete(key);
		}
		this.destroyCells(cellsToRemove);
		this.ensureDomOrder(cellCtrls);
	}
	ensureDomOrder(cellCtrls) {
		if (!this.domOrder) return;
		const elementsInOrder = [];
		for (const cellCtrl of cellCtrls) {
			const cellComp = this.cellComps.get(cellCtrl.instanceId);
			if (cellComp) elementsInOrder.push(cellComp.getGui());
		}
		_setDomChildOrder(this.getGui(), elementsInOrder);
	}
	newCellComp(cellCtrl) {
		const editing = this.beans.editSvc?.isEditing(cellCtrl, { withOpenEditor: true }) ?? false;
		const cellComp = new CellComp(this.beans, cellCtrl, this.rowCtrl.printLayout, this.getGui(), editing);
		this.cellComps.set(cellCtrl.instanceId, cellComp);
		this.getGui().appendChild(cellComp.getGui());
	}
	destroy() {
		super.destroy();
		this.destroyCells(this.cellComps);
	}
	setFullWidthRowComp(fullWidthRowComponent) {
		this.fullWidthCellRenderer = fullWidthRowComponent;
		this.addDestroyFunc(() => {
			this.fullWidthCellRenderer = this.beans.context.destroyBean(this.fullWidthCellRenderer);
		});
	}
	destroyCells(cellComps) {
		for (const cellComp of cellComps.values()) {
			if (!cellComp) return;
			const instanceId = cellComp.cellCtrl.instanceId;
			if (this.cellComps.get(instanceId) !== cellComp) return;
			cellComp.detach();
			cellComp.destroy();
			this.cellComps.delete(instanceId);
		}
	}
};
function getElementParams(name, options, beans) {
	const isCellSpanning = !!beans.gos.get("enableCellSpan") && !!options.getSpannedRowCtrls;
	const eContainerElement = {
		tag: "div",
		ref: "eContainer",
		cls: _getRowContainerClass(name),
		role: "rowgroup"
	};
	if (options.type === "center" || isCellSpanning) {
		const eSpannedContainerElement = {
			tag: "div",
			ref: "eSpannedContainer",
			cls: `ag-spanning-container ${_getRowSpanContainerClass(name)}`,
			role: "rowgroup"
		};
		return {
			tag: "div",
			ref: "eViewport",
			cls: `ag-viewport ${_getRowViewportClass(name)}`,
			role: "presentation",
			children: [eContainerElement, isCellSpanning ? eSpannedContainerElement : null]
		};
	}
	return eContainerElement;
}
var RowContainerComp = class extends Component {
	constructor(params) {
		super();
		this.eViewport = null;
		this.eContainer = null;
		this.eSpannedContainer = null;
		this.rowCompsNoSpan = {};
		this.rowCompsWithSpan = {};
		this.name = params?.name;
		this.options = _getRowContainerOptions(this.name);
	}
	postConstruct() {
		this.setTemplate(getElementParams(this.name, this.options, this.beans));
		this.createManagedBean(new RowContainerCtrl(this.name)).setComp({
			setHorizontalScroll: (offset) => this.eViewport.scrollLeft = offset,
			setViewportHeight: (height) => this.eViewport.style.height = height,
			setRowCtrls: ({ rowCtrls }) => this.setRowCtrls(rowCtrls),
			setSpannedRowCtrls: (rowCtrls) => this.setRowCtrls(rowCtrls, true),
			setDomOrder: (domOrder) => {
				this.domOrder = domOrder;
			},
			setContainerWidth: (width) => {
				this.eContainer.style.width = width;
				if (this.eSpannedContainer) this.eSpannedContainer.style.width = width;
			},
			setOffsetTop: (offset) => {
				const top = `translateY(${offset})`;
				this.eContainer.style.transform = top;
				if (this.eSpannedContainer) this.eSpannedContainer.style.transform = top;
			}
		}, this.eContainer, this.eSpannedContainer, this.eViewport);
	}
	destroy() {
		this.setRowCtrls([]);
		this.setRowCtrls([], true);
		super.destroy();
		this.lastPlacedElement = null;
	}
	setRowCtrls(rowCtrls, spanContainer) {
		const { beans, options } = this;
		const container = spanContainer ? this.eSpannedContainer : this.eContainer;
		const oldRows = spanContainer ? { ...this.rowCompsWithSpan } : { ...this.rowCompsNoSpan };
		const newComps = {};
		if (spanContainer) this.rowCompsWithSpan = newComps;
		else this.rowCompsNoSpan = newComps;
		this.lastPlacedElement = null;
		const orderedRows = [];
		for (const rowCtrl of rowCtrls) {
			const instanceId = rowCtrl.instanceId;
			const existingRowComp = oldRows[instanceId];
			let rowComp;
			if (existingRowComp) {
				rowComp = existingRowComp;
				delete oldRows[instanceId];
			} else {
				if (!rowCtrl.rowNode.displayed) continue;
				rowComp = new RowComp(rowCtrl, beans, options.type);
			}
			newComps[instanceId] = rowComp;
			orderedRows.push([rowComp, !existingRowComp]);
		}
		this.removeOldRows(Object.values(oldRows), container);
		this.addRowNodes(orderedRows, container);
	}
	addRowNodes(rows, container) {
		const { domOrder } = this;
		for (const [rowComp, isNew] of rows) {
			const eGui = rowComp.getGui();
			if (!domOrder) {
				if (isNew) container.appendChild(eGui);
			} else this.ensureDomOrder(eGui, container);
		}
	}
	removeOldRows(rowComps, container) {
		for (const oldRowComp of rowComps) {
			container.removeChild(oldRowComp.getGui());
			oldRowComp.destroy();
		}
	}
	ensureDomOrder(eRow, container) {
		_ensureDomOrder(container, eRow, this.lastPlacedElement);
		this.lastPlacedElement = eRow;
	}
};
var RowContainerSelector = {
	selector: "AG-ROW-CONTAINER",
	component: RowContainerComp
};
function makeRowContainers(paramsMap, names) {
	return names.map((name) => {
		const refName = `e${name[0].toUpperCase() + name.substring(1)}RowContainer`;
		paramsMap[refName] = { name };
		return {
			tag: "ag-row-container",
			ref: refName,
			attrs: { name }
		};
	});
}
function getGridBodyTemplate(includeOverlay) {
	const paramsMap = {};
	return {
		paramsMap,
		elementParams: {
			tag: "div",
			ref: "eGridRoot",
			cls: "ag-root ag-unselectable",
			children: [
				{ tag: "ag-header-root" },
				{
					tag: "div",
					ref: "eTop",
					cls: "ag-floating-top",
					role: "presentation",
					children: makeRowContainers(paramsMap, [
						"topLeft",
						"topCenter",
						"topRight",
						"topFullWidth"
					])
				},
				{
					tag: "div",
					ref: "eBody",
					cls: "ag-body",
					role: "presentation",
					children: [{
						tag: "div",
						ref: "eBodyViewport",
						cls: "ag-body-viewport",
						role: "presentation",
						children: makeRowContainers(paramsMap, [
							"left",
							"center",
							"right",
							"fullWidth"
						])
					}, { tag: "ag-fake-vertical-scroll" }]
				},
				{
					tag: "div",
					ref: "eStickyTop",
					cls: "ag-sticky-top",
					role: "presentation",
					children: makeRowContainers(paramsMap, [
						"stickyTopLeft",
						"stickyTopCenter",
						"stickyTopRight",
						"stickyTopFullWidth"
					])
				},
				{
					tag: "div",
					ref: "eStickyBottom",
					cls: "ag-sticky-bottom",
					role: "presentation",
					children: makeRowContainers(paramsMap, [
						"stickyBottomLeft",
						"stickyBottomCenter",
						"stickyBottomRight",
						"stickyBottomFullWidth"
					])
				},
				{
					tag: "div",
					ref: "eBottom",
					cls: "ag-floating-bottom",
					role: "presentation",
					children: makeRowContainers(paramsMap, [
						"bottomLeft",
						"bottomCenter",
						"bottomRight",
						"bottomFullWidth"
					])
				},
				{ tag: "ag-fake-horizontal-scroll" },
				includeOverlay ? { tag: "ag-overlay-wrapper" } : null
			]
		}
	};
}
var GridBodyComp = class extends Component {
	constructor() {
		super(...arguments);
		this.eGridRoot = null;
		this.eBodyViewport = null;
		this.eStickyTop = null;
		this.eStickyBottom = null;
		this.eTop = null;
		this.eBottom = null;
		this.eBody = null;
	}
	postConstruct() {
		const { overlays, rangeSvc } = this.beans;
		const overlaySelector = overlays?.getOverlayWrapperSelector();
		const { paramsMap, elementParams } = getGridBodyTemplate(!!overlaySelector);
		this.setTemplate(elementParams, [
			...overlaySelector ? [overlaySelector] : [],
			FakeHScrollSelector,
			FakeVScrollSelector,
			GridHeaderSelector,
			RowContainerSelector
		], paramsMap);
		const setHeight = (height, element) => {
			const heightString = `${height}px`;
			element.style.minHeight = heightString;
			element.style.height = heightString;
		};
		const compProxy = {
			setRowAnimationCssOnBodyViewport: (cssClass, animate) => this.setRowAnimationCssOnBodyViewport(cssClass, animate),
			setColumnCount: (count) => _setAriaColCount(this.getGui(), count),
			setRowCount: (count) => _setAriaRowCount(this.getGui(), count),
			setTopHeight: (height) => setHeight(height, this.eTop),
			setBottomHeight: (height) => setHeight(height, this.eBottom),
			setTopInvisible: (invisible) => this.eTop.classList.toggle("ag-invisible", invisible),
			setBottomInvisible: (invisible) => this.eBottom.classList.toggle("ag-invisible", invisible),
			setStickyTopHeight: (height) => this.eStickyTop.style.height = height,
			setStickyTopTop: (top) => this.eStickyTop.style.top = top,
			setStickyTopWidth: (width) => this.eStickyTop.style.width = width,
			setStickyBottomHeight: (height) => {
				this.eStickyBottom.style.height = height;
				this.eStickyBottom.classList.toggle("ag-invisible", height === "0px");
			},
			setStickyBottomBottom: (bottom) => this.eStickyBottom.style.bottom = bottom,
			setStickyBottomWidth: (width) => this.eStickyBottom.style.width = width,
			setColumnMovingCss: (cssClass, flag) => this.toggleCss(cssClass, flag),
			updateLayoutClasses: (cssClass, params) => {
				const classLists = [this.eBodyViewport.classList, this.eBody.classList];
				for (const classList of classLists) {
					classList.toggle(LayoutCssClasses.AUTO_HEIGHT, params.autoHeight);
					classList.toggle(LayoutCssClasses.NORMAL, params.normal);
					classList.toggle(LayoutCssClasses.PRINT, params.print);
				}
				this.toggleCss(LayoutCssClasses.AUTO_HEIGHT, params.autoHeight);
				this.toggleCss(LayoutCssClasses.NORMAL, params.normal);
				this.toggleCss(LayoutCssClasses.PRINT, params.print);
			},
			setAlwaysVerticalScrollClass: (cssClass, on) => this.eBodyViewport.classList.toggle(CSS_CLASS_FORCE_VERTICAL_SCROLL, on),
			registerBodyViewportResizeListener: (listener) => {
				const unsubscribeFromResize = _observeResize(this.beans, this.eBodyViewport, listener);
				this.addDestroyFunc(() => unsubscribeFromResize());
			},
			setPinnedTopBottomOverflowY: (overflow) => this.eTop.style.overflowY = this.eBottom.style.overflowY = overflow,
			setCellSelectableCss: (cssClass, selectable) => {
				[
					this.eTop,
					this.eBodyViewport,
					this.eBottom
				].forEach((ct) => ct.classList.toggle(cssClass, selectable));
			},
			setBodyViewportWidth: (width) => this.eBodyViewport.style.width = width,
			setGridRootRole: (role) => _setAriaRole(this.eGridRoot, role)
		};
		this.ctrl = this.createManagedBean(new GridBodyCtrl());
		this.ctrl.setComp(compProxy, this.getGui(), this.eBodyViewport, this.eTop, this.eBottom, this.eStickyTop, this.eStickyBottom);
		if (rangeSvc && _isCellSelectionEnabled(this.gos) || _isMultiRowSelection(this.gos)) _setAriaMultiSelectable(this.getGui(), true);
	}
	setRowAnimationCssOnBodyViewport(cssClass, animateRows) {
		const bodyViewportClassList = this.eBodyViewport.classList;
		bodyViewportClassList.toggle("ag-row-animation", animateRows);
		bodyViewportClassList.toggle("ag-row-no-animation", !animateRows);
	}
};
var GridBodySelector = {
	selector: "AG-GRID-BODY",
	component: GridBodyComp
};
var GridCtrl = class extends BeanStub {
	constructor() {
		super(...arguments);
		this.additionalFocusableContainers = /* @__PURE__ */ new Set();
	}
	setComp(view, eGridDiv, eGui) {
		this.view = view;
		this.eGridHostDiv = eGridDiv;
		this.eGui = eGui;
		this.eGui.setAttribute("grid-id", this.beans.context.getGridId());
		const { dragAndDrop, ctrlsSvc } = this.beans;
		dragAndDrop?.registerGridDropTarget(() => this.eGui, this);
		_stampTopLevelGridCompWithGridInstance(this.gos, eGridDiv);
		this.createManagedBean(new LayoutFeature(this.view));
		this.view.setRtlClass(this.gos.get("enableRtl") ? "ag-rtl" : "ag-ltr");
		const unsubscribeFromResize = _observeResize(this.beans, this.eGridHostDiv, this.onGridSizeChanged.bind(this));
		this.addDestroyFunc(() => unsubscribeFromResize());
		ctrlsSvc.register("gridCtrl", this);
	}
	isDetailGrid() {
		return _findTabbableParent(this.getGui())?.getAttribute("row-id")?.startsWith("detail") || false;
	}
	getOptionalSelectors() {
		const beans = this.beans;
		return {
			paginationSelector: beans.pagination?.getPaginationSelector(),
			gridHeaderDropZonesSelector: beans.registry?.getSelector("AG-GRID-HEADER-DROP-ZONES"),
			sideBarSelector: beans.sideBar?.getSelector(),
			statusBarSelector: beans.registry?.getSelector("AG-STATUS-BAR"),
			watermarkSelector: beans.licenseManager?.getWatermarkSelector()
		};
	}
	onGridSizeChanged() {
		this.eventSvc.dispatchEvent({
			type: "gridSizeChanged",
			clientWidth: this.eGridHostDiv.clientWidth,
			clientHeight: this.eGridHostDiv.clientHeight
		});
	}
	destroyGridUi() {
		this.view.destroyGridUi();
	}
	getGui() {
		return this.eGui;
	}
	setResizeCursor(direction) {
		const { view } = this;
		if (direction === false) view.setCursor(null);
		else {
			const cursor = direction === 1 ? "ew-resize" : "ns-resize";
			view.setCursor(cursor);
		}
	}
	disableUserSelect(on) {
		this.view.setUserSelect(on ? "none" : null);
	}
	focusNextInnerContainer(backwards) {
		const focusableContainers = this.getFocusableContainers();
		const { indexWithFocus, nextIndex } = this.getNextFocusableIndex(focusableContainers, backwards);
		if (nextIndex < 0 || nextIndex >= focusableContainers.length) return false;
		if (nextIndex === 0) {
			if (indexWithFocus > 0) {
				const { visibleCols, focusSvc } = this.beans;
				const allColumns = visibleCols.allCols;
				const lastColumn = _last(allColumns);
				if (focusSvc.focusGridView({
					column: lastColumn,
					backwards: true
				})) return true;
			}
			return false;
		}
		return this.focusContainer(focusableContainers[nextIndex], backwards);
	}
	focusInnerElement(fromBottom) {
		const userCallbackFunction = this.gos.getCallback("focusGridInnerElement");
		if (userCallbackFunction && userCallbackFunction({ fromBottom: !!fromBottom })) return true;
		const focusableContainers = this.getFocusableContainers();
		const { focusSvc, visibleCols } = this.beans;
		const allColumns = visibleCols.allCols;
		if (fromBottom) {
			if (focusableContainers.length > 1) return this.focusContainer(_last(focusableContainers), fromBottom);
			const lastColumn = _last(allColumns);
			if (focusSvc.focusGridView({
				column: lastColumn,
				backwards: fromBottom
			})) return true;
		}
		if (this.gos.get("headerHeight") === 0 || _isHeaderFocusSuppressed(this.beans)) {
			if (focusSvc.focusGridView({
				column: allColumns[0],
				backwards: fromBottom
			})) return true;
			for (let i = 1; i < focusableContainers.length; i++) if (_focusInto(focusableContainers[i].getGui(), fromBottom)) return true;
			return false;
		}
		return focusSvc.focusFirstHeader();
	}
	forceFocusOutOfContainer(up = false) {
		this.view.forceFocusOutOfContainer(up);
	}
	addFocusableContainer(container) {
		this.additionalFocusableContainers.add(container);
	}
	removeFocusableContainer(container) {
		this.additionalFocusableContainers.delete(container);
	}
	allowFocusForNextCoreContainer(up) {
		const coreContainers = this.view.getFocusableContainers();
		const { nextIndex, indexWithFocus } = this.getNextFocusableIndex(coreContainers, up);
		if (indexWithFocus === -1 || nextIndex < 0 || nextIndex >= coreContainers.length) return;
		const comp = coreContainers[nextIndex];
		comp.setAllowFocus?.(true);
		setTimeout(() => {
			comp.setAllowFocus?.(false);
		});
	}
	isFocusable() {
		const beans = this.beans;
		return !_isCellFocusSuppressed(beans) || !_isHeaderFocusSuppressed(beans) || !!beans.sideBar?.comp?.isDisplayed();
	}
	getNextFocusableIndex(focusableContainers, backwards) {
		const activeEl = _getActiveDomElement(this.beans);
		const indexWithFocus = focusableContainers.findIndex((container) => container.getGui().contains(activeEl));
		return {
			indexWithFocus,
			nextIndex: indexWithFocus + (backwards ? -1 : 1)
		};
	}
	focusContainer(comp, up) {
		comp.setAllowFocus?.(true);
		const result = _focusInto(comp.getGui(), up, false, true);
		comp.setAllowFocus?.(false);
		return result;
	}
	getFocusableContainers() {
		return [...this.view.getFocusableContainers(), ...this.additionalFocusableContainers];
	}
	destroy() {
		this.additionalFocusableContainers.clear();
		super.destroy();
	}
};
var GridComp = class extends TabGuardComp {
	constructor(eGridDiv) {
		super();
		this.gridBody = null;
		this.sideBar = null;
		this.pagination = null;
		this.rootWrapperBody = null;
		this.eGridDiv = eGridDiv;
	}
	postConstruct() {
		const compProxy = {
			destroyGridUi: () => this.destroyBean(this),
			setRtlClass: (cssClass) => this.addCss(cssClass),
			forceFocusOutOfContainer: this.forceFocusOutOfContainer.bind(this),
			updateLayoutClasses: this.updateLayoutClasses.bind(this),
			getFocusableContainers: this.getFocusableContainers.bind(this),
			setUserSelect: (value) => {
				this.getGui().style.userSelect = value != null ? value : "";
				this.getGui().style.webkitUserSelect = value != null ? value : "";
			},
			setCursor: (value) => {
				this.getGui().style.cursor = value != null ? value : "";
			}
		};
		const ctrl = this.createManagedBean(new GridCtrl());
		const comps = ctrl.getOptionalSelectors();
		const template = this.createTemplate(comps);
		const requiredComps = [GridBodySelector, ...Object.values(comps).filter((c) => !!c)];
		this.setTemplate(template, requiredComps);
		ctrl.setComp(compProxy, this.eGridDiv, this.getGui());
		this.insertGridIntoDom();
		this.initialiseTabGuard({
			onTabKeyDown: () => void 0,
			focusInnerElement: (fromBottom) => ctrl.focusInnerElement(fromBottom),
			forceFocusOutWhenTabGuardsAreEmpty: true,
			isEmpty: () => !ctrl.isFocusable()
		});
	}
	insertGridIntoDom() {
		const eGui = this.getGui();
		this.eGridDiv.appendChild(eGui);
		this.addDestroyFunc(() => {
			this.eGridDiv.removeChild(eGui);
			_logIfDebug(this.gos, "Grid removed from DOM");
		});
	}
	updateLayoutClasses(cssClass, params) {
		const eRootWrapperBodyClassList = this.rootWrapperBody.classList;
		const { AUTO_HEIGHT, NORMAL, PRINT } = LayoutCssClasses;
		const { autoHeight, normal, print } = params;
		eRootWrapperBodyClassList.toggle(AUTO_HEIGHT, autoHeight);
		eRootWrapperBodyClassList.toggle(NORMAL, normal);
		eRootWrapperBodyClassList.toggle(PRINT, print);
		this.toggleCss(AUTO_HEIGHT, autoHeight);
		this.toggleCss(NORMAL, normal);
		this.toggleCss(PRINT, print);
	}
	createTemplate(params) {
		const dropZones = params.gridHeaderDropZonesSelector ? { tag: "ag-grid-header-drop-zones" } : null;
		const sideBar = params.sideBarSelector ? {
			tag: "ag-side-bar",
			ref: "sideBar"
		} : null;
		const statusBar = params.statusBarSelector ? { tag: "ag-status-bar" } : null;
		const watermark = params.watermarkSelector ? { tag: "ag-watermark" } : null;
		const pagination = params.paginationSelector ? {
			tag: "ag-pagination",
			ref: "pagination"
		} : null;
		return {
			tag: "div",
			cls: "ag-root-wrapper",
			role: "presentation",
			children: [
				dropZones,
				{
					tag: "div",
					ref: "rootWrapperBody",
					cls: "ag-root-wrapper-body",
					role: "presentation",
					children: [{
						tag: "ag-grid-body",
						ref: "gridBody"
					}, sideBar]
				},
				statusBar,
				pagination,
				watermark
			]
		};
	}
	getFocusableElement() {
		return this.rootWrapperBody;
	}
	forceFocusOutOfContainer(up = false) {
		if (!up && this.pagination?.isDisplayed()) {
			this.pagination.forceFocusOutOfContainer(up);
			return;
		}
		super.forceFocusOutOfContainer(up);
	}
	getFocusableContainers() {
		const focusableContainers = [this.gridBody];
		[this.sideBar, this.pagination].forEach((comp) => {
			if (comp) focusableContainers.push(comp);
		});
		return focusableContainers.filter((el) => _isVisible(el.getGui()));
	}
};
var mod = (moduleName, input) => {
	for (const key of Object.keys(input)) input[key] = moduleName;
	return input;
};
var gridApiFunctionsMap = {
	dispatchEvent: "CommunityCore",
	...mod("CommunityCore", {
		destroy: 0,
		getGridId: 0,
		getGridOption: 0,
		isDestroyed: 0,
		setGridOption: 0,
		updateGridOptions: 0,
		isModuleRegistered: 0
	}),
	...mod("GridState", {
		getState: 0,
		setState: 0
	}),
	...mod("SharedRowSelection", {
		setNodesSelected: 0,
		selectAll: 0,
		deselectAll: 0,
		selectAllFiltered: 0,
		deselectAllFiltered: 0,
		selectAllOnCurrentPage: 0,
		deselectAllOnCurrentPage: 0,
		getSelectedNodes: 0,
		getSelectedRows: 0
	}),
	...mod("RowApi", {
		redrawRows: 0,
		setRowNodeExpanded: 0,
		getRowNode: 0,
		addRenderedRowListener: 0,
		getRenderedNodes: 0,
		forEachNode: 0,
		getFirstDisplayedRowIndex: 0,
		getLastDisplayedRowIndex: 0,
		getDisplayedRowAtIndex: 0,
		getDisplayedRowCount: 0
	}),
	...mod("ScrollApi", {
		getVerticalPixelRange: 0,
		getHorizontalPixelRange: 0,
		ensureColumnVisible: 0,
		ensureIndexVisible: 0,
		ensureNodeVisible: 0
	}),
	...mod("KeyboardNavigation", {
		getFocusedCell: 0,
		clearFocusedCell: 0,
		setFocusedCell: 0,
		tabToNextCell: 0,
		tabToPreviousCell: 0,
		setFocusedHeader: 0
	}),
	...mod("EventApi", {
		addEventListener: 0,
		addGlobalListener: 0,
		removeEventListener: 0,
		removeGlobalListener: 0
	}),
	...mod("ValueCache", { expireValueCache: 0 }),
	...mod("CellApi", { getCellValue: 0 }),
	...mod("SharedMenu", {
		showColumnMenu: 0,
		hidePopupMenu: 0
	}),
	...mod("Sort", { onSortChanged: 0 }),
	...mod("PinnedRow", {
		getPinnedTopRowCount: 0,
		getPinnedBottomRowCount: 0,
		getPinnedTopRow: 0,
		getPinnedBottomRow: 0,
		forEachPinnedRow: 0
	}),
	...mod("Overlay", {
		showLoadingOverlay: 0,
		showNoRowsOverlay: 0,
		hideOverlay: 0
	}),
	...mod("RenderApi", {
		setGridAriaProperty: 0,
		refreshCells: 0,
		refreshHeader: 0,
		isAnimationFrameQueueEmpty: 0,
		flushAllAnimationFrames: 0,
		getSizesForCurrentTheme: 0,
		getCellRendererInstances: 0
	}),
	...mod("HighlightChanges", { flashCells: 0 }),
	...mod("RowDrag", {
		addRowDropZone: 0,
		removeRowDropZone: 0,
		getRowDropZoneParams: 0,
		getRowDropPositionIndicator: 0,
		setRowDropPositionIndicator: 0
	}),
	...mod("ColumnApi", {
		getColumnDefs: 0,
		getColumnDef: 0,
		getDisplayNameForColumn: 0,
		getColumn: 0,
		getColumns: 0,
		applyColumnState: 0,
		getColumnState: 0,
		resetColumnState: 0,
		isPinning: 0,
		isPinningLeft: 0,
		isPinningRight: 0,
		getDisplayedColAfter: 0,
		getDisplayedColBefore: 0,
		setColumnsVisible: 0,
		setColumnsPinned: 0,
		getAllGridColumns: 0,
		getDisplayedLeftColumns: 0,
		getDisplayedCenterColumns: 0,
		getDisplayedRightColumns: 0,
		getAllDisplayedColumns: 0,
		getAllDisplayedVirtualColumns: 0
	}),
	...mod("ColumnAutoSize", {
		sizeColumnsToFit: 0,
		autoSizeColumns: 0,
		autoSizeAllColumns: 0
	}),
	...mod("ColumnGroup", {
		setColumnGroupOpened: 0,
		getColumnGroup: 0,
		getProvidedColumnGroup: 0,
		getDisplayNameForColumnGroup: 0,
		getColumnGroupState: 0,
		setColumnGroupState: 0,
		resetColumnGroupState: 0,
		getLeftDisplayedColumnGroups: 0,
		getCenterDisplayedColumnGroups: 0,
		getRightDisplayedColumnGroups: 0,
		getAllDisplayedColumnGroups: 0
	}),
	...mod("ColumnMove", {
		moveColumnByIndex: 0,
		moveColumns: 0
	}),
	...mod("ColumnResize", { setColumnWidths: 0 }),
	...mod("ColumnHover", { isColumnHovered: 0 }),
	...mod("EditCore", {
		getCellEditorInstances: 0,
		getEditingCells: 0,
		stopEditing: 0,
		startEditingCell: 0,
		isEditing: 0,
		validateEdit: 0
	}),
	...mod("BatchEdit", {
		startBatchEdit: 0,
		cancelBatchEdit: 0,
		commitBatchEdit: 0,
		isBatchEditing: 0
	}),
	...mod("UndoRedoEdit", {
		undoCellEditing: 0,
		redoCellEditing: 0,
		getCurrentUndoSize: 0,
		getCurrentRedoSize: 0
	}),
	...mod("FilterCore", {
		isAnyFilterPresent: 0,
		onFilterChanged: 0
	}),
	...mod("ColumnFilter", {
		isColumnFilterPresent: 0,
		getColumnFilterInstance: 0,
		destroyFilter: 0,
		setFilterModel: 0,
		getFilterModel: 0,
		getColumnFilterModel: 0,
		setColumnFilterModel: 0,
		showColumnFilter: 0,
		hideColumnFilter: 0,
		getColumnFilterHandler: 0,
		doFilterAction: 0
	}),
	...mod("QuickFilter", {
		isQuickFilterPresent: 0,
		getQuickFilter: 0,
		resetQuickFilter: 0
	}),
	...mod("Find", {
		findGetActiveMatch: 0,
		findGetTotalMatches: 0,
		findGoTo: 0,
		findNext: 0,
		findPrevious: 0,
		findGetNumMatches: 0,
		findGetParts: 0,
		findClearActive: 0,
		findRefresh: 0
	}),
	...mod("Pagination", {
		paginationIsLastPageFound: 0,
		paginationGetPageSize: 0,
		paginationGetCurrentPage: 0,
		paginationGetTotalPages: 0,
		paginationGetRowCount: 0,
		paginationGoToNextPage: 0,
		paginationGoToPreviousPage: 0,
		paginationGoToFirstPage: 0,
		paginationGoToLastPage: 0,
		paginationGoToPage: 0
	}),
	...mod("CsrmSsrmSharedApi", {
		expandAll: 0,
		collapseAll: 0,
		onRowHeightChanged: 0
	}),
	...mod("SsrmInfiniteSharedApi", {
		setRowCount: 0,
		getCacheBlockState: 0,
		isLastRowIndexKnown: 0
	}),
	...mod("ClientSideRowModelApi", {
		onGroupExpandedOrCollapsed: 0,
		refreshClientSideRowModel: 0,
		isRowDataEmpty: 0,
		forEachLeafNode: 0,
		forEachNodeAfterFilter: 0,
		forEachNodeAfterFilterAndSort: 0,
		resetRowHeights: 0,
		applyTransaction: 0,
		applyTransactionAsync: 0,
		flushAsyncTransactions: 0,
		getBestCostNodeSelection: 0
	}),
	...mod("CsvExport", {
		getDataAsCsv: 0,
		exportDataAsCsv: 0
	}),
	...mod("InfiniteRowModel", {
		refreshInfiniteCache: 0,
		purgeInfiniteCache: 0,
		getInfiniteRowCount: 0
	}),
	...mod("AdvancedFilter", {
		getAdvancedFilterModel: 0,
		setAdvancedFilterModel: 0,
		showAdvancedFilterBuilder: 0,
		hideAdvancedFilterBuilder: 0
	}),
	...mod("IntegratedCharts", {
		getChartModels: 0,
		getChartRef: 0,
		getChartImageDataURL: 0,
		downloadChart: 0,
		openChartToolPanel: 0,
		closeChartToolPanel: 0,
		createRangeChart: 0,
		createPivotChart: 0,
		createCrossFilterChart: 0,
		updateChart: 0,
		restoreChart: 0
	}),
	...mod("Clipboard", {
		copyToClipboard: 0,
		cutToClipboard: 0,
		copySelectedRowsToClipboard: 0,
		copySelectedRangeToClipboard: 0,
		copySelectedRangeDown: 0,
		pasteFromClipboard: 0
	}),
	...mod("ExcelExport", {
		getDataAsExcel: 0,
		exportDataAsExcel: 0,
		getSheetDataForExcel: 0,
		getMultipleSheetsAsExcel: 0,
		exportMultipleSheetsAsExcel: 0
	}),
	...mod("SharedMasterDetail", {
		addDetailGridInfo: 0,
		removeDetailGridInfo: 0,
		getDetailGridInfo: 0,
		forEachDetailGridInfo: 0
	}),
	...mod("ContextMenu", { showContextMenu: 0 }),
	...mod("ColumnMenu", {
		showColumnChooser: 0,
		hideColumnChooser: 0
	}),
	...mod("CellSelection", {
		getCellRanges: 0,
		addCellRange: 0,
		clearRangeSelection: 0,
		clearCellSelection: 0
	}),
	...mod("SharedRowGrouping", {
		setRowGroupColumns: 0,
		removeRowGroupColumns: 0,
		addRowGroupColumns: 0,
		getRowGroupColumns: 0,
		moveRowGroupColumn: 0
	}),
	...mod("SharedAggregation", {
		addAggFuncs: 0,
		clearAggFuncs: 0,
		setColumnAggFunc: 0
	}),
	...mod("SharedPivot", {
		isPivotMode: 0,
		getPivotResultColumn: 0,
		setValueColumns: 0,
		getValueColumns: 0,
		removeValueColumns: 0,
		addValueColumns: 0,
		setPivotColumns: 0,
		removePivotColumns: 0,
		addPivotColumns: 0,
		getPivotColumns: 0,
		setPivotResultColumns: 0,
		getPivotResultColumns: 0
	}),
	...mod("ServerSideRowModelApi", {
		getServerSideSelectionState: 0,
		setServerSideSelectionState: 0,
		applyServerSideTransaction: 0,
		applyServerSideTransactionAsync: 0,
		applyServerSideRowData: 0,
		retryServerSideLoads: 0,
		flushServerSideAsyncTransactions: 0,
		refreshServerSide: 0,
		getServerSideGroupLevelState: 0
	}),
	...mod("SideBar", {
		isSideBarVisible: 0,
		setSideBarVisible: 0,
		setSideBarPosition: 0,
		openToolPanel: 0,
		closeToolPanel: 0,
		getOpenedToolPanel: 0,
		refreshToolPanel: 0,
		isToolPanelShowing: 0,
		getToolPanelInstance: 0,
		getSideBar: 0
	}),
	...mod("StatusBar", { getStatusPanel: 0 })
};
var defaultFns = {
	isDestroyed: () => true,
	destroy() {},
	preConstruct() {},
	postConstruct() {},
	preWireBeans() {},
	wireBeans() {}
};
var dispatchEvent = (beans, event) => beans.eventSvc.dispatchEvent(event);
var GridApiClass = class {};
Reflect.defineProperty(GridApiClass, "name", { value: "GridApi" });
var ApiFunctionService = class extends BeanStub {
	constructor() {
		super();
		this.beanName = "apiFunctionSvc";
		this.api = new GridApiClass();
		this.fns = {
			...defaultFns,
			dispatchEvent
		};
		this.preDestroyLink = "";
		const { api } = this;
		for (const key of Object.keys(gridApiFunctionsMap)) api[key] = this.makeApi(key)[key];
	}
	postConstruct() {
		this.preDestroyLink = this.beans.frameworkOverrides.getDocLink("grid-lifecycle/#grid-pre-destroyed");
	}
	addFunction(functionName, func) {
		const { fns, beans } = this;
		if (fns !== defaultFns) fns[functionName] = beans?.validation?.validateApiFunction(functionName, func) ?? func;
	}
	makeApi(apiName) {
		return { [apiName]: (...args) => {
			const { beans, fns: { [apiName]: fn } } = this;
			return fn ? fn(beans, ...args) : this.apiNotFound(apiName);
		} };
	}
	apiNotFound(fnName) {
		const { beans, gos, preDestroyLink } = this;
		if (!beans) _warn(26, {
			fnName,
			preDestroyLink
		});
		else {
			const module = gridApiFunctionsMap[fnName];
			if (gos.assertModuleRegistered(module, `api.${fnName}`)) _warn(27, {
				fnName,
				module
			});
		}
	}
	destroy() {
		super.destroy();
		this.fns = defaultFns;
		this.beans = null;
	}
};
function getGridId(beans) {
	return beans.context.getGridId();
}
function destroy(beans) {
	beans.gridDestroySvc.destroy();
}
function isDestroyed(beans) {
	return beans.gridDestroySvc.destroyCalled;
}
function getGridOption(beans, key) {
	return beans.gos.get(key);
}
function setGridOption(beans, key, value) {
	updateGridOptions(beans, { [key]: value });
}
function updateGridOptions(beans, options) {
	beans.gos.updateGridOptions({ options });
}
function isModuleRegistered(beans, moduleName) {
	const withoutSuffix = moduleName.replace(/Module$/, "");
	return beans.gos.isModuleRegistered(withoutSuffix);
}
var HorizontalResizeService = class extends BeanStub {
	constructor() {
		super(...arguments);
		this.beanName = "horizontalResizeSvc";
	}
	addResizeBar(params) {
		const dragSource = {
			dragStartPixels: params.dragStartPixels || 0,
			eElement: params.eResizeBar,
			onDragStart: this.onDragStart.bind(this, params),
			onDragStop: this.onDragStop.bind(this, params),
			onDragging: this.onDragging.bind(this, params),
			onDragCancel: this.onDragStop.bind(this, params),
			includeTouch: true,
			stopPropagationForTouch: true
		};
		const { dragSvc } = this.beans;
		dragSvc.addDragSource(dragSource);
		const finishedWithResizeFunc = () => dragSvc.removeDragSource(dragSource);
		return finishedWithResizeFunc;
	}
	onDragStart(params, mouseEvent) {
		this.dragStartX = mouseEvent.clientX;
		this.setResizeIcons();
		const shiftKey = mouseEvent instanceof MouseEvent && mouseEvent.shiftKey === true;
		params.onResizeStart(shiftKey);
	}
	setResizeIcons() {
		const ctrl = this.beans.ctrlsSvc.get("gridCtrl");
		ctrl.setResizeCursor(1);
		ctrl.disableUserSelect(true);
	}
	onDragStop(params) {
		params.onResizeEnd(this.resizeAmount);
		this.resetIcons();
	}
	resetIcons() {
		const ctrl = this.beans.ctrlsSvc.get("gridCtrl");
		ctrl.setResizeCursor(false);
		ctrl.disableUserSelect(false);
	}
	onDragging(params, mouseEvent) {
		this.resizeAmount = mouseEvent.clientX - this.dragStartX;
		params.onResizing(this.resizeAmount);
	}
};
var ChangedPath = class {
	constructor(keepingColumns, rootNode) {
		this.active = true;
		this.nodeIdsToColumns = {};
		this.mapToItems = {};
		this.keepingColumns = keepingColumns;
		this.pathRoot = {
			rowNode: rootNode,
			children: null
		};
		this.mapToItems[rootNode.id] = this.pathRoot;
	}
	depthFirstSearchChangedPath(pathItem, callback) {
		const { rowNode, children } = pathItem;
		if (children) for (let i = 0; i < children.length; ++i) this.depthFirstSearchChangedPath(children[i], callback);
		callback(rowNode);
	}
	depthFirstSearchEverything(rowNode, callback, traverseEverything) {
		const childrenAfterGroup = rowNode.childrenAfterGroup;
		if (childrenAfterGroup) for (let i = 0, len = childrenAfterGroup.length; i < len; ++i) {
			const childNode = childrenAfterGroup[i];
			if (childNode.childrenAfterGroup) this.depthFirstSearchEverything(childNode, callback, traverseEverything);
			else if (traverseEverything) callback(childNode);
		}
		callback(rowNode);
	}
	forEachChangedNodeDepthFirst(callback, traverseLeafNodes = false, includeUnchangedNodes = false) {
		if (this.active && !includeUnchangedNodes) this.depthFirstSearchChangedPath(this.pathRoot, callback);
		else this.depthFirstSearchEverything(this.pathRoot.rowNode, callback, traverseLeafNodes);
	}
	executeFromRootNode(callback) {
		callback(this.pathRoot.rowNode);
	}
	createPathItems(rowNode) {
		let pointer = rowNode;
		let newEntryCount = 0;
		while (!this.mapToItems[pointer.id]) {
			const newEntry = {
				rowNode: pointer,
				children: null
			};
			this.mapToItems[pointer.id] = newEntry;
			newEntryCount++;
			pointer = pointer.parent;
		}
		return newEntryCount;
	}
	populateColumnsMap(rowNode, columns) {
		if (!this.keepingColumns || !columns) return;
		let pointer = rowNode;
		while (pointer) {
			if (!this.nodeIdsToColumns[pointer.id]) this.nodeIdsToColumns[pointer.id] = {};
			columns.forEach((col) => this.nodeIdsToColumns[pointer.id][col.getId()] = true);
			pointer = pointer.parent;
		}
	}
	linkPathItems(rowNode, newEntryCount) {
		let pointer = rowNode;
		for (let i = 0; i < newEntryCount; i++) {
			const thisItem = this.mapToItems[pointer.id];
			const parentItem = this.mapToItems[pointer.parent.id];
			if (!parentItem.children) parentItem.children = [];
			parentItem.children.push(thisItem);
			pointer = pointer.parent;
		}
	}
	addParentNode(rowNode, columns) {
		if (!rowNode || rowNode.isRowPinned()) return;
		const newEntryCount = this.createPathItems(rowNode);
		this.linkPathItems(rowNode, newEntryCount);
		this.populateColumnsMap(rowNode, columns);
	}
	canSkip(rowNode) {
		return this.active && !this.mapToItems[rowNode.id];
	}
	getValueColumnsForNode(rowNode, valueColumns) {
		if (!this.keepingColumns) return valueColumns;
		const colsForThisNode = this.nodeIdsToColumns[rowNode.id];
		return valueColumns.filter((col) => colsForThisNode[col.getId()]);
	}
	getNotValueColumnsForNode(rowNode, valueColumns) {
		if (!this.keepingColumns) return null;
		const colsForThisNode = this.nodeIdsToColumns[rowNode.id];
		return valueColumns.filter((col) => !colsForThisNode[col.getId()]);
	}
};
var DragModule = {
	moduleName: "Drag",
	version: VERSION,
	beans: [DragService]
};
var SharedDragAndDropModule = {
	moduleName: "SharedDragAndDrop",
	version: VERSION,
	beans: [DragAndDropService],
	dependsOn: [DragModule],
	userComponents: { agDragAndDropImage: DragAndDropImageComponent2 },
	icons: {
		columnMovePin: "pin",
		columnMoveHide: "eye-slash",
		columnMoveMove: "arrows",
		columnMoveLeft: "left",
		columnMoveRight: "right",
		columnMoveGroup: "group",
		columnMoveValue: "aggregation",
		columnMovePivot: "pivot",
		dropNotAllowed: "not-allowed",
		rowDrag: "grip"
	}
};
var HorizontalResizeModule = {
	moduleName: "HorizontalResize",
	version: VERSION,
	beans: [HorizontalResizeService],
	dependsOn: [DragModule]
};
var columnMovingCSS = `:where(.ag-ltr) :where(.ag-column-moving){.ag-cell,.ag-header-cell,.ag-spanned-cell-wrapper{transition:left .2s}.ag-header-group-cell{transition:left .2s,width .2s}}:where(.ag-rtl) :where(.ag-column-moving){.ag-cell,.ag-header-cell,.ag-spanned-cell-wrapper{transition:right .2s}.ag-header-group-cell{transition:right .2s,width .2s}}`;
var ColumnAnimationService = class extends BeanStub {
	constructor() {
		super(...arguments);
		this.beanName = "colAnimation";
		this.executeNextFuncs = [];
		this.executeLaterFuncs = [];
		this.active = false;
		this.activeNext = false;
		this.suppressAnimation = false;
		this.animationThreadCount = 0;
	}
	postConstruct() {
		this.beans.ctrlsSvc.whenReady(this, (p) => this.gridBodyCtrl = p.gridBodyCtrl);
	}
	isActive() {
		return this.active && !this.suppressAnimation;
	}
	setSuppressAnimation(suppress) {
		this.suppressAnimation = suppress;
	}
	start() {
		if (this.active) return;
		const { gos } = this;
		if (gos.get("suppressColumnMoveAnimation")) return;
		if (gos.get("enableRtl")) return;
		this.ensureAnimationCssClassPresent();
		this.active = true;
		this.activeNext = true;
	}
	finish() {
		if (!this.active) return;
		this.flush(() => this.activeNext = false, () => this.active = false);
	}
	executeNextVMTurn(func) {
		if (this.activeNext) this.executeNextFuncs.push(func);
		else func();
	}
	executeLaterVMTurn(func) {
		if (this.active) this.executeLaterFuncs.push(func);
		else func();
	}
	ensureAnimationCssClassPresent() {
		this.animationThreadCount++;
		const animationThreadCountCopy = this.animationThreadCount;
		const { gridBodyCtrl } = this;
		gridBodyCtrl.setColumnMovingCss(true);
		this.executeLaterFuncs.push(() => {
			if (this.animationThreadCount === animationThreadCountCopy) gridBodyCtrl.setColumnMovingCss(false);
		});
	}
	flush(callbackNext, callbackLater) {
		const { executeNextFuncs, executeLaterFuncs } = this;
		if (executeNextFuncs.length === 0 && executeLaterFuncs.length === 0) {
			callbackNext();
			callbackLater();
			return;
		}
		const runFuncs = (queue) => {
			while (queue.length) {
				const func = queue.pop();
				if (func) func();
			}
		};
		this.beans.frameworkOverrides.wrapIncoming(() => {
			window.setTimeout(() => {
				callbackNext();
				runFuncs(executeNextFuncs);
			}, 0);
			window.setTimeout(() => {
				callbackLater();
				runFuncs(executeLaterFuncs);
			}, 200);
		});
	}
};
function moveColumnByIndex(beans, fromIndex, toIndex) {
	beans.colMoves?.moveColumnByIndex(fromIndex, toIndex, "api");
}
function moveColumns(beans, columnsToMoveKeys, toIndex) {
	beans.colMoves?.moveColumns(columnsToMoveKeys, toIndex, "api");
}
var BodyDropPivotTarget = class extends BeanStub {
	constructor(pinned) {
		super();
		this.pinned = pinned;
		this.columnsToAggregate = [];
		this.columnsToGroup = [];
		this.columnsToPivot = [];
	}
	onDragEnter(draggingEvent) {
		this.clearColumnsList();
		if (this.gos.get("functionsReadOnly")) return;
		const dragColumns = draggingEvent.dragItem.columns;
		if (!dragColumns) return;
		dragColumns.forEach((column) => {
			if (!column.isPrimary()) return;
			if (column.isAnyFunctionActive()) return;
			if (column.isAllowValue()) this.columnsToAggregate.push(column);
			else if (column.isAllowRowGroup()) this.columnsToGroup.push(column);
			else if (column.isAllowPivot()) this.columnsToPivot.push(column);
		});
	}
	getIconName() {
		if (this.columnsToAggregate.length + this.columnsToGroup.length + this.columnsToPivot.length > 0) return this.pinned ? "pinned" : "move";
		return null;
	}
	onDragLeave(draggingEvent) {
		this.clearColumnsList();
	}
	clearColumnsList() {
		this.columnsToAggregate.length = 0;
		this.columnsToGroup.length = 0;
		this.columnsToPivot.length = 0;
	}
	onDragging(draggingEvent) {}
	onDragStop(draggingEvent) {
		const { valueColsSvc, rowGroupColsSvc, pivotColsSvc } = this.beans;
		if (this.columnsToAggregate.length > 0) valueColsSvc?.addColumns(this.columnsToAggregate, "toolPanelDragAndDrop");
		if (this.columnsToGroup.length > 0) rowGroupColsSvc?.addColumns(this.columnsToGroup, "toolPanelDragAndDrop");
		if (this.columnsToPivot.length > 0) pivotColsSvc?.addColumns(this.columnsToPivot, "toolPanelDragAndDrop");
	}
	onDragCancel() {
		this.clearColumnsList();
	}
};
function sortColsLikeCols(colsList, cols) {
	if (!cols || cols.length <= 1) return;
	if (cols.filter((c) => colsList.indexOf(c) < 0).length > 0) return;
	cols.sort((a, b) => {
		return colsList.indexOf(a) - colsList.indexOf(b);
	});
}
function getColsToMove(allMovingColumns) {
	const newCols = [...allMovingColumns];
	allMovingColumns.forEach((col) => {
		let movingGroup = null;
		let parent = col.getParent();
		while (parent != null && parent.getDisplayedLeafColumns().length === 1) {
			movingGroup = parent;
			parent = parent.getParent();
		}
		if (movingGroup != null) (!!movingGroup.getColGroupDef()?.marryChildren ? movingGroup.getProvidedColumnGroup().getLeafColumns() : movingGroup.getLeafColumns()).forEach((newCol) => {
			if (!newCols.includes(newCol)) newCols.push(newCol);
		});
	});
	return newCols;
}
function getLowestFragMove(validMoves, allMovingColumnsOrdered, colMoves, visibleCols) {
	const displayedCols = visibleCols.allCols;
	let lowestFragMove = null;
	let targetOrder = null;
	for (let i = 0; i < validMoves.length; i++) {
		const move = validMoves[i];
		const order = colMoves.getProposedColumnOrder(allMovingColumnsOrdered, move);
		if (!colMoves.doesOrderPassRules(order)) continue;
		const displayedOrder = order.filter((col) => displayedCols.includes(col));
		if (targetOrder === null) targetOrder = displayedOrder;
		else if (!_areEqual(displayedOrder, targetOrder)) break;
		const fragCount = groupFragCount(order);
		if (lowestFragMove === null || fragCount < lowestFragMove.fragCount) lowestFragMove = {
			move,
			fragCount
		};
	}
	return lowestFragMove;
}
function getBestColumnMoveIndexFromXPosition(params) {
	const { isFromHeader, fromLeft, xPosition, fromEnter, fakeEvent, pinned, gos, colModel, colMoves, visibleCols } = params;
	let { allMovingColumns } = params;
	if (isFromHeader) allMovingColumns = getColsToMove(allMovingColumns);
	const allMovingColumnsOrdered = allMovingColumns.slice();
	sortColsLikeCols(colModel.getCols(), allMovingColumnsOrdered);
	const validMoves = calculateValidMoves({
		movingCols: allMovingColumnsOrdered,
		draggingRight: fromLeft,
		xPosition,
		pinned,
		gos,
		colModel,
		visibleCols
	});
	const oldIndex = calculateOldIndex(allMovingColumnsOrdered, colModel);
	if (validMoves.length === 0) return;
	const firstValidMove = validMoves[0];
	if (oldIndex !== null && (isFromHeader || !fromEnter) && !fakeEvent) {
		if (!fromLeft && firstValidMove >= oldIndex) return;
		if (fromLeft && firstValidMove <= oldIndex) return;
	}
	const lowestFragMove = getLowestFragMove(validMoves, allMovingColumnsOrdered, colMoves, visibleCols);
	if (!lowestFragMove) return;
	const toIndex = lowestFragMove.move;
	if (toIndex > colModel.getCols().length - allMovingColumnsOrdered.length) return;
	return {
		columns: allMovingColumnsOrdered,
		toIndex
	};
}
function attemptMoveColumns(params) {
	const { columns, toIndex } = getBestColumnMoveIndexFromXPosition(params) || {};
	const { finished, colMoves } = params;
	if (!columns || toIndex == null) return null;
	colMoves.moveColumns(columns, toIndex, "uiColumnMoved", finished);
	return finished ? null : {
		columns,
		toIndex
	};
}
function calculateOldIndex(movingCols, colModel) {
	const gridCols = colModel.getCols();
	const indexes = movingCols.map((col) => gridCols.indexOf(col)).sort((a, b) => a - b);
	const firstIndex = indexes[0];
	return _last(indexes) - firstIndex !== indexes.length - 1 ? null : firstIndex;
}
function groupFragCount(columns) {
	function parents(col) {
		const result = [];
		let parent = col.getOriginalParent();
		while (parent != null) {
			result.push(parent);
			parent = parent.getOriginalParent();
		}
		return result;
	}
	let count = 0;
	for (let i = 0; i < columns.length - 1; i++) {
		let a = parents(columns[i]);
		let b = parents(columns[i + 1]);
		[a, b] = a.length > b.length ? [a, b] : [b, a];
		a.forEach((parent) => {
			if (b.indexOf(parent) === -1) count++;
		});
	}
	return count;
}
function getDisplayedColumns(visibleCols, type) {
	switch (type) {
		case "left": return visibleCols.leftCols;
		case "right": return visibleCols.rightCols;
		default: return visibleCols.centerCols;
	}
}
function calculateValidMoves(params) {
	const { movingCols, draggingRight, xPosition, pinned, gos, colModel, visibleCols } = params;
	if (gos.get("suppressMovableColumns") || movingCols.some((col) => col.getColDef().suppressMovable)) return [];
	const allDisplayedCols = getDisplayedColumns(visibleCols, pinned);
	const allGridCols = colModel.getCols();
	const movingDisplayedCols = allDisplayedCols.filter((col) => movingCols.includes(col));
	const otherDisplayedCols = allDisplayedCols.filter((col) => !movingCols.includes(col));
	const otherGridCols = allGridCols.filter((col) => !movingCols.includes(col));
	let displayIndex = 0;
	let availableWidth = xPosition;
	if (draggingRight) {
		let widthOfMovingDisplayedCols = 0;
		movingDisplayedCols.forEach((col) => widthOfMovingDisplayedCols += col.getActualWidth());
		availableWidth -= widthOfMovingDisplayedCols;
	}
	if (availableWidth > 0) {
		for (let i = 0; i < otherDisplayedCols.length; i++) {
			const col = otherDisplayedCols[i];
			availableWidth -= col.getActualWidth();
			if (availableWidth < 0) break;
			displayIndex++;
		}
		if (draggingRight) displayIndex++;
	}
	let firstValidMove;
	if (displayIndex > 0) {
		const leftColumn = otherDisplayedCols[displayIndex - 1];
		firstValidMove = otherGridCols.indexOf(leftColumn) + 1;
	} else {
		firstValidMove = otherGridCols.indexOf(otherDisplayedCols[0]);
		if (firstValidMove === -1) firstValidMove = 0;
	}
	const validMoves = [firstValidMove];
	const numberComparator = (a, b) => a - b;
	if (draggingRight) {
		let pointer = firstValidMove + 1;
		const lastIndex = allGridCols.length - 1;
		while (pointer <= lastIndex) {
			validMoves.push(pointer);
			pointer++;
		}
		validMoves.sort(numberComparator);
	} else {
		let pointer = firstValidMove;
		const lastIndex = allGridCols.length - 1;
		let displacedCol = allGridCols[pointer];
		while (pointer <= lastIndex && allDisplayedCols.indexOf(displacedCol) < 0) {
			pointer++;
			validMoves.push(pointer);
			displacedCol = allGridCols[pointer];
		}
		pointer = firstValidMove - 1;
		const firstDisplayIndex = 0;
		while (pointer >= firstDisplayIndex) {
			validMoves.push(pointer);
			pointer--;
		}
		validMoves.sort(numberComparator).reverse();
	}
	return validMoves;
}
function normaliseX(params) {
	const { pinned, fromKeyboard, gos, ctrlsSvc, useHeaderRow, skipScrollPadding } = params;
	let eViewport = ctrlsSvc.getHeaderRowContainerCtrl(pinned)?.eViewport;
	let { x } = params;
	if (!eViewport) return 0;
	if (fromKeyboard) x -= eViewport.getBoundingClientRect().left;
	if (gos.get("enableRtl")) {
		if (useHeaderRow) eViewport = eViewport.querySelector(".ag-header-row");
		x = eViewport.clientWidth - x;
	}
	if (pinned == null && !skipScrollPadding) x += ctrlsSvc.get("center").getCenterViewportScrollLeft();
	return x;
}
function setColumnsMoving(columns, isMoving) {
	for (const column of columns) {
		column.moving = isMoving;
		column.dispatchColEvent("movingChanged", "uiColumnMoved");
	}
}
var MOVE_FAIL_THRESHOLD = 7;
var SCROLL_MOVE_WIDTH = 100;
var SCROLL_GAP_NEEDED_BEFORE_MOVE = SCROLL_MOVE_WIDTH / 2;
var SCROLL_ACCELERATION_RATE = 5;
var SCROLL_TIME_INTERVAL = 100;
var MoveColumnFeature = class extends BeanStub {
	constructor(pinned) {
		super();
		this.pinned = pinned;
		this.needToMoveLeft = false;
		this.needToMoveRight = false;
		this.lastMovedInfo = null;
		this.isCenterContainer = !_exists(pinned);
	}
	postConstruct() {
		this.beans.ctrlsSvc.whenReady(this, (p) => {
			this.gridBodyCon = p.gridBodyCtrl;
		});
	}
	getIconName() {
		const { pinned, lastDraggingEvent } = this;
		const { dragItem } = lastDraggingEvent || {};
		const columns = dragItem?.columns ?? [];
		for (const col of columns) {
			const colPinned = col.getPinned();
			if (col.getColDef().lockPinned) {
				if (colPinned == pinned) return "move";
				continue;
			}
			const initialPinnedState = dragItem?.containerType;
			if (initialPinnedState === pinned || !pinned) return "move";
			if (pinned && (!colPinned || initialPinnedState !== pinned)) return "pinned";
		}
		return "notAllowed";
	}
	onDragEnter(draggingEvent) {
		const dragItem = draggingEvent.dragItem;
		const columns = dragItem.columns;
		if (draggingEvent.dragSource.type === 0) this.setColumnsVisible(columns, true, "uiColumnDragged");
		else {
			const visibleState = dragItem.visibleState;
			const visibleColumns = (columns || []).filter((column) => visibleState[column.getId()] && !column.isVisible());
			this.setColumnsVisible(visibleColumns, true, "uiColumnDragged");
		}
		if (!this.gos.get("suppressMoveWhenColumnDragging")) this.attemptToPinColumns(columns, this.pinned);
		this.onDragging(draggingEvent, true, true);
	}
	onDragging(draggingEvent = this.lastDraggingEvent, fromEnter = false, fakeEvent = false, finished = false) {
		const { gos, ctrlsSvc } = this.beans;
		const isSuppressMoveWhenDragging = gos.get("suppressMoveWhenColumnDragging");
		if (finished && !isSuppressMoveWhenDragging) {
			this.finishColumnMoving();
			return;
		}
		this.lastDraggingEvent = draggingEvent;
		if (!draggingEvent || !finished && _missing(draggingEvent.hDirection)) return;
		const mouseX = normaliseX({
			x: draggingEvent.x,
			pinned: this.pinned,
			gos,
			ctrlsSvc
		});
		if (!fromEnter) this.checkCenterForScrolling(mouseX);
		if (isSuppressMoveWhenDragging) this.handleColumnDragWhileSuppressingMovement(draggingEvent, fromEnter, fakeEvent, mouseX, finished);
		else this.handleColumnDragWhileAllowingMovement(draggingEvent, fromEnter, fakeEvent, mouseX, finished);
	}
	onDragLeave() {
		this.ensureIntervalCleared();
		this.clearHighlighted();
		this.updateDragItemContainerType();
		this.lastMovedInfo = null;
	}
	onDragStop() {
		this.onDragging(this.lastDraggingEvent, false, true, true);
		this.ensureIntervalCleared();
		this.lastMovedInfo = null;
	}
	onDragCancel() {
		this.clearHighlighted();
		this.ensureIntervalCleared();
		this.lastMovedInfo = null;
	}
	setColumnsVisible(columns, visible, source) {
		if (!columns?.length) return;
		const allowedCols = columns.filter((c) => !c.getColDef().lockVisible);
		if (!allowedCols.length) return;
		this.beans.colModel.setColsVisible(allowedCols, visible, source);
	}
	finishColumnMoving() {
		this.clearHighlighted();
		const lastMovedInfo = this.lastMovedInfo;
		if (!lastMovedInfo) return;
		const { columns, toIndex } = lastMovedInfo;
		this.beans.colMoves.moveColumns(columns, toIndex, "uiColumnMoved", true);
	}
	updateDragItemContainerType() {
		const { lastDraggingEvent } = this;
		if (this.gos.get("suppressMoveWhenColumnDragging") || !lastDraggingEvent) return;
		const dragItem = lastDraggingEvent.dragItem;
		if (!dragItem) return;
		dragItem.containerType = this.pinned;
	}
	handleColumnDragWhileSuppressingMovement(draggingEvent, fromEnter, fakeEvent, mouseX, finished) {
		const allMovingColumns = this.getAllMovingColumns(draggingEvent, true);
		if (finished) {
			const isAttemptingToPin = this.isAttemptingToPin(allMovingColumns);
			if (isAttemptingToPin) this.attemptToPinColumns(allMovingColumns, void 0, true);
			const { fromLeft, xPosition } = this.getNormalisedXPositionInfo(allMovingColumns, isAttemptingToPin) || {};
			if (fromLeft == null || xPosition == null) {
				this.finishColumnMoving();
				return;
			}
			this.moveColumnsAfterHighlight({
				allMovingColumns,
				xPosition,
				fromEnter,
				fakeEvent,
				fromLeft
			});
		} else {
			if (!this.beans.dragAndDrop.isDropZoneWithinThisGrid(draggingEvent)) return;
			this.highlightHoveredColumn(allMovingColumns, mouseX);
		}
	}
	handleColumnDragWhileAllowingMovement(draggingEvent, fromEnter, fakeEvent, mouseX, finished) {
		const allMovingColumns = this.getAllMovingColumns(draggingEvent);
		const fromLeft = this.normaliseDirection(draggingEvent.hDirection) === "right";
		const isFromHeader = draggingEvent.dragSource.type === 1;
		const lastMovedInfo = attemptMoveColumns({
			...this.getMoveColumnParams({
				allMovingColumns,
				isFromHeader,
				xPosition: mouseX,
				fromLeft,
				fromEnter,
				fakeEvent
			}),
			finished
		});
		if (lastMovedInfo) this.lastMovedInfo = lastMovedInfo;
	}
	getAllMovingColumns(draggingEvent, useSplit = false) {
		const dragItem = draggingEvent.dragSource.getDragItem();
		let columns = null;
		if (useSplit) {
			columns = dragItem.columnsInSplit;
			if (!columns) columns = dragItem.columns;
		} else columns = dragItem.columns;
		const conditionCallback = (col) => col.getColDef().lockPinned ? col.getPinned() == this.pinned : true;
		if (!columns) return [];
		return columns.filter(conditionCallback);
	}
	getMoveColumnParams(params) {
		const { allMovingColumns, isFromHeader, xPosition, fromLeft, fromEnter, fakeEvent } = params;
		const { gos, colModel, colMoves, visibleCols } = this.beans;
		return {
			allMovingColumns,
			isFromHeader,
			fromLeft,
			xPosition,
			pinned: this.pinned,
			fromEnter,
			fakeEvent,
			gos,
			colModel,
			colMoves,
			visibleCols
		};
	}
	highlightHoveredColumn(movingColumns, mouseX) {
		const { gos, colModel } = this.beans;
		const isRtl = gos.get("enableRtl");
		const consideredColumns = colModel.getCols().filter((col) => col.isVisible() && col.getPinned() === this.pinned);
		let start = null;
		let width = null;
		let targetColumn = null;
		for (const col of consideredColumns) {
			width = col.getActualWidth();
			start = this.getNormalisedColumnLeft(col, 0, isRtl);
			if (start != null) {
				const end = start + width;
				if (start <= mouseX && end >= mouseX) {
					targetColumn = col;
					break;
				}
			}
			start = null;
			width = null;
		}
		if (!targetColumn) {
			for (let i = consideredColumns.length - 1; i >= 0; i--) {
				const currentColumn = consideredColumns[i];
				const parent = consideredColumns[i].getParent();
				if (!parent) {
					targetColumn = currentColumn;
					break;
				}
				const leafDisplayedCols = parent?.getDisplayedLeafColumns();
				if (leafDisplayedCols.length) {
					targetColumn = _last(leafDisplayedCols);
					break;
				}
			}
			if (!targetColumn) return;
			start = this.getNormalisedColumnLeft(targetColumn, 0, isRtl);
			width = targetColumn.getActualWidth();
		} else if (movingColumns.indexOf(targetColumn) !== -1) targetColumn = null;
		if (this.lastHighlightedColumn?.column !== targetColumn) this.clearHighlighted();
		if (targetColumn == null || start == null || width == null) return;
		let position;
		if (mouseX - start < width / 2 !== isRtl) position = 0;
		else position = 1;
		setColumnHighlighted(targetColumn, position);
		this.lastHighlightedColumn = {
			column: targetColumn,
			position
		};
	}
	getNormalisedXPositionInfo(allMovingColumns, isAttemptingToPin) {
		const { gos, visibleCols } = this.beans;
		const isRtl = gos.get("enableRtl");
		const { firstMovingCol, column, position } = this.getColumnMoveAndTargetInfo(allMovingColumns, isAttemptingToPin, isRtl);
		if (!firstMovingCol || !column || position == null) return;
		const visibleColumns = visibleCols.allCols;
		const movingColIndex = visibleColumns.indexOf(firstMovingCol);
		const targetIndex = visibleColumns.indexOf(column);
		const isBefore = position === 0 !== isRtl;
		const fromLeft = movingColIndex < targetIndex || movingColIndex === targetIndex && !isBefore;
		let diff = 0;
		if (isBefore) {
			if (fromLeft) diff -= 1;
		} else if (!fromLeft) diff += 1;
		if (targetIndex + diff === movingColIndex) return;
		const targetColumn = visibleColumns[targetIndex + diff];
		if (!targetColumn) return;
		return {
			fromLeft,
			xPosition: this.getNormalisedColumnLeft(targetColumn, 20, isRtl)
		};
	}
	getColumnMoveAndTargetInfo(allMovingColumns, isAttemptingToPin, isRtl) {
		const lastHighlightedColumn = this.lastHighlightedColumn || {};
		const { firstMovingCol, lastMovingCol } = findFirstAndLastMovingColumns(allMovingColumns);
		if (!firstMovingCol || !lastMovingCol || lastHighlightedColumn.column || !isAttemptingToPin) return {
			firstMovingCol,
			...lastHighlightedColumn
		};
		const isLeft = this.getPinDirection() === "left";
		return {
			firstMovingCol,
			position: isLeft ? 1 : 0,
			column: isLeft !== isRtl ? firstMovingCol : lastMovingCol
		};
	}
	normaliseDirection(hDirection) {
		if (this.gos.get("enableRtl")) switch (hDirection) {
			case "left": return "right";
			case "right": return "left";
		}
		return hDirection;
	}
	getNormalisedColumnLeft(col, padding, isRtl) {
		const { gos, ctrlsSvc } = this.beans;
		const left = col.getLeft();
		if (left == null) return null;
		const width = col.getActualWidth();
		return normaliseX({
			x: isRtl ? left + width - padding : left + padding,
			pinned: col.getPinned(),
			useHeaderRow: isRtl,
			skipScrollPadding: true,
			gos,
			ctrlsSvc
		});
	}
	isAttemptingToPin(columns) {
		const isMovingHorizontally = this.needToMoveLeft || this.needToMoveRight;
		const isFailedMoreThanThreshold = this.failedMoveAttempts > MOVE_FAIL_THRESHOLD;
		return isMovingHorizontally && isFailedMoreThanThreshold || columns.some((col) => col.getPinned() !== this.pinned);
	}
	moveColumnsAfterHighlight(params) {
		const { allMovingColumns, xPosition, fromEnter, fakeEvent, fromLeft } = params;
		const { columns, toIndex } = getBestColumnMoveIndexFromXPosition(this.getMoveColumnParams({
			allMovingColumns,
			isFromHeader: true,
			xPosition,
			fromLeft,
			fromEnter,
			fakeEvent
		})) || {};
		if (columns && toIndex != null) this.lastMovedInfo = {
			columns,
			toIndex
		};
		this.finishColumnMoving();
	}
	clearHighlighted() {
		const { lastHighlightedColumn } = this;
		if (!lastHighlightedColumn) return;
		setColumnHighlighted(lastHighlightedColumn.column, null);
		this.lastHighlightedColumn = null;
	}
	checkCenterForScrolling(xAdjustedForScroll) {
		if (!this.isCenterContainer) return;
		const centerCtrl = this.beans.ctrlsSvc.get("center");
		const firstVisiblePixel = centerCtrl.getCenterViewportScrollLeft();
		const lastVisiblePixel = firstVisiblePixel + centerCtrl.getCenterWidth();
		let needToMoveRight;
		let needToMoveLeft;
		if (this.gos.get("enableRtl")) {
			needToMoveRight = xAdjustedForScroll < firstVisiblePixel + SCROLL_GAP_NEEDED_BEFORE_MOVE;
			needToMoveLeft = xAdjustedForScroll > lastVisiblePixel - SCROLL_GAP_NEEDED_BEFORE_MOVE;
		} else {
			needToMoveLeft = xAdjustedForScroll < firstVisiblePixel + SCROLL_GAP_NEEDED_BEFORE_MOVE;
			needToMoveRight = xAdjustedForScroll > lastVisiblePixel - SCROLL_GAP_NEEDED_BEFORE_MOVE;
		}
		this.needToMoveRight = needToMoveRight;
		this.needToMoveLeft = needToMoveLeft;
		if (needToMoveLeft || needToMoveRight) this.ensureIntervalStarted();
		else this.ensureIntervalCleared();
	}
	ensureIntervalStarted() {
		if (this.movingIntervalId) return;
		this.intervalCount = 0;
		this.failedMoveAttempts = 0;
		this.movingIntervalId = window.setInterval(this.moveInterval.bind(this), SCROLL_TIME_INTERVAL);
		this.beans.dragAndDrop.getDragAndDropImageComponent()?.setIcon(this.needToMoveLeft ? "left" : "right", true);
	}
	ensureIntervalCleared() {
		if (!this.movingIntervalId) return;
		window.clearInterval(this.movingIntervalId);
		this.movingIntervalId = null;
		this.failedMoveAttempts = 0;
		this.beans.dragAndDrop.getDragAndDropImageComponent()?.setIcon(this.getIconName(), false);
	}
	moveInterval() {
		let pixelsToMove;
		this.intervalCount++;
		pixelsToMove = 10 + this.intervalCount * SCROLL_ACCELERATION_RATE;
		if (pixelsToMove > SCROLL_MOVE_WIDTH) pixelsToMove = SCROLL_MOVE_WIDTH;
		let pixelsMoved = null;
		const scrollFeature = this.gridBodyCon.scrollFeature;
		if (this.needToMoveLeft) pixelsMoved = scrollFeature.scrollHorizontally(-pixelsToMove);
		else if (this.needToMoveRight) pixelsMoved = scrollFeature.scrollHorizontally(pixelsToMove);
		if (pixelsMoved !== 0) {
			this.onDragging(this.lastDraggingEvent);
			this.failedMoveAttempts = 0;
		} else {
			this.failedMoveAttempts++;
			const { pinnedCols, dragAndDrop, gos } = this.beans;
			if (this.failedMoveAttempts <= MOVE_FAIL_THRESHOLD + 1 || !pinnedCols) return;
			dragAndDrop.getDragAndDropImageComponent()?.setIcon("pinned", false);
			if (!gos.get("suppressMoveWhenColumnDragging")) {
				const columns = this.lastDraggingEvent?.dragItem.columns;
				this.attemptToPinColumns(columns, void 0, true);
			}
		}
	}
	getPinDirection() {
		if (this.needToMoveLeft || this.pinned === "left") return "left";
		if (this.needToMoveRight || this.pinned === "right") return "right";
	}
	attemptToPinColumns(columns, pinned, fromMoving = false) {
		const allowedCols = (columns || []).filter((c) => !c.getColDef().lockPinned);
		if (!allowedCols.length) return 0;
		if (fromMoving) pinned = this.getPinDirection();
		const { pinnedCols, dragAndDrop } = this.beans;
		pinnedCols?.setColsPinned(allowedCols, pinned, "uiColumnDragged");
		if (fromMoving) dragAndDrop.nudge();
		return allowedCols.length;
	}
	destroy() {
		super.destroy();
		this.lastDraggingEvent = null;
		this.clearHighlighted();
		this.lastMovedInfo = null;
	}
};
function setColumnHighlighted(column, highlighted) {
	if (column.highlighted === highlighted) return;
	column.highlighted = highlighted;
	column.dispatchColEvent("headerHighlightChanged", "uiColumnMoved");
}
function findFirstAndLastMovingColumns(allMovingColumns) {
	const moveLen = allMovingColumns.length;
	let firstMovingCol;
	let lastMovingCol;
	for (let i = 0; i < moveLen; i++) {
		if (!firstMovingCol) {
			const leftCol = allMovingColumns[i];
			if (leftCol.getLeft() != null) firstMovingCol = leftCol;
		}
		if (!lastMovingCol) {
			const rightCol = allMovingColumns[moveLen - 1 - i];
			if (rightCol.getLeft() != null) lastMovingCol = rightCol;
		}
		if (firstMovingCol && lastMovingCol) break;
	}
	return {
		firstMovingCol,
		lastMovingCol
	};
}
var BodyDropTarget = class extends BeanStub {
	constructor(pinned, eContainer) {
		super();
		this.pinned = pinned;
		this.eContainer = eContainer;
	}
	postConstruct() {
		const { ctrlsSvc, dragAndDrop } = this.beans;
		const pinned = this.pinned;
		ctrlsSvc.whenReady(this, (p) => {
			let eSecondaryContainers;
			const eBodyViewport = p.gridBodyCtrl.eBodyViewport;
			switch (pinned) {
				case "left":
					eSecondaryContainers = [
						[eBodyViewport, p.left.eContainer],
						[p.bottomLeft.eContainer],
						[p.topLeft.eContainer]
					];
					break;
				case "right":
					eSecondaryContainers = [
						[eBodyViewport, p.right.eContainer],
						[p.bottomRight.eContainer],
						[p.topRight.eContainer]
					];
					break;
				default:
					eSecondaryContainers = [
						[eBodyViewport, p.center.eViewport],
						[p.bottomCenter.eViewport],
						[p.topCenter.eViewport]
					];
					break;
			}
			this.eSecondaryContainers = eSecondaryContainers;
		});
		this.moveColumnFeature = this.createManagedBean(new MoveColumnFeature(pinned));
		this.bodyDropPivotTarget = this.createManagedBean(new BodyDropPivotTarget(pinned));
		dragAndDrop.addDropTarget(this);
		this.addDestroyFunc(() => dragAndDrop.removeDropTarget(this));
	}
	isInterestedIn(type) {
		return type === 1 || type === 0 && this.gos.get("allowDragFromColumnsToolPanel");
	}
	getSecondaryContainers() {
		return this.eSecondaryContainers;
	}
	getContainer() {
		return this.eContainer;
	}
	getIconName() {
		return this.currentDropListener.getIconName();
	}
	isDropColumnInPivotMode(draggingEvent) {
		return this.beans.colModel.isPivotMode() && draggingEvent.dragSource.type === 0;
	}
	onDragEnter(draggingEvent) {
		this.currentDropListener = this.isDropColumnInPivotMode(draggingEvent) ? this.bodyDropPivotTarget : this.moveColumnFeature;
		this.currentDropListener.onDragEnter(draggingEvent);
	}
	onDragLeave(params) {
		this.currentDropListener.onDragLeave(params);
	}
	onDragging(params) {
		this.currentDropListener.onDragging(params);
	}
	onDragStop(params) {
		this.currentDropListener.onDragStop(params);
	}
	onDragCancel() {
		this.currentDropListener.onDragCancel();
	}
};
var ColumnMoveService = class extends BeanStub {
	constructor() {
		super(...arguments);
		this.beanName = "colMoves";
	}
	moveColumnByIndex(fromIndex, toIndex, source) {
		const gridColumns = this.beans.colModel.getCols();
		if (!gridColumns) return;
		const column = gridColumns[fromIndex];
		this.moveColumns([column], toIndex, source);
	}
	moveColumns(columnsToMoveKeys, toIndex, source, finished = true) {
		const { colModel, colAnimation, visibleCols, eventSvc } = this.beans;
		const gridColumns = colModel.getCols();
		if (!gridColumns) return;
		if (toIndex > gridColumns.length - columnsToMoveKeys.length) {
			_warn(30, { toIndex });
			return;
		}
		colAnimation?.start();
		const movedColumns = colModel.getColsForKeys(columnsToMoveKeys);
		if (this.doesMovePassRules(movedColumns, toIndex)) {
			_moveInArray(colModel.getCols(), movedColumns, toIndex);
			visibleCols.refresh(source);
			eventSvc.dispatchEvent({
				type: "columnMoved",
				columns: movedColumns,
				column: movedColumns.length === 1 ? movedColumns[0] : null,
				toIndex,
				finished,
				source
			});
		}
		colAnimation?.finish();
	}
	doesMovePassRules(columnsToMove, toIndex) {
		const proposedColumnOrder = this.getProposedColumnOrder(columnsToMove, toIndex);
		return this.doesOrderPassRules(proposedColumnOrder);
	}
	doesOrderPassRules(gridOrder) {
		const { colModel, gos } = this.beans;
		if (!doesMovePassMarryChildren(gridOrder, colModel.getColTree())) return false;
		const doesMovePassLockedPositions = (proposedColumnOrder) => {
			const lockPositionToPlacement = (position) => {
				if (!position) return 0;
				return position === "left" || position === true ? -1 : 1;
			};
			const isRtl = gos.get("enableRtl");
			let lastPlacement = isRtl ? 1 : -1;
			let rulePassed = true;
			proposedColumnOrder.forEach((col) => {
				const placement = lockPositionToPlacement(col.getColDef().lockPosition);
				if (isRtl) {
					if (placement > lastPlacement) rulePassed = false;
				} else if (placement < lastPlacement) rulePassed = false;
				lastPlacement = placement;
			});
			return rulePassed;
		};
		if (!doesMovePassLockedPositions(gridOrder)) return false;
		return true;
	}
	getProposedColumnOrder(columnsToMove, toIndex) {
		const proposedColumnOrder = this.beans.colModel.getCols().slice();
		_moveInArray(proposedColumnOrder, columnsToMove, toIndex);
		return proposedColumnOrder;
	}
	createBodyDropTarget(pinned, dropContainer) {
		return new BodyDropTarget(pinned, dropContainer);
	}
	moveHeader(hDirection, eGui, column, pinned, bean) {
		const { ctrlsSvc, gos, colModel, visibleCols, focusSvc } = this.beans;
		const rect = eGui.getBoundingClientRect();
		const left = rect.left;
		const isGroup = isColumnGroup(column);
		const width = isGroup ? rect.width : column.getActualWidth();
		const isLeft = hDirection === "left" !== gos.get("enableRtl");
		const xPosition = normaliseX({
			x: isLeft ? left - 20 : left + width + 20,
			pinned,
			fromKeyboard: true,
			gos,
			ctrlsSvc
		});
		const headerPosition = focusSvc.focusedHeader;
		attemptMoveColumns({
			allMovingColumns: isGroup ? column.getLeafColumns() : [column],
			isFromHeader: true,
			fromLeft: hDirection === "right",
			xPosition,
			pinned,
			fromEnter: false,
			fakeEvent: false,
			gos,
			colModel,
			colMoves: this,
			visibleCols,
			finished: true
		});
		let targetColumn;
		if (isGroup) {
			const displayedLeafColumns = column.getDisplayedLeafColumns();
			targetColumn = isLeft ? displayedLeafColumns[0] : _last(displayedLeafColumns);
		} else targetColumn = column;
		ctrlsSvc.getScrollFeature().ensureColumnVisible(targetColumn, "auto");
		if ((!bean.isAlive() || gos.get("ensureDomOrder")) && headerPosition) {
			let restoreFocusColumn;
			if (isGroup) {
				const groupId = column.getGroupId();
				const leafCols = column.getLeafColumns();
				if (!leafCols.length) return;
				const parent = leafCols[0].getParent();
				if (!parent) return;
				restoreFocusColumn = findGroupWidthId(parent, groupId);
			} else restoreFocusColumn = column;
			if (restoreFocusColumn) focusSvc.focusHeaderPosition({ headerPosition: {
				...headerPosition,
				column: restoreFocusColumn
			} });
		}
	}
	setDragSourceForHeader(eSource, column, displayName) {
		const { gos, colModel, dragAndDrop, visibleCols } = this.beans;
		let hideColumnOnExit = !gos.get("suppressDragLeaveHidesColumns");
		const isGroup = isColumnGroup(column);
		const columns = isGroup ? column.getProvidedColumnGroup().getLeafColumns() : [column];
		const dragSource = {
			type: 1,
			eElement: eSource,
			getDefaultIconName: () => hideColumnOnExit ? "hide" : "notAllowed",
			getDragItem: isGroup ? () => createDragItemForGroup(column, visibleCols.allCols) : () => createDragItem(column),
			dragItemName: displayName,
			onDragStarted: () => {
				hideColumnOnExit = !gos.get("suppressDragLeaveHidesColumns");
				setColumnsMoving(columns, true);
			},
			onDragStopped: () => setColumnsMoving(columns, false),
			onDragCancelled: () => setColumnsMoving(columns, false),
			onGridEnter: (dragItem) => {
				if (hideColumnOnExit) {
					const { columns: columns2 = [], visibleState } = dragItem ?? {};
					const hasVisibleState = isGroup ? (col) => !visibleState || visibleState[col.getColId()] : () => true;
					const unlockedColumns = columns2.filter((col) => !col.getColDef().lockVisible && hasVisibleState(col));
					colModel.setColsVisible(unlockedColumns, true, "uiColumnMoved");
				}
			},
			onGridExit: (dragItem) => {
				if (hideColumnOnExit) {
					const unlockedColumns = dragItem?.columns?.filter((col) => !col.getColDef().lockVisible) || [];
					colModel.setColsVisible(unlockedColumns, false, "uiColumnMoved");
				}
			}
		};
		dragAndDrop.addDragSource(dragSource, true);
		return dragSource;
	}
};
function findGroupWidthId(columnGroup, id) {
	while (columnGroup) {
		if (columnGroup.getGroupId() === id) return columnGroup;
		columnGroup = columnGroup.getParent();
	}
}
function createDragItem(column) {
	const visibleState = {};
	visibleState[column.getId()] = column.isVisible();
	return {
		columns: [column],
		visibleState,
		containerType: column.pinned
	};
}
function createDragItemForGroup(columnGroup, allCols) {
	const allColumnsOriginalOrder = columnGroup.getProvidedColumnGroup().getLeafColumns();
	const visibleState = {};
	allColumnsOriginalOrder.forEach((column) => visibleState[column.getId()] = column.isVisible());
	const allColumnsCurrentOrder = [];
	allCols.forEach((column) => {
		if (allColumnsOriginalOrder.indexOf(column) >= 0) {
			allColumnsCurrentOrder.push(column);
			_removeFromArray(allColumnsOriginalOrder, column);
		}
	});
	allColumnsOriginalOrder.forEach((column) => allColumnsCurrentOrder.push(column));
	const columnsInSplit = [];
	const columnGroupColumns = columnGroup.getLeafColumns();
	for (const col of allColumnsCurrentOrder) if (columnGroupColumns.indexOf(col) !== -1) columnsInSplit.push(col);
	return {
		columns: allColumnsCurrentOrder,
		columnsInSplit,
		visibleState,
		containerType: columnsInSplit[0]?.pinned
	};
}
var ColumnMoveModule = {
	moduleName: "ColumnMove",
	version: VERSION,
	beans: [ColumnMoveService, ColumnAnimationService],
	apiFunctions: {
		moveColumnByIndex,
		moveColumns
	},
	dependsOn: [SharedDragAndDropModule],
	css: [columnMovingCSS]
};
var AutoWidthCalculator = class extends BeanStub {
	constructor() {
		super(...arguments);
		this.beanName = "autoWidthCalc";
	}
	postConstruct() {
		this.beans.ctrlsSvc.whenReady(this, (p) => {
			this.centerRowContainerCtrl = p.center;
		});
	}
	getPreferredWidthForColumn(column, skipHeader) {
		const eHeaderCell = this.getHeaderCellForColumn(column);
		if (!eHeaderCell) return -1;
		const elements = this.beans.rowRenderer.getAllCellsNotSpanningForColumn(column);
		if (!skipHeader) elements.push(eHeaderCell);
		return this.getPreferredWidthForElements(elements);
	}
	getPreferredWidthForColumnGroup(columnGroup) {
		const eHeaderCell = this.getHeaderCellForColumn(columnGroup);
		if (!eHeaderCell) return -1;
		return this.getPreferredWidthForElements([eHeaderCell]);
	}
	getPreferredWidthForElements(elements, extraPadding) {
		const eDummyContainer = document.createElement("form");
		eDummyContainer.style.position = "fixed";
		const eBodyContainer = this.centerRowContainerCtrl.eContainer;
		elements.forEach((el) => this.cloneItemIntoDummy(el, eDummyContainer));
		eBodyContainer.appendChild(eDummyContainer);
		const dummyContainerWidth = eDummyContainer.offsetWidth;
		eBodyContainer.removeChild(eDummyContainer);
		extraPadding = extraPadding ?? this.gos.get("autoSizePadding");
		return dummyContainerWidth + extraPadding;
	}
	getHeaderCellForColumn(column) {
		let element = null;
		this.beans.ctrlsSvc.getHeaderRowContainerCtrls().forEach((container) => {
			const res = container.getHtmlElementForColumnHeader(column);
			if (res != null) element = res;
		});
		return element;
	}
	cloneItemIntoDummy(eCell, eDummyContainer) {
		const eCellClone = eCell.cloneNode(true);
		eCellClone.style.width = "";
		eCellClone.style.position = "static";
		eCellClone.style.left = "";
		const eCloneParent = document.createElement("div");
		const eCloneParentClassList = eCloneParent.classList;
		if (["ag-header-cell", "ag-header-group-cell"].some((cls) => eCellClone.classList.contains(cls))) {
			eCloneParentClassList.add("ag-header", "ag-header-row");
			eCloneParent.style.position = "static";
		} else eCloneParentClassList.add("ag-row");
		let pointer = eCell.parentElement;
		while (pointer) {
			if (["ag-header-row", "ag-row"].some((cls) => pointer.classList.contains(cls))) {
				for (let i = 0; i < pointer.classList.length; i++) {
					const item = pointer.classList[i];
					if (item != "ag-row-position-absolute") eCloneParentClassList.add(item);
				}
				break;
			}
			pointer = pointer.parentElement;
		}
		eCloneParent.appendChild(eCellClone);
		eDummyContainer.appendChild(eCloneParent);
	}
};
var AutoWidthModule = {
	moduleName: "AutoWidth",
	version: VERSION,
	beans: [AutoWidthCalculator]
};
function setColumnWidths(beans, columnWidths, finished = true, source = "api") {
	beans.colResize?.setColumnWidths(columnWidths, false, finished, source);
}
var GroupResizeFeature = class extends BeanStub {
	constructor(comp, eResize, pinned, columnGroup) {
		super();
		this.comp = comp;
		this.eResize = eResize;
		this.pinned = pinned;
		this.columnGroup = columnGroup;
	}
	postConstruct() {
		if (!this.columnGroup.isResizable()) {
			this.comp.setResizableDisplayed(false);
			return;
		}
		const { horizontalResizeSvc, gos, colAutosize } = this.beans;
		const finishedWithResizeFunc = horizontalResizeSvc.addResizeBar({
			eResizeBar: this.eResize,
			onResizeStart: this.onResizeStart.bind(this),
			onResizing: this.onResizing.bind(this, false),
			onResizeEnd: this.onResizing.bind(this, true)
		});
		this.addDestroyFunc(finishedWithResizeFunc);
		if (!gos.get("suppressAutoSize") && colAutosize) this.addDestroyFunc(colAutosize.addColumnGroupResize(this.eResize, this.columnGroup, () => this.resizeLeafColumnsToFit("uiColumnResized")));
	}
	onResizeStart(shiftKey) {
		const { columnsToResize, resizeStartWidth, resizeRatios, groupAfterColumns, groupAfterStartWidth, groupAfterRatios } = this.getInitialValues(shiftKey);
		this.resizeCols = columnsToResize;
		this.resizeStartWidth = resizeStartWidth;
		this.resizeRatios = resizeRatios;
		this.resizeTakeFromCols = groupAfterColumns;
		this.resizeTakeFromStartWidth = groupAfterStartWidth;
		this.resizeTakeFromRatios = groupAfterRatios;
		this.toggleColumnResizing(true);
	}
	onResizing(finished, resizeAmount, source = "uiColumnResized") {
		const resizeAmountNormalised = this.normaliseDragChange(resizeAmount);
		const width = this.resizeStartWidth + resizeAmountNormalised;
		this.resizeColumnsFromLocalValues(width, source, finished);
	}
	getInitialValues(shiftKey) {
		const getInitialSizeOfColumns = (columns) => columns.reduce((totalWidth, column) => totalWidth + column.getActualWidth(), 0);
		const getSizeRatiosOfColumns = (columns, initialSizeOfColumns) => columns.map((column) => column.getActualWidth() / initialSizeOfColumns);
		const columnsToResize = this.getColumnsToResize();
		const resizeStartWidth = getInitialSizeOfColumns(columnsToResize);
		const columnSizeAndRatios = {
			columnsToResize,
			resizeStartWidth,
			resizeRatios: getSizeRatiosOfColumns(columnsToResize, resizeStartWidth)
		};
		let groupAfter = null;
		if (shiftKey) groupAfter = this.beans.colGroupSvc?.getGroupAtDirection(this.columnGroup, "After") ?? null;
		if (groupAfter) {
			const groupAfterColumns = columnSizeAndRatios.groupAfterColumns = groupAfter.getDisplayedLeafColumns().filter((col) => col.isResizable());
			columnSizeAndRatios.groupAfterRatios = getSizeRatiosOfColumns(groupAfterColumns, columnSizeAndRatios.groupAfterStartWidth = getInitialSizeOfColumns(groupAfterColumns));
		} else {
			columnSizeAndRatios.groupAfterColumns = void 0;
			columnSizeAndRatios.groupAfterStartWidth = void 0;
			columnSizeAndRatios.groupAfterRatios = void 0;
		}
		return columnSizeAndRatios;
	}
	resizeLeafColumnsToFit(source) {
		const preferredSize = this.beans.autoWidthCalc.getPreferredWidthForColumnGroup(this.columnGroup);
		const initialValues = this.getInitialValues();
		if (preferredSize > initialValues.resizeStartWidth) this.resizeColumns(initialValues, preferredSize, source, true);
	}
	resizeColumnsFromLocalValues(totalWidth, source, finished = true) {
		if (!this.resizeCols || !this.resizeRatios) return;
		const initialValues = {
			columnsToResize: this.resizeCols,
			resizeStartWidth: this.resizeStartWidth,
			resizeRatios: this.resizeRatios,
			groupAfterColumns: this.resizeTakeFromCols,
			groupAfterStartWidth: this.resizeTakeFromStartWidth,
			groupAfterRatios: this.resizeTakeFromRatios
		};
		this.resizeColumns(initialValues, totalWidth, source, finished);
	}
	resizeColumns(initialValues, totalWidth, source, finished = true) {
		const { columnsToResize, resizeStartWidth, resizeRatios, groupAfterColumns, groupAfterStartWidth, groupAfterRatios } = initialValues;
		const resizeSets = [];
		resizeSets.push({
			columns: columnsToResize,
			ratios: resizeRatios,
			width: totalWidth
		});
		if (groupAfterColumns) {
			const diff = totalWidth - resizeStartWidth;
			resizeSets.push({
				columns: groupAfterColumns,
				ratios: groupAfterRatios,
				width: groupAfterStartWidth - diff
			});
		}
		this.beans.colResize?.resizeColumnSets({
			resizeSets,
			finished,
			source
		});
		if (finished) this.toggleColumnResizing(false);
	}
	toggleColumnResizing(resizing) {
		this.comp.toggleCss("ag-column-resizing", resizing);
	}
	getColumnsToResize() {
		return this.columnGroup.getDisplayedLeafColumns().filter((col) => col.isResizable());
	}
	normaliseDragChange(dragChange) {
		let result = dragChange;
		if (this.gos.get("enableRtl")) {
			if (this.pinned !== "left") result *= -1;
		} else if (this.pinned === "right") result *= -1;
		return result;
	}
	destroy() {
		super.destroy();
		this.resizeCols = void 0;
		this.resizeRatios = void 0;
		this.resizeTakeFromCols = void 0;
		this.resizeTakeFromRatios = void 0;
	}
};
var ResizeFeature = class extends BeanStub {
	constructor(pinned, column, eResize, comp, ctrl) {
		super();
		this.pinned = pinned;
		this.column = column;
		this.eResize = eResize;
		this.comp = comp;
		this.ctrl = ctrl;
	}
	postConstruct() {
		const destroyResizeFuncs = [];
		let canResize;
		let canAutosize;
		const addResize = () => {
			_setDisplayed(this.eResize, canResize);
			if (!canResize) return;
			const { horizontalResizeSvc, colAutosize } = this.beans;
			const finishedWithResizeFunc = horizontalResizeSvc.addResizeBar({
				eResizeBar: this.eResize,
				onResizeStart: this.onResizeStart.bind(this),
				onResizing: this.onResizing.bind(this, false),
				onResizeEnd: this.onResizing.bind(this, true)
			});
			destroyResizeFuncs.push(finishedWithResizeFunc);
			if (canAutosize && colAutosize) destroyResizeFuncs.push(colAutosize.addColumnAutosize(this.eResize, this.column));
		};
		const removeResize = () => {
			destroyResizeFuncs.forEach((f) => f());
			destroyResizeFuncs.length = 0;
		};
		const refresh = () => {
			const resize = this.column.isResizable();
			const autoSize = !this.gos.get("suppressAutoSize") && !this.column.getColDef().suppressAutoSize;
			if (resize !== canResize || autoSize !== canAutosize) {
				canResize = resize;
				canAutosize = autoSize;
				removeResize();
				addResize();
			}
		};
		refresh();
		this.addDestroyFunc(removeResize);
		this.ctrl.setRefreshFunction("resize", refresh);
	}
	onResizing(finished, resizeAmount) {
		const { column: key, lastResizeAmount, resizeStartWidth, beans } = this;
		const resizeAmountNormalised = this.normaliseResizeAmount(resizeAmount);
		const columnWidths = [{
			key,
			newWidth: resizeStartWidth + resizeAmountNormalised
		}];
		const { pinnedCols, ctrlsSvc, colResize } = beans;
		if (this.column.getPinned()) {
			const leftWidth = pinnedCols?.leftWidth ?? 0;
			const rightWidth = pinnedCols?.rightWidth ?? 0;
			const bodyWidth = _getInnerWidth(ctrlsSvc.getGridBodyCtrl().eBodyViewport) - 50;
			if (leftWidth + rightWidth + (resizeAmountNormalised - lastResizeAmount) > bodyWidth) return;
		}
		this.lastResizeAmount = resizeAmountNormalised;
		colResize?.setColumnWidths(columnWidths, this.resizeWithShiftKey, finished, "uiColumnResized");
		if (finished) this.toggleColumnResizing(false);
	}
	onResizeStart(shiftKey) {
		this.resizeStartWidth = this.column.getActualWidth();
		this.lastResizeAmount = 0;
		this.resizeWithShiftKey = shiftKey;
		this.toggleColumnResizing(true);
	}
	toggleColumnResizing(resizing) {
		this.column.resizing = resizing;
		this.comp.toggleCss("ag-column-resizing", resizing);
	}
	normaliseResizeAmount(dragChange) {
		let result = dragChange;
		const notPinningLeft = this.pinned !== "left";
		const pinningRight = this.pinned === "right";
		if (this.gos.get("enableRtl")) {
			if (notPinningLeft) result *= -1;
		} else if (pinningRight) result *= -1;
		return result;
	}
};
var ColumnResizeService = class extends BeanStub {
	constructor() {
		super(...arguments);
		this.beanName = "colResize";
	}
	setColumnWidths(columnWidths, shiftKey, finished, source) {
		const sets = [];
		const { colModel, gos, visibleCols } = this.beans;
		columnWidths.forEach((columnWidth) => {
			const col = colModel.getColDefCol(columnWidth.key) || colModel.getCol(columnWidth.key);
			if (!col) return;
			sets.push({
				width: columnWidth.newWidth,
				ratios: [1],
				columns: [col]
			});
			if (gos.get("colResizeDefault") === "shift") shiftKey = !shiftKey;
			if (shiftKey) {
				const otherCol = visibleCols.getColAfter(col);
				if (!otherCol) return;
				const widthDiff = col.getActualWidth() - columnWidth.newWidth;
				const otherColWidth = otherCol.getActualWidth() + widthDiff;
				sets.push({
					width: otherColWidth,
					ratios: [1],
					columns: [otherCol]
				});
			}
		});
		if (sets.length === 0) return;
		this.resizeColumnSets({
			resizeSets: sets,
			finished,
			source
		});
	}
	resizeColumnSets(params) {
		const { resizeSets, finished, source } = params;
		if (!(!resizeSets || resizeSets.every((columnResizeSet) => checkMinAndMaxWidthsForSet(columnResizeSet)))) {
			if (finished) {
				const columns = resizeSets && resizeSets.length > 0 ? resizeSets[0].columns : null;
				dispatchColumnResizedEvent(this.eventSvc, columns, finished, source);
			}
			return;
		}
		const changedCols = [];
		const allResizedCols = [];
		resizeSets.forEach((set) => {
			const { width, columns, ratios } = set;
			const newWidths = {};
			const finishedCols = {};
			columns.forEach((col) => allResizedCols.push(col));
			let finishedColsGrew = true;
			let loopCount = 0;
			while (finishedColsGrew) {
				loopCount++;
				if (loopCount > 1e3) {
					_error(31);
					break;
				}
				finishedColsGrew = false;
				const subsetCols = [];
				let subsetRatioTotal = 0;
				let pixelsToDistribute = width;
				columns.forEach((col, index) => {
					if (finishedCols[col.getId()]) pixelsToDistribute -= newWidths[col.getId()];
					else {
						subsetCols.push(col);
						const ratioThisCol = ratios[index];
						subsetRatioTotal += ratioThisCol;
					}
				});
				const ratioScale = 1 / subsetRatioTotal;
				subsetCols.forEach((col, index) => {
					const lastCol = index === subsetCols.length - 1;
					let colNewWidth;
					if (lastCol) colNewWidth = pixelsToDistribute;
					else {
						colNewWidth = Math.round(ratios[index] * width * ratioScale);
						pixelsToDistribute -= colNewWidth;
					}
					const minWidth = col.getMinWidth();
					const maxWidth = col.getMaxWidth();
					if (colNewWidth < minWidth) {
						colNewWidth = minWidth;
						finishedCols[col.getId()] = true;
						finishedColsGrew = true;
					} else if (maxWidth > 0 && colNewWidth > maxWidth) {
						colNewWidth = maxWidth;
						finishedCols[col.getId()] = true;
						finishedColsGrew = true;
					}
					newWidths[col.getId()] = colNewWidth;
				});
			}
			columns.forEach((col) => {
				const newWidth = newWidths[col.getId()];
				if (col.getActualWidth() !== newWidth) {
					col.setActualWidth(newWidth, source);
					changedCols.push(col);
				}
			});
		});
		const atLeastOneColChanged = changedCols.length > 0;
		let flexedCols = [];
		if (atLeastOneColChanged) {
			const { colFlex, visibleCols, colViewport } = this.beans;
			flexedCols = colFlex?.refreshFlexedColumns({
				resizingCols: allResizedCols,
				skipSetLeft: true
			}) ?? [];
			visibleCols.setLeftValues(source);
			visibleCols.updateBodyWidths();
			colViewport.checkViewportColumns();
		}
		const colsForEvent = allResizedCols.concat(flexedCols);
		if (atLeastOneColChanged || finished) dispatchColumnResizedEvent(this.eventSvc, colsForEvent, finished, source, flexedCols);
	}
	resizeHeader(column, delta, shiftKey) {
		if (!column.isResizable()) return;
		const actualWidth = column.getActualWidth();
		const minWidth = column.getMinWidth();
		const maxWidth = column.getMaxWidth();
		const newWidth = Math.min(Math.max(actualWidth + delta, minWidth), maxWidth);
		this.setColumnWidths([{
			key: column,
			newWidth
		}], shiftKey, true, "uiColumnResized");
	}
	createResizeFeature(pinned, column, eResize, comp, ctrl) {
		return new ResizeFeature(pinned, column, eResize, comp, ctrl);
	}
	createGroupResizeFeature(comp, eResize, pinned, columnGroup) {
		return new GroupResizeFeature(comp, eResize, pinned, columnGroup);
	}
};
function checkMinAndMaxWidthsForSet(columnResizeSet) {
	const { columns, width } = columnResizeSet;
	let minWidthAccumulated = 0;
	let maxWidthAccumulated = 0;
	let maxWidthActive = true;
	columns.forEach((col) => {
		const minWidth = col.getMinWidth();
		minWidthAccumulated += minWidth || 0;
		const maxWidth = col.getMaxWidth();
		if (maxWidth > 0) maxWidthAccumulated += maxWidth;
		else maxWidthActive = false;
	});
	return width >= minWidthAccumulated && (!maxWidthActive || width <= maxWidthAccumulated);
}
var ColumnResizeModule = {
	moduleName: "ColumnResize",
	version: VERSION,
	beans: [ColumnResizeService],
	apiFunctions: { setColumnWidths },
	dependsOn: [HorizontalResizeModule, AutoWidthModule]
};
var GroupWidthFeature = class extends BeanStub {
	constructor(comp, columnGroup) {
		super();
		this.removeChildListenersFuncs = [];
		this.columnGroup = columnGroup;
		this.comp = comp;
	}
	postConstruct() {
		this.addListenersToChildrenColumns();
		this.addManagedListeners(this.columnGroup, { displayedChildrenChanged: this.onDisplayedChildrenChanged.bind(this) });
		this.onWidthChanged();
		this.addDestroyFunc(this.removeListenersOnChildrenColumns.bind(this));
	}
	addListenersToChildrenColumns() {
		this.removeListenersOnChildrenColumns();
		const widthChangedListener = this.onWidthChanged.bind(this);
		this.columnGroup.getLeafColumns().forEach((column) => {
			column.__addEventListener("widthChanged", widthChangedListener);
			column.__addEventListener("visibleChanged", widthChangedListener);
			this.removeChildListenersFuncs.push(() => {
				column.__removeEventListener("widthChanged", widthChangedListener);
				column.__removeEventListener("visibleChanged", widthChangedListener);
			});
		});
	}
	removeListenersOnChildrenColumns() {
		this.removeChildListenersFuncs.forEach((func) => func());
		this.removeChildListenersFuncs = [];
	}
	onDisplayedChildrenChanged() {
		this.addListenersToChildrenColumns();
		this.onWidthChanged();
	}
	onWidthChanged() {
		const columnWidth = this.columnGroup.getActualWidth();
		this.comp.setWidth(`${columnWidth}px`);
		this.comp.toggleCss("ag-hidden", columnWidth === 0);
	}
};
var HeaderGroupCellCtrl = class extends AbstractHeaderCellCtrl {
	constructor() {
		super(...arguments);
		this.onSuppressColMoveChange = () => {
			if (!this.isAlive() || this.isSuppressMoving()) this.removeDragSource();
			else if (!this.dragSource) this.setDragSource(this.eGui);
		};
	}
	setComp(comp, eGui, eResize, eHeaderCompWrapper, compBean) {
		const { column, beans } = this;
		const { context, colNames, colHover, rangeSvc, colResize } = beans;
		this.comp = comp;
		compBean = setupCompBean(this, context, compBean);
		this.setGui(eGui, compBean);
		this.displayName = colNames.getDisplayNameForColumnGroup(column, "header");
		this.refreshHeaderStyles();
		this.addClasses();
		this.setupMovingCss(compBean);
		this.setupExpandable(compBean);
		this.setupTooltip();
		this.setupAutoHeight({
			wrapperElement: eHeaderCompWrapper,
			compBean
		});
		this.setupUserComp();
		this.addHeaderMouseListeners(compBean);
		this.addManagedPropertyListener("groupHeaderHeight", this.refreshMaxHeaderHeight.bind(this));
		this.refreshMaxHeaderHeight();
		const pinned = this.rowCtrl.pinned;
		const leafCols = column.getProvidedColumnGroup().getLeafColumns();
		colHover?.createHoverFeature(compBean, leafCols, eGui);
		rangeSvc?.createRangeHighlightFeature(compBean, column, comp);
		compBean.createManagedBean(new SetLeftFeature(column, eGui, beans));
		compBean.createManagedBean(new GroupWidthFeature(comp, column));
		if (colResize) this.resizeFeature = compBean.createManagedBean(colResize.createGroupResizeFeature(comp, eResize, pinned, column));
		else comp.setResizableDisplayed(false);
		compBean.createManagedBean(new ManagedFocusFeature(eGui, {
			shouldStopEventPropagation: this.shouldStopEventPropagation.bind(this),
			onTabKeyDown: () => void 0,
			handleKeyDown: this.handleKeyDown.bind(this),
			onFocusIn: this.onFocusIn.bind(this)
		}));
		this.addHighlightListeners(compBean, leafCols);
		compBean.addManagedPropertyListener("suppressMovableColumns", this.onSuppressColMoveChange);
		this.addResizeAndMoveKeyboardListeners(compBean);
		compBean.addDestroyFunc(() => this.clearComponent());
	}
	getHeaderClassParams() {
		const { column, beans } = this;
		const colDef = column.getDefinition();
		return _addGridCommonParams(beans.gos, {
			colDef,
			columnGroup: column,
			floatingFilter: false
		});
	}
	refreshMaxHeaderHeight() {
		const { gos, comp } = this;
		const groupHeaderHeight = gos.get("groupHeaderHeight");
		if (groupHeaderHeight != null) if (groupHeaderHeight === 0) comp.setHeaderWrapperHidden(true);
		else comp.setHeaderWrapperMaxHeight(groupHeaderHeight);
		else {
			comp.setHeaderWrapperHidden(false);
			comp.setHeaderWrapperMaxHeight(null);
		}
	}
	addHighlightListeners(compBean, columns) {
		if (!this.beans.gos.get("suppressMoveWhenColumnDragging")) return;
		for (const column of columns) compBean.addManagedListeners(column, { headerHighlightChanged: this.onLeafColumnHighlightChanged.bind(this, column) });
	}
	onLeafColumnHighlightChanged(column) {
		const displayedColumns = this.column.getDisplayedLeafColumns();
		const isFirst = displayedColumns[0] === column;
		const isLast = _last(displayedColumns) === column;
		if (!isFirst && !isLast) return;
		const highlighted = column.getHighlighted();
		const isColumnMoveAtThisLevel = !!this.rowCtrl.getHeaderCellCtrls().find((ctrl) => {
			return ctrl.column.isMoving();
		});
		let beforeOn = false;
		let afterOn = false;
		if (isColumnMoveAtThisLevel) {
			const isRtl = this.beans.gos.get("enableRtl");
			const isHighlightAfter = highlighted === 1;
			const isHighlightBefore = highlighted === 0;
			if (isFirst) if (isRtl) afterOn = isHighlightAfter;
			else beforeOn = isHighlightBefore;
			if (isLast) if (isRtl) beforeOn = isHighlightBefore;
			else afterOn = isHighlightAfter;
		}
		this.comp.toggleCss("ag-header-highlight-before", beforeOn);
		this.comp.toggleCss("ag-header-highlight-after", afterOn);
	}
	resizeHeader(delta, shiftKey) {
		const { resizeFeature } = this;
		if (!resizeFeature) return;
		const initialValues = resizeFeature.getInitialValues(shiftKey);
		resizeFeature.resizeColumns(initialValues, initialValues.resizeStartWidth + delta, "uiColumnResized", true);
	}
	resizeLeafColumnsToFit(source) {
		this.resizeFeature?.resizeLeafColumnsToFit(source);
	}
	setupUserComp() {
		const { colGroupSvc, userCompFactory, gos, enterpriseMenuFactory } = this.beans;
		const columnGroup = this.column;
		const providedColumnGroup = columnGroup.getProvidedColumnGroup();
		const compDetails = _getHeaderGroupCompDetails(userCompFactory, _addGridCommonParams(gos, {
			displayName: this.displayName,
			columnGroup,
			setExpanded: (expanded) => {
				colGroupSvc.setColumnGroupOpened(providedColumnGroup, expanded, "gridInitializing");
			},
			setTooltip: (value, shouldDisplayTooltip) => {
				gos.assertModuleRegistered("Tooltip", 3);
				this.setupTooltip(value, shouldDisplayTooltip);
			},
			showColumnMenu: (buttonElement, onClosedCallback) => enterpriseMenuFactory?.showMenuAfterButtonClick(providedColumnGroup, buttonElement, "columnMenu", onClosedCallback),
			showColumnMenuAfterMouseClick: (mouseEvent, onClosedCallback) => enterpriseMenuFactory?.showMenuAfterMouseEvent(providedColumnGroup, mouseEvent, "columnMenu", onClosedCallback),
			eGridHeader: this.eGui
		}));
		if (compDetails) this.comp.setUserCompDetails(compDetails);
	}
	addHeaderMouseListeners(compBean) {
		const listener = (e) => this.handleMouseOverChange(e.type === "mouseenter");
		const clickListener = () => this.dispatchColumnMouseEvent("columnHeaderClicked", this.column.getProvidedColumnGroup());
		const contextMenuListener = (event) => this.handleContextMenuMouseEvent(event, void 0, this.column.getProvidedColumnGroup());
		compBean.addManagedListeners(this.eGui, {
			mouseenter: listener,
			mouseleave: listener,
			click: clickListener,
			contextmenu: contextMenuListener
		});
	}
	handleMouseOverChange(isMouseOver) {
		this.eventSvc.dispatchEvent({
			type: isMouseOver ? "columnHeaderMouseOver" : "columnHeaderMouseLeave",
			column: this.column.getProvidedColumnGroup()
		});
	}
	setupTooltip(value, shouldDisplayTooltip) {
		this.tooltipFeature = this.beans.tooltipSvc?.setupHeaderGroupTooltip(this.tooltipFeature, this, value, shouldDisplayTooltip);
	}
	setupExpandable(compBean) {
		const providedColGroup = this.column.getProvidedColumnGroup();
		this.refreshExpanded();
		const listener = this.refreshExpanded.bind(this);
		compBean.addManagedListeners(providedColGroup, {
			expandedChanged: listener,
			expandableChanged: listener
		});
	}
	refreshExpanded() {
		const { column } = this;
		this.expandable = column.isExpandable();
		const expanded = column.isExpanded();
		if (this.expandable) this.comp.setAriaExpanded(expanded ? "true" : "false");
		else this.comp.setAriaExpanded(void 0);
		this.refreshHeaderStyles();
	}
	addClasses() {
		const { column } = this;
		const colGroupDef = column.getColGroupDef();
		const classes = _getHeaderClassesFromColDef(colGroupDef, this.gos, null, column);
		if (column.isPadding()) {
			classes.push("ag-header-group-cell-no-group");
			if (column.getLeafColumns().every((col) => col.isSpanHeaderHeight())) classes.push("ag-header-span-height");
		} else {
			classes.push("ag-header-group-cell-with-group");
			if (colGroupDef?.wrapHeaderText) classes.push("ag-header-cell-wrap-text");
		}
		classes.forEach((c) => this.comp.toggleCss(c, true));
	}
	setupMovingCss(compBean) {
		const { column } = this;
		const leafColumns = column.getProvidedColumnGroup().getLeafColumns();
		const listener = () => this.comp.toggleCss("ag-header-cell-moving", column.isMoving());
		leafColumns.forEach((col) => {
			compBean.addManagedListeners(col, { movingChanged: listener });
		});
		listener();
	}
	onFocusIn(e) {
		if (!this.eGui.contains(e.relatedTarget)) this.focusThis();
	}
	handleKeyDown(e) {
		super.handleKeyDown(e);
		const wrapperHasFocus = this.getWrapperHasFocus();
		if (!this.expandable || !wrapperHasFocus) return;
		if (e.key === KeyCode.ENTER) {
			const column = this.column;
			const newExpandedValue = !column.isExpanded();
			this.beans.colGroupSvc.setColumnGroupOpened(column.getProvidedColumnGroup(), newExpandedValue, "uiColumnExpanded");
		}
	}
	setDragSource(eHeaderGroup) {
		if (!this.isAlive() || this.isSuppressMoving()) return;
		this.removeDragSource();
		if (!eHeaderGroup) return;
		this.dragSource = this.beans.colMoves?.setDragSourceForHeader(eHeaderGroup, this.column, this.displayName) ?? null;
	}
	isSuppressMoving() {
		return this.gos.get("suppressMovableColumns") || this.column.getLeafColumns().some((column) => column.getColDef().suppressMovable || column.getColDef().lockPosition);
	}
	destroy() {
		this.tooltipFeature = this.destroyBean(this.tooltipFeature);
		super.destroy();
	}
};
function setColumnGroupOpened(beans, group, newValue) {
	beans.colGroupSvc?.setColumnGroupOpened(group, newValue, "api");
}
function getColumnGroup(beans, name, instanceId) {
	return beans.colGroupSvc?.getColumnGroup(name, instanceId) ?? null;
}
function getProvidedColumnGroup(beans, name) {
	return beans.colGroupSvc?.getProvidedColGroup(name) ?? null;
}
function getDisplayNameForColumnGroup(beans, columnGroup, location) {
	return beans.colNames.getDisplayNameForColumnGroup(columnGroup, location) || "";
}
function getColumnGroupState(beans) {
	return beans.colGroupSvc?.getColumnGroupState() ?? [];
}
function setColumnGroupState(beans, stateItems) {
	beans.colGroupSvc?.setColumnGroupState(stateItems, "api");
}
function resetColumnGroupState(beans) {
	beans.colGroupSvc?.resetColumnGroupState("api");
}
function getLeftDisplayedColumnGroups(beans) {
	return beans.visibleCols.treeLeft;
}
function getCenterDisplayedColumnGroups(beans) {
	return beans.visibleCols.treeCenter;
}
function getRightDisplayedColumnGroups(beans) {
	return beans.visibleCols.treeRight;
}
function getAllDisplayedColumnGroups(beans) {
	return beans.visibleCols.getAllTrees();
}
function _removeAllFromUnorderedArray(array, toRemove) {
	for (let i = 0; i < toRemove.length; i++) {
		const index = array.indexOf(toRemove[i]);
		if (index >= 0) {
			array[index] = array[array.length - 1];
			array.pop();
		}
	}
}
var VisibleColsService = class extends BeanStub {
	constructor() {
		super(...arguments);
		this.beanName = "visibleCols";
		this.colsAndGroupsMap = {};
		this.leftCols = [];
		this.rightCols = [];
		this.centerCols = [];
		this.allCols = [];
		this.headerGroupRowCount = 0;
		this.bodyWidth = 0;
		this.leftWidth = 0;
		this.rightWidth = 0;
		this.isBodyWidthDirty = true;
	}
	refresh(source, skipTreeBuild = false) {
		const { colFlex, colModel, colGroupSvc, colViewport, selectionColSvc } = this.beans;
		if (!skipTreeBuild) this.buildTrees(colModel, colGroupSvc);
		colGroupSvc?.updateOpenClosedVisibility();
		this.leftCols = pickDisplayedCols(this.treeLeft);
		this.centerCols = pickDisplayedCols(this.treeCenter);
		this.rightCols = pickDisplayedCols(this.treeRight);
		selectionColSvc?.refreshVisibility(this.leftCols, this.centerCols, this.rightCols);
		this.joinColsAriaOrder(colModel);
		this.joinCols();
		this.headerGroupRowCount = this.getHeaderRowCount();
		this.setLeftValues(source);
		this.autoHeightCols = this.allCols.filter((col) => col.isAutoHeight());
		colFlex?.refreshFlexedColumns();
		this.updateBodyWidths();
		this.setFirstRightAndLastLeftPinned(colModel, this.leftCols, this.rightCols, source);
		colViewport.checkViewportColumns(false);
		this.eventSvc.dispatchEvent({
			type: "displayedColumnsChanged",
			source
		});
	}
	getHeaderRowCount() {
		if (!this.gos.get("hidePaddedHeaderRows")) return this.beans.colModel.cols.treeDepth;
		let headerGroupRowCount = 0;
		for (const col of this.allCols) {
			let parent = col.getParent();
			while (parent) {
				if (!parent.isPadding()) {
					const level = parent.getProvidedColumnGroup().getLevel() + 1;
					if (level > headerGroupRowCount) headerGroupRowCount = level;
					break;
				}
				parent = parent.getParent();
			}
		}
		return headerGroupRowCount;
	}
	updateBodyWidths() {
		const newBodyWidth = getWidthOfColsInList(this.centerCols);
		const newLeftWidth = getWidthOfColsInList(this.leftCols);
		const newRightWidth = getWidthOfColsInList(this.rightCols);
		this.isBodyWidthDirty = this.bodyWidth !== newBodyWidth;
		if (this.bodyWidth !== newBodyWidth || this.leftWidth !== newLeftWidth || this.rightWidth !== newRightWidth) {
			this.bodyWidth = newBodyWidth;
			this.leftWidth = newLeftWidth;
			this.rightWidth = newRightWidth;
			this.eventSvc.dispatchEvent({ type: "columnContainerWidthChanged" });
			this.eventSvc.dispatchEvent({ type: "displayedColumnsWidthChanged" });
		}
	}
	setLeftValues(source) {
		this.setLeftValuesOfCols(source);
		this.setLeftValuesOfGroups();
	}
	setFirstRightAndLastLeftPinned(colModel, leftCols, rightCols, source) {
		let lastLeft;
		let firstRight;
		if (this.gos.get("enableRtl")) {
			lastLeft = leftCols ? leftCols[0] : null;
			firstRight = rightCols ? _last(rightCols) : null;
		} else {
			lastLeft = leftCols ? _last(leftCols) : null;
			firstRight = rightCols ? rightCols[0] : null;
		}
		colModel.getCols().forEach((col) => {
			col.setLastLeftPinned(col === lastLeft, source);
			col.setFirstRightPinned(col === firstRight, source);
		});
	}
	buildTrees(colModel, columnGroupSvc) {
		const cols = colModel.getColsToShow();
		const leftCols = cols.filter((col) => col.getPinned() == "left");
		const rightCols = cols.filter((col) => col.getPinned() == "right");
		const centerCols = cols.filter((col) => col.getPinned() != "left" && col.getPinned() != "right");
		const idCreator = new GroupInstanceIdCreator();
		const createGroups = (params) => {
			return columnGroupSvc ? columnGroupSvc.createColumnGroups(params) : params.columns;
		};
		this.treeLeft = createGroups({
			columns: leftCols,
			idCreator,
			pinned: "left",
			oldDisplayedGroups: this.treeLeft
		});
		this.treeRight = createGroups({
			columns: rightCols,
			idCreator,
			pinned: "right",
			oldDisplayedGroups: this.treeRight
		});
		this.treeCenter = createGroups({
			columns: centerCols,
			idCreator,
			pinned: null,
			oldDisplayedGroups: this.treeCenter
		});
		this.updateColsAndGroupsMap();
	}
	clear() {
		this.leftCols = [];
		this.rightCols = [];
		this.centerCols = [];
		this.allCols = [];
		this.ariaOrderColumns = [];
	}
	joinColsAriaOrder(colModel) {
		const allColumns = colModel.getCols();
		const pinnedLeft = [];
		const center = [];
		const pinnedRight = [];
		for (const col of allColumns) {
			const pinned = col.getPinned();
			if (!pinned) center.push(col);
			else if (pinned === true || pinned === "left") pinnedLeft.push(col);
			else pinnedRight.push(col);
		}
		this.ariaOrderColumns = pinnedLeft.concat(center).concat(pinnedRight);
	}
	getAriaColIndex(colOrGroup) {
		let col;
		if (isColumnGroup(colOrGroup)) col = colOrGroup.getLeafColumns()[0];
		else col = colOrGroup;
		return this.ariaOrderColumns.indexOf(col) + 1;
	}
	setLeftValuesOfGroups() {
		[
			this.treeLeft,
			this.treeRight,
			this.treeCenter
		].forEach((columns) => {
			columns.forEach((column) => {
				if (isColumnGroup(column)) column.checkLeft();
			});
		});
	}
	setLeftValuesOfCols(source) {
		const { colModel } = this.beans;
		if (!colModel.getColDefCols()) return;
		const allColumns = colModel.getCols().slice(0);
		const doingRtl = this.gos.get("enableRtl");
		[
			this.leftCols,
			this.rightCols,
			this.centerCols
		].forEach((columns) => {
			if (doingRtl) {
				let left = getWidthOfColsInList(columns);
				columns.forEach((column) => {
					left -= column.getActualWidth();
					column.setLeft(left, source);
				});
			} else {
				let left = 0;
				columns.forEach((column) => {
					column.setLeft(left, source);
					left += column.getActualWidth();
				});
			}
			_removeAllFromUnorderedArray(allColumns, columns);
		});
		allColumns.forEach((column) => {
			column.setLeft(null, source);
		});
	}
	joinCols() {
		if (this.gos.get("enableRtl")) this.allCols = this.rightCols.concat(this.centerCols).concat(this.leftCols);
		else this.allCols = this.leftCols.concat(this.centerCols).concat(this.rightCols);
	}
	getAllTrees() {
		if (this.treeLeft && this.treeRight && this.treeCenter) return this.treeLeft.concat(this.treeCenter).concat(this.treeRight);
		return null;
	}
	isColDisplayed(column) {
		return this.allCols.indexOf(column) >= 0;
	}
	getLeftColsForRow(rowNode) {
		const { leftCols, beans: { colModel } } = this;
		if (!colModel.colSpanActive) return leftCols;
		return this.getColsForRow(rowNode, leftCols);
	}
	getRightColsForRow(rowNode) {
		const { rightCols, beans: { colModel } } = this;
		if (!colModel.colSpanActive) return rightCols;
		return this.getColsForRow(rowNode, rightCols);
	}
	getColsForRow(rowNode, displayedColumns, filterCallback, emptySpaceBeforeColumn) {
		const result = [];
		let lastConsideredCol = null;
		for (let i = 0; i < displayedColumns.length; i++) {
			const col = displayedColumns[i];
			const maxAllowedColSpan = displayedColumns.length - i;
			const colSpan = Math.min(col.getColSpan(rowNode), maxAllowedColSpan);
			const columnsToCheckFilter = [col];
			if (colSpan > 1) {
				const colsToRemove = colSpan - 1;
				for (let j = 1; j <= colsToRemove; j++) columnsToCheckFilter.push(displayedColumns[i + j]);
				i += colsToRemove;
			}
			let filterPasses;
			if (filterCallback) {
				filterPasses = false;
				columnsToCheckFilter.forEach((colForFilter) => {
					if (filterCallback(colForFilter)) filterPasses = true;
				});
			} else filterPasses = true;
			if (filterPasses) {
				if (result.length === 0 && lastConsideredCol) {
					if (emptySpaceBeforeColumn ? emptySpaceBeforeColumn(col) : false) result.push(lastConsideredCol);
				}
				result.push(col);
			}
			lastConsideredCol = col;
		}
		return result;
	}
	getContainerWidth(pinned) {
		switch (pinned) {
			case "left": return this.leftWidth;
			case "right": return this.rightWidth;
			default: return this.bodyWidth;
		}
	}
	getColBefore(col) {
		const allDisplayedColumns = this.allCols;
		const oldIndex = allDisplayedColumns.indexOf(col);
		if (oldIndex > 0) return allDisplayedColumns[oldIndex - 1];
		return null;
	}
	isPinningLeft() {
		return this.leftCols.length > 0;
	}
	isPinningRight() {
		return this.rightCols.length > 0;
	}
	updateColsAndGroupsMap() {
		this.colsAndGroupsMap = {};
		const func = (child) => {
			this.colsAndGroupsMap[child.getUniqueId()] = child;
		};
		depthFirstAllColumnTreeSearch(this.treeCenter, false, func);
		depthFirstAllColumnTreeSearch(this.treeLeft, false, func);
		depthFirstAllColumnTreeSearch(this.treeRight, false, func);
	}
	isVisible(item) {
		return this.colsAndGroupsMap[item.getUniqueId()] === item;
	}
	getFirstColumn() {
		const isRtl = this.gos.get("enableRtl");
		const queryOrder = [
			"leftCols",
			"centerCols",
			"rightCols"
		];
		if (isRtl) queryOrder.reverse();
		for (let i = 0; i < queryOrder.length; i++) {
			const container = this[queryOrder[i]];
			if (container.length) return isRtl ? _last(container) : container[0];
		}
		return null;
	}
	getColAfter(col) {
		const allDisplayedColumns = this.allCols;
		const oldIndex = allDisplayedColumns.indexOf(col);
		if (oldIndex < allDisplayedColumns.length - 1) return allDisplayedColumns[oldIndex + 1];
		return null;
	}
	getColsLeftWidth() {
		return getWidthOfColsInList(this.leftCols);
	}
	getDisplayedColumnsRightWidth() {
		return getWidthOfColsInList(this.rightCols);
	}
	isColAtEdge(col, edge) {
		const allColumns = this.allCols;
		if (!allColumns.length) return false;
		const isFirst = edge === "first";
		let columnToCompare;
		if (isColumnGroup(col)) {
			const leafColumns = col.getDisplayedLeafColumns();
			if (!leafColumns.length) return false;
			columnToCompare = isFirst ? leafColumns[0] : _last(leafColumns);
		} else columnToCompare = col;
		return (isFirst ? allColumns[0] : _last(allColumns)) === columnToCompare;
	}
};
function depthFirstAllColumnTreeSearch(tree, useDisplayedChildren, callback) {
	if (!tree) return;
	for (let i = 0; i < tree.length; i++) {
		const child = tree[i];
		if (isColumnGroup(child)) depthFirstAllColumnTreeSearch(useDisplayedChildren ? child.getDisplayedChildren() : child.getChildren(), useDisplayedChildren, callback);
		callback(child);
	}
}
function pickDisplayedCols(tree) {
	const res = [];
	depthFirstAllColumnTreeSearch(tree, true, (child) => {
		if (isColumn(child)) res.push(child);
	});
	return res;
}
var ColumnGroupService = class extends BeanStub {
	constructor() {
		super(...arguments);
		this.beanName = "colGroupSvc";
	}
	getColumnGroupState() {
		const columnGroupState = [];
		depthFirstOriginalTreeSearch(null, this.beans.colModel.getColTree(), (node) => {
			if (isProvidedColumnGroup(node)) columnGroupState.push({
				groupId: node.getGroupId(),
				open: node.isExpanded()
			});
		});
		return columnGroupState;
	}
	resetColumnGroupState(source) {
		const primaryColumnTree = this.beans.colModel.getColDefColTree();
		if (!primaryColumnTree) return;
		const stateItems = [];
		depthFirstOriginalTreeSearch(null, primaryColumnTree, (child) => {
			if (isProvidedColumnGroup(child)) {
				const colGroupDef = child.getColGroupDef();
				const groupState = {
					groupId: child.getGroupId(),
					open: !colGroupDef ? void 0 : colGroupDef.openByDefault
				};
				stateItems.push(groupState);
			}
		});
		this.setColumnGroupState(stateItems, source);
	}
	setColumnGroupState(stateItems, source) {
		const { colModel, colAnimation, visibleCols, eventSvc } = this.beans;
		if (!colModel.getColTree().length) return;
		colAnimation?.start();
		const impactedGroups = [];
		stateItems.forEach((stateItem) => {
			const groupKey = stateItem.groupId;
			const newValue = stateItem.open;
			const providedColumnGroup = this.getProvidedColGroup(groupKey);
			if (!providedColumnGroup) return;
			if (providedColumnGroup.isExpanded() === newValue) return;
			providedColumnGroup.setExpanded(newValue);
			impactedGroups.push(providedColumnGroup);
		});
		visibleCols.refresh(source, true);
		if (impactedGroups.length) eventSvc.dispatchEvent({
			type: "columnGroupOpened",
			columnGroup: impactedGroups.length === 1 ? impactedGroups[0] : void 0,
			columnGroups: impactedGroups
		});
		colAnimation?.finish();
	}
	setColumnGroupOpened(key, newValue, source) {
		let keyAsString;
		if (isProvidedColumnGroup(key)) keyAsString = key.getId();
		else keyAsString = key || "";
		this.setColumnGroupState([{
			groupId: keyAsString,
			open: newValue
		}], source);
	}
	getProvidedColGroup(key) {
		let res = null;
		depthFirstOriginalTreeSearch(null, this.beans.colModel.getColTree(), (node) => {
			if (isProvidedColumnGroup(node)) {
				if (node.getId() === key) res = node;
			}
		});
		return res;
	}
	getGroupAtDirection(columnGroup, direction) {
		const requiredLevel = columnGroup.getProvidedColumnGroup().getLevel() + columnGroup.getPaddingLevel();
		const colGroupLeafColumns = columnGroup.getDisplayedLeafColumns();
		const col = direction === "After" ? _last(colGroupLeafColumns) : colGroupLeafColumns[0];
		const getDisplayColMethod = `getCol${direction}`;
		while (true) {
			const column = this.beans.visibleCols[getDisplayColMethod](col);
			if (!column) return null;
			const groupPointer = this.getColGroupAtLevel(column, requiredLevel);
			if (groupPointer !== columnGroup) return groupPointer;
		}
	}
	getColGroupAtLevel(column, level) {
		let groupPointer = column.getParent();
		let originalGroupLevel;
		let groupPointerLevel;
		while (true) {
			originalGroupLevel = groupPointer.getProvidedColumnGroup().getLevel();
			groupPointerLevel = groupPointer.getPaddingLevel();
			if (originalGroupLevel + groupPointerLevel <= level) break;
			groupPointer = groupPointer.getParent();
		}
		return groupPointer;
	}
	updateOpenClosedVisibility() {
		depthFirstAllColumnTreeSearch(this.beans.visibleCols.getAllTrees(), false, (child) => {
			if (isColumnGroup(child)) child.calculateDisplayedColumns();
		});
	}
	getColumnGroup(colId, partId) {
		if (!colId) return null;
		if (isColumnGroup(colId)) return colId;
		const allColumnGroups = this.beans.visibleCols.getAllTrees();
		const checkPartId = typeof partId === "number";
		let result = null;
		depthFirstAllColumnTreeSearch(allColumnGroups, false, (child) => {
			if (isColumnGroup(child)) {
				const columnGroup = child;
				let matched;
				if (checkPartId) matched = colId === columnGroup.getGroupId() && partId === columnGroup.getPartId();
				else matched = colId === columnGroup.getGroupId();
				if (matched) result = columnGroup;
			}
		});
		return result;
	}
	createColumnGroups(params) {
		const { columns, idCreator, pinned, oldDisplayedGroups, isStandaloneStructure } = params;
		const oldColumnsMapped = this.mapOldGroupsById(oldDisplayedGroups);
		const topLevelResultCols = [];
		let groupsOrColsAtCurrentLevel = columns;
		while (groupsOrColsAtCurrentLevel.length) {
			const currentlyIterating = groupsOrColsAtCurrentLevel;
			groupsOrColsAtCurrentLevel = [];
			let lastGroupedColIdx = 0;
			const createGroupToIndex = (to) => {
				const from = lastGroupedColIdx;
				lastGroupedColIdx = to;
				const previousNode = currentlyIterating[from];
				const previousNodeParent = (isColumnGroup(previousNode) ? previousNode.getProvidedColumnGroup() : previousNode).getOriginalParent();
				if (previousNodeParent == null) {
					for (let i = from; i < to; i++) topLevelResultCols.push(currentlyIterating[i]);
					return;
				}
				const newGroup = this.createColumnGroup(previousNodeParent, idCreator, oldColumnsMapped, pinned, isStandaloneStructure);
				for (let i = from; i < to; i++) newGroup.addChild(currentlyIterating[i]);
				groupsOrColsAtCurrentLevel.push(newGroup);
			};
			for (let i = 1; i < currentlyIterating.length; i++) {
				const thisNode = currentlyIterating[i];
				const thisNodeParent = (isColumnGroup(thisNode) ? thisNode.getProvidedColumnGroup() : thisNode).getOriginalParent();
				const previousNode = currentlyIterating[lastGroupedColIdx];
				if (thisNodeParent !== (isColumnGroup(previousNode) ? previousNode.getProvidedColumnGroup() : previousNode).getOriginalParent()) createGroupToIndex(i);
			}
			if (lastGroupedColIdx < currentlyIterating.length) createGroupToIndex(currentlyIterating.length);
		}
		if (!isStandaloneStructure) this.setupParentsIntoCols(topLevelResultCols, null);
		return topLevelResultCols;
	}
	createProvidedColumnGroup(primaryColumns, colGroupDef, level, existingColumns, columnKeyCreator, existingGroups, source) {
		const groupId = columnKeyCreator.getUniqueKey(colGroupDef.groupId || null, null);
		const colGroupDefMerged = createMergedColGroupDef(this.beans, colGroupDef, groupId);
		const providedGroup = new AgProvidedColumnGroup(colGroupDefMerged, groupId, false, level);
		this.createBean(providedGroup);
		const existingGroupAndIndex = this.findExistingGroup(colGroupDef, existingGroups);
		if (existingGroupAndIndex) existingGroups.splice(existingGroupAndIndex.idx, 1);
		const existingGroup = existingGroupAndIndex?.group;
		if (existingGroup) providedGroup.setExpanded(existingGroup.isExpanded());
		const children = _recursivelyCreateColumns(this.beans, colGroupDefMerged.children, level + 1, primaryColumns, existingColumns, columnKeyCreator, existingGroups, source);
		providedGroup.setChildren(children);
		return providedGroup;
	}
	balanceColumnTree(unbalancedTree, currentDepth, columnDepth, columnKeyCreator) {
		const result = [];
		for (let i = 0; i < unbalancedTree.length; i++) {
			const child = unbalancedTree[i];
			if (isProvidedColumnGroup(child)) {
				const originalGroup = child;
				const newChildren = this.balanceColumnTree(originalGroup.getChildren(), currentDepth + 1, columnDepth, columnKeyCreator);
				originalGroup.setChildren(newChildren);
				result.push(originalGroup);
			} else {
				let firstPaddedGroup;
				let currentPaddedGroup;
				for (let j = currentDepth; j < columnDepth; j++) {
					const newColId = columnKeyCreator.getUniqueKey(null, null);
					const paddedGroup = new AgProvidedColumnGroup(createMergedColGroupDef(this.beans, null, newColId), newColId, true, j);
					this.createBean(paddedGroup);
					if (currentPaddedGroup) currentPaddedGroup.setChildren([paddedGroup]);
					currentPaddedGroup = paddedGroup;
					if (!firstPaddedGroup) firstPaddedGroup = currentPaddedGroup;
				}
				if (firstPaddedGroup && currentPaddedGroup) {
					result.push(firstPaddedGroup);
					if (unbalancedTree.some((leaf) => isProvidedColumnGroup(leaf))) {
						currentPaddedGroup.setChildren([child]);
						continue;
					} else {
						currentPaddedGroup.setChildren(unbalancedTree);
						break;
					}
				}
				result.push(child);
			}
		}
		return result;
	}
	findDepth(balancedColumnTree) {
		let depth = 0;
		let pointer = balancedColumnTree;
		while (pointer && pointer[0] && isProvidedColumnGroup(pointer[0])) {
			depth++;
			pointer = pointer[0].getChildren();
		}
		return depth;
	}
	findMaxDepth(treeChildren, depth) {
		let maxDepthThisLevel = depth;
		for (let i = 0; i < treeChildren.length; i++) {
			const abstractColumn = treeChildren[i];
			if (isProvidedColumnGroup(abstractColumn)) {
				const originalGroup = abstractColumn;
				const newDepth = this.findMaxDepth(originalGroup.getChildren(), depth + 1);
				if (maxDepthThisLevel < newDepth) maxDepthThisLevel = newDepth;
			}
		}
		return maxDepthThisLevel;
	}
	balanceTreeForAutoCols(autoCols, depth) {
		const tree = [];
		autoCols.forEach((col) => {
			let nextChild = col;
			for (let i = depth - 1; i >= 0; i--) {
				const autoGroup = new AgProvidedColumnGroup(null, `FAKE_PATH_${col.getId()}}_${i}`, true, i);
				this.createBean(autoGroup);
				autoGroup.setChildren([nextChild]);
				nextChild.originalParent = autoGroup;
				nextChild = autoGroup;
			}
			if (depth === 0) col.originalParent = null;
			tree.push(nextChild);
		});
		return tree;
	}
	findExistingGroup(newGroupDef, existingGroups) {
		if (!(newGroupDef.groupId != null)) return;
		for (let i = 0; i < existingGroups.length; i++) {
			const existingGroup = existingGroups[i];
			if (!existingGroup.getColGroupDef()) continue;
			if (existingGroup.getId() === newGroupDef.groupId) return {
				idx: i,
				group: existingGroup
			};
		}
	}
	createColumnGroup(providedGroup, groupInstanceIdCreator, oldColumnsMapped, pinned, isStandaloneStructure) {
		const groupId = providedGroup.getGroupId();
		const instanceId = groupInstanceIdCreator.getInstanceIdForKey(groupId);
		let columnGroup = oldColumnsMapped[createUniqueColumnGroupId(groupId, instanceId)];
		if (columnGroup && columnGroup.getProvidedColumnGroup() !== providedGroup) columnGroup = null;
		if (_exists(columnGroup)) columnGroup.reset();
		else {
			columnGroup = new AgColumnGroup(providedGroup, groupId, instanceId, pinned);
			if (!isStandaloneStructure) this.createBean(columnGroup);
		}
		return columnGroup;
	}
	mapOldGroupsById(displayedGroups) {
		const result = {};
		const recursive = (columnsOrGroups) => {
			columnsOrGroups.forEach((columnOrGroup) => {
				if (isColumnGroup(columnOrGroup)) {
					const columnGroup = columnOrGroup;
					result[columnOrGroup.getUniqueId()] = columnGroup;
					recursive(columnGroup.getChildren());
				}
			});
		};
		if (displayedGroups) recursive(displayedGroups);
		return result;
	}
	setupParentsIntoCols(columnsOrGroups, parent) {
		columnsOrGroups.forEach((columnsOrGroup) => {
			if (columnsOrGroup.parent !== parent) this.beans.colViewport.colsWithinViewportHash = "";
			columnsOrGroup.parent = parent;
			if (isColumnGroup(columnsOrGroup)) {
				const columnGroup = columnsOrGroup;
				this.setupParentsIntoCols(columnGroup.getChildren(), columnGroup);
			}
		});
	}
};
var ColumnGroupModule = {
	moduleName: "ColumnGroup",
	version: VERSION,
	dynamicBeans: { headerGroupCellCtrl: HeaderGroupCellCtrl },
	beans: [ColumnGroupService],
	apiFunctions: {
		getAllDisplayedColumnGroups,
		getCenterDisplayedColumnGroups,
		getColumnGroup,
		getColumnGroupState,
		getDisplayNameForColumnGroup,
		getLeftDisplayedColumnGroups,
		getProvidedColumnGroup,
		getRightDisplayedColumnGroups,
		resetColumnGroupState,
		setColumnGroupOpened,
		setColumnGroupState
	}
};
var SkeletonCellRendererElement = {
	tag: "div",
	cls: "ag-skeleton-container"
};
var SkeletonCellRenderer = class extends Component {
	constructor() {
		super(SkeletonCellRendererElement);
	}
	init(params) {
		const id = `ag-cell-skeleton-renderer-${this.getCompId()}`;
		this.getGui().setAttribute("id", id);
		this.addDestroyFunc(() => _setAriaLabelledBy(params.eParentOfValue));
		_setAriaLabelledBy(params.eParentOfValue, id);
		if (params.deferRender) this.setupLoading(params);
		else params.node.failedLoad ? this.setupFailed() : this.setupLoading(params);
	}
	setupFailed() {
		const localeTextFunc = this.getLocaleTextFunc();
		this.getGui().textContent = localeTextFunc("loadingError", "ERR");
		const ariaFailed = localeTextFunc("ariaSkeletonCellLoadingFailed", "Row failed to load");
		_setAriaLabel(this.getGui(), ariaFailed);
	}
	setupLoading(params) {
		const skeletonEffect = _createElement({
			tag: "div",
			cls: "ag-skeleton-effect"
		});
		const rowIndex = params.node.rowIndex;
		if (rowIndex != null) {
			const width = 75 + 25 * (rowIndex % 2 === 0 ? Math.sin(rowIndex) : Math.cos(rowIndex));
			skeletonEffect.style.width = `${width}%`;
		}
		this.getGui().appendChild(skeletonEffect);
		const localeTextFunc = this.getLocaleTextFunc();
		const ariaLoading = params.deferRender ? localeTextFunc("ariaDeferSkeletonCellLoading", "Cell is loading") : localeTextFunc("ariaSkeletonCellLoading", "Row data is loading");
		_setAriaLabel(this.getGui(), ariaLoading);
	}
	refresh(_params) {
		return false;
	}
};
var CheckboxCellRendererModule = {
	moduleName: "CheckboxCellRenderer",
	version: VERSION,
	userComponents: { agCheckboxCellRenderer: CheckboxCellRenderer }
};
var SkeletonCellRendererModule = {
	moduleName: "SkeletonCellRenderer",
	version: VERSION,
	userComponents: { agSkeletonCellRenderer: SkeletonCellRenderer }
};
function getColumnDef(beans, key) {
	const column = beans.colModel.getColDefCol(key);
	if (column) return column.getColDef();
	return null;
}
function getColumnDefs(beans) {
	return beans.colModel.getColumnDefs();
}
function getDisplayNameForColumn(beans, column, location) {
	return beans.colNames.getDisplayNameForColumn(column, location) || "";
}
function getColumn(beans, key) {
	return beans.colModel.getColDefCol(key);
}
function getColumns(beans) {
	return beans.colModel.getColDefCols();
}
function applyColumnState(beans, params) {
	return _applyColumnState(beans, params, "api");
}
function getColumnState(beans) {
	return _getColumnState(beans);
}
function resetColumnState(beans) {
	_resetColumnState(beans, "api");
}
function isPinning(beans) {
	return beans.visibleCols.isPinningLeft() || beans.visibleCols.isPinningRight();
}
function isPinningLeft(beans) {
	return beans.visibleCols.isPinningLeft();
}
function isPinningRight(beans) {
	return beans.visibleCols.isPinningRight();
}
function getDisplayedColAfter(beans, col) {
	return beans.visibleCols.getColAfter(col);
}
function getDisplayedColBefore(beans, col) {
	return beans.visibleCols.getColBefore(col);
}
function setColumnsVisible(beans, keys, visible) {
	beans.colModel.setColsVisible(keys, visible, "api");
}
function setColumnsPinned(beans, keys, pinned) {
	beans.pinnedCols?.setColsPinned(keys, pinned, "api");
}
function getAllGridColumns(beans) {
	return beans.colModel.getCols();
}
function getDisplayedLeftColumns(beans) {
	return beans.visibleCols.leftCols;
}
function getDisplayedCenterColumns(beans) {
	return beans.visibleCols.centerCols;
}
function getDisplayedRightColumns(beans) {
	return beans.visibleCols.rightCols;
}
function getAllDisplayedColumns(beans) {
	return beans.visibleCols.allCols;
}
function getAllDisplayedVirtualColumns(beans) {
	return beans.colViewport.getViewportColumns();
}
function _deepCloneDefinition(object, keysToSkip) {
	if (!object) return;
	const obj = object;
	const res = {};
	Object.keys(obj).forEach((key) => {
		if (keysToSkip && keysToSkip.indexOf(key) >= 0 || SKIP_JS_BUILTINS.has(key)) return;
		const value = obj[key];
		if (typeof value === "object" && value !== null && value.constructor === Object) res[key] = _deepCloneDefinition(value);
		else res[key] = value;
	});
	return res;
}
var ColumnDefFactory = class extends BeanStub {
	constructor() {
		super(...arguments);
		this.beanName = "colDefFactory";
	}
	wireBeans(beans) {
		this.rowGroupColsSvc = beans.rowGroupColsSvc;
		this.pivotColsSvc = beans.pivotColsSvc;
	}
	getColumnDefs(colDefColsList, showingPivotResult, lastOrder, colsList) {
		const cols = colDefColsList.slice();
		if (showingPivotResult) cols.sort((a, b) => lastOrder.indexOf(a) - lastOrder.indexOf(b));
		else if (lastOrder) cols.sort((a, b) => colsList.indexOf(a) - colsList.indexOf(b));
		const rowGroupColumns = this.rowGroupColsSvc?.columns;
		const pivotColumns = this.pivotColsSvc?.columns;
		return this.buildColumnDefs(cols, rowGroupColumns, pivotColumns);
	}
	buildColumnDefs(cols, rowGroupColumns = [], pivotColumns = []) {
		const res = [];
		const colGroupDefs = {};
		cols.forEach((col) => {
			const colDef = this.createDefFromColumn(col, rowGroupColumns, pivotColumns);
			let addToResult = true;
			let childDef = colDef;
			let pointer = col.getOriginalParent();
			let lastPointer = null;
			while (pointer) {
				let parentDef = null;
				if (pointer.isPadding()) {
					pointer = pointer.getOriginalParent();
					continue;
				}
				const existingParentDef = colGroupDefs[pointer.getGroupId()];
				if (existingParentDef) {
					existingParentDef.children.push(childDef);
					addToResult = false;
					break;
				}
				parentDef = this.createDefFromGroup(pointer);
				if (parentDef) {
					parentDef.children = [childDef];
					colGroupDefs[parentDef.groupId] = parentDef;
					childDef = parentDef;
					pointer = pointer.getOriginalParent();
				}
				if (pointer != null && lastPointer === pointer) {
					addToResult = false;
					break;
				}
				lastPointer = pointer;
			}
			if (addToResult) res.push(childDef);
		});
		return res;
	}
	createDefFromGroup(group) {
		const defCloned = _deepCloneDefinition(group.getColGroupDef(), ["children"]);
		if (defCloned) defCloned.groupId = group.getGroupId();
		return defCloned;
	}
	createDefFromColumn(col, rowGroupColumns, pivotColumns) {
		const colDefCloned = _deepCloneDefinition(col.getColDef());
		colDefCloned.colId = col.getColId();
		colDefCloned.width = col.getActualWidth();
		colDefCloned.rowGroup = col.isRowGroupActive();
		colDefCloned.rowGroupIndex = col.isRowGroupActive() ? rowGroupColumns.indexOf(col) : null;
		colDefCloned.pivot = col.isPivotActive();
		colDefCloned.pivotIndex = col.isPivotActive() ? pivotColumns.indexOf(col) : null;
		colDefCloned.aggFunc = col.isValueActive() ? col.getAggFunc() : null;
		colDefCloned.hide = col.isVisible() ? void 0 : true;
		colDefCloned.pinned = col.isPinned() ? col.getPinned() : null;
		colDefCloned.sort = col.getSort() ? col.getSort() : null;
		colDefCloned.sortIndex = col.getSortIndex() != null ? col.getSortIndex() : null;
		return colDefCloned;
	}
};
var ColumnFlexService = class extends BeanStub {
	constructor() {
		super(...arguments);
		this.beanName = "colFlex";
	}
	refreshFlexedColumns(params = {}) {
		const source = params.source ?? "flex";
		if (params.viewportWidth != null) this.flexViewportWidth = params.viewportWidth;
		const totalSpace = this.flexViewportWidth;
		if (!totalSpace) return [];
		const { visibleCols } = this.beans;
		const visibleCenterCols = visibleCols.centerCols;
		let flexAfterDisplayIndex = -1;
		if (params.resizingCols) {
			const allResizingCols = new Set(params.resizingCols);
			for (let i = visibleCenterCols.length - 1; i >= 0; i--) if (allResizingCols.has(visibleCenterCols[i])) {
				flexAfterDisplayIndex = i;
				break;
			}
		}
		let hasFlexItems = false;
		const items = visibleCenterCols.map((col, i) => {
			const flex = col.getFlex();
			const isFlex = flex != null && flex > 0 && i > flexAfterDisplayIndex;
			hasFlexItems || (hasFlexItems = isFlex);
			return {
				col,
				isFlex,
				flex: Math.max(0, flex ?? 0),
				initialSize: col.getActualWidth(),
				min: col.getMinWidth(),
				max: col.getMaxWidth(),
				targetSize: 0
			};
		});
		if (!hasFlexItems) return [];
		let unfrozenItemCount = items.length;
		let unfrozenFlex = items.reduce((acc, item) => acc + item.flex, 0);
		let unfrozenSpace = totalSpace;
		const freeze = (item, width) => {
			item.frozenSize = width;
			item.col.setActualWidth(width, source);
			unfrozenSpace -= width;
			unfrozenFlex -= item.flex;
			unfrozenItemCount -= 1;
		};
		const isFrozen = (item) => item.frozenSize != null;
		for (const item of items) if (!item.isFlex) freeze(item, item.initialSize);
		while (unfrozenItemCount > 0) {
			const spaceToFill = Math.round(unfrozenFlex < 1 ? unfrozenSpace * unfrozenFlex : unfrozenSpace);
			let lastUnfrozenItem;
			let actualLeft = 0;
			let idealRight = 0;
			for (const item of items) {
				if (isFrozen(item)) continue;
				lastUnfrozenItem = item;
				idealRight += spaceToFill * (item.flex / unfrozenFlex);
				const idealSize = idealRight - actualLeft;
				const roundedSize = Math.round(idealSize);
				item.targetSize = roundedSize;
				actualLeft += roundedSize;
			}
			if (lastUnfrozenItem) lastUnfrozenItem.targetSize += spaceToFill - actualLeft;
			let totalViolation = 0;
			for (const item of items) {
				if (isFrozen(item)) continue;
				const unclampedSize = item.targetSize;
				const clampedSize = Math.min(Math.max(unclampedSize, item.min), item.max);
				totalViolation += clampedSize - unclampedSize;
				item.violationType = clampedSize === unclampedSize ? void 0 : clampedSize < unclampedSize ? "max" : "min";
				item.targetSize = clampedSize;
			}
			const freezeType = totalViolation === 0 ? "all" : totalViolation > 0 ? "min" : "max";
			for (const item of items) {
				if (isFrozen(item)) continue;
				if (freezeType === "all" || item.violationType === freezeType) freeze(item, item.targetSize);
			}
		}
		if (!params.skipSetLeft) visibleCols.setLeftValues(source);
		if (params.updateBodyWidths) visibleCols.updateBodyWidths();
		const unconstrainedFlexColumns = items.filter((item) => item.isFlex && !item.violationType).map((item) => item.col);
		if (params.fireResizedEvent) {
			const changedColumns = items.filter((item) => item.initialSize !== item.frozenSize).map((item) => item.col);
			const flexingColumns = items.filter((item) => item.flex).map((item) => item.col);
			dispatchColumnResizedEvent(this.eventSvc, changedColumns, true, source, flexingColumns);
		}
		return unconstrainedFlexColumns;
	}
	initCol(column) {
		const { flex, initialFlex } = column.colDef;
		if (flex !== void 0) column.flex = flex;
		else if (initialFlex !== void 0) column.flex = initialFlex;
	}
	setColFlex(column, flex) {
		column.flex = flex ?? null;
		column.dispatchStateUpdatedEvent("flex");
	}
};
var SORTED_CELL_DATA_TYPES_FOR_MATCHING = [
	"dateTimeString",
	"dateString",
	"text",
	"number",
	"boolean",
	"date"
];
var DataTypeService = class extends BeanStub {
	constructor() {
		super(...arguments);
		this.beanName = "dataTypeSvc";
		this.dataTypeDefinitions = {};
		this.isPendingInference = false;
		this.isColumnTypeOverrideInDataTypeDefinitions = false;
		this.columnStateUpdatesPendingInference = {};
		this.columnStateUpdateListenerDestroyFuncs = [];
		this.columnDefinitionPropsPerDataType = {
			number() {
				return { cellEditor: "agNumberCellEditor" };
			},
			boolean() {
				return {
					cellEditor: "agCheckboxCellEditor",
					cellRenderer: "agCheckboxCellRenderer",
					getFindText: () => null,
					suppressKeyboardEvent: (params) => !!params.colDef.editable && params.event.key === KeyCode.SPACE
				};
			},
			date({ formatValue }) {
				return {
					cellEditor: "agDateCellEditor",
					keyCreator: formatValue
				};
			},
			dateString({ formatValue }) {
				return {
					cellEditor: "agDateStringCellEditor",
					keyCreator: formatValue
				};
			},
			dateTime(args) {
				return this.date(args);
			},
			dateTimeString(args) {
				return this.dateString(args);
			},
			object({ formatValue, colModel, colId }) {
				return {
					cellEditorParams: { useFormatter: true },
					comparator: (a, b) => {
						const column = colModel.getColDefCol(colId);
						const colDef = column?.getColDef();
						if (!column || !colDef) return 0;
						const valA = a == null ? "" : formatValue({
							column,
							node: null,
							value: a
						});
						const valB = b == null ? "" : formatValue({
							column,
							node: null,
							value: b
						});
						if (valA === valB) return 0;
						return valA > valB ? 1 : -1;
					},
					keyCreator: formatValue
				};
			},
			text() {
				return {};
			}
		};
	}
	wireBeans(beans) {
		this.colModel = beans.colModel;
	}
	postConstruct() {
		this.processDataTypeDefinitions();
		this.addManagedPropertyListener("dataTypeDefinitions", (event) => {
			this.processDataTypeDefinitions();
			this.colModel.recreateColumnDefs(event);
		});
	}
	processDataTypeDefinitions() {
		const defaultDataTypes = this.getDefaultDataTypes();
		const newDataTypeDefinitions = {};
		const newFormatValueFuncs = {};
		const generateFormatValueFunc = (dataTypeDefinition) => {
			return (params) => {
				const { column, node, value } = params;
				let valueFormatter = column.getColDef().valueFormatter;
				if (valueFormatter === dataTypeDefinition.groupSafeValueFormatter) valueFormatter = dataTypeDefinition.valueFormatter;
				return this.beans.valueSvc.formatValue(column, node, value, valueFormatter);
			};
		};
		for (const cellDataType of Object.keys(defaultDataTypes)) {
			const defaultDataTypeDef = defaultDataTypes[cellDataType];
			const mergedDataTypeDefinition = {
				...defaultDataTypeDef,
				groupSafeValueFormatter: createGroupSafeValueFormatter(defaultDataTypeDef, this.gos)
			};
			newDataTypeDefinitions[cellDataType] = mergedDataTypeDefinition;
			newFormatValueFuncs[cellDataType] = generateFormatValueFunc(mergedDataTypeDefinition);
		}
		const userDataTypeDefs = this.gos.get("dataTypeDefinitions") ?? {};
		const newDataTypeMatchers = {};
		for (const cellDataType of Object.keys(userDataTypeDefs)) {
			const userDataTypeDef = userDataTypeDefs[cellDataType];
			const mergedDataTypeDefinition = this.processDataTypeDefinition(userDataTypeDef, userDataTypeDefs, [cellDataType], defaultDataTypes);
			if (mergedDataTypeDefinition) {
				newDataTypeDefinitions[cellDataType] = mergedDataTypeDefinition;
				if (userDataTypeDef.dataTypeMatcher) newDataTypeMatchers[cellDataType] = userDataTypeDef.dataTypeMatcher;
				newFormatValueFuncs[cellDataType] = generateFormatValueFunc(mergedDataTypeDefinition);
			}
		}
		const { valueParser: defaultValueParser, valueFormatter: defaultValueFormatter } = defaultDataTypes.object;
		const { valueParser: userValueParser, valueFormatter: userValueFormatter } = newDataTypeDefinitions.object;
		this.hasObjectValueParser = userValueParser !== defaultValueParser;
		this.hasObjectValueFormatter = userValueFormatter !== defaultValueFormatter;
		this.formatValueFuncs = newFormatValueFuncs;
		this.dataTypeDefinitions = newDataTypeDefinitions;
		this.dataTypeMatchers = this.sortKeysInMatchers(newDataTypeMatchers, defaultDataTypes);
	}
	sortKeysInMatchers(matchers, dataTypes) {
		const sortedMatchers = { ...matchers };
		for (const cellDataType of SORTED_CELL_DATA_TYPES_FOR_MATCHING) {
			delete sortedMatchers[cellDataType];
			sortedMatchers[cellDataType] = matchers[cellDataType] ?? dataTypes[cellDataType].dataTypeMatcher;
		}
		return sortedMatchers;
	}
	processDataTypeDefinition(userDataTypeDef, userDataTypeDefs, alreadyProcessedDataTypes, defaultDataTypes) {
		let mergedDataTypeDefinition;
		const extendsCellDataType = userDataTypeDef.extendsDataType;
		if (userDataTypeDef.columnTypes) this.isColumnTypeOverrideInDataTypeDefinitions = true;
		if (userDataTypeDef.extendsDataType === userDataTypeDef.baseDataType) {
			let baseDataTypeDefinition = defaultDataTypes[extendsCellDataType];
			const overriddenBaseDataTypeDefinition = userDataTypeDefs[extendsCellDataType];
			if (baseDataTypeDefinition && overriddenBaseDataTypeDefinition) baseDataTypeDefinition = overriddenBaseDataTypeDefinition;
			if (!validateDataTypeDefinition(userDataTypeDef, baseDataTypeDefinition, extendsCellDataType)) return;
			mergedDataTypeDefinition = mergeDataTypeDefinitions(baseDataTypeDefinition, userDataTypeDef);
		} else {
			if (alreadyProcessedDataTypes.includes(extendsCellDataType)) {
				_warn(44);
				return;
			}
			const extendedDataTypeDefinition = userDataTypeDefs[extendsCellDataType];
			if (!validateDataTypeDefinition(userDataTypeDef, extendedDataTypeDefinition, extendsCellDataType)) return;
			const mergedExtendedDataTypeDefinition = this.processDataTypeDefinition(extendedDataTypeDefinition, userDataTypeDefs, [...alreadyProcessedDataTypes, extendsCellDataType], defaultDataTypes);
			if (!mergedExtendedDataTypeDefinition) return;
			mergedDataTypeDefinition = mergeDataTypeDefinitions(mergedExtendedDataTypeDefinition, userDataTypeDef);
		}
		return {
			...mergedDataTypeDefinition,
			groupSafeValueFormatter: createGroupSafeValueFormatter(mergedDataTypeDefinition, this.gos)
		};
	}
	updateColDefAndGetColumnType(colDef, userColDef, colId) {
		let { cellDataType } = userColDef;
		const { field } = userColDef;
		if (cellDataType === void 0) cellDataType = colDef.cellDataType;
		if (cellDataType == null || cellDataType === true) cellDataType = this.canInferCellDataType(colDef, userColDef) ? this.inferCellDataType(field, colId) : false;
		if (!cellDataType) {
			colDef.cellDataType = false;
			return;
		}
		const dataTypeDefinition = this.dataTypeDefinitions[cellDataType];
		if (!dataTypeDefinition) {
			_warn(47, { cellDataType });
			return;
		}
		colDef.cellDataType = cellDataType;
		if (dataTypeDefinition.groupSafeValueFormatter) colDef.valueFormatter = dataTypeDefinition.groupSafeValueFormatter;
		if (dataTypeDefinition.valueParser) colDef.valueParser = dataTypeDefinition.valueParser;
		if (!dataTypeDefinition.suppressDefaultProperties) this.setColDefPropertiesForBaseDataType(colDef, cellDataType, dataTypeDefinition, colId);
		return dataTypeDefinition.columnTypes;
	}
	addColumnListeners(column) {
		if (!this.isPendingInference) return;
		const columnStateUpdates = this.columnStateUpdatesPendingInference[column.getColId()];
		if (!columnStateUpdates) return;
		const columnListener = (event) => {
			columnStateUpdates.add(event.key);
		};
		column.__addEventListener("columnStateUpdated", columnListener);
		this.columnStateUpdateListenerDestroyFuncs.push(() => column.__removeEventListener("columnStateUpdated", columnListener));
	}
	canInferCellDataType(colDef, userColDef) {
		const { gos } = this;
		if (!_isClientSideRowModel(gos)) return false;
		const propsToCheckForInference = {
			cellRenderer: true,
			valueGetter: true,
			valueParser: true,
			refData: true
		};
		if (doColDefPropsPreventInference(userColDef, propsToCheckForInference)) return false;
		const columnTypes = userColDef.type === null ? colDef.type : userColDef.type;
		if (columnTypes) {
			const columnTypeDefs = gos.get("columnTypes") ?? {};
			if (convertColumnTypes(columnTypes).some((columnType) => {
				const columnTypeDef = columnTypeDefs[columnType.trim()];
				return columnTypeDef && doColDefPropsPreventInference(columnTypeDef, propsToCheckForInference);
			})) return false;
		}
		return !doColDefPropsPreventInference(colDef, propsToCheckForInference);
	}
	inferCellDataType(field, colId) {
		if (!field) return;
		let value;
		const initialData = this.getInitialData();
		if (initialData) value = _getValueUsingField(initialData, field, field.indexOf(".") >= 0 && !this.gos.get("suppressFieldDotNotation"));
		else this.initWaitForRowData(colId);
		if (value == null) return;
		return Object.keys(this.dataTypeMatchers).find((_cellDataType) => this.dataTypeMatchers[_cellDataType](value)) ?? "object";
	}
	getInitialData() {
		const rowData = this.gos.get("rowData");
		if (rowData?.length) return rowData[0];
		else if (this.initialData) return this.initialData;
		else {
			const rowNodes = this.beans.rowModel.rootNode?.allLeafChildren;
			if (rowNodes?.length) return rowNodes[0].data;
		}
		return null;
	}
	initWaitForRowData(colId) {
		this.columnStateUpdatesPendingInference[colId] = /* @__PURE__ */ new Set();
		if (this.isPendingInference) return;
		this.isPendingInference = true;
		const columnTypeOverridesExist = this.isColumnTypeOverrideInDataTypeDefinitions;
		const { colAutosize, eventSvc } = this.beans;
		if (columnTypeOverridesExist && colAutosize) colAutosize.shouldQueueResizeOperations = true;
		const [destroyFunc] = this.addManagedEventListeners({ rowDataUpdateStarted: (event) => {
			const { firstRowData } = event;
			if (!firstRowData) return;
			destroyFunc?.();
			this.isPendingInference = false;
			this.processColumnsPendingInference(firstRowData, columnTypeOverridesExist);
			this.columnStateUpdatesPendingInference = {};
			if (columnTypeOverridesExist) colAutosize?.processResizeOperations();
			eventSvc.dispatchEvent({ type: "dataTypesInferred" });
		} });
	}
	processColumnsPendingInference(firstRowData, columnTypeOverridesExist) {
		this.initialData = firstRowData;
		const state = [];
		this.destroyColumnStateUpdateListeners();
		const newRowGroupColumnStateWithoutIndex = {};
		const newPivotColumnStateWithoutIndex = {};
		for (const colId of Object.keys(this.columnStateUpdatesPendingInference)) {
			const columnStateUpdates = this.columnStateUpdatesPendingInference[colId];
			const column = this.colModel.getCol(colId);
			if (!column) return;
			const oldColDef = column.getColDef();
			if (!this.resetColDefIntoCol(column, "cellDataTypeInferred")) return;
			const newColDef = column.getColDef();
			if (columnTypeOverridesExist && newColDef.type && newColDef.type !== oldColDef.type) {
				const updatedColumnState = getUpdatedColumnState(column, columnStateUpdates);
				if (updatedColumnState.rowGroup && updatedColumnState.rowGroupIndex == null) newRowGroupColumnStateWithoutIndex[colId] = updatedColumnState;
				if (updatedColumnState.pivot && updatedColumnState.pivotIndex == null) newPivotColumnStateWithoutIndex[colId] = updatedColumnState;
				state.push(updatedColumnState);
			}
		}
		if (columnTypeOverridesExist) state.push(...this.generateColumnStateForRowGroupAndPivotIndexes(newRowGroupColumnStateWithoutIndex, newPivotColumnStateWithoutIndex));
		if (state.length) _applyColumnState(this.beans, { state }, "cellDataTypeInferred");
		this.initialData = null;
	}
	generateColumnStateForRowGroupAndPivotIndexes(updatedRowGroupColumnState, updatedPivotColumnState) {
		const existingColumnStateUpdates = {};
		const { rowGroupColsSvc, pivotColsSvc } = this.beans;
		rowGroupColsSvc?.restoreColumnOrder(existingColumnStateUpdates, updatedRowGroupColumnState);
		pivotColsSvc?.restoreColumnOrder(existingColumnStateUpdates, updatedPivotColumnState);
		return Object.values(existingColumnStateUpdates);
	}
	resetColDefIntoCol(column, source) {
		const userColDef = column.getUserProvidedColDef();
		if (!userColDef) return false;
		const newColDef = _addColumnDefaultAndTypes(this.beans, userColDef, column.getColId());
		column.setColDef(newColDef, userColDef, source);
		return true;
	}
	getDateStringTypeDefinition(column) {
		const { dateString } = this.dataTypeDefinitions;
		if (!column) return dateString;
		return this.getDataTypeDefinition(column) ?? dateString;
	}
	getDateParserFunction(column) {
		return this.getDateStringTypeDefinition(column).dateParser;
	}
	getDateFormatterFunction(column) {
		return this.getDateStringTypeDefinition(column).dateFormatter;
	}
	getDateIncludesTimeFlag(cellDataType) {
		return cellDataType === "dateTime" || cellDataType === "dateTimeString";
	}
	getDataTypeDefinition(column) {
		const colDef = column.getColDef();
		if (!colDef.cellDataType) return;
		return this.dataTypeDefinitions[colDef.cellDataType];
	}
	getBaseDataType(column) {
		return this.getDataTypeDefinition(column)?.baseDataType;
	}
	checkType(column, value) {
		if (value == null) return true;
		const dataTypeMatcher = this.getDataTypeDefinition(column)?.dataTypeMatcher;
		if (!dataTypeMatcher) return true;
		return dataTypeMatcher(value);
	}
	validateColDef(colDef) {
		const warning = (property) => _warn(48, { property });
		if (colDef.cellDataType === "object") {
			const { object } = this.dataTypeDefinitions;
			if (colDef.valueFormatter === object.groupSafeValueFormatter && !this.hasObjectValueFormatter) warning("Formatter");
			if (colDef.editable && colDef.valueParser === object.valueParser && !this.hasObjectValueParser) warning("Parser");
		}
	}
	postProcess(colDef) {
		const cellDataType = colDef.cellDataType;
		if (!cellDataType || typeof cellDataType !== "string") return;
		const { dataTypeDefinitions, beans, formatValueFuncs } = this;
		const dataTypeDefinition = dataTypeDefinitions[cellDataType];
		beans.colFilter?.setColDefPropsForDataType(colDef, dataTypeDefinition, formatValueFuncs[cellDataType]);
	}
	getFormatValue(cellDataType) {
		return this.formatValueFuncs[cellDataType];
	}
	isColPendingInference(colId) {
		return this.isPendingInference && !!this.columnStateUpdatesPendingInference[colId];
	}
	setColDefPropertiesForBaseDataType(colDef, cellDataType, dataTypeDefinition, colId) {
		const formatValue = this.formatValueFuncs[cellDataType];
		const partialColDef = this.columnDefinitionPropsPerDataType[dataTypeDefinition.baseDataType]({
			colDef,
			cellDataType,
			colModel: this.colModel,
			dataTypeDefinition,
			colId,
			formatValue
		});
		Object.assign(colDef, partialColDef);
	}
	getDateObjectTypeDef(baseDataType) {
		const translate = this.getLocaleTextFunc();
		const includeTime = this.getDateIncludesTimeFlag(baseDataType);
		return {
			baseDataType,
			valueParser: (params) => _parseDateTimeFromString(params.newValue && String(params.newValue)),
			valueFormatter: (params) => {
				if (params.value == null) return "";
				if (!(params.value instanceof Date) || isNaN(params.value.getTime())) return translate("invalidDate", "Invalid Date");
				return _serialiseDate(params.value, includeTime) ?? "";
			},
			dataTypeMatcher: (value) => value instanceof Date
		};
	}
	getDateStringTypeDef(baseDataType) {
		const includeTime = this.getDateIncludesTimeFlag(baseDataType);
		return {
			baseDataType,
			dateParser: (value) => _parseDateTimeFromString(value) ?? void 0,
			dateFormatter: (value) => _serialiseDate(value ?? null, includeTime) ?? void 0,
			valueParser: (params) => _isValidDate(String(params.newValue)) ? params.newValue : null,
			valueFormatter: (params) => _isValidDate(String(params.value)) ? String(params.value) : "",
			dataTypeMatcher: (value) => typeof value === "string" && _isValidDate(value)
		};
	}
	getDefaultDataTypes() {
		const translate = this.getLocaleTextFunc();
		return {
			number: {
				baseDataType: "number",
				valueParser: (params) => params.newValue?.trim?.() === "" ? null : Number(params.newValue),
				valueFormatter: (params) => {
					if (params.value == null) return "";
					if (typeof params.value !== "number" || isNaN(params.value)) return translate("invalidNumber", "Invalid Number");
					return String(params.value);
				},
				dataTypeMatcher: (value) => typeof value === "number"
			},
			text: {
				baseDataType: "text",
				valueParser: (params) => params.newValue === "" ? null : _toStringOrNull(params.newValue),
				dataTypeMatcher: (value) => typeof value === "string"
			},
			boolean: {
				baseDataType: "boolean",
				valueParser: (params) => {
					if (params.newValue == null) return params.newValue;
					return params.newValue?.trim?.() === "" ? null : String(params.newValue).toLowerCase() === "true";
				},
				valueFormatter: (params) => params.value == null ? "" : String(params.value),
				dataTypeMatcher: (value) => typeof value === "boolean"
			},
			date: this.getDateObjectTypeDef("date"),
			dateString: this.getDateStringTypeDef("dateString"),
			dateTime: this.getDateObjectTypeDef("dateTime"),
			dateTimeString: {
				...this.getDateStringTypeDef("dateTimeString"),
				dataTypeMatcher: (value) => typeof value === "string" && _isValidDateTime(value)
			},
			object: {
				baseDataType: "object",
				valueParser: () => null,
				valueFormatter: (params) => _toStringOrNull(params.value) ?? ""
			}
		};
	}
	destroyColumnStateUpdateListeners() {
		this.columnStateUpdateListenerDestroyFuncs.forEach((destroyFunc) => destroyFunc());
		this.columnStateUpdateListenerDestroyFuncs = [];
	}
	destroy() {
		this.dataTypeDefinitions = {};
		this.dataTypeMatchers = {};
		this.formatValueFuncs = {};
		this.columnStateUpdatesPendingInference = {};
		this.destroyColumnStateUpdateListeners();
		super.destroy();
	}
};
function mergeDataTypeDefinitions(parentDataTypeDefinition, childDataTypeDefinition) {
	const mergedDataTypeDefinition = {
		...parentDataTypeDefinition,
		...childDataTypeDefinition
	};
	if (parentDataTypeDefinition.columnTypes && childDataTypeDefinition.columnTypes && childDataTypeDefinition.appendColumnTypes) mergedDataTypeDefinition.columnTypes = [...convertColumnTypes(parentDataTypeDefinition.columnTypes), ...convertColumnTypes(childDataTypeDefinition.columnTypes)];
	return mergedDataTypeDefinition;
}
function validateDataTypeDefinition(dataTypeDefinition, parentDataTypeDefinition, parentCellDataType) {
	if (!parentDataTypeDefinition) {
		_warn(45, { parentCellDataType });
		return false;
	}
	if (parentDataTypeDefinition.baseDataType !== dataTypeDefinition.baseDataType) {
		_warn(46);
		return false;
	}
	return true;
}
function createGroupSafeValueFormatter(dataTypeDefinition, gos) {
	if (!dataTypeDefinition.valueFormatter) return;
	return (params) => {
		if (params.node?.group) {
			const aggFunc = (params.colDef.pivotValueColumn ?? params.column).getAggFunc();
			if (aggFunc) {
				if (aggFunc === "first" || aggFunc === "last") return dataTypeDefinition.valueFormatter(params);
				if (dataTypeDefinition.baseDataType === "number" && aggFunc !== "count") {
					if (typeof params.value === "number") return dataTypeDefinition.valueFormatter(params);
					if (typeof params.value === "object") {
						if (!params.value) return;
						if ("toNumber" in params.value) return dataTypeDefinition.valueFormatter({
							...params,
							value: params.value.toNumber()
						});
						if ("value" in params.value) return dataTypeDefinition.valueFormatter({
							...params,
							value: params.value.value
						});
					}
				}
				return;
			}
		} else if (gos.get("groupHideOpenParents") && params.column.isRowGroupActive()) {
			if (typeof params.value === "string" && !dataTypeDefinition.dataTypeMatcher?.(params.value)) return;
		}
		return dataTypeDefinition.valueFormatter(params);
	};
}
function doesColDefPropPreventInference(colDef, checkProps, prop, comparisonValue) {
	if (!checkProps[prop]) return false;
	const value = colDef[prop];
	if (value === null) {
		checkProps[prop] = false;
		return false;
	} else return comparisonValue === void 0 ? !!value : value === comparisonValue;
}
function doColDefPropsPreventInference(colDef, propsToCheckForInference) {
	return [
		["cellRenderer", "agSparklineCellRenderer"],
		["valueGetter", void 0],
		["valueParser", void 0],
		["refData", void 0]
	].some(([prop, comparisonValue]) => doesColDefPropPreventInference(colDef, propsToCheckForInference, prop, comparisonValue));
}
function getUpdatedColumnState(column, columnStateUpdates) {
	const columnState = getColumnStateFromColDef(column);
	columnStateUpdates.forEach((key) => {
		delete columnState[key];
		if (key === "rowGroup") delete columnState.rowGroupIndex;
		else if (key === "pivot") delete columnState.pivotIndex;
	});
	return columnState;
}
var DataTypeModule = {
	moduleName: "DataType",
	version: VERSION,
	beans: [DataTypeService],
	dependsOn: [CheckboxCellRendererModule]
};
var ColumnFlexModule = {
	moduleName: "ColumnFlex",
	version: VERSION,
	beans: [ColumnFlexService]
};
var ColumnApiModule = {
	moduleName: "ColumnApi",
	version: VERSION,
	beans: [ColumnDefFactory],
	apiFunctions: {
		getColumnDef,
		getDisplayNameForColumn,
		getColumn,
		getColumns,
		applyColumnState,
		getColumnState,
		resetColumnState,
		isPinning,
		isPinningLeft,
		isPinningRight,
		getDisplayedColAfter,
		getDisplayedColBefore,
		setColumnsVisible,
		setColumnsPinned,
		getAllGridColumns,
		getDisplayedLeftColumns,
		getDisplayedCenterColumns,
		getDisplayedRightColumns,
		getAllDisplayedColumns,
		getAllDisplayedVirtualColumns,
		getColumnDefs
	}
};
function _camelCaseToHumanText(camelCase) {
	if (!camelCase || camelCase == null) return null;
	return camelCase.replace(/([a-z])([A-Z])/g, "$1 $2").replace(/([A-Z]+)([A-Z])([a-z])/g, "$1 $2$3").replace(/\./g, " ").split(" ").map((word) => word.substring(0, 1).toUpperCase() + (word.length > 1 ? word.substring(1, word.length) : "")).join(" ");
}
var ColumnNameService = class extends BeanStub {
	constructor() {
		super(...arguments);
		this.beanName = "colNames";
	}
	getDisplayNameForColumn(column, location, includeAggFunc = false) {
		if (!column) return null;
		const headerName = this.getHeaderName(column.getColDef(), column, null, null, location);
		const { aggColNameSvc } = this.beans;
		if (includeAggFunc && aggColNameSvc) return aggColNameSvc.getHeaderName(column, headerName);
		return headerName;
	}
	getDisplayNameForProvidedColumnGroup(columnGroup, providedColumnGroup, location) {
		const colGroupDef = providedColumnGroup?.getColGroupDef();
		if (colGroupDef) return this.getHeaderName(colGroupDef, null, columnGroup, providedColumnGroup, location);
		return null;
	}
	getDisplayNameForColumnGroup(columnGroup, location) {
		return this.getDisplayNameForProvidedColumnGroup(columnGroup, columnGroup.getProvidedColumnGroup(), location);
	}
	getHeaderName(colDef, column, columnGroup, providedColumnGroup, location) {
		const headerValueGetter = colDef.headerValueGetter;
		if (headerValueGetter) {
			const params = _addGridCommonParams(this.gos, {
				colDef,
				column,
				columnGroup,
				providedColumnGroup,
				location
			});
			if (typeof headerValueGetter === "function") return headerValueGetter(params);
			else if (typeof headerValueGetter === "string") return this.beans.expressionSvc?.evaluate(headerValueGetter, params) ?? null;
			return "";
		} else if (colDef.headerName != null) return colDef.headerName;
		else if (colDef.field) return _camelCaseToHumanText(colDef.field);
		return "";
	}
};
var ColumnViewportService = class extends BeanStub {
	constructor() {
		super(...arguments);
		this.beanName = "colViewport";
		this.colsWithinViewport = [];
		this.headerColsWithinViewport = [];
		this.colsWithinViewportHash = "";
		this.rowsOfHeadersToRenderLeft = {};
		this.rowsOfHeadersToRenderRight = {};
		this.rowsOfHeadersToRenderCenter = {};
		this.columnsToRenderLeft = [];
		this.columnsToRenderRight = [];
		this.columnsToRenderCenter = [];
	}
	wireBeans(beans) {
		this.visibleCols = beans.visibleCols;
		this.colModel = beans.colModel;
	}
	postConstruct() {
		this.suppressColumnVirtualisation = this.gos.get("suppressColumnVirtualisation");
	}
	setScrollPosition(scrollWidth, scrollPosition, afterScroll = false) {
		const { visibleCols } = this;
		const bodyWidthDirty = visibleCols.isBodyWidthDirty;
		if (scrollWidth === this.scrollWidth && scrollPosition === this.scrollPosition && !bodyWidthDirty) return;
		this.scrollWidth = scrollWidth;
		this.scrollPosition = scrollPosition;
		visibleCols.isBodyWidthDirty = true;
		if (this.gos.get("enableRtl")) {
			const bodyWidth = visibleCols.bodyWidth;
			this.viewportLeft = bodyWidth - scrollPosition - scrollWidth;
			this.viewportRight = bodyWidth - scrollPosition;
		} else {
			this.viewportLeft = scrollPosition;
			this.viewportRight = scrollWidth + scrollPosition;
		}
		if (this.colModel.ready) this.checkViewportColumns(afterScroll);
	}
	getColumnHeadersToRender(type) {
		switch (type) {
			case "left": return this.columnsToRenderLeft;
			case "right": return this.columnsToRenderRight;
			default: return this.columnsToRenderCenter;
		}
	}
	getHeadersToRender(type, depth) {
		let result;
		switch (type) {
			case "left":
				result = this.rowsOfHeadersToRenderLeft[depth];
				break;
			case "right":
				result = this.rowsOfHeadersToRenderRight[depth];
				break;
			default:
				result = this.rowsOfHeadersToRenderCenter[depth];
				break;
		}
		return result ?? [];
	}
	extractViewportColumns() {
		const displayedColumnsCenter = this.visibleCols.centerCols;
		if (this.isColumnVirtualisationSuppressed()) {
			this.colsWithinViewport = displayedColumnsCenter;
			this.headerColsWithinViewport = displayedColumnsCenter;
		} else {
			this.colsWithinViewport = displayedColumnsCenter.filter(this.isColumnInRowViewport.bind(this));
			this.headerColsWithinViewport = displayedColumnsCenter.filter(this.isColumnInHeaderViewport.bind(this));
		}
	}
	isColumnVirtualisationSuppressed() {
		return this.suppressColumnVirtualisation || this.viewportRight === 0;
	}
	clear() {
		this.rowsOfHeadersToRenderLeft = {};
		this.rowsOfHeadersToRenderRight = {};
		this.rowsOfHeadersToRenderCenter = {};
		this.colsWithinViewportHash = "";
	}
	isColumnInHeaderViewport(col) {
		if (col.isAutoHeaderHeight() || isAnyParentAutoHeaderHeight(col)) return true;
		return this.isColumnInRowViewport(col);
	}
	isColumnInRowViewport(col) {
		if (col.isAutoHeight()) return true;
		const columnLeft = col.getLeft() || 0;
		const columnRight = columnLeft + col.getActualWidth();
		const leftBounds = this.viewportLeft - 200;
		const rightBounds = this.viewportRight + 200;
		return !(columnLeft < leftBounds && columnRight < leftBounds) && !(columnLeft > rightBounds && columnRight > rightBounds);
	}
	getViewportColumns() {
		const { leftCols, rightCols } = this.visibleCols;
		return this.colsWithinViewport.concat(leftCols).concat(rightCols);
	}
	getColsWithinViewport(rowNode) {
		if (!this.colModel.colSpanActive) return this.colsWithinViewport;
		const emptySpaceBeforeColumn = (col) => {
			const left = col.getLeft();
			return _exists(left) && left > this.viewportLeft;
		};
		const inViewportCallback = this.isColumnVirtualisationSuppressed() ? void 0 : this.isColumnInRowViewport.bind(this);
		const { visibleCols } = this;
		const displayedColumnsCenter = visibleCols.centerCols;
		return visibleCols.getColsForRow(rowNode, displayedColumnsCenter, inViewportCallback, emptySpaceBeforeColumn);
	}
	checkViewportColumns(afterScroll = false) {
		if (this.extractViewport()) this.eventSvc.dispatchEvent({
			type: "virtualColumnsChanged",
			afterScroll
		});
	}
	calculateHeaderRows() {
		const { leftCols, rightCols } = this.visibleCols;
		this.columnsToRenderLeft = leftCols;
		this.columnsToRenderRight = rightCols;
		this.columnsToRenderCenter = this.colsWithinViewport;
		const workOutGroupsToRender = (cols) => {
			const groupsToRenderSet = /* @__PURE__ */ new Set();
			const groupsToRender = {};
			for (const col of cols) {
				let group = col.getParent();
				const skipFillers = col.isSpanHeaderHeight();
				while (group) {
					if (groupsToRenderSet.has(group)) break;
					if (skipFillers && group.isPadding()) {
						group = group.getParent();
						continue;
					}
					const level = group.getProvidedColumnGroup().getLevel();
					groupsToRender[level] ?? (groupsToRender[level] = []);
					groupsToRender[level].push(group);
					groupsToRenderSet.add(group);
					group = group.getParent();
				}
			}
			return groupsToRender;
		};
		this.rowsOfHeadersToRenderLeft = workOutGroupsToRender(leftCols);
		this.rowsOfHeadersToRenderRight = workOutGroupsToRender(rightCols);
		this.rowsOfHeadersToRenderCenter = workOutGroupsToRender(this.headerColsWithinViewport);
	}
	extractViewport() {
		const hashColumn = (c) => `${c.getId()}-${c.getPinned() || "normal"}`;
		this.extractViewportColumns();
		const newHash = this.getViewportColumns().map(hashColumn).join("#");
		const changed = this.colsWithinViewportHash !== newHash;
		if (changed) {
			this.colsWithinViewportHash = newHash;
			this.calculateHeaderRows();
		}
		return changed;
	}
};
function isAnyParentAutoHeaderHeight(col) {
	while (col) {
		if (col.isAutoHeaderHeight()) return true;
		col = col.getParent();
	}
	return false;
}
var AgComponentUtils = class extends BeanStub {
	constructor() {
		super(...arguments);
		this.beanName = "agCompUtils";
	}
	adaptFunction(type, jsCompFunc) {
		if (!type.cellRenderer) return null;
		class Adapter {
			refresh() {
				return false;
			}
			getGui() {
				return this.eGui;
			}
			init(params) {
				const callbackResult = jsCompFunc(params);
				const type2 = typeof callbackResult;
				if (type2 === "string" || type2 === "number" || type2 === "boolean") {
					this.eGui = _loadTemplate("<span>" + callbackResult + "</span>");
					return;
				}
				if (callbackResult == null) {
					this.eGui = _createElement({ tag: "span" });
					return;
				}
				this.eGui = callbackResult;
			}
		}
		return Adapter;
	}
};
var CellRendererFunctionModule = {
	moduleName: "CellRendererFunction",
	version: VERSION,
	beans: [AgComponentUtils]
};
var Registry = class extends BeanStub {
	constructor() {
		super(...arguments);
		this.beanName = "registry";
		this.agGridDefaults = {};
		this.agGridDefaultOverrides = {};
		this.jsComps = {};
		this.selectors = {};
		this.icons = {};
	}
	postConstruct() {
		const comps = this.gos.get("components");
		if (comps != null) for (const key of Object.keys(comps)) this.jsComps[key] = comps[key];
	}
	registerModule(module) {
		const { icons, userComponents, dynamicBeans, selectors } = module;
		if (userComponents) {
			const registerUserComponent = (name, component, params, processParams) => {
				this.agGridDefaults[name] = component;
				if (params || processParams) this.agGridDefaultOverrides[name] = {
					params,
					processParams
				};
			};
			for (const name of Object.keys(userComponents)) {
				let comp = userComponents[name];
				if (isComponentMetaFunc(comp)) comp = comp.getComp(this.beans);
				if (typeof comp === "object") {
					const { classImp, params, processParams } = comp;
					registerUserComponent(name, classImp, params, processParams);
				} else registerUserComponent(name, comp);
			}
		}
		if (dynamicBeans) {
			this.dynamicBeans ?? (this.dynamicBeans = {});
			for (const name of Object.keys(dynamicBeans)) this.dynamicBeans[name] = dynamicBeans[name];
		}
		selectors?.forEach((selector) => {
			this.selectors[selector.selector] = selector;
		});
		if (icons) for (const name of Object.keys(icons)) this.icons[name] = icons[name];
	}
	getUserComponent(propertyName, name) {
		const createResult = (component, componentFromFramework, params, processParams) => ({
			componentFromFramework,
			component,
			params,
			processParams
		});
		const { frameworkOverrides } = this.beans;
		const registeredViaFrameworkComp = frameworkOverrides.frameworkComponent(name, this.gos.get("components"));
		if (registeredViaFrameworkComp != null) return createResult(registeredViaFrameworkComp, true);
		const jsComponent = this.jsComps[name];
		if (jsComponent) return createResult(jsComponent, frameworkOverrides.isFrameworkComponent(jsComponent));
		const defaultComponent = this.agGridDefaults[name];
		if (defaultComponent) {
			const overrides = this.agGridDefaultOverrides[name];
			return createResult(defaultComponent, false, overrides?.params, overrides?.processParams);
		}
		this.beans.validation?.missingUserComponent(propertyName, name, this.agGridDefaults, this.jsComps);
		return null;
	}
	createDynamicBean(name, mandatory, ...args) {
		if (!this.dynamicBeans) throw new Error(_errMsg(279, { name }));
		const BeanClass = this.dynamicBeans[name];
		if (BeanClass == null) {
			if (mandatory) throw new Error(this.beans.validation?.missingDynamicBean(name) ?? _errMsg(256));
			return;
		}
		return new BeanClass(...args);
	}
	getSelector(name) {
		return this.selectors[name];
	}
	getIcon(name) {
		return this.icons[name];
	}
};
var NUM_CTRLS = 23;
var CtrlsService = class extends BeanStub {
	constructor() {
		super(...arguments);
		this.beanName = "ctrlsSvc";
		this.params = {};
		this.ready = false;
		this.readyCallbacks = [];
	}
	postConstruct() {
		this.addEventListener("ready", () => {
			this.updateReady();
			if (this.ready) {
				this.readyCallbacks.forEach((c) => c(this.params));
				this.readyCallbacks.length = 0;
			}
		}, this.beans.frameworkOverrides.runWhenReadyAsync?.() ?? false);
	}
	updateReady() {
		const values = Object.values(this.params);
		this.ready = values.length === NUM_CTRLS && values.every((ctrl) => {
			return ctrl?.isAlive() ?? false;
		});
	}
	whenReady(caller, callback) {
		if (this.ready) callback(this.params);
		else this.readyCallbacks.push(callback);
		caller.addDestroyFunc(() => {
			const index = this.readyCallbacks.indexOf(callback);
			if (index >= 0) this.readyCallbacks.splice(index, 1);
		});
	}
	register(ctrlType, ctrl) {
		this.params[ctrlType] = ctrl;
		this.updateReady();
		if (this.ready) this.dispatchLocalEvent({ type: "ready" });
		ctrl.addDestroyFunc(() => {
			this.updateReady();
		});
	}
	get(ctrlType) {
		return this.params[ctrlType];
	}
	getGridBodyCtrl() {
		return this.params.gridBodyCtrl;
	}
	getHeaderRowContainerCtrls() {
		const { leftHeader, centerHeader, rightHeader } = this.params;
		return [
			leftHeader,
			rightHeader,
			centerHeader
		];
	}
	getHeaderRowContainerCtrl(pinned) {
		const params = this.params;
		switch (pinned) {
			case "left": return params.leftHeader;
			case "right": return params.rightHeader;
			default: return params.centerHeader;
		}
	}
	getScrollFeature() {
		return this.getGridBodyCtrl().scrollFeature;
	}
};
var coreCSS = `:where(.ag-root-wrapper,.ag-popup,.ag-dnd-ghost,.ag-chart),:where(.ag-root-wrapper,.ag-popup,.ag-dnd-ghost,.ag-chart) :where([class^=ag-]){box-sizing:border-box;&:after,&:before{box-sizing:border-box}&:where(div,span,label):focus-visible{box-shadow:inset var(--ag-focus-shadow);outline:none;&:where(.invalid){box-shadow:inset var(--ag-focus-error-shadow)}}&:where(button){color:inherit}}:where(.ag-root-wrapper,.ag-popup,.ag-dnd-ghost,.ag-chart) :where([class^=ag-]) ::-ms-clear{display:none}.ag-aria-description-container{border:0;z-index:9999;clip:rect(1px,1px,1px,1px);height:1px;overflow:hidden;padding:0;position:absolute;white-space:nowrap;width:1px}.ag-hidden{display:none!important}.ag-invisible{visibility:hidden!important}.ag-unselectable{-webkit-user-select:none;-moz-user-select:none;user-select:none}.ag-selectable{-webkit-user-select:text;-moz-user-select:text;user-select:text}.ag-tab-guard{display:block;height:0;position:absolute;width:0}:where(.ag-virtual-list-viewport) .ag-tab-guard{position:sticky}.ag-tab-guard-top{top:1px}.ag-tab-guard-bottom{bottom:1px}.ag-shake-left-to-right{animation-direction:alternate;animation-duration:.2s;animation-iteration-count:infinite;animation-name:ag-shake-left-to-right}@keyframes ag-shake-left-to-right{0%{padding-left:6px;padding-right:2px}to{padding-left:2px;padding-right:6px}}.ag-body-horizontal-scroll-viewport,.ag-body-vertical-scroll-viewport,.ag-body-viewport,.ag-center-cols-viewport,.ag-floating-bottom-viewport,.ag-floating-top-viewport,.ag-header-viewport,.ag-sticky-bottom-viewport,.ag-sticky-top-viewport,.ag-virtual-list-viewport{flex:1 1 auto;height:100%;min-width:0;overflow:hidden;position:relative}.ag-viewport{position:relative}.ag-spanning-container{position:absolute;top:0;z-index:1}.ag-body-viewport,.ag-center-cols-viewport,.ag-floating-bottom-viewport,.ag-floating-top-viewport,.ag-header-viewport,.ag-sticky-bottom-viewport,.ag-sticky-top-viewport{overflow-x:auto;-ms-overflow-style:none!important;scrollbar-width:none!important;&::-webkit-scrollbar{display:none!important}}.ag-body-viewport{display:flex;overflow-x:hidden;&:where(.ag-layout-normal){overflow-y:auto;-webkit-overflow-scrolling:touch}}.ag-floating-bottom-container,.ag-floating-top-container,.ag-sticky-bottom-container,.ag-sticky-top-container{min-height:1px}.ag-center-cols-viewport{min-height:100%;width:100%}.ag-body-horizontal-scroll-viewport{overflow-x:scroll}.ag-body-vertical-scroll-viewport{overflow-y:scroll}.ag-virtual-list-viewport{overflow:auto;width:100%}.ag-body-container,.ag-body-horizontal-scroll-container,.ag-body-vertical-scroll-container,.ag-center-cols-container,.ag-floating-bottom-container,.ag-floating-bottom-full-width-container,.ag-floating-top-container,.ag-full-width-container,.ag-header-container,.ag-pinned-left-cols-container,.ag-pinned-right-cols-container,.ag-sticky-bottom-container,.ag-sticky-top-container,.ag-virtual-list-container{position:relative}.ag-floating-bottom-container,.ag-floating-top-container,.ag-header-container,.ag-pinned-left-floating-bottom,.ag-pinned-left-floating-top,.ag-pinned-right-floating-bottom,.ag-pinned-right-floating-top,.ag-sticky-bottom-container,.ag-sticky-top-container{height:100%;white-space:nowrap}.ag-center-cols-container,.ag-pinned-right-cols-container{display:block}.ag-body-horizontal-scroll-container{height:100%}.ag-body-vertical-scroll-container{width:100%}.ag-floating-bottom-full-width-container,.ag-floating-top-full-width-container,.ag-full-width-container,.ag-sticky-bottom-full-width-container,.ag-sticky-top-full-width-container{pointer-events:none;position:absolute;top:0}:where(.ag-ltr) .ag-floating-bottom-full-width-container,:where(.ag-ltr) .ag-floating-top-full-width-container,:where(.ag-ltr) .ag-full-width-container,:where(.ag-ltr) .ag-sticky-bottom-full-width-container,:where(.ag-ltr) .ag-sticky-top-full-width-container{left:0}:where(.ag-rtl) .ag-floating-bottom-full-width-container,:where(.ag-rtl) .ag-floating-top-full-width-container,:where(.ag-rtl) .ag-full-width-container,:where(.ag-rtl) .ag-sticky-bottom-full-width-container,:where(.ag-rtl) .ag-sticky-top-full-width-container{right:0}.ag-full-width-container{width:100%}.ag-floating-bottom-full-width-container,.ag-floating-top-full-width-container{display:inline-block;height:100%;overflow:hidden;width:100%}.ag-virtual-list-container{overflow:hidden}.ag-body{display:flex;flex:1 1 auto;flex-direction:row!important;min-height:0;position:relative}.ag-body-horizontal-scroll,.ag-body-vertical-scroll{display:flex;min-height:0;min-width:0;position:relative;&:where(.ag-scrollbar-invisible){bottom:0;position:absolute;&:where(.ag-apple-scrollbar){opacity:0;transition:opacity .4s;visibility:hidden;&:where(.ag-scrollbar-scrolling,.ag-scrollbar-active){opacity:1;visibility:visible}}}}.ag-body-horizontal-scroll{width:100%;&:where(.ag-scrollbar-invisible){left:0;right:0}}.ag-body-vertical-scroll{height:100%;&:where(.ag-scrollbar-invisible){top:0;z-index:10}}:where(.ag-ltr) .ag-body-vertical-scroll{&:where(.ag-scrollbar-invisible){right:0}}:where(.ag-rtl) .ag-body-vertical-scroll{&:where(.ag-scrollbar-invisible){left:0}}.ag-force-vertical-scroll{overflow-y:scroll!important}.ag-horizontal-left-spacer,.ag-horizontal-right-spacer{height:100%;min-width:0;overflow-x:scroll;&:where(.ag-scroller-corner){overflow-x:hidden}}:where(.ag-row-animation) .ag-row{transition:transform .4s,top .4s,opacity .2s;&:where(.ag-after-created){transition:transform .4s,top .4s,height .4s,opacity .2s}}:where(.ag-row-animation.ag-prevent-animation) .ag-row{transition:none!important;&:where(.ag-row.ag-after-created){transition:none!important}}:where(.ag-row-no-animation) .ag-row{transition:none}.ag-row-loading{align-items:center;display:flex}.ag-row-position-absolute{position:absolute}.ag-row-position-relative{position:relative}.ag-full-width-row{overflow:hidden;pointer-events:all}.ag-row-inline-editing{z-index:1}.ag-row-dragging{z-index:2}.ag-stub-cell{align-items:center;display:flex}.ag-cell{display:inline-block;height:100%;position:absolute;white-space:nowrap;&:focus-visible{box-shadow:none}}.ag-cell-value{flex:1 1 auto}.ag-cell-value,.ag-group-value{overflow:hidden;text-overflow:ellipsis}.ag-cell-wrap-text{white-space:normal;word-break:break-word}:where(.ag-cell) .ag-icon{display:inline-block;vertical-align:middle}.ag-floating-top{display:flex;overflow:hidden;position:relative;white-space:nowrap;width:100%}:where(.ag-floating-top:not(.ag-invisible)){border-bottom:var(--ag-pinned-row-border)}.ag-floating-bottom{display:flex;overflow:hidden;position:relative;white-space:nowrap;width:100%}:where(.ag-floating-bottom:not(.ag-invisible)){border-top:var(--ag-pinned-row-border)}.ag-sticky-bottom,.ag-sticky-top{background-color:var(--ag-background-color);display:flex;height:0;overflow:hidden;position:absolute;width:100%;z-index:1}.ag-opacity-zero{opacity:0!important}.ag-cell-label-container{align-items:center;display:flex;flex-direction:row-reverse;height:100%;justify-content:space-between;width:100%}:where(.ag-right-aligned-header){.ag-cell-label-container{flex-direction:row}.ag-header-cell-text{text-align:end}}.ag-column-group-icons{display:block;>*{cursor:pointer}}:where(.ag-ltr){direction:ltr;.ag-body,.ag-body-horizontal-scroll,.ag-body-viewport,.ag-floating-bottom,.ag-floating-top,.ag-header,.ag-sticky-bottom,.ag-sticky-top{flex-direction:row}}:where(.ag-rtl){direction:rtl;text-align:right;.ag-body,.ag-body-horizontal-scroll,.ag-body-viewport,.ag-floating-bottom,.ag-floating-top,.ag-header,.ag-sticky-bottom,.ag-sticky-top{flex-direction:row-reverse}.ag-icon-contracted,.ag-icon-expanded,.ag-icon-tree-closed{display:block}}:where(.ag-rtl){.ag-icon-contracted,.ag-icon-expanded,.ag-icon-tree-closed{transform:rotate(180deg)}}:where(.ag-rtl){.ag-icon-contracted,.ag-icon-expanded,.ag-icon-tree-closed{transform:rotate(-180deg)}}.ag-measurement-container{height:0;overflow:hidden;visibility:hidden;width:0}.ag-measurement-element-border{display:inline-block;&:before{border-left:var(--ag-internal-measurement-border);content:"";display:block}}.ag-group{position:relative;width:100%}.ag-group-title-bar{align-items:center;display:flex;padding:var(--ag-spacing)}.ag-group-title{display:inline;min-width:0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}:where(.ag-group-title-bar) .ag-group-title{cursor:default}.ag-group-toolbar{align-items:center;display:flex;padding:var(--ag-spacing)}.ag-group-container{display:flex}.ag-disabled .ag-group-container{pointer-events:none}.ag-disabled-group-container,.ag-disabled-group-title-bar{opacity:.5}.ag-group-container-horizontal{flex-flow:row wrap}.ag-group-container-vertical{flex-direction:column}.ag-group-title-bar-icon{cursor:pointer;flex:none}:where(.ag-ltr) .ag-group-title-bar-icon{margin-right:var(--ag-spacing)}:where(.ag-rtl) .ag-group-title-bar-icon{margin-left:var(--ag-spacing)}:where(.ag-group-item-alignment-stretch) .ag-group-item{align-items:stretch}:where(.ag-group-item-alignment-start) .ag-group-item{align-items:flex-start}:where(.ag-group-item-alignment-end) .ag-group-item{align-items:flex-end}.ag-popup-child{top:0;z-index:5;&:where(:not(.ag-tooltip-custom)){box-shadow:var(--ag-popup-shadow)}}.ag-popup-editor{position:absolute;-webkit-user-select:none;-moz-user-select:none;user-select:none}.ag-large-text-input{display:block}:where(.ag-ltr) .ag-row:not(.ag-row-level-0) .ag-pivot-leaf-group{margin-left:var(--ag-row-group-indent-size)}:where(.ag-rtl) .ag-row:not(.ag-row-level-0) .ag-pivot-leaf-group{margin-right:var(--ag-row-group-indent-size)}:where(.ag-ltr) .ag-row-group-leaf-indent{margin-left:calc(var(--ag-cell-widget-spacing) + var(--ag-icon-size))}:where(.ag-rtl) .ag-row-group-leaf-indent{margin-right:calc(var(--ag-cell-widget-spacing) + var(--ag-icon-size))}.ag-value-change-delta{padding:0 2px}.ag-value-change-delta-up{color:var(--ag-value-change-delta-up-color)}.ag-value-change-delta-down{color:var(--ag-value-change-delta-down-color)}.ag-value-change-value{background-color:transparent;border-radius:1px;padding-left:1px;padding-right:1px;transition:background-color 1s}.ag-value-change-value-highlight{background-color:var(--ag-value-change-value-highlight-background-color);transition:background-color .1s}.ag-cell-data-changed{background-color:var(--ag-value-change-value-highlight-background-color)!important}.ag-cell-data-changed-animation{background-color:transparent}.ag-cell-highlight{background-color:var(--ag-range-selection-highlight-color)!important}.ag-row,.ag-spanned-row{color:var(--ag-cell-text-color);font-family:var(--ag-cell-font-family);font-size:var(--ag-data-font-size);white-space:nowrap;--ag-internal-content-line-height:calc(min(var(--ag-row-height), var(--ag-line-height, 1000px)) - var(--ag-internal-row-border-width, 1px) - 2px)}.ag-row{background-color:var(--ag-background-color);border-bottom:var(--ag-row-border);height:var(--ag-row-height);width:100%;&.ag-row-editing-invalid{background-color:var(--ag-full-row-edit-invalid-background-color)}}:where(.ag-body-vertical-content-no-gap>div>div>div,.ag-body-vertical-content-no-gap>div>div>div>div)>.ag-row-last{border-bottom-color:transparent}.ag-sticky-bottom{border-top:var(--ag-row-border);box-sizing:content-box!important}.ag-group-contracted,.ag-group-expanded{cursor:pointer}.ag-cell,.ag-full-width-row .ag-cell-wrapper.ag-row-group{border:1px solid transparent;line-height:var(--ag-internal-content-line-height);-webkit-font-smoothing:subpixel-antialiased}:where(.ag-ltr) .ag-cell{border-right:var(--ag-column-border)}:where(.ag-rtl) .ag-cell{border-left:var(--ag-column-border)}.ag-spanned-cell-wrapper{background-color:var(--ag-background-color);position:absolute}.ag-spanned-cell-wrapper>.ag-spanned-cell{display:block;position:relative}:where(.ag-ltr) :where(.ag-body-horizontal-content-no-gap) .ag-column-last{border-right-color:transparent}:where(.ag-rtl) :where(.ag-body-horizontal-content-no-gap) .ag-column-last{border-left-color:transparent}.ag-cell-wrapper{align-items:center;display:flex;>:where(:not(.ag-cell-value,.ag-group-value)){align-items:center;display:flex;height:var(--ag-internal-content-line-height)}&:where(.ag-row-group){align-items:flex-start}:where(.ag-full-width-row) &:where(.ag-row-group){align-items:center;height:100%}}:where(.ag-ltr) .ag-cell-wrapper{padding-left:calc(var(--ag-indentation-level)*var(--ag-row-group-indent-size))}:where(.ag-rtl) .ag-cell-wrapper{padding-right:calc(var(--ag-indentation-level)*var(--ag-row-group-indent-size))}:where(.ag-cell-wrap-text:not(.ag-cell-auto-height)) .ag-cell-wrapper{align-items:normal;height:100%;:where(.ag-cell-value){height:100%}}:where(.ag-ltr) .ag-row>.ag-cell-wrapper.ag-row-group{padding-left:calc(var(--ag-cell-horizontal-padding) + var(--ag-row-group-indent-size)*var(--ag-indentation-level))}:where(.ag-rtl) .ag-row>.ag-cell-wrapper.ag-row-group{padding-right:calc(var(--ag-cell-horizontal-padding) + var(--ag-row-group-indent-size)*var(--ag-indentation-level))}.ag-cell-focus:not(.ag-cell-range-selected):focus-within,.ag-cell-range-single-cell,.ag-cell-range-single-cell.ag-cell-range-handle,.ag-context-menu-open .ag-cell-focus:not(.ag-cell-range-selected),.ag-context-menu-open .ag-full-width-row.ag-row-focus .ag-cell-wrapper.ag-row-group,.ag-full-width-row.ag-row-focus:focus .ag-cell-wrapper.ag-row-group{border:1px solid;border-color:var(--ag-range-selection-border-color);border-style:var(--ag-range-selection-border-style);outline:initial}.ag-full-width-row.ag-row-focus:focus{box-shadow:none}:where(.ag-ltr) .ag-group-contracted,:where(.ag-ltr) .ag-group-expanded,:where(.ag-ltr) .ag-row-drag,:where(.ag-ltr) .ag-selection-checkbox{margin-right:var(--ag-cell-widget-spacing)}:where(.ag-rtl) .ag-group-contracted,:where(.ag-rtl) .ag-group-expanded,:where(.ag-rtl) .ag-row-drag,:where(.ag-rtl) .ag-selection-checkbox{margin-left:var(--ag-cell-widget-spacing)}:where(.ag-ltr) .ag-group-child-count{margin-left:3px}:where(.ag-rtl) .ag-group-child-count{margin-right:3px}.ag-row-highlight-above:after,.ag-row-highlight-below:after,.ag-row-highlight-inside:after{background-color:var(--ag-range-selection-border-color);content:"";height:1px;pointer-events:none;position:absolute;width:calc(100% - 1px)}:where(.ag-ltr) .ag-row-highlight-above:after,:where(.ag-ltr) .ag-row-highlight-below:after,:where(.ag-ltr) .ag-row-highlight-inside:after{left:1px}:where(.ag-rtl) .ag-row-highlight-above:after,:where(.ag-rtl) .ag-row-highlight-below:after,:where(.ag-rtl) .ag-row-highlight-inside:after{right:1px}.ag-row-highlight-above:after{top:0}.ag-row-highlight-below:after{bottom:0}.ag-row-highlight-indent:after{display:block;width:auto}:where(.ag-ltr) .ag-row-highlight-indent:after{left:calc((var(--ag-cell-widget-spacing) + var(--ag-icon-size))*2 + var(--ag-cell-horizontal-padding) + var(--ag-row-highlight-level)*var(--ag-row-group-indent-size));right:1px}:where(.ag-rtl) .ag-row-highlight-indent:after{left:1px;right:calc((var(--ag-cell-widget-spacing) + var(--ag-icon-size))*2 + var(--ag-cell-horizontal-padding) + var(--ag-row-highlight-level)*var(--ag-row-group-indent-size))}.ag-row-highlight-inside:after{background-color:var(--ag-selected-row-background-color);border:1px solid var(--ag-range-selection-border-color);display:block;height:auto;inset:0;width:auto}.ag-row-odd{background-color:var(--ag-odd-row-background-color)}.ag-row-selected:before{background-color:var(--ag-selected-row-background-color);content:"";display:block;inset:0;pointer-events:none;position:absolute}.ag-row-hover.ag-full-width-row.ag-row-group:before,.ag-row-hover:not(.ag-full-width-row):before{background-color:var(--ag-row-hover-color);content:"";display:block;inset:0;pointer-events:none;position:absolute}.ag-row-hover.ag-row-selected:before{background-color:var(--ag-row-hover-color);background-image:linear-gradient(var(--ag-selected-row-background-color),var(--ag-selected-row-background-color))}.ag-row.ag-full-width-row.ag-row-group>*{position:relative}.ag-column-hover{background-color:var(--ag-column-hover-color)}.ag-header-range-highlight{background-color:var(--ag-range-header-highlight-color)}.ag-right-aligned-cell{font-variant-numeric:tabular-nums}:where(.ag-ltr) .ag-right-aligned-cell{text-align:right}:where(.ag-rtl) .ag-right-aligned-cell{text-align:left}.ag-right-aligned-cell .ag-cell-value,.ag-right-aligned-cell .ag-group-value{margin-left:auto}:where(.ag-ltr) .ag-cell:not(.ag-cell-inline-editing),:where(.ag-ltr) .ag-full-width-row .ag-cell-wrapper.ag-row-group{padding-left:calc(var(--ag-cell-horizontal-padding) - 1px + var(--ag-row-group-indent-size)*var(--ag-indentation-level));padding-right:calc(var(--ag-cell-horizontal-padding) - 1px)}:where(.ag-rtl) .ag-cell:not(.ag-cell-inline-editing),:where(.ag-rtl) .ag-full-width-row .ag-cell-wrapper.ag-row-group{padding-left:calc(var(--ag-cell-horizontal-padding) - 1px);padding-right:calc(var(--ag-cell-horizontal-padding) - 1px + var(--ag-row-group-indent-size)*var(--ag-indentation-level))}.ag-row>.ag-cell-wrapper{padding-left:calc(var(--ag-cell-horizontal-padding) - 1px);padding-right:calc(var(--ag-cell-horizontal-padding) - 1px)}.ag-row-dragging{cursor:move;opacity:.5}.ag-details-row{background-color:var(--ag-background-color);padding:calc(var(--ag-spacing)*3.75)}.ag-layout-auto-height,.ag-layout-print{.ag-center-cols-container,.ag-center-cols-viewport{min-height:150px}}.ag-overlay-loading-wrapper{background-color:var(--ag-modal-overlay-background-color)}.ag-skeleton-container{align-content:center;height:100%;width:100%}.ag-skeleton-effect{animation:ag-skeleton-loading 1.5s ease-in-out .5s infinite;background-color:var(--ag-row-loading-skeleton-effect-color);border-radius:.25rem;height:1em;width:100%}:where(.ag-ltr) .ag-right-aligned-cell .ag-skeleton-effect{margin-left:auto}:where(.ag-rtl) .ag-right-aligned-cell .ag-skeleton-effect{margin-right:auto}@keyframes ag-skeleton-loading{0%{background-color:var(--ag-row-loading-skeleton-effect-color)}50%{background-color:color-mix(in srgb,transparent,var(--ag-row-loading-skeleton-effect-color) 40%)}to{background-color:var(--ag-row-loading-skeleton-effect-color)}}.ag-loading{align-items:center;display:flex;height:100%}:where(.ag-ltr) .ag-loading{padding-left:var(--ag-cell-horizontal-padding)}:where(.ag-rtl) .ag-loading{padding-right:var(--ag-cell-horizontal-padding)}:where(.ag-ltr) .ag-loading-icon{padding-right:var(--ag-cell-widget-spacing)}:where(.ag-rtl) .ag-loading-icon{padding-left:var(--ag-cell-widget-spacing)}.ag-icon-loading{animation-duration:1s;animation-iteration-count:infinite;animation-name:spin;animation-timing-function:linear}@keyframes spin{0%{transform:rotate(0deg)}to{transform:rotate(1turn)}}.ag-input-wrapper,.ag-picker-field-wrapper{align-items:center;display:flex;flex:1 1 auto;line-height:normal;position:relative}.ag-input-field{align-items:center;display:flex;flex-direction:row}.ag-input-field-input:where(:not([type=checkbox],[type=radio])){flex:1 1 auto;min-width:0;width:100%}.ag-header{background-color:var(--ag-header-background-color);border-bottom:var(--ag-header-row-border);color:var(--ag-header-text-color);display:flex;font-family:var(--ag-header-font-family);font-size:var(--ag-header-font-size);font-weight:var(--ag-header-font-weight);overflow:hidden;white-space:nowrap;width:100%}.ag-header-row{height:var(--ag-header-height);position:absolute}.ag-floating-filter-button-button,.ag-header-cell-filter-button,.ag-header-cell-menu-button,.ag-header-expand-icon,.ag-panel-title-bar-button,:where(.ag-header-cell-sortable) .ag-header-cell-label{cursor:pointer}:where(.ag-ltr) .ag-header-expand-icon{margin-left:4px}:where(.ag-rtl) .ag-header-expand-icon{margin-right:4px}.ag-header-row:where(:not(:first-child)){:where(.ag-header-cell:not(.ag-header-span-height.ag-header-span-total,.ag-header-parent-hidden),.ag-header-group-cell.ag-header-group-cell-with-group){border-top:var(--ag-header-row-border)}}.ag-header-row:where(:not(.ag-header-row-column-group)){overflow:hidden}:where(.ag-header.ag-header-allow-overflow) .ag-header-row{overflow:visible}.ag-header-cell{display:inline-flex;overflow:hidden}.ag-header-group-cell{contain:paint;display:flex}.ag-header-cell,.ag-header-group-cell{align-items:center;gap:var(--ag-cell-widget-spacing);height:100%;padding:0 var(--ag-cell-horizontal-padding);position:absolute}@property --ag-internal-moving-color{syntax:"<color>";inherits:false;initial-value:transparent}@property --ag-internal-hover-color{syntax:"<color>";inherits:false;initial-value:transparent}.ag-header-cell:where(:not(.ag-floating-filter)),.ag-header-group-cell{&:before{background-image:linear-gradient(var(--ag-internal-hover-color),var(--ag-internal-hover-color)),linear-gradient(var(--ag-internal-moving-color),var(--ag-internal-moving-color));content:"";inset:0;position:absolute;--ag-internal-moving-color:transparent;--ag-internal-hover-color:transparent;transition:--ag-internal-moving-color var(--ag-header-cell-background-transition-duration),--ag-internal-hover-color var(--ag-header-cell-background-transition-duration)}&:where(:hover):before{--ag-internal-hover-color:var(--ag-header-cell-hover-background-color)}&:where(.ag-header-cell-moving):before{--ag-internal-moving-color:var(--ag-header-cell-moving-background-color);--ag-internal-hover-color:var(--ag-header-cell-hover-background-color)}}:where(.ag-header-cell:not(.ag-floating-filter) *,.ag-header-group-cell *){position:relative;z-index:1}.ag-header-cell-menu-button:where(:not(.ag-header-menu-always-show)){opacity:0;transition:opacity .2s}.ag-header-cell-filter-button,:where(.ag-header-cell.ag-header-active) .ag-header-cell-menu-button{opacity:1}.ag-header-cell-label,.ag-header-group-cell-label{align-items:center;align-self:stretch;display:flex;flex:1 1 auto;overflow:hidden;padding:5px 0}:where(.ag-ltr) .ag-sort-indicator-icon{padding-left:var(--ag-spacing)}:where(.ag-rtl) .ag-sort-indicator-icon{padding-right:var(--ag-spacing)}.ag-header-cell-label{text-overflow:ellipsis}.ag-header-group-cell-label.ag-sticky-label{flex:none;max-width:100%;overflow:visible;position:sticky}:where(.ag-ltr) .ag-header-group-cell-label.ag-sticky-label{left:var(--ag-cell-horizontal-padding)}:where(.ag-rtl) .ag-header-group-cell-label.ag-sticky-label{right:var(--ag-cell-horizontal-padding)}.ag-header-cell-text,.ag-header-group-text{overflow:hidden;text-overflow:ellipsis}.ag-header-cell-text{word-break:break-word}.ag-header-cell-comp-wrapper{width:100%}:where(.ag-header-group-cell) .ag-header-cell-comp-wrapper{display:flex}:where(.ag-header-cell:not(.ag-header-cell-auto-height)) .ag-header-cell-comp-wrapper{align-items:center;display:flex;height:100%}.ag-header-cell-wrap-text .ag-header-cell-comp-wrapper{white-space:normal}.ag-header-cell-comp-wrapper-limited-height>*{overflow:hidden}:where(.ag-right-aligned-header) .ag-header-cell-label{flex-direction:row-reverse}:where(.ag-ltr) :where(.ag-header-cell:not(.ag-right-aligned-header)){.ag-header-label-icon,.ag-header-menu-icon{margin-left:var(--ag-spacing)}}:where(.ag-rtl) :where(.ag-header-cell:not(.ag-right-aligned-header)){.ag-header-label-icon,.ag-header-menu-icon{margin-right:var(--ag-spacing)}}:where(.ag-ltr) :where(.ag-header-cell.ag-right-aligned-header){.ag-header-label-icon,.ag-header-menu-icon{margin-right:var(--ag-spacing)}}:where(.ag-rtl) :where(.ag-header-cell.ag-right-aligned-header){.ag-header-label-icon,.ag-header-menu-icon{margin-left:var(--ag-spacing)}}.ag-header-cell:after,.ag-header-group-cell:where(:not(.ag-header-span-height.ag-header-group-cell-no-group)):after{content:"";height:var(--ag-header-column-border-height);position:absolute;top:calc(50% - var(--ag-header-column-border-height)*.5);z-index:1}:where(.ag-ltr) .ag-header-cell:after,:where(.ag-ltr) .ag-header-group-cell:where(:not(.ag-header-span-height.ag-header-group-cell-no-group)):after{border-right:var(--ag-header-column-border);right:0}:where(.ag-rtl) .ag-header-cell:after,:where(.ag-rtl) .ag-header-group-cell:where(:not(.ag-header-span-height.ag-header-group-cell-no-group)):after{border-left:var(--ag-header-column-border);left:0}.ag-header-highlight-after:after,.ag-header-highlight-before:after{background-color:var(--ag-accent-color);content:"";height:100%;position:absolute;width:1px}:where(.ag-ltr) .ag-header-highlight-before:after{left:0}:where(.ag-rtl) .ag-header-highlight-before:after{right:0}:where(.ag-ltr) .ag-header-highlight-after:after{right:0;:where(.ag-pinned-left-header) &{right:1px}}:where(.ag-rtl) .ag-header-highlight-after:after{left:0;:where(.ag-pinned-left-header) &{left:1px}}.ag-header-cell-resize{align-items:center;cursor:ew-resize;display:flex;height:100%;position:absolute;top:0;width:8px;z-index:2;&:after{background-color:var(--ag-header-column-resize-handle-color);content:"";height:var(--ag-header-column-resize-handle-height);position:absolute;top:calc(50% - var(--ag-header-column-resize-handle-height)*.5);width:var(--ag-header-column-resize-handle-width);z-index:1}}:where(.ag-ltr) .ag-header-cell-resize{right:-3px;&:after{left:calc(50% - var(--ag-header-column-resize-handle-width))}}:where(.ag-rtl) .ag-header-cell-resize{left:-3px;&:after{right:calc(50% - var(--ag-header-column-resize-handle-width))}}:where(.ag-header-cell.ag-header-span-height) .ag-header-cell-resize:after{height:calc(100% - var(--ag-spacing)*4);top:calc(var(--ag-spacing)*2)}.ag-header-group-cell-no-group:where(.ag-header-span-height){display:none}.ag-sort-indicator-container{display:flex;gap:var(--ag-spacing)}.ag-layout-print{&.ag-body{display:block;height:unset}&.ag-root-wrapper{display:inline-block}.ag-body-horizontal-scroll,.ag-body-vertical-scroll{display:none}&.ag-force-vertical-scroll{overflow-y:visible!important}}@media print{.ag-root-wrapper.ag-layout-print{display:table;.ag-body-horizontal-scroll-viewport,.ag-body-viewport,.ag-center-cols-container,.ag-center-cols-viewport,.ag-root,.ag-root-wrapper-body,.ag-virtual-list-viewport{display:block!important;height:auto!important;overflow:hidden!important}.ag-cell,.ag-row{-moz-column-break-inside:avoid;break-inside:avoid}}}ag-grid,ag-grid-angular{display:block}.ag-chart,.ag-dnd-ghost,.ag-popup,.ag-root-wrapper{cursor:default;line-height:normal;white-space:normal;-webkit-font-smoothing:antialiased;background-color:var(--ag-background-color);color:var(--ag-text-color);color-scheme:var(--ag-browser-color-scheme);font-family:var(--ag-font-family);font-size:var(--ag-font-size);--ag-indentation-level:0}.ag-root-wrapper{border:var(--ag-wrapper-border);border-radius:var(--ag-wrapper-border-radius);display:flex;flex-direction:column;overflow:hidden;position:relative;&.ag-layout-normal{height:100%}}.ag-root-wrapper-body{display:flex;flex-direction:row;&.ag-layout-normal{flex:1 1 auto;height:0;min-height:0}}.ag-root{display:flex;flex-direction:column;position:relative;&.ag-layout-auto-height,&.ag-layout-normal{flex:1 1 auto;overflow:hidden;width:0}&.ag-layout-normal{height:100%}}.ag-list-item,.ag-virtual-list-item{height:var(--ag-list-item-height)}.ag-virtual-list-item{position:absolute;width:100%}.ag-select-list{background-color:var(--ag-picker-list-background-color);border:var(--ag-picker-list-border);border-radius:var(--ag-border-radius);box-shadow:var(--ag-dropdown-shadow);overflow:hidden auto}.ag-list-item{align-items:center;display:flex;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;&.ag-active-item{background-color:var(--ag-row-hover-color)}}.ag-select-list-item{cursor:default;-webkit-user-select:none;-moz-user-select:none;user-select:none;:where(span){overflow:hidden;text-overflow:ellipsis;white-space:nowrap}}:where(.ag-ltr) .ag-select-list-item{padding-left:calc(var(--ag-cell-horizontal-padding)/2)}:where(.ag-rtl) .ag-select-list-item{padding-right:calc(var(--ag-cell-horizontal-padding)/2)}.ag-list-item-hovered:after{background-color:var(--ag-accent-color);content:"";height:1px;left:0;position:absolute;right:0}.ag-item-highlight-top:after{top:0}.ag-item-highlight-bottom:after{bottom:0}:where(.ag-icon):before{align-items:center;background-color:currentcolor;color:inherit;content:"";display:flex;font-family:inherit;font-size:var(--ag-icon-size);font-style:normal;font-variant:normal;height:var(--ag-icon-size);justify-content:center;line-height:var(--ag-icon-size);-webkit-mask-size:contain;mask-size:contain;text-transform:none;width:var(--ag-icon-size)}.ag-icon{background-position:50%;background-repeat:no-repeat;background-size:contain;color:var(--ag-icon-color);display:block;height:var(--ag-icon-size);position:relative;-webkit-user-select:none;-moz-user-select:none;user-select:none;width:var(--ag-icon-size)}.ag-column-select-column-group-readonly,.ag-column-select-column-readonly,.ag-disabled,[disabled]{.ag-icon{opacity:.5}&.ag-icon-grip{opacity:.35}}.ag-column-select-column-readonly{&.ag-icon-grip,.ag-icon-grip{opacity:.35}}.ag-drag-handle{color:var(--ag-drag-handle-color);cursor:grab;:where(.ag-icon){color:var(--ag-drag-handle-color)}}.ag-chart-menu-icon,.ag-chart-settings-next,.ag-chart-settings-prev,.ag-column-group-icons,.ag-column-select-header-icon,.ag-filter-toolpanel-expand,.ag-floating-filter-button-button,.ag-group-title-bar-icon,.ag-header-cell-filter-button,.ag-header-cell-menu-button,.ag-header-expand-icon,.ag-panel-title-bar-button,.ag-panel-title-bar-button-icon,.ag-set-filter-group-icons,:where(.ag-group-contracted) .ag-icon,:where(.ag-group-expanded) .ag-icon{background-color:var(--ag-icon-button-background-color);border-radius:var(--ag-icon-button-border-radius);box-shadow:0 0 0 var(--ag-icon-button-background-spread) var(--ag-icon-button-background-color);color:var(--ag-icon-button-color);&:hover{background-color:var(--ag-icon-button-hover-background-color);box-shadow:0 0 0 var(--ag-icon-button-background-spread) var(--ag-icon-button-hover-background-color);color:var(--ag-icon-button-hover-color)}}.ag-filter-active{background-image:linear-gradient(var(--ag-icon-button-active-background-color),var(--ag-icon-button-active-background-color));border-radius:1px;outline:solid var(--ag-icon-button-background-spread) var(--ag-icon-button-active-background-color);position:relative;&:after{background-color:var(--ag-icon-button-active-indicator-color);border-radius:50%;content:"";height:6px;position:absolute;top:-1px;width:6px}:where(.ag-icon-filter){clip-path:path("M8,0C8,4.415 11.585,8 16,8L16,16L0,16L0,0L8,0Z");color:var(--ag-icon-button-active-color)}}:where(.ag-ltr) .ag-filter-active{&:after{right:-1px}}:where(.ag-rtl) .ag-filter-active{&:after{left:-1px}}.ag-menu{background-color:var(--ag-menu-background-color);border:var(--ag-menu-border);border-radius:var(--ag-border-radius);box-shadow:var(--ag-menu-shadow);color:var(--ag-menu-text-color);max-height:100%;overflow-y:auto}.ag-menu,.ag-resizer{position:absolute;-webkit-user-select:none;-moz-user-select:none;user-select:none}.ag-resizer{pointer-events:none;z-index:1}:where(.ag-resizer){&.ag-resizer-topLeft{cursor:nwse-resize;height:5px;left:0;top:0;width:5px}&.ag-resizer-top{cursor:ns-resize;height:5px;left:5px;right:5px;top:0}&.ag-resizer-topRight{cursor:nesw-resize;height:5px;right:0;top:0;width:5px}&.ag-resizer-right{bottom:5px;cursor:ew-resize;right:0;top:5px;width:5px}&.ag-resizer-bottomRight{bottom:0;cursor:nwse-resize;height:5px;right:0;width:5px}&.ag-resizer-bottom{bottom:0;cursor:ns-resize;height:5px;left:5px;right:5px}&.ag-resizer-bottomLeft{bottom:0;cursor:nesw-resize;height:5px;left:0;width:5px}&.ag-resizer-left{bottom:5px;cursor:ew-resize;left:0;top:5px;width:5px}}`;
var IS_SSR = typeof window !== "object" || !window?.document?.fonts?.forEach;
var _injectGlobalCSS = (css, styleContainer, debugId, layer, priority, nonce) => {
	if (IS_SSR) return;
	if (FORCE_LEGACY_THEMES) return;
	if (layer) css = `@layer ${CSS.escape(layer)} { ${css} }`;
	let injections = injectionState.map.get(styleContainer);
	if (!injections) {
		injections = [];
		injectionState.map.set(styleContainer, injections);
	}
	if (injections.find((i) => i.css === css)) return;
	const el = document.createElement("style");
	if (nonce) el.setAttribute("nonce", nonce);
	el.dataset.agGlobalCss = debugId;
	el.textContent = css;
	const newInjection = {
		css,
		el,
		priority
	};
	let insertAfter;
	for (const injection of injections) {
		if (injection.priority > priority) break;
		insertAfter = injection;
	}
	if (insertAfter) {
		insertAfter.el.insertAdjacentElement("afterend", el);
		const index = injections.indexOf(insertAfter);
		injections.splice(index + 1, 0, newInjection);
	} else {
		styleContainer.insertBefore(el, styleContainer.querySelector(":not(title, meta)"));
		injections.push(newInjection);
	}
};
var _injectCoreAndModuleCSS = (styleContainer, layer, nonce) => {
	_injectGlobalCSS(coreCSS, styleContainer, "core", layer, 0, nonce);
	Array.from(_getAllRegisteredModules()).sort((a, b) => a.moduleName.localeCompare(b.moduleName)).forEach((module) => module.css?.forEach((css) => _injectGlobalCSS(css, styleContainer, `module-${module.moduleName}`, layer, 0, nonce)));
};
var _registerGridUsingThemingAPI = (environment) => {
	injectionState.grids.add(environment);
};
var _unregisterGridUsingThemingAPI = (environment) => {
	injectionState.grids.delete(environment);
	if (injectionState.grids.size === 0) {
		injectionState.map = /* @__PURE__ */ new WeakMap();
		for (const style of document.head.querySelectorAll("style[data-ag-global-css]")) style.remove();
	}
};
var _a;
var injectionState = (_a = typeof window === "object" ? window : {}).agStyleInjectionState ?? (_a.agStyleInjectionState = {
	map: /* @__PURE__ */ new WeakMap(),
	grids: /* @__PURE__ */ new Set()
});
var createPart = (args) => {
	return new PartImpl(args);
};
var defaultModeName = "$default";
var partCounter = 0;
var PartImpl = class {
	constructor({ feature, params, modeParams = {}, css, cssImports }) {
		this.feature = feature;
		this.css = css;
		this.cssImports = cssImports;
		this.modeParams = {
			[defaultModeName]: {
				...modeParams[defaultModeName] ?? {},
				...params ?? {}
			},
			...modeParams
		};
	}
	use(styleContainer, layer, nonce) {
		let inject = this._inject;
		if (inject == null) {
			let { css } = this;
			if (css) {
				const className = `ag-theme-${this.feature ?? "part"}-${++partCounter}`;
				if (typeof css === "function") css = css();
				css = `:where(.${className}) {
${css}
}
`;
				for (const cssImport of this.cssImports ?? []) css = `@import url(${JSON.stringify(cssImport)});
${css}`;
				inject = {
					css,
					class: className
				};
			} else inject = false;
			this._inject = inject;
		}
		if (inject && styleContainer) _injectGlobalCSS(inject.css, styleContainer, inject.class, layer, 1, nonce);
		return inject ? inject.class : false;
	}
};
var kebabCase = (str) => str.replace(/[A-Z]/g, (m) => `-${m}`).toLowerCase();
var paramToVariableName = (paramName) => `--ag-${kebabCase(paramName)}`;
var paramToVariableExpression = (paramName) => `var(${paramToVariableName(paramName)})`;
var clamp = (value, min, max) => Math.max(min, Math.min(max, value));
var memoize = (fn) => {
	const values = /* @__PURE__ */ new Map();
	return (a) => {
		const key = a;
		if (!values.has(key)) values.set(key, fn(a));
		return values.get(key);
	};
};
var accentMix = (mix) => ({
	ref: "accentColor",
	mix
});
var foregroundMix = (mix) => ({
	ref: "foregroundColor",
	mix
});
var foregroundBackgroundMix = (mix) => ({
	ref: "foregroundColor",
	mix,
	onto: "backgroundColor"
});
var foregroundHeaderBackgroundMix = (mix) => ({
	ref: "foregroundColor",
	mix,
	onto: "headerBackgroundColor"
});
var backgroundColor = { ref: "backgroundColor" };
var foregroundColor = { ref: "foregroundColor" };
var accentColor = { ref: "accentColor" };
var defaultLightColorSchemeParams = {
	backgroundColor: "#fff",
	foregroundColor: "#181d1f",
	borderColor: foregroundMix(.15),
	chromeBackgroundColor: foregroundBackgroundMix(.02),
	browserColorScheme: "light"
};
var coreDefaults = {
	...defaultLightColorSchemeParams,
	textColor: foregroundColor,
	accentColor: "#2196f3",
	invalidColor: "#e02525",
	wrapperBorder: true,
	rowBorder: true,
	headerRowBorder: true,
	footerRowBorder: { ref: "rowBorder" },
	columnBorder: {
		style: "solid",
		width: 1,
		color: "transparent"
	},
	headerColumnBorder: false,
	headerColumnBorderHeight: "100%",
	pinnedColumnBorder: true,
	pinnedRowBorder: true,
	sidePanelBorder: true,
	sideBarPanelWidth: 250,
	sideBarBackgroundColor: { ref: "chromeBackgroundColor" },
	sideButtonBarBackgroundColor: { ref: "sideBarBackgroundColor" },
	sideButtonBarTopPadding: 0,
	sideButtonSelectedUnderlineWidth: 2,
	sideButtonSelectedUnderlineColor: "transparent",
	sideButtonSelectedUnderlineTransitionDuration: 0,
	sideButtonBackgroundColor: "transparent",
	sideButtonTextColor: { ref: "textColor" },
	sideButtonHoverBackgroundColor: { ref: "sideButtonBackgroundColor" },
	sideButtonHoverTextColor: { ref: "sideButtonTextColor" },
	sideButtonSelectedBackgroundColor: backgroundColor,
	sideButtonSelectedTextColor: { ref: "sideButtonTextColor" },
	sideButtonBorder: "solid 1px transparent",
	sideButtonSelectedBorder: true,
	sideButtonLeftPadding: { ref: "spacing" },
	sideButtonRightPadding: { ref: "spacing" },
	sideButtonVerticalPadding: { calc: "spacing * 3" },
	fontFamily: [
		"-apple-system",
		"BlinkMacSystemFont",
		"Segoe UI",
		"Roboto",
		"Oxygen-Sans",
		"Ubuntu",
		"Cantarell",
		"Helvetica Neue",
		"sans-serif"
	],
	headerBackgroundColor: { ref: "chromeBackgroundColor" },
	headerFontFamily: { ref: "fontFamily" },
	cellFontFamily: { ref: "fontFamily" },
	headerFontWeight: 500,
	headerFontSize: { ref: "fontSize" },
	dataFontSize: { ref: "fontSize" },
	headerTextColor: { ref: "textColor" },
	headerCellHoverBackgroundColor: "transparent",
	headerCellMovingBackgroundColor: { ref: "headerCellHoverBackgroundColor" },
	headerCellBackgroundTransitionDuration: "0.2s",
	cellTextColor: { ref: "textColor" },
	subtleTextColor: {
		ref: "textColor",
		mix: .5
	},
	rangeSelectionBorderStyle: "solid",
	rangeSelectionBorderColor: accentColor,
	rangeSelectionBackgroundColor: accentMix(.2),
	rangeSelectionChartBackgroundColor: "#0058FF1A",
	rangeSelectionChartCategoryBackgroundColor: "#00FF841A",
	rangeSelectionHighlightColor: accentMix(.5),
	rangeHeaderHighlightColor: foregroundHeaderBackgroundMix(.08),
	rowNumbersSelectedColor: accentMix(.5),
	rowHoverColor: accentMix(.08),
	columnHoverColor: accentMix(.05),
	selectedRowBackgroundColor: accentMix(.12),
	modalOverlayBackgroundColor: {
		ref: "backgroundColor",
		mix: .66
	},
	oddRowBackgroundColor: backgroundColor,
	borderWidth: 1,
	borderRadius: 4,
	wrapperBorderRadius: 8,
	cellHorizontalPadding: { calc: "spacing * 2 * cellHorizontalPaddingScale" },
	cellWidgetSpacing: { calc: "spacing * 1.5" },
	cellHorizontalPaddingScale: 1,
	rowGroupIndentSize: { calc: "cellWidgetSpacing + iconSize" },
	valueChangeDeltaUpColor: "#43a047",
	valueChangeDeltaDownColor: "#e53935",
	valueChangeValueHighlightBackgroundColor: "#16a08580",
	spacing: 8,
	fontSize: 14,
	rowHeight: { calc: "max(iconSize, dataFontSize) + spacing * 3.25 * rowVerticalPaddingScale" },
	rowVerticalPaddingScale: 1,
	headerHeight: { calc: "max(iconSize, dataFontSize) + spacing * 4 * headerVerticalPaddingScale" },
	headerVerticalPaddingScale: 1,
	paginationPanelHeight: {
		ref: "rowHeight",
		calc: "max(rowHeight, 22px)"
	},
	popupShadow: "0 0 16px #00000026",
	cardShadow: "0 1px 4px 1px #00000018",
	dropdownShadow: { ref: "cardShadow" },
	dragAndDropImageBackgroundColor: backgroundColor,
	dragAndDropImageBorder: true,
	dragAndDropImageShadow: { ref: "popupShadow" },
	dragHandleColor: foregroundMix(.7),
	focusShadow: {
		spread: 3,
		color: accentMix(.5)
	},
	focusErrorShadow: {
		spread: 3,
		color: {
			ref: "invalidColor",
			onto: "backgroundColor",
			mix: .5
		}
	},
	headerColumnResizeHandleHeight: "30%",
	headerColumnResizeHandleWidth: 2,
	headerColumnResizeHandleColor: { ref: "borderColor" },
	widgetContainerHorizontalPadding: { calc: "spacing * 1.5" },
	widgetContainerVerticalPadding: { calc: "spacing * 1.5" },
	widgetHorizontalSpacing: { calc: "spacing * 1.5" },
	widgetVerticalSpacing: { ref: "spacing" },
	listItemHeight: { calc: "max(iconSize, dataFontSize) + widgetVerticalSpacing" },
	iconSize: 16,
	iconColor: "inherit",
	iconButtonColor: { ref: "iconColor" },
	iconButtonBackgroundColor: "transparent",
	iconButtonBackgroundSpread: 4,
	iconButtonBorderRadius: 1,
	iconButtonHoverColor: { ref: "iconButtonColor" },
	iconButtonHoverBackgroundColor: foregroundMix(.1),
	iconButtonActiveColor: accentColor,
	iconButtonActiveBackgroundColor: accentMix(.28),
	iconButtonActiveIndicatorColor: accentColor,
	toggleButtonWidth: 28,
	toggleButtonHeight: 18,
	toggleButtonOnBackgroundColor: accentColor,
	toggleButtonOffBackgroundColor: foregroundBackgroundMix(.3),
	toggleButtonSwitchBackgroundColor: backgroundColor,
	toggleButtonSwitchInset: 2,
	menuBorder: { color: foregroundMix(.2) },
	menuBackgroundColor: foregroundBackgroundMix(.03),
	menuTextColor: foregroundBackgroundMix(.95),
	menuShadow: { ref: "popupShadow" },
	menuSeparatorColor: { ref: "borderColor" },
	setFilterIndentSize: { ref: "iconSize" },
	chartMenuPanelWidth: 260,
	chartMenuLabelColor: foregroundMix(.8),
	dialogShadow: { ref: "popupShadow" },
	cellEditingBorder: { color: accentColor },
	cellEditingShadow: { ref: "cardShadow" },
	fullRowEditInvalidBackgroundColor: {
		ref: "invalidColor",
		onto: "backgroundColor",
		mix: .25
	},
	dialogBorder: { color: foregroundMix(.2) },
	panelBackgroundColor: backgroundColor,
	panelTitleBarBackgroundColor: { ref: "headerBackgroundColor" },
	panelTitleBarIconColor: { ref: "headerTextColor" },
	panelTitleBarTextColor: { ref: "headerTextColor" },
	panelTitleBarFontWeight: { ref: "headerFontWeight" },
	panelTitleBarBorder: true,
	columnSelectIndentSize: { ref: "iconSize" },
	toolPanelSeparatorBorder: true,
	tooltipBackgroundColor: { ref: "chromeBackgroundColor" },
	tooltipErrorBackgroundColor: {
		ref: "invalidColor",
		onto: "backgroundColor",
		mix: .1
	},
	tooltipTextColor: { ref: "textColor" },
	tooltipErrorTextColor: { ref: "invalidColor" },
	tooltipBorder: true,
	tooltipErrorBorder: { color: {
		ref: "invalidColor",
		onto: "backgroundColor",
		mix: .25
	} },
	columnDropCellBackgroundColor: foregroundMix(.07),
	columnDropCellTextColor: { ref: "textColor" },
	columnDropCellDragHandleColor: { ref: "textColor" },
	columnDropCellBorder: { color: foregroundMix(.13) },
	selectCellBackgroundColor: foregroundMix(.07),
	selectCellBorder: { color: foregroundMix(.13) },
	advancedFilterBuilderButtonBarBorder: true,
	advancedFilterBuilderIndentSize: { calc: "spacing * 2 + iconSize" },
	advancedFilterBuilderJoinPillColor: "#f08e8d",
	advancedFilterBuilderColumnPillColor: "#a6e194",
	advancedFilterBuilderOptionPillColor: "#f3c08b",
	advancedFilterBuilderValuePillColor: "#85c0e4",
	filterPanelApplyButtonColor: backgroundColor,
	filterPanelApplyButtonBackgroundColor: accentColor,
	filterPanelCardSubtleColor: {
		ref: "textColor",
		mix: .7
	},
	filterPanelCardSubtleHoverColor: { ref: "textColor" },
	findMatchColor: foregroundColor,
	findMatchBackgroundColor: "#ffff00",
	findActiveMatchColor: foregroundColor,
	findActiveMatchBackgroundColor: "#ffa500",
	filterToolPanelGroupIndent: { ref: "spacing" },
	rowLoadingSkeletonEffectColor: foregroundMix(.15),
	statusBarLabelColor: foregroundColor,
	statusBarLabelFontWeight: 500,
	statusBarValueColor: foregroundColor,
	statusBarValueFontWeight: 500,
	pinnedSourceRowTextColor: { ref: "textColor" },
	pinnedSourceRowBackgroundColor: { ref: "backgroundColor" },
	pinnedSourceRowFontWeight: 600,
	pinnedRowFontWeight: 600,
	pinnedRowBackgroundColor: { ref: "backgroundColor" },
	pinnedRowTextColor: { ref: "textColor" }
};
var batchEditStyleDefaultCSS = `.ag-cell-batch-edit{background-color:var(--ag-cell-batch-edit-background-color);color:var(--ag-cell-batch-edit-text-color);display:inherit}.ag-row-batch-edit{background-color:var(--ag-row-batch-edit-background-color);color:var(--ag-row-batch-edit-text-color)}`;
var baseParams = {
	cellBatchEditBackgroundColor: "rgba(220 181 139 / 16%)",
	cellBatchEditTextColor: "#422f00",
	rowBatchEditBackgroundColor: { ref: "cellBatchEditBackgroundColor" },
	rowBatchEditTextColor: { ref: "cellBatchEditTextColor" }
};
var baseDarkBatchEditParams = {
	...baseParams,
	cellBatchEditTextColor: "#f3d0b3"
};
var makeBatchEditStyleBaseTreeShakeable = () => createPart({
	feature: "batchEditStyle",
	params: baseParams,
	css: batchEditStyleDefaultCSS
});
var batchEditStyleBase = /* @__PURE__ */ makeBatchEditStyleBaseTreeShakeable();
var buttonStyleBaseCSS = `:where(.ag-button){background:none;border:none;color:inherit;cursor:pointer;font-family:inherit;font-size:inherit;font-weight:inherit;letter-spacing:inherit;line-height:inherit;margin:0;padding:0;text-indent:inherit;text-shadow:inherit;text-transform:inherit;word-spacing:inherit;&:disabled{cursor:default}&:focus-visible{box-shadow:var(--ag-focus-shadow);outline:none}}.ag-standard-button{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:var(--ag-button-background-color);border:var(--ag-button-border);border-radius:var(--ag-button-border-radius);color:var(--ag-button-text-color);cursor:pointer;font-weight:var(--ag-button-font-weight);padding:var(--ag-button-vertical-padding) var(--ag-button-horizontal-padding);&:hover{background-color:var(--ag-button-hover-background-color);border:var(--ag-button-hover-border);color:var(--ag-button-hover-text-color)}&:active{background-color:var(--ag-button-active-background-color);border:var(--ag-button-active-border);color:var(--ag-button-active-text-color)}&:disabled{background-color:var(--ag-button-disabled-background-color);border:var(--ag-button-disabled-border);color:var(--ag-button-disabled-text-color)}}`;
var baseParams2 = {
	buttonTextColor: "inherit",
	buttonFontWeight: "normal",
	buttonBackgroundColor: "transparent",
	buttonBorder: false,
	buttonBorderRadius: { ref: "borderRadius" },
	buttonHorizontalPadding: { calc: "spacing * 2" },
	buttonVerticalPadding: { ref: "spacing" },
	buttonHoverTextColor: { ref: "buttonTextColor" },
	buttonHoverBackgroundColor: { ref: "buttonBackgroundColor" },
	buttonHoverBorder: { ref: "buttonBorder" },
	buttonActiveTextColor: { ref: "buttonHoverTextColor" },
	buttonActiveBackgroundColor: { ref: "buttonHoverBackgroundColor" },
	buttonActiveBorder: { ref: "buttonHoverBorder" },
	buttonDisabledTextColor: { ref: "inputDisabledTextColor" },
	buttonDisabledBackgroundColor: { ref: "inputDisabledBackgroundColor" },
	buttonDisabledBorder: { ref: "inputDisabledBorder" }
};
var makeButtonStyleQuartzTreeShakeable = () => createPart({
	feature: "buttonStyle",
	params: {
		...baseParams2,
		buttonBackgroundColor: backgroundColor,
		buttonBorder: true,
		buttonHoverBackgroundColor: { ref: "rowHoverColor" },
		buttonActiveBorder: { color: accentColor }
	},
	css: buttonStyleBaseCSS
});
var buttonStyleQuartz = /* @__PURE__ */ makeButtonStyleQuartzTreeShakeable();
var columnDropStyleBorderedCSS = `.ag-column-drop-vertical-empty-message{align-items:center;border:dashed var(--ag-border-width);border-color:var(--ag-border-color);display:flex;inset:0;justify-content:center;margin:calc(var(--ag-spacing)*1.5) calc(var(--ag-spacing)*2);overflow:hidden;padding:calc(var(--ag-spacing)*2);position:absolute}`;
var makeColumnDropStyleBorderedTreeShakeable = () => {
	return createPart({
		feature: "columnDropStyle",
		css: columnDropStyleBorderedCSS
	});
};
var columnDropStyleBordered = /* @__PURE__ */ makeColumnDropStyleBorderedTreeShakeable();
var paramTypes = [
	"colorScheme",
	"color",
	"length",
	"scale",
	"borderStyle",
	"border",
	"shadow",
	"image",
	"fontFamily",
	"fontWeight",
	"duration"
];
var getParamType = memoize((param) => {
	param = param.toLowerCase();
	return paramTypes.find((type) => param.endsWith(type.toLowerCase())) ?? "length";
});
var literalToCSS = (value) => {
	if (typeof value === "object" && value?.ref) return paramToVariableExpression(value.ref);
	if (typeof value === "string") return value;
	if (typeof value === "number") return String(value);
	return false;
};
var colorValueToCss = (value) => {
	if (typeof value === "string") return value;
	if (value && "ref" in value) {
		const colorExpr = paramToVariableExpression(value.ref);
		if (value.mix == null) return colorExpr;
		return `color-mix(in srgb, ${value.onto ? paramToVariableExpression(value.onto) : "transparent"}, ${colorExpr} ${clamp(value.mix * 100, 0, 100)}%)`;
	}
	return false;
};
var colorSchemeValueToCss = literalToCSS;
var lengthValueToCss = (value) => {
	if (typeof value === "string") return value;
	if (typeof value === "number") return `${value}px`;
	if (value && "calc" in value) return `calc(${value.calc.replace(/ ?[*/+] ?/g, " $& ").replace(/-?\b[a-z][a-z0-9]*\b(?![-(])/gi, (p) => p[0] === "-" ? p : ` ${paramToVariableExpression(p)} `)})`;
	if (value && "ref" in value) return paramToVariableExpression(value.ref);
	return false;
};
var scaleValueToCss = literalToCSS;
var borderValueToCss = (value, param) => {
	if (typeof value === "string") return value;
	if (value === true) return borderValueToCss({}, param);
	if (value === false) return param === "columnBorder" ? borderValueToCss({ color: "transparent" }, param) : "none";
	if (value && "ref" in value) return paramToVariableExpression(value.ref);
	return borderStyleValueToCss(value.style ?? "solid") + " " + lengthValueToCss(value.width ?? { ref: "borderWidth" }) + " " + colorValueToCss(value.color ?? { ref: "borderColor" });
};
var shadowValueToCss = (value) => {
	if (typeof value === "string") return value;
	if (value === false) return "none";
	if (value && "ref" in value) return paramToVariableExpression(value.ref);
	return [
		lengthValueToCss(value.offsetX ?? 0),
		lengthValueToCss(value.offsetY ?? 0),
		lengthValueToCss(value.radius ?? 0),
		lengthValueToCss(value.spread ?? 0),
		colorValueToCss(value.color ?? { ref: "foregroundColor" })
	].join(" ");
};
var borderStyleValueToCss = literalToCSS;
var fontFamilyValueToCss = (value) => {
	if (typeof value === "string") return value.includes(",") ? value : quoteUnsafeChars(value);
	if (value && "googleFont" in value) return fontFamilyValueToCss(value.googleFont);
	if (value && "ref" in value) return paramToVariableExpression(value.ref);
	if (Array.isArray(value)) return value.map((font) => {
		if (typeof font === "object" && "googleFont" in font) font = font.googleFont;
		return quoteUnsafeChars(font);
	}).join(", ");
	return false;
};
var quoteUnsafeChars = (font) => /^[\w-]+$|\w\(/.test(font) ? font : JSON.stringify(font);
var fontWeightValueToCss = literalToCSS;
var imageValueToCss = (value) => {
	if (typeof value === "string") return value;
	if (value && "url" in value) return `url(${JSON.stringify(value.url)})`;
	if (value && "svg" in value) return imageValueToCss({ url: `data:image/svg+xml,${encodeURIComponent(value.svg)}` });
	if (value && "ref" in value) return paramToVariableExpression(value.ref);
	return false;
};
var durationValueToCss = (value, param) => {
	if (typeof value === "string") return value;
	if (typeof value === "number") {
		if (value >= 10) _error(104, {
			value,
			param
		});
		return `${value}s`;
	}
	if (value && "ref" in value) return paramToVariableExpression(value.ref);
	return false;
};
var paramValidators = {
	color: colorValueToCss,
	colorScheme: colorSchemeValueToCss,
	length: lengthValueToCss,
	scale: scaleValueToCss,
	border: borderValueToCss,
	borderStyle: borderStyleValueToCss,
	shadow: shadowValueToCss,
	image: imageValueToCss,
	fontFamily: fontFamilyValueToCss,
	fontWeight: fontWeightValueToCss,
	duration: durationValueToCss
};
var paramValueToCss = (param, value) => {
	return paramValidators[getParamType(param)](value, param);
};
var FORCE_LEGACY_THEMES = false;
var createTheme = () => new ThemeImpl().withPart(buttonStyleQuartz).withPart(columnDropStyleBordered).withPart(batchEditStyleBase);
var ThemeImpl = class _ThemeImpl {
	constructor(parts = []) {
		this.parts = parts;
	}
	withPart(part) {
		if (typeof part === "function") part = part();
		if (!(part instanceof PartImpl)) {
			_logPreInitErr(259, { part }, "Invalid part");
			return this;
		}
		return new _ThemeImpl([...this.parts, part]);
	}
	withoutPart(feature) {
		return this.withPart(createPart({ feature }));
	}
	withParams(params, mode = defaultModeName) {
		return this.withPart(createPart({ modeParams: { [mode]: params } }));
	}
	_startUse({ styleContainer, cssLayer, nonce, loadThemeGoogleFonts }) {
		if (IS_SSR) return;
		if (FORCE_LEGACY_THEMES) return;
		uninstallLegacyCSS();
		_injectCoreAndModuleCSS(styleContainer, cssLayer, nonce);
		const googleFontsUsed = getGoogleFontsUsed(this);
		if (googleFontsUsed.length > 0) {
			for (const googleFont of googleFontsUsed) if (loadThemeGoogleFonts) loadGoogleFont(googleFont, nonce);
		}
		for (const part of this.parts) part.use(styleContainer, cssLayer, nonce);
	}
	_getCssClass() {
		if (FORCE_LEGACY_THEMES) return "ag-theme-quartz";
		return this._cssClassCache ?? (this._cssClassCache = deduplicatePartsByFeature(this.parts).map((part) => part.use(void 0, void 0, void 0)).filter(Boolean).join(" "));
	}
	_getModeParams() {
		let paramsCache = this._paramsCache;
		if (!paramsCache) {
			const mergedModeParams = { [defaultModeName]: { ...coreDefaults } };
			for (const part of deduplicatePartsByFeature(this.parts)) for (const partMode of Object.keys(part.modeParams)) {
				const partParams = part.modeParams[partMode];
				if (partParams) {
					const mergedParams = mergedModeParams[partMode] ?? (mergedModeParams[partMode] = {});
					const partParamNames = /* @__PURE__ */ new Set();
					for (const partParamName of Object.keys(partParams)) {
						const partParamValue = partParams[partParamName];
						if (partParamValue !== void 0) {
							mergedParams[partParamName] = partParamValue;
							partParamNames.add(partParamName);
						}
					}
					if (partMode === defaultModeName) for (const mergedMode of Object.keys(mergedModeParams)) {
						const mergedParams2 = mergedModeParams[mergedMode];
						if (mergedMode !== defaultModeName) for (const partParamName of partParamNames) delete mergedParams2[partParamName];
					}
				}
			}
			this._paramsCache = paramsCache = mergedModeParams;
		}
		return paramsCache;
	}
	_getPerGridCss(className) {
		const selectorPlaceholder = "##SELECTOR##";
		let innerParamsCss = this._paramsCssCache;
		if (!innerParamsCss) {
			let variablesCss = "";
			let inheritanceCss = "";
			const modeParams = this._getModeParams();
			for (const mode of Object.keys(modeParams)) {
				const params = modeParams[mode];
				if (mode !== defaultModeName) {
					const wrapPrefix = `:where([data-ag-theme-mode="${typeof CSS === "object" ? CSS.escape(mode) : mode}"]) & {
`;
					variablesCss += wrapPrefix;
					inheritanceCss += wrapPrefix;
				}
				for (const key of Object.keys(params).sort()) {
					const value = params[key];
					const cssValue = paramValueToCss(key, value);
					if (cssValue === false) _error(107, {
						key,
						value
					});
					else {
						const cssName = paramToVariableName(key);
						const inheritedName = cssName.replace("--ag-", "--ag-inherited-");
						variablesCss += `	${cssName}: var(${inheritedName}, ${cssValue});
`;
						inheritanceCss += `	${inheritedName}: var(${cssName});
`;
					}
				}
				if (mode !== defaultModeName) {
					variablesCss += "}\n";
					inheritanceCss += "}\n";
				}
			}
			let css = `${selectorPlaceholder} {
${variablesCss}}
`;
			css += `:has(> ${selectorPlaceholder}):not(${selectorPlaceholder}) {
${inheritanceCss}}
`;
			this._paramsCssCache = innerParamsCss = css;
		}
		return innerParamsCss.replaceAll(selectorPlaceholder, `:where(.${className})`);
	}
};
var deduplicatePartsByFeature = (parts) => {
	const lastPartByFeature = /* @__PURE__ */ new Map();
	for (const part of parts) lastPartByFeature.set(part.feature, part);
	const result = [];
	for (const part of parts) if (!part.feature || lastPartByFeature.get(part.feature) === part) result.push(part);
	return result;
};
var getGoogleFontsUsed = (theme) => {
	const googleFontsUsed = /* @__PURE__ */ new Set();
	const visitParamValue = (paramValue) => {
		if (Array.isArray(paramValue)) paramValue.forEach(visitParamValue);
		else {
			const googleFont = paramValue?.googleFont;
			if (typeof googleFont === "string") googleFontsUsed.add(googleFont);
		}
	};
	Object.values(theme._getModeParams()).flatMap((mv) => Object.values(mv)).forEach(visitParamValue);
	return Array.from(googleFontsUsed).sort();
};
var uninstalledLegacyCSS = false;
var uninstallLegacyCSS = () => {
	if (uninstalledLegacyCSS) return;
	uninstalledLegacyCSS = true;
	for (const style of Array.from(document.head.querySelectorAll("style[data-ag-scope=\"legacy\"]"))) style.remove();
};
var googleFontsLoaded = /* @__PURE__ */ new Set();
var loadGoogleFont = async (font, nonce) => {
	googleFontsLoaded.add(font);
	_injectGlobalCSS(`@import url('https://${googleFontsDomain}/css2?family=${encodeURIComponent(font)}:wght@100;200;300;400;500;600;700;800;900&display=swap');
`, document.head, `googleFont:${font}`, void 0, 0, nonce);
};
var googleFontsDomain = "fonts.googleapis.com";
var checkboxStyleDefaultCSS = `.ag-checkbox-input-wrapper,.ag-radio-button-input-wrapper{background-color:var(--ag-checkbox-unchecked-background-color);border:solid var(--ag-checkbox-border-width) var(--ag-checkbox-unchecked-border-color);flex:none;height:var(--ag-icon-size);position:relative;width:var(--ag-icon-size);:where(input){-webkit-appearance:none;-moz-appearance:none;appearance:none;cursor:pointer;display:block;height:var(--ag-icon-size);margin:0;opacity:0;width:var(--ag-icon-size)}&:after{content:"";display:block;inset:0;-webkit-mask-position:center;mask-position:center;-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;pointer-events:none;position:absolute}&:where(.ag-checked){background-color:var(--ag-checkbox-checked-background-color);border-color:var(--ag-checkbox-checked-border-color);&:after{background-color:var(--ag-checkbox-checked-shape-color)}}&:where(:focus-within,:active){box-shadow:var(--ag-focus-shadow)}&:where(.ag-disabled){filter:grayscale();opacity:.5}}.ag-checkbox-input-wrapper{border-radius:var(--ag-checkbox-border-radius);&:where(.ag-checked):after{-webkit-mask-image:var(--ag-checkbox-checked-shape-image);mask-image:var(--ag-checkbox-checked-shape-image)}&:where(.ag-indeterminate){background-color:var(--ag-checkbox-indeterminate-background-color);border-color:var(--ag-checkbox-indeterminate-border-color);&:after{background-color:var(--ag-checkbox-indeterminate-shape-color);-webkit-mask-image:var(--ag-checkbox-indeterminate-shape-image);mask-image:var(--ag-checkbox-indeterminate-shape-image)}}}.ag-cell-editing-error .ag-checkbox-input-wrapper:focus-within{box-shadow:var(--ag-focus-error-shadow)}.ag-radio-button-input-wrapper{border-radius:100%;&:where(.ag-checked):after{-webkit-mask-image:var(--ag-radio-checked-shape-image);mask-image:var(--ag-radio-checked-shape-image)}}`;
var makeCheckboxStyleDefaultTreeShakeable = () => createPart({
	feature: "checkboxStyle",
	params: {
		checkboxBorderWidth: 1,
		checkboxBorderRadius: { ref: "borderRadius" },
		checkboxUncheckedBackgroundColor: backgroundColor,
		checkboxUncheckedBorderColor: foregroundBackgroundMix(.3),
		checkboxCheckedBackgroundColor: accentColor,
		checkboxCheckedBorderColor: { ref: "checkboxCheckedBackgroundColor" },
		checkboxCheckedShapeImage: { svg: "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"10\" height=\"7\" fill=\"none\"><path stroke=\"#000\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"1.75\" d=\"M1 3.5 3.5 6l5-5\"/></svg>" },
		checkboxCheckedShapeColor: backgroundColor,
		checkboxIndeterminateBackgroundColor: foregroundBackgroundMix(.3),
		checkboxIndeterminateBorderColor: { ref: "checkboxIndeterminateBackgroundColor" },
		checkboxIndeterminateShapeImage: { svg: "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"10\" height=\"2\" fill=\"none\"><rect width=\"10\" height=\"2\" fill=\"#000\" rx=\"1\"/></svg>" },
		checkboxIndeterminateShapeColor: backgroundColor,
		radioCheckedShapeImage: { svg: "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"6\" height=\"6\" fill=\"none\"><circle cx=\"3\" cy=\"3\" r=\"3\" fill=\"#000\"/></svg>" }
	},
	css: checkboxStyleDefaultCSS
});
var checkboxStyleDefault = /* @__PURE__ */ makeCheckboxStyleDefaultTreeShakeable();
var darkParams = () => ({
	...defaultLightColorSchemeParams,
	...baseDarkBatchEditParams,
	backgroundColor: "hsl(217, 0%, 17%)",
	foregroundColor: "#FFF",
	chromeBackgroundColor: foregroundBackgroundMix(.05),
	rowHoverColor: accentMix(.15),
	selectedRowBackgroundColor: accentMix(.2),
	menuBackgroundColor: foregroundBackgroundMix(.1),
	browserColorScheme: "dark",
	popupShadow: "0 0px 20px #000A",
	cardShadow: "0 1px 4px 1px #000A",
	advancedFilterBuilderJoinPillColor: "#7a3a37",
	advancedFilterBuilderColumnPillColor: "#355f2d",
	advancedFilterBuilderOptionPillColor: "#5a3168",
	advancedFilterBuilderValuePillColor: "#374c86",
	filterPanelApplyButtonColor: foregroundColor,
	findMatchColor: backgroundColor,
	findActiveMatchColor: backgroundColor,
	checkboxUncheckedBorderColor: foregroundBackgroundMix(.4),
	toggleButtonOffBackgroundColor: foregroundBackgroundMix(.4),
	rowBatchEditBackgroundColor: foregroundBackgroundMix(.1)
});
var darkBlueParams = () => ({
	...darkParams(),
	backgroundColor: "#1f2836"
});
var makeColorSchemeVariableTreeShakeable = () => createPart({
	feature: "colorScheme",
	params: defaultLightColorSchemeParams,
	modeParams: {
		light: defaultLightColorSchemeParams,
		dark: darkParams(),
		"dark-blue": darkBlueParams()
	}
});
var colorSchemeVariable = /* @__PURE__ */ makeColorSchemeVariableTreeShakeable();
var iconSetAlpine = /* @__PURE__ */ createPart({
	feature: "iconSet",
	css: `.ag-icon-aggregation:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M24 6H8v2l8 8-8 8v2h16v-2H11l8-8-8-8h13z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-arrows:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M7.515 11.171 2.687 16l4.828 4.829-1.414 1.414L-.142 16l6.243-6.243zm16.97 0 1.414-1.414L32.142 16l-6.243 6.243-1.414-1.414L29.313 16zM16.028 13.2l2.829 2.828-2.829 2.829-2.828-2.829zm-4.857 11.285L16 29.313l4.829-4.828 1.414 1.414L16 32.142l-6.243-6.243zm0-16.97L9.757 6.101 16-.142l6.243 6.243-1.414 1.414L16 2.687z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-asc:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='m5.333 16 1.88 1.88 7.453-7.44v16.227h2.667V10.44l7.44 7.453L26.666 16 15.999 5.333 5.332 16z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-cancel:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M16 2.667A13.32 13.32 0 0 0 2.667 16c0 7.373 5.96 13.333 13.333 13.333S29.333 23.373 29.333 16 23.373 2.667 16 2.667m6.667 18.12-1.88 1.88L16 17.88l-4.787 4.787-1.88-1.88L14.12 16l-4.787-4.787 1.88-1.88L16 14.12l4.787-4.787 1.88 1.88L17.88 16z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-chart:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Echart%3C/title%3E%3Cg fill='%23000' fill-rule='nonzero'%3E%3Cpath d='M14 7h4v18h-4zM8 17h4v8H8zM20 13h4v12h-4z'/%3E%3C/g%3E%3C/svg%3E")}.ag-icon-color-picker:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M23.907 17.587 10.574 4.254l-1.88 1.88 3.173 3.173-8.28 8.28 10.16 10.16zm-16.547 0 6.387-6.387 6.387 6.387zm18.387 2s-2.667 2.893-2.667 4.667c0 1.467 1.2 2.667 2.667 2.667s2.667-1.2 2.667-2.667c0-1.773-2.667-4.667-2.667-4.667' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-columns:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M26 25H6V7h20zM12 11H8v12h4zm6 0h-4v12h4zm6 12V11h-4v12z' style='fill-rule:nonzero' transform='translate(0 -1)'/%3E%3C/svg%3E")}.ag-icon-contracted:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='m12 6 10 10-10 10-2-2 8-8-8-8z'/%3E%3C/svg%3E")}.ag-icon-copy:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M22 1.333H6A2.675 2.675 0 0 0 3.333 4v18.667H6V4h16zm4 5.334H11.333a2.675 2.675 0 0 0-2.667 2.667v18.667c0 1.467 1.2 2.667 2.667 2.667H26c1.467 0 2.667-1.2 2.667-2.667V9.334c0-1.467-1.2-2.667-2.667-2.667M26 28H11.333V9.333H26z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-cross:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M15.984 13.894 27.05 2.828l2.122 2.122-11.066 11.066 11.066 11.066-2.122 2.12-11.066-11.066L4.918 29.202l-2.12-2.12 11.066-11.066L2.798 4.95l2.12-2.122z'/%3E%3C/svg%3E")}.ag-icon-csv:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M384 131.9c-7.753-8.433-110.425-128.473-114.9-133L48-.1C21.5 0 0 21.5 0 48v416c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48zm-35.9 2.1H257V27.9zM30 479V27h200l1 105c0 13.3-1.3 29 12 29h111l1 318z' style='fill-rule:nonzero' transform='matrix(.06285 0 0 .06285 3.934 -.054)'/%3E%3Cpath d='M.688-.226a.2.2 0 0 1-.017.074.28.28 0 0 1-.145.14.412.412 0 0 1-.234.013.28.28 0 0 1-.202-.168.468.468 0 0 1-.04-.19q0-.086.025-.155a.319.319 0 0 1 .182-.191.4.4 0 0 1 .134-.025q.087 0 .155.035a.3.3 0 0 1 .104.085.17.17 0 0 1 .036.097.06.06 0 0 1-.018.044.06.06 0 0 1-.042.019.06.06 0 0 1-.042-.013.2.2 0 0 1-.031-.046.2.2 0 0 0-.066-.079.16.16 0 0 0-.095-.027.17.17 0 0 0-.142.068.3.3 0 0 0-.053.193.4.4 0 0 0 .023.139.2.2 0 0 0 .067.083.2.2 0 0 0 .1.027q.063 0 .106-.031a.2.2 0 0 0 .065-.091.2.2 0 0 1 .023-.046q.014-.018.044-.018a.06.06 0 0 1 .044.018.06.06 0 0 1 .019.045' style='fill-rule:nonzero' transform='matrix(8.39799 0 0 12.455 7.122 25.977)'/%3E%3Cpath d='M.622-.215a.2.2 0 0 1-.033.117.23.23 0 0 1-.098.081.4.4 0 0 1-.153.029.34.34 0 0 1-.175-.04.23.23 0 0 1-.079-.077.17.17 0 0 1-.031-.093q0-.027.019-.045a.06.06 0 0 1 .046-.019.06.06 0 0 1 .039.014.1.1 0 0 1 .027.044.3.3 0 0 0 .03.057q.015.023.044.038.03.015.076.015.065 0 .105-.03a.09.09 0 0 0 .04-.075.08.08 0 0 0-.022-.058.14.14 0 0 0-.056-.034 1 1 0 0 0-.092-.025.7.7 0 0 1-.129-.042.2.2 0 0 1-.083-.066.17.17 0 0 1-.03-.104q0-.058.032-.105a.2.2 0 0 1 .093-.07.4.4 0 0 1 .144-.025q.066 0 .114.016a.3.3 0 0 1 .08.044.2.2 0 0 1 .046.057q.015.03.015.058a.07.07 0 0 1-.018.046.06.06 0 0 1-.046.021q-.025 0-.038-.012a.2.2 0 0 1-.028-.041.2.2 0 0 0-.047-.063Q.387-.625.326-.625a.15.15 0 0 0-.09.025q-.035.024-.035.059 0 .021.012.037a.1.1 0 0 0 .032.027.4.4 0 0 0 .111.036q.06.015.11.031.048.018.083.042a.2.2 0 0 1 .054.062.2.2 0 0 1 .019.091' style='fill-rule:nonzero' transform='matrix(8.39799 0 0 12.455 13.339 25.977)'/%3E%3Cpath d='m.184-.633.162.48.163-.483q.013-.038.019-.053a.062.062 0 0 1 .061-.039q.018 0 .034.009a.1.1 0 0 1 .025.025q.009.015.009.031L.654-.64l-.007.025-.009.024-.173.468-.019.051a.2.2 0 0 1-.021.042.1.1 0 0 1-.033.03.1.1 0 0 1-.049.012.1.1 0 0 1-.05-.011A.1.1 0 0 1 .26-.03a.2.2 0 0 1-.021-.042L.22-.123.05-.587.041-.612.033-.638.03-.662q0-.025.02-.046a.07.07 0 0 1 .05-.02q.037 0 .053.023.015.023.031.072' style='fill-rule:nonzero' transform='matrix(8.39799 0 0 12.455 18.94 25.977)'/%3E%3C/svg%3E")}.ag-icon-cut:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M13.775 15.198 3.835 2.945a1.501 1.501 0 0 1 2.33-1.89l14.997 18.488A6.003 6.003 0 0 1 29.657 25c0 3.311-2.688 6-6 6s-6-2.689-6-6c0-1.335.437-2.569 1.176-3.566l-3.127-3.855-3.001 3.7A5.97 5.97 0 0 1 14 25c0 3.311-2.689 6-6 6s-6-2.689-6-6a6.003 6.003 0 0 1 8.315-5.536zm9.882 6.702a3.1 3.1 0 0 0-3.1 3.1c0 1.711 1.389 3.1 3.1 3.1s3.1-1.389 3.1-3.1-1.389-3.1-3.1-3.1M8 21.95a3.05 3.05 0 1 0 .001 6.101A3.05 3.05 0 0 0 8 21.95m9.63-11.505 1.932 2.381 8.015-9.881a1.5 1.5 0 0 0-2.329-1.89z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-desc:before,.ag-icon-down:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='m26.667 16-1.88-1.88-7.453 7.44V5.333h-2.667V21.56l-7.44-7.453L5.334 16l10.667 10.667z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-excel:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M384 131.9c-7.753-8.433-110.425-128.473-114.9-133L48-.1C21.5 0 0 21.5 0 48v416c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48zm-35.9 2.1H257V27.9zM30 479V27h200l1 105c0 13.3-1.3 29 12 29h111l1 318z' style='fill-rule:nonzero' transform='matrix(.06285 0 0 .06285 3.934 -.054)'/%3E%3Cpath d='m.052-.139.16-.234-.135-.208a.4.4 0 0 1-.028-.052.1.1 0 0 1-.01-.042.05.05 0 0 1 .018-.037.07.07 0 0 1 .045-.016q.03 0 .047.018a1 1 0 0 1 .047.066l.107.174.115-.174.024-.038.019-.026.021-.015a.1.1 0 0 1 .027-.005.06.06 0 0 1 .044.016.05.05 0 0 1 .018.039q0 .033-.038.089l-.141.211.152.234a.3.3 0 0 1 .03.051.1.1 0 0 1 .009.038.1.1 0 0 1-.008.031.1.1 0 0 1-.024.023.1.1 0 0 1-.034.008.1.1 0 0 1-.035-.008.1.1 0 0 1-.023-.022L.427-.067.301-.265l-.134.204-.022.034-.016.019a.1.1 0 0 1-.022.015.1.1 0 0 1-.03.005.06.06 0 0 1-.044-.016.06.06 0 0 1-.017-.047q0-.036.036-.088' style='fill-rule:nonzero' transform='matrix(17.82892 0 0 16.50777 10.371 25.928)'/%3E%3C/svg%3E")}.ag-icon-expanded:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M20 26 10 16 20 6l2 2-8 8 8 8z'/%3E%3C/svg%3E")}.ag-icon-eye-slash:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Eeye-slash%3C/title%3E%3Cpath fill='%23000' fill-rule='nonzero' d='M8.95 10.364 7 8.414 8.414 7l2.32 2.32A13.2 13.2 0 0 1 16.5 8c5.608 0 10.542 3.515 12.381 8.667L29 17l-.119.333a13 13 0 0 1-4.255 5.879l1.466 1.466-1.414 1.414-1.754-1.753A13.2 13.2 0 0 1 16.5 26c-5.608 0-10.542-3.515-12.381-8.667L4 17l.119-.333a13 13 0 0 1 4.83-6.303m1.445 1.445A11.02 11.02 0 0 0 6.148 17c1.646 4.177 5.728 7 10.352 7 1.76 0 3.441-.409 4.94-1.146l-1.878-1.878A5.06 5.06 0 0 1 16.5 22c-2.789 0-5.05-2.239-5.05-5 0-1.158.398-2.223 1.065-3.07zm1.855-.974 1.794 1.795A5.07 5.07 0 0 1 16.5 12c2.789 0 5.05 2.239 5.05 5 0 .9-.24 1.745-.661 2.474l2.305 2.306A11 11 0 0 0 26.852 17c-1.646-4.177-5.728-7-10.352-7-1.495 0-2.933.295-4.25.835'/%3E%3C/svg%3E")}.ag-icon-eye:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M16.5 23c4.624 0 8.706-2.823 10.352-7-1.646-4.177-5.728-7-10.352-7s-8.706 2.823-10.352 7c1.646 4.177 5.728 7 10.352 7M4.119 15.667C5.958 10.515 10.892 7 16.5 7s10.542 3.515 12.381 8.667L29 16l-.119.333C27.042 21.485 22.108 25 16.5 25S5.958 21.485 4.119 16.333L4 16zM16.5 21c2.789 0 5.049-2.239 5.049-5s-2.26-5-5.049-5-5.049 2.239-5.049 5 2.26 5 5.049 5' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-filter:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='m28 8-8 8v5l-6 6V16L6 8V6h22zM9 8l7 7v7l2-2v-5l7-7z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-first:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M24.273 22.12 18.153 16l6.12-6.12L22.393 8l-8 8 8 8zM7.727 8h2.667v16H7.727z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-group:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M14 7v1H9V7zm0-3v1H5.001V4zm-7 7H5v-1h2zm0-3H5V7h2zM3 5H1V4h2zm11 5v1H9v-1zm-7 4H5v-1h2zm7-1v1H9v-1z' style='fill-rule:nonzero' transform='matrix(2 0 0 2 0 -2)'/%3E%3C/svg%3E")}.ag-icon-last:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='m7.727 9.88 6.12 6.12-6.12 6.12L9.607 24l8-8-8-8zM21.607 8h2.667v16h-2.667z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-left:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M26.667 14.667H10.44l7.453-7.453L16 5.334 5.333 16.001 16 26.668l1.88-1.88-7.44-7.453h16.227z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-linked:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M5.2 16a4.136 4.136 0 0 1 4.133-4.133h5.333V9.334H9.333a6.67 6.67 0 0 0-6.667 6.667 6.67 6.67 0 0 0 6.667 6.667h5.333v-2.533H9.333A4.136 4.136 0 0 1 5.2 16.002zm5.467 1.333h10.667v-2.667H10.667zm12-8h-5.333v2.533h5.333a4.136 4.136 0 0 1 4.133 4.133 4.136 4.136 0 0 1-4.133 4.133h-5.333v2.533h5.333a6.67 6.67 0 0 0 6.667-6.667 6.67 6.67 0 0 0-6.667-6.667z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-loading:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M17 29h-2v-8h2zm-3.586-9L7 26.414 5.586 25 12 18.586zm13 5L25 26.414 18.586 20 20 18.586zM29 17h-8v-2h8zm-18 0H3v-2h8zm2.414-5L12 13.414 5.586 7 7 5.586zm13-5L20 13.414 18.586 12 25 5.586zM17 11h-2V3h2z' style='fill-rule:nonzero' transform='translate(-3.692 -3.692)scale(1.23077)'/%3E%3C/svg%3E")}.ag-icon-maximize:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M14 30H2V18h2.828v7.05l8.254-8.252 2.12 2.12-8.252 8.254H14zm4-28h12v12h-2.828V6.95l-8.254 8.252-2.12-2.12 8.252-8.254H18z'/%3E%3C/svg%3E")}.ag-icon-menu:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M20 13H0v-2h20zm0-6H0V5h20zm0-6H0v-2h20z' style='fill-rule:nonzero' transform='translate(6 9)'/%3E%3C/svg%3E")}.ag-icon-menu-alt:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32' fill='none' viewBox='0 0 32 32'%3E%3Cpath fill='%23000' d='M16 19a3 3 0 1 0 0-6 3 3 0 0 0 0 6M16 11a3 3 0 1 0 0-6 3 3 0 0 0 0 6M16 27a3 3 0 1 0 0-6 3 3 0 0 0 0 6'/%3E%3C/svg%3E")}.ag-icon-minimize:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M2 18h12v12h-2.828v-7.05l-8.254 8.252-2.12-2.12 8.252-8.254H2zm28-4H18V2h2.828v7.05L29.082.798l2.12 2.12-8.252 8.254H30z'/%3E%3C/svg%3E")}.ag-icon-minus:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M6.572 6.572a13.32 13.32 0 0 0 0 18.856 13.32 13.32 0 0 0 18.856 0 13.32 13.32 0 0 0 0-18.856 13.32 13.32 0 0 0-18.856 0m17.527 8.099v2.658H7.901v-2.658z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-next:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M10.94 6 9.06 7.88 17.167 16 9.06 24.12 10.94 26l10-10z' style='fill-rule:nonzero' transform='translate(1)'/%3E%3C/svg%3E")}.ag-icon-none:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctitle%3Enone%3C/title%3E%3Cg fill='%23000' fill-rule='nonzero'%3E%3Cpath d='M23.708 14.645 16 6.939l-7.708 7.706 1.416 1.416L16 9.767l6.292 6.294zM23.708 20.355 16 28.061l-7.708-7.706 1.416-1.416L16 25.233l6.292-6.294z'/%3E%3C/g%3E%3C/svg%3E")}.ag-icon-not-allowed:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M16 2.667C8.64 2.667 2.667 8.64 2.667 16S8.64 29.333 16 29.333 29.333 23.36 29.333 16 23.36 2.667 16 2.667M5.333 16c0-5.893 4.773-10.667 10.667-10.667 2.467 0 4.733.84 6.533 2.253L7.586 22.533A10.54 10.54 0 0 1 5.333 16M16 26.667c-2.467 0-4.733-.84-6.533-2.253L24.414 9.467A10.54 10.54 0 0 1 26.667 16c0 5.893-4.773 10.667-10.667 10.667' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-paste:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M25.334 4H19.76C19.2 2.453 17.733 1.333 16 1.333S12.8 2.453 12.24 4H6.667A2.675 2.675 0 0 0 4 6.667V28c0 1.467 1.2 2.667 2.667 2.667h18.667c1.467 0 2.667-1.2 2.667-2.667V6.667C28.001 5.2 26.801 4 25.334 4M16 4c.733 0 1.333.6 1.333 1.333s-.6 1.333-1.333 1.333-1.333-.6-1.333-1.333S15.267 4 16 4m9.333 24H6.666V6.667h2.667v4h13.333v-4h2.667z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-pin:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='m10.78 19.777-4.668-4.666s.032-1 .67-1.87c1.366-1.86 4.052-1.96 6.056-1.572l3.158-3.108c-.7-2.342 3.352-5.046 3.352-5.046l9.166 9.168q-.334.447-.67.894c-1.074 1.426-2.538 2.63-4.272 2.338l-3.32 3.218c.046.344.042.03.118 1.152.144 2.13-.64 4.324-2.632 5.34l-.746.364-4.798-4.798-7.292 7.294-1.416-1.416zm8.24-13.672c-.688.568-1.416 1.45-1.024 2.072l.49.722-4.986 4.988c-1.988-.506-4.346-.636-5.156.614l9.02 9.032q.14-.099.272-.21c1.226-1.08.764-3.04.498-4.9l4.79-4.79s1.47.938 2.936-.776l-6.79-6.79q-.026.019-.05.038' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-pivot:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M25.128 2.002c2.56.096 4.772 2.292 4.87 4.87a712 712 0 0 1 0 18.256c-.096 2.56-2.292 4.772-4.87 4.87a712 712 0 0 1-18.256 0c-2.558-.096-4.772-2.29-4.87-4.87a712 712 0 0 1 0-18.256c.096-2.56 2.292-4.772 4.87-4.87a712 712 0 0 1 18.256 0m2.966 7.954H9.892v18.136c5.086.13 10.18.098 15.264-.096 1.48-.094 2.746-1.35 2.84-2.84.192-5.064.226-10.134.098-15.2M3.968 24.1q.015.528.036 1.056c.094 1.484 1.354 2.746 2.84 2.84l1.012.036V24.1zM22 15.414l-.292.294-1.416-1.416L23 11.586l2.708 2.706-1.416 1.416-.292-.294v3.592c-.032 2.604-2.246 4.892-4.872 4.992L15.414 24l.294.292-1.416 1.416L11.586 23l2.706-2.708 1.416 1.416-.322.32c3.372.03 6.578-.164 6.614-3.034zM3.88 18.038c.002 1.346.012 2.694.038 4.04h3.938v-4.04zm.05-6.062a681 681 0 0 0-.044 4.042h3.97v-4.042zm5.962-7.99Q8.449 3.999 7.006 4c-1.57.02-2.946 1.348-3.004 2.922q-.02 1.517-.042 3.034h3.896v-2.02h2.036zm14.244-.016v3.966h3.898q-.017-.546-.038-1.092c-.094-1.48-1.35-2.746-2.84-2.84q-.51-.019-1.02-.034m-8.14-.054q-2.035.022-4.07.048v3.972h4.07zm6.106.008a213 213 0 0 0-4.07-.022v4.034h4.07z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-plus:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M6.572 6.572a13.32 13.32 0 0 0 0 18.856 13.32 13.32 0 0 0 18.856 0 13.32 13.32 0 0 0 0-18.856 13.32 13.32 0 0 0-18.856 0m17.527 8.099v2.658h-6.77v6.77h-2.658v-6.77h-6.77v-2.658h6.77v-6.77h2.658v6.77z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-previous:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M21.94 7.88 20.06 6l-10 10 10 10 1.88-1.88L13.833 16z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-right:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='m16 5.333-1.88 1.88 7.44 7.453H5.333v2.667H21.56l-7.44 7.453 1.88 1.88 10.667-10.667L16 5.332z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-save:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M15.708 2.355 8 10.061.292 2.355 1.708.939 8 7.233 14.292.939z' style='fill-rule:nonzero' transform='translate(8 14)'/%3E%3Cpath d='M5 26h22v2H5zM15 4h2v18h-2z'/%3E%3C/svg%3E")}.ag-icon-small-down:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M7.334 10.667 16 21.334l8.667-10.667z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-small-left:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M21.333 7.334 10.666 16l10.667 8.667z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-small-right:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M10.667 24.666 21.334 16 10.667 7.333z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-small-up:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M7.334 21.333 16 10.666l8.667 10.667z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-tick:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M11.586 22.96 27.718 6.828 29.84 8.95 11.586 27.202 2.4 18.016l2.12-2.122z'/%3E%3C/svg%3E")}.ag-icon-tree-closed:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='m11.94 6-1.88 1.88L18.167 16l-8.107 8.12L11.94 26l10-10z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-tree-indeterminate:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M6 13.5h20v3H6z'/%3E%3C/svg%3E")}.ag-icon-tree-open:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M24.12 9.06 16 17.167 7.88 9.06 6 10.94l10 10 10-10z' style='fill-rule:nonzero' transform='translate(0 1)'/%3E%3C/svg%3E")}.ag-icon-unlinked:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M22.667 9.333h-5.333v2.533h5.333a4.136 4.136 0 0 1 4.133 4.133c0 1.907-1.307 3.507-3.08 3.973l1.947 1.947c2.173-1.107 3.667-3.32 3.667-5.92a6.67 6.67 0 0 0-6.667-6.667zm-1.334 5.334h-2.92l2.667 2.667h.253zM2.667 5.693 6.814 9.84A6.65 6.65 0 0 0 2.667 16a6.67 6.67 0 0 0 6.667 6.667h5.333v-2.533H9.334a4.136 4.136 0 0 1-4.133-4.133c0-2.12 1.613-3.867 3.68-4.093l2.76 2.76h-.973v2.667h3.64l3.027 3.027v2.307h2.307l5.347 5.333 1.68-1.68L4.362 4.002 2.669 5.695z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-up:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='m5.333 16 1.88 1.88 7.453-7.44v16.227h2.667V10.44l7.44 7.453L26.666 16 15.999 5.333 5.332 16z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-grip:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 32 32'%3E%3Cpath d='M8 24H6v-4h2zm6 0h-2v-4h2zm6 0h-2v-4h2zm6 0h-2v-4h2zM8 18H6v-4h2zm6 0h-2v-4h2zm6 0h-2v-4h2zm6 0h-2v-4h2zM8 12H6V8h2zm6 0h-2V8h2zm6 0h-2V8h2zm6 0h-2V8h2z' style='fill-rule:nonzero'/%3E%3C/svg%3E")}.ag-icon-settings:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32' fill='none' viewBox='0 0 32 32'%3E%3Cpath fill='%23000' d='M30 8h-4.1c-.5-2.3-2.5-4-4.9-4s-4.4 1.7-4.9 4H2v2h14.1c.5 2.3 2.5 4 4.9 4s4.4-1.7 4.9-4H30zm-9 4c-1.7 0-3-1.3-3-3s1.3-3 3-3 3 1.3 3 3-1.3 3-3 3M2 24h4.1c.5 2.3 2.5 4 4.9 4s4.4-1.7 4.9-4H30v-2H15.9c-.5-2.3-2.5-4-4.9-4s-4.4 1.7-4.9 4H2zm9-4c1.7 0 3 1.3 3 3s-1.3 3-3 3-3-1.3-3-3 1.3-3 3-3'/%3E%3C/svg%3E")}.ag-icon-column-arrow:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 32 32'%3E%3Cpath fill='currentColor' fill-rule='evenodd' d='M11 4a1 1 0 0 1 1 1v22a1 1 0 1 1-2 0V5a1 1 0 0 1 1-1' clip-rule='evenodd'/%3E%3Cpath fill='currentColor' fill-rule='evenodd' d='M2 13a1 1 0 0 1 1-1h23.5a1 1 0 1 1 0 2H3a1 1 0 0 1-1-1' clip-rule='evenodd'/%3E%3Cpath fill='currentColor' fill-rule='evenodd' d='M2 4h18v24H2zm2 2v20h14V6zM26.793 13 23 9.207l1.414-1.414L29.621 13l-5.207 5.207L23 16.793z' clip-rule='evenodd'/%3E%3C/svg%3E")}.ag-icon-un-pin:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32' fill='none' viewBox='0 0 32 32'%3E%3Cpath fill='currentColor' fill-rule='evenodd' d='m6.112 15.111 3.272 3.271 1.436-1.402-2.476-2.479c.81-1.25 3.168-1.12 5.156-.614l4.986-4.988-.49-.722c-.392-.622.336-1.504 1.024-2.072l.008-.007.01-.006.032-.025 1.447 1.447 1.432-1.397-2.601-2.602s-4.052 2.704-3.352 5.046l-3.158 3.108c-2.004-.388-4.69-.288-6.056 1.572-.638.87-.67 1.87-.67 1.87m.581 11.582.014.014 5.502-5.501 4.783 4.783.746-.364c1.992-1.016 2.776-3.21 2.632-5.34-.055-.805-.068-.87-.088-.97-.008-.04-.017-.085-.03-.182l3.32-3.218c1.734.292 3.198-.912 4.272-2.338q.337-.447.67-.894l-.001-.001-.007-.007-.007-.007-.007-.007-3.87-3.87 1.585-1.584-1.414-1.414-14.381 14.38-1.237 1.209-5.69 5.687 1.417 1.416zM23.21 10.206l2.65 2.651c-1.465 1.714-2.935.776-2.935.776l-4.79 4.79q.041.291.087.583c.257 1.676.513 3.35-.585 4.317a4 4 0 0 1-.272.21l-3.739-3.744z' clip-rule='evenodd'/%3E%3C/svg%3E")}.ag-icon-pinned-top:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32' fill='none' viewBox='0 0 32 32'%3E%3Cpath fill='currentColor' d='m16.708 10.878 8.708 8.706L24 21l-6.292-6.294V27h-2V14.706L9.416 21 8 19.584q4.348-4.344 8.691-8.69zM25 6H8v2h17z'/%3E%3C/svg%3E")}.ag-icon-pinned-bottom:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32' fill='none' viewBox='0 0 32 32'%3E%3Cpath fill='currentColor' d='M16.708 22.122 8 13.416 9.416 12l6.292 6.294V6h2v12.294L24 12l1.416 1.416-8.691 8.69zM7.416 28h17v-2h-17z'/%3E%3C/svg%3E")}.ag-icon-chevron-up:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='none' viewBox='0 0 16 16'%3E%3Cpath fill='currentColor' fill-rule='evenodd' d='M3.479 10.521a.75.75 0 0 1 0-1.06l4-4a.75.75 0 0 1 1.06 0l4 4a.75.75 0 0 1-1.06 1.06l-3.47-3.47-3.47 3.47a.75.75 0 0 1-1.06 0' clip-rule='evenodd'/%3E%3C/svg%3E")}.ag-icon-chevron-down:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='none' viewBox='0 0 16 16'%3E%3Cpath fill='currentColor' fill-rule='evenodd' d='M12.521 5.461a.75.75 0 0 1 0 1.06l-4 4a.75.75 0 0 1-1.06 0l-4-4a.75.75 0 0 1 1.06-1.06l3.47 3.47 3.47-3.47a.75.75 0 0 1 1.06 0' clip-rule='evenodd'/%3E%3C/svg%3E")}.ag-icon-chevron-left:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='none' viewBox='0 0 16 16'%3E%3Cpath fill='currentColor' fill-rule='evenodd' d='M10.53 12.512a.75.75 0 0 1-1.06 0l-4-4a.75.75 0 0 1 0-1.06l4-4a.75.75 0 0 1 1.06 1.06l-3.47 3.47 3.47 3.47a.75.75 0 0 1 0 1.06' clip-rule='evenodd'/%3E%3C/svg%3E")}.ag-icon-chevron-right:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='none' viewBox='0 0 16 16'%3E%3Cpath fill='currentColor' fill-rule='evenodd' d='M5.47 3.47a.75.75 0 0 1 1.06 0l4 4a.75.75 0 0 1 0 1.06l-4 4a.75.75 0 0 1-1.06-1.06L8.94 8 5.47 4.53a.75.75 0 0 1 0-1.06' clip-rule='evenodd'/%3E%3C/svg%3E")}.ag-icon-filter-add:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32' fill='none' viewBox='0 0 32 32'%3E%3Cpath fill='currentColor' d='M19.834 8H8c0 .304.06.612.258.842 2.716 2.854 6.682 5.548 6.742 7.974V21l2-1.5v-2.684c.056-2.267 2.968-4.417 5.49-6.75v3.087c-1.081.974-2.245 1.968-3.232 3.005a1.05 1.05 0 0 0-.258.682v3.66L13 25c0-2.74.066-5.482-.002-8.222a1.05 1.05 0 0 0-.256-.62C10.026 13.304 6.06 10.61 6 8.184V6h13.834z'/%3E%3Cpath fill='currentColor' d='M26 6h2.946v2.002H26v3.313h-2.002V8.002h-2.946V6h2.946V3.04H26z'/%3E%3C/svg%3E")}.ag-icon-edit:before{mask-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32' fill='none' viewBox='0 0 32 32'%3E%3Cpath fill='currentColor' d='M6.222 25.778h1.611l14.834-14.811-1.611-1.611-14.834 14.81zM4 28v-4.733L22.644 4.656a2.26 2.26 0 0 1 1.567-.634q.423 0 .833.167.412.166.734.478l1.589 1.6q.333.322.483.733t.15.822q0 .423-.161.839-.162.416-.472.728L8.733 28zm17.856-17.833-.8-.811 1.61 1.61z'/%3E%3C/svg%3E")}`
});
var iconNameToSvgFragment = {
	aggregation: "<path d=\"M18 7V4H6l6 8-6 8h12v-3\"/>",
	arrows: "<polyline points=\"5 9 2 12 5 15\"/><polyline points=\"9 5 12 2 15 5\"/><polyline points=\"15 19 12 22 9 19\"/><polyline points=\"19 9 22 12 19 15\"/><line x1=\"2\" x2=\"22\" y1=\"12\" y2=\"12\"/><line x1=\"12\" x2=\"12\" y1=\"2\" y2=\"22\"/>",
	asc: "<path d=\"m5 12 7-7 7 7\"/><path d=\"M12 19V5\"/>",
	cancel: "<path d=\"m18 6-12 12\"/><path d=\"m6 6 12 12\"/>",
	chart: "<line x1=\"18\" x2=\"18\" y1=\"20\" y2=\"10\"/><line x1=\"12\" x2=\"12\" y1=\"20\" y2=\"4\"/><line x1=\"6\" x2=\"6\" y1=\"20\" y2=\"14\"/>",
	"color-picker": "<path d=\"m19 11-8-8-8.6 8.6a2 2 0 0 0 0 2.8l5.2 5.2c.8.8 2 .8 2.8 0L19 11Z\"/><path d=\"m5 2 5 5\"/><path d=\"M2 13h15\"/><path d=\"M22 20a2 2 0 1 1-4 0c0-1.6 1.7-2.4 2-4 .3 1.6 2 2.4 2 4Z\"/>",
	columns: "<path d=\"M9 3H5a2 2 0 0 0-2 2v4m6-6h10a2 2 0 0 1 2 2v4M9 3v18m0 0h10a2 2 0 0 0 2-2V9M9 21H5a2 2 0 0 1-2-2V9m0 0h18\"/>",
	contracted: "<path d=\"m9 18 6-6-6-6\"/>",
	copy: "<rect width=\"14\" height=\"14\" x=\"8\" y=\"8\" rx=\"2\" ry=\"2\"/><path d=\"M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2\"/>",
	cross: "<path d=\"M18 6 6 18\"/><path d=\"m6 6 12 12\"/>",
	csv: "<path d=\"M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z\"/><polyline points=\"14 2 14 8 20 8\"/><path d=\"M8 13h2\"/><path d=\"M8 17h2\"/><path d=\"M14 13h2\"/><path d=\"M14 17h2\"/>",
	cut: "<circle cx=\"6\" cy=\"6\" r=\"3\"/><path d=\"M8.12 8.12 12 12\"/><path d=\"M20 4 8.12 15.88\"/><circle cx=\"6\" cy=\"18\" r=\"3\"/><path d=\"M14.8 14.8 20 20\"/>",
	desc: "<path d=\"M12 5v14\"/><path d=\"m19 12-7 7-7-7\"/>",
	down: "<path d=\"M12 5v14\"/><path d=\"m19 12-7 7-7-7\"/>",
	excel: "<path d=\"M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z\"/><polyline points=\"14 2 14 8 20 8\"/><path d=\"M8 13h2\"/><path d=\"M8 17h2\"/><path d=\"M14 13h2\"/><path d=\"M14 17h2\"/>",
	expanded: "<path d=\"m15 18-6-6 6-6\"/>",
	"eye-slash": "<path d=\"M9.88 9.88a3 3 0 1 0 4.24 4.24\"/><path d=\"M10.73 5.08A10.43 10.43 0 0 1 12 5c7 0 10 7 10 7a13.16 13.16 0 0 1-1.67 2.68\"/><path d=\"M6.61 6.61A13.526 13.526 0 0 0 2 12s3 7 10 7a9.74 9.74 0 0 0 5.39-1.61\"/><line x1=\"2\" x2=\"22\" y1=\"2\" y2=\"22\"/>",
	eye: "<path d=\"M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z\"/><circle cx=\"12\" cy=\"12\" r=\"3\"/>",
	filter: "<path d=\"M3 6h18\"/><path d=\"M7 12h10\"/><path d=\"M10 18h4\"/>",
	first: "<path d=\"m17 18-6-6 6-6\"/><path d=\"M7 6v12\"/>",
	group: "<path d=\"M16 12H3\"/><path d=\"M16 18H3\"/><path d=\"M10 6H3\"/><path d=\"M21 18V8a2 2 0 0 0-2-2h-5\"/><path d=\"m16 8-2-2 2-2\"/>",
	last: "<path d=\"m7 18 6-6-6-6\"/><path d=\"M17 6v12\"/>",
	left: "<path d=\"m12 19-7-7 7-7\"/><path d=\"M19 12H5\"/>",
	linked: "<path d=\"M9 17H7A5 5 0 0 1 7 7h2\"/><path d=\"M15 7h2a5 5 0 1 1 0 10h-2\"/><line x1=\"8\" x2=\"16\" y1=\"12\" y2=\"12\"/>",
	loading: "<line x1=\"12\" x2=\"12\" y1=\"2\" y2=\"6\"/><line x1=\"12\" x2=\"12\" y1=\"18\" y2=\"22\"/><line x1=\"4.93\" x2=\"7.76\" y1=\"4.93\" y2=\"7.76\"/><line x1=\"16.24\" x2=\"19.07\" y1=\"16.24\" y2=\"19.07\"/><line x1=\"2\" x2=\"6\" y1=\"12\" y2=\"12\"/><line x1=\"18\" x2=\"22\" y1=\"12\" y2=\"12\"/><line x1=\"4.93\" x2=\"7.76\" y1=\"19.07\" y2=\"16.24\"/><line x1=\"16.24\" x2=\"19.07\" y1=\"7.76\" y2=\"4.93\"/>",
	maximize: "<polyline points=\"15 3 21 3 21 9\"/><polyline points=\"9 21 3 21 3 15\"/><line x1=\"21\" x2=\"14\" y1=\"3\" y2=\"10\"/><line x1=\"3\" x2=\"10\" y1=\"21\" y2=\"14\"/>",
	menu: "<line x1=\"4\" x2=\"20\" y1=\"12\" y2=\"12\"/><line x1=\"4\" x2=\"20\" y1=\"6\" y2=\"6\"/><line x1=\"4\" x2=\"20\" y1=\"18\" y2=\"18\"/>",
	"menu-alt": "<circle cx=\"12\" cy=\"5\" r=\"0.75\" fill=\"#D9D9D9\"/><circle cx=\"12\" cy=\"12\" r=\"0.75\" fill=\"#D9D9D9\"/><circle cx=\"12\" cy=\"19\" r=\"0.75\" fill=\"#D9D9D9\"/>",
	minimize: "<polyline points=\"4 14 10 14 10 20\"/><polyline points=\"20 10 14 10 14 4\"/><line x1=\"14\" x2=\"21\" y1=\"10\" y2=\"3\"/><line x1=\"3\" x2=\"10\" y1=\"21\" y2=\"14\"/>",
	minus: "<circle cx=\"12\" cy=\"12\" r=\"10\"/><path d=\"M8 12h8\"/>",
	next: "<path d=\"m9 18 6-6-6-6\"/>",
	none: "<path d=\"m7 15 5 5 5-5\"/><path d=\"m7 9 5-5 5 5\"/>",
	"not-allowed": "<circle cx=\"12\" cy=\"12\" r=\"10\"/><path d=\"m4.9 4.9 14.2 14.2\"/>",
	paste: "<path d=\"M15 2H9a1 1 0 0 0-1 1v2c0 .6.4 1 1 1h6c.6 0 1-.4 1-1V3c0-.6-.4-1-1-1Z\"/><path d=\"M8 4H6a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2M16 4h2a2 2 0 0 1 2 2v2M11 14h10\"/><path d=\"m17 10 4 4-4 4\"/>",
	pin: "<line x1=\"12\" x2=\"12\" y1=\"17\" y2=\"22\"/><path d=\"M5 17h14v-1.76a2 2 0 0 0-1.11-1.79l-1.78-.9A2 2 0 0 1 15 10.76V6h1a2 2 0 0 0 0-4H8a2 2 0 0 0 0 4h1v4.76a2 2 0 0 1-1.11 1.79l-1.78.9A2 2 0 0 0 5 15.24Z\"/>",
	pivot: "<path d=\"M15 3v18\"/><rect width=\"18\" height=\"18\" x=\"3\" y=\"3\" rx=\"2\"/><path d=\"M21 9H3\"/><path d=\"M21 15H3\"/>",
	plus: "<circle cx=\"12\" cy=\"12\" r=\"10\"/><path d=\"M8 12h8\"/><path d=\"M12 8v8\"/>",
	previous: "<path d=\"m15 18-6-6 6-6\"/>",
	right: "<path d=\"M5 12h14\"/><path d=\"m12 5 7 7-7 7\"/>",
	save: "<path d=\"M12 17V3\"/><path d=\"m6 11 6 6 6-6\"/><path d=\"M19 21H5\"/>",
	"small-left": "<path d=\"m15 18-6-6 6-6\"/>",
	"small-right": "<path d=\"m9 18 6-6-6-6\"/>",
	tick: "<path d=\"M20 6 9 17l-5-5\"/>",
	"tree-closed": "<path d=\"m9 18 6-6-6-6\"/>",
	"tree-indeterminate": "<path d=\"M5 12h14\"/>",
	"tree-open": "<path d=\"m6 9 6 6 6-6\"/>",
	unlinked: "<path d=\"M9 17H7A5 5 0 0 1 7 7\"/><path d=\"M15 7h2a5 5 0 0 1 4 8\"/><line x1=\"8\" x2=\"12\" y1=\"12\" y2=\"12\"/><line x1=\"2\" x2=\"22\" y1=\"2\" y2=\"22\"/>",
	up: "<path d=\"m5 12 7-7 7 7\"/><path d=\"M12 19V5\"/>",
	grip: "<circle cx=\"5\" cy=\"8\" r=\"0.5\"/><circle cx=\"12\" cy=\"8\" r=\"0.5\"/><circle cx=\"19\" cy=\"8\" r=\"0.5\"/><circle cx=\"5\" cy=\"16\" r=\"0.5\"/><circle cx=\"12\" cy=\"16\" r=\"0.5\"/><circle cx=\"19\" cy=\"16\" r=\"0.5\"/><g stroke=\"none\" fill=\"currentColor\"><circle cx=\"5\" cy=\"8\" r=\"1\"/><circle cx=\"12\" cy=\"8\" r=\"1\"/><circle cx=\"19\" cy=\"8\" r=\"1\"/><circle cx=\"5\" cy=\"16\" r=\"1\"/><circle cx=\"12\" cy=\"16\" r=\"1\"/><circle cx=\"19\" cy=\"16\" r=\"1\"/></g>",
	settings: "<path d=\"M20 7h-9\"/><path d=\"M14 17H5\"/><circle cx=\"17\" cy=\"17\" r=\"3\"/><circle cx=\"7\" cy=\"7\" r=\"3\"/>"
};
var iconNameToFullSvg = {
	"column-arrow": "<svg xmlns=\"http://www.w3.org/2000/svg\" class=\"ag-icon\" fill=\"none\" viewBox=\"0 0 32 32\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M0 26C0 28.2092 1.79086 30 4 30H14C16.2091 30 18 28.2092 18 26V15H25.8786L24.4394 16.4393C23.8536 17.0251 23.8536 17.9749 24.4394 18.5607C25.0252 19.1464 25.9748 19.1464 26.5606 18.5607L30.5606 14.5607C31.1464 13.9749 31.1464 13.0251 30.5606 12.4393L26.5606 8.43934C25.9748 7.85356 25.0252 7.85356 24.4394 8.43934C23.8536 9.02512 23.8536 9.97488 24.4394 10.5607L25.8786 12H18V6C18 3.79086 16.2091 2 14 2H4C1.79086 2 0 3.79086 0 6V26ZM14 5H10.5V12H15V6C15 5.44772 14.5523 5 14 5ZM4 5H7.5V12H3V6C3 5.44772 3.44772 5 4 5ZM10.5 15H15V26C15 26.5522 14.5523 27 14 27H10.5V15ZM4 27H7.5V15H3V26C3 26.5522 3.44772 27 4 27Z\" fill=\"currentColor\"/></svg>",
	"small-down": "<svg xmlns=\"http://www.w3.org/2000/svg\" class=\"ag-icon\" fill=\"black\" stroke=\"none\" viewBox=\"0 0 32 32\"><path d=\"M7.334 10.667 16 21.334l8.667-10.667H7.334Z\"/></svg>",
	"small-up": "<svg xmlns=\"http://www.w3.org/2000/svg\" class=\"ag-icon\" fill=\"black\" stroke=\"none\" viewBox=\"0 0 32 32\"><path d=\"M7.334 21.333 16 10.666l8.667 10.667H7.334Z\"/></svg>",
	"pinned-top": "<svg xmlns=\"http://www.w3.org/2000/svg\" class=\"ag-icon\" fill=\"none\" viewBox=\"0 0 16 16\"><path fill=\"currentColor\" d=\"M12.53 3.72A.75.75 0 0 1 12 5H4a.75.75 0 0 1 0-1.5h8a.75.75 0 0 1 .53.22ZM3.269 10.744a.75.75 0 0 1 .2-.524l4-4a.75.75 0 0 1 1.06 0l4 4a.75.75 0 1 1-1.06 1.06L8.75 8.56V14a.75.75 0 0 1-1.5 0V8.56l-2.72 2.72a.75.75 0 0 1-1.26-.536Z\"/></svg>",
	"pinned-bottom": "<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" class=\"ag-icon\" viewBox=\"0 0 16 16\"><path fill=\"currentColor\" d=\"M3.47 12.28A.75.75 0 0 1 4 11h8a.75.75 0 0 1 0 1.5H4a.75.75 0 0 1-.53-.22ZM12.731 5.256a.75.75 0 0 1-.2.524l-4 4a.75.75 0 0 1-1.06 0l-4-4a.75.75 0 1 1 1.06-1.06l2.72 2.72V2a.75.75 0 0 1 1.5 0v5.44l2.72-2.72a.75.75 0 0 1 1.26.536Z\"/></svg>",
	"un-pin": "<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" class=\"ag-icon\" viewBox=\"0 0 16 16\"><path fill=\"currentColor\" d=\"M8 11a.75.75 0 0 0-.75.75v3.333a.75.75 0 1 0 1.5 0V11.75A.75.75 0 0 0 8 11Z\"/><path fill=\"currentColor\" d=\"M13.11 1.436a.75.75 0 0 0-1.22-.872l-10 14a.75.75 0 1 0 1.22.872L5.207 12.5h7.376a.75.75 0 0 0 .75-.75v-1.174a2.08 2.08 0 0 0-1.153-1.863l-1.185-.599-.005-.002a.58.58 0 0 1-.323-.522V5.165a2.083 2.083 0 0 0 1.854-2.904l.589-.825Zm-3.943 5.52v.634a2.08 2.08 0 0 0 1.153 1.863l1.185.6.005.002a.58.58 0 0 1 .323.522V11H6.28l2.887-4.044ZM9.277 1H5.25a2.084 2.084 0 0 0-.083 4.165v1.676l1.5-2.132v-.292a.75.75 0 0 0-.75-.75H5.25a.584.584 0 0 1 0-1.167h2.972L9.277 1Z\"/></svg>",
	"chevron-down": "<svg width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" class=\"ag-icon\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M12 6L8 10L4 6\" stroke=\"currentColor\" stroke-width=\"1.5\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/></svg>",
	"chevron-up": "<svg width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" class=\"ag-icon\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M4 10L8 6L12 10\" stroke=\"currentColor\" stroke-width=\"1.5\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/></svg>",
	"chevron-left": "<svg width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" class=\"ag-icon\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M10 12L6 8L10 4\" stroke=\"currentColor\" stroke-width=\"1.5\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/></svg>",
	"chevron-right": "<svg width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" class=\"ag-icon\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M6 12L10 8L6 4\" stroke=\"currentColor\" stroke-width=\"1.5\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/></svg>",
	"filter-add": "<svg width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" class=\"ag-icon\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M5.12126 7.75L10.8517 7.75\" stroke=\"currentColor\" stroke-width=\"1.5\" stroke-linecap=\"round\"/><path d=\"M6.65934 11.748L9.32778 11.748\" stroke=\"currentColor\" stroke-width=\"1.5\" stroke-linecap=\"round\"/><path d=\"M12.2943 1.04872V6.19184M14.9886 3.74341H9.68478\" stroke=\"currentColor\" stroke-width=\"1.5\" stroke-linecap=\"round\"/><path d=\"M8.25488 3C8.04799 3.18323 7.91706 3.45099 7.91699 3.74902C7.91713 4.04868 8.04988 4.31681 8.25879 4.5H2C1.58579 4.5 1.25 4.16421 1.25 3.75C1.25 3.33579 1.58579 3 2 3H8.25488Z\" fill=\"currentColor\"/></svg>",
	edit: "<svg width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M3.5 10.6262V12.5012H5.375L10.905 6.97122L9.03 5.09622L3.5 10.6262ZM12.355 5.52122C12.4014 5.47497 12.4381 5.42002 12.4632 5.35953C12.4883 5.29905 12.5012 5.23421 12.5012 5.16872C12.5012 5.10324 12.4883 5.0384 12.4632 4.97791C12.4381 4.91742 12.4014 4.86248 12.355 4.81622L11.185 3.64622C11.1387 3.59987 11.0838 3.5631 11.0233 3.53801C10.9628 3.51291 10.898 3.5 10.8325 3.5C10.767 3.5 10.7022 3.51291 10.6417 3.53801C10.5812 3.5631 10.5263 3.59987 10.48 3.64622L9.565 4.56122L11.44 6.43622L12.355 5.52122Z\" fill=\"currentColor\"/></svg>"
};
var getQuartzIconsCss = (args = {}) => {
	let result = "";
	for (const iconName of [...Object.keys(iconNameToSvgFragment), ...Object.keys(iconNameToFullSvg)]) {
		const iconSvg = quartzIconSvg(iconName, args.strokeWidth);
		result += `.ag-icon-${iconName}::before { mask-image: url('data:image/svg+xml,${encodeURIComponent(iconSvg)}'); }
`;
	}
	return result;
};
var quartzIconSvg = (name, strokeWidth = 1.5) => {
	const fullSVG = iconNameToFullSvg[name];
	if (fullSVG) return fullSVG;
	const svgFragment = iconNameToSvgFragment[name];
	if (!svgFragment) throw new Error(`Missing icon data for ${name}`);
	return `<svg xmlns="http://www.w3.org/2000/svg" class="ag-icon" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke="black" stroke-width="${strokeWidth}" viewBox="0 0 24 24"><style>* { vector-effect: non-scaling-stroke; }</style>` + svgFragment + "</svg>";
};
var iconSetQuartz = (args = {}) => {
	return createPart({
		feature: "iconSet",
		css: () => getQuartzIconsCss(args)
	});
};
var iconSetQuartzRegular = /* @__PURE__ */ iconSetQuartz();
var inputStyleBaseCSS = `:where(.ag-input-field-input[type=number]:not(.ag-number-field-input-stepper)){-webkit-appearance:textfield;-moz-appearance:textfield;appearance:textfield;&::-webkit-inner-spin-button,&::-webkit-outer-spin-button{-webkit-appearance:none;appearance:none;margin:0}}.ag-input-field-input:where(input:not([type]),input[type=text],input[type=number],input[type=tel],input[type=date],input[type=datetime-local],textarea){background-color:var(--ag-input-background-color);border:var(--ag-input-border);border-radius:var(--ag-input-border-radius);color:var(--ag-input-text-color);font-family:inherit;font-size:inherit;line-height:inherit;margin:0;min-height:var(--ag-input-height);padding:0;&:where(:disabled){background-color:var(--ag-input-disabled-background-color);border:var(--ag-input-disabled-border);color:var(--ag-input-disabled-text-color)}&:where(:focus){background-color:var(--ag-input-focus-background-color);border:var(--ag-input-focus-border);box-shadow:var(--ag-input-focus-shadow);color:var(--ag-input-focus-text-color);outline:none}&:where(:invalid){background-color:var(--ag-input-invalid-background-color);border:var(--ag-input-invalid-border);color:var(--ag-input-invalid-text-color)}&:where(.invalid){background-color:var(--ag-input-invalid-background-color);border:var(--ag-input-invalid-border);color:var(--ag-input-invalid-text-color)}&::-moz-placeholder{color:var(--ag-input-placeholder-text-color)}&::placeholder{color:var(--ag-input-placeholder-text-color)}}:where(.ag-ltr) .ag-input-field-input:where(input:not([type]),input[type=text],input[type=number],input[type=tel],input[type=date],input[type=datetime-local],textarea){padding-left:var(--ag-input-padding-start)}:where(.ag-rtl) .ag-input-field-input:where(input:not([type]),input[type=text],input[type=number],input[type=tel],input[type=date],input[type=datetime-local],textarea){padding-right:var(--ag-input-padding-start)}:where(.ag-column-select-header-filter-wrapper,.ag-filter-toolpanel-search,.ag-mini-filter,.ag-filter-filter,.ag-filter-add-select){.ag-input-wrapper:before{background-color:currentcolor;color:var(--ag-input-icon-color);content:"";display:block;height:12px;-webkit-mask-image:url("data:image/svg+xml;charset=utf-8;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMiIgaGVpZ2h0PSIxMiIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS13aWR0aD0iMS41Ij48cGF0aCBkPSJNNS4zIDlhMy43IDMuNyAwIDEgMCAwLTcuNSAzLjcgMy43IDAgMCAwIDAgNy41Wk0xMC41IDEwLjUgOC4zIDguMiIvPjwvc3ZnPg==");mask-image:url("data:image/svg+xml;charset=utf-8;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMiIgaGVpZ2h0PSIxMiIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS13aWR0aD0iMS41Ij48cGF0aCBkPSJNNS4zIDlhMy43IDMuNyAwIDEgMCAwLTcuNSAzLjcgMy43IDAgMCAwIDAgNy41Wk0xMC41IDEwLjUgOC4zIDguMiIvPjwvc3ZnPg==");-webkit-mask-position:center;mask-position:center;-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;opacity:.5;position:absolute;width:12px}}:where(.ag-ltr) :where(.ag-column-select-header-filter-wrapper,.ag-filter-toolpanel-search,.ag-mini-filter,.ag-filter-filter,.ag-filter-add-select){.ag-input-wrapper:before{margin-left:var(--ag-spacing)}.ag-number-field-input,.ag-text-field-input{padding-left:calc(var(--ag-spacing)*1.5 + 12px)}}:where(.ag-rtl) :where(.ag-column-select-header-filter-wrapper,.ag-filter-toolpanel-search,.ag-mini-filter,.ag-filter-filter,.ag-filter-add-select){.ag-input-wrapper:before{margin-right:var(--ag-spacing)}.ag-number-field-input,.ag-text-field-input{padding-right:calc(var(--ag-spacing)*1.5 + 12px)}}`;
var inputStyleBorderedCSS = `.ag-input-field-input:where(input:not([type]),input[type=text],input[type=number],input[type=tel],input[type=date],input[type=datetime-local],textarea){&:focus{box-shadow:var(--ag-focus-shadow);&:where(.invalid),&:where(:invalid){box-shadow:var(--ag-focus-error-shadow)}}}`;
var baseParams3 = {
	inputBackgroundColor: "transparent",
	inputBorder: false,
	inputBorderRadius: 0,
	inputTextColor: { ref: "textColor" },
	inputPlaceholderTextColor: {
		ref: "inputTextColor",
		mix: .5
	},
	inputPaddingStart: 0,
	inputHeight: { calc: "max(iconSize, fontSize) + spacing * 2" },
	inputFocusBackgroundColor: { ref: "inputBackgroundColor" },
	inputFocusBorder: { ref: "inputBorder" },
	inputFocusShadow: "none",
	inputFocusTextColor: { ref: "inputTextColor" },
	inputDisabledBackgroundColor: { ref: "inputBackgroundColor" },
	inputDisabledBorder: { ref: "inputBorder" },
	inputDisabledTextColor: { ref: "inputTextColor" },
	inputInvalidBackgroundColor: { ref: "inputBackgroundColor" },
	inputInvalidBorder: { ref: "inputBorder" },
	inputInvalidTextColor: { ref: "inputTextColor" },
	inputIconColor: { ref: "inputTextColor" },
	pickerButtonBorder: false,
	pickerButtonFocusBorder: { ref: "inputFocusBorder" },
	pickerButtonBackgroundColor: { ref: "backgroundColor" },
	pickerButtonFocusBackgroundColor: { ref: "backgroundColor" },
	pickerListBorder: false,
	pickerListBackgroundColor: { ref: "backgroundColor" },
	colorPickerThumbSize: 18,
	colorPickerTrackSize: 12,
	colorPickerThumbBorderWidth: 3,
	colorPickerTrackBorderRadius: 12,
	colorPickerColorBorderRadius: 4
};
var makeInputStyleBorderedTreeShakeable = () => createPart({
	feature: "inputStyle",
	params: {
		...baseParams3,
		inputBackgroundColor: backgroundColor,
		inputBorder: true,
		inputBorderRadius: { ref: "borderRadius" },
		inputPaddingStart: { ref: "spacing" },
		inputFocusBorder: { color: accentColor },
		inputFocusShadow: { ref: "focusShadow" },
		inputDisabledBackgroundColor: foregroundBackgroundMix(.06),
		inputDisabledTextColor: {
			ref: "textColor",
			mix: .5
		},
		inputInvalidBorder: { color: { ref: "invalidColor" } },
		pickerButtonBorder: true,
		pickerListBorder: true
	},
	css: () => inputStyleBaseCSS + inputStyleBorderedCSS
});
var inputStyleBordered = /* @__PURE__ */ makeInputStyleBorderedTreeShakeable();
var tabStyleBaseCSS = `.ag-tabs-header{background-color:var(--ag-tab-bar-background-color);border-bottom:var(--ag-tab-bar-border);display:flex;flex:1;gap:var(--ag-tab-spacing);padding:var(--ag-tab-bar-top-padding) var(--ag-tab-bar-horizontal-padding) 0}.ag-tabs-header-wrapper{display:flex}.ag-tabs-close-button-wrapper{align-items:center;border:0;display:flex;padding:var(--ag-spacing)}:where(.ag-ltr) .ag-tabs-close-button-wrapper{border-right:solid var(--ag-border-width) var(--ag-border-color)}:where(.ag-rtl) .ag-tabs-close-button-wrapper{border-left:solid var(--ag-border-width) var(--ag-border-color)}.ag-tabs-close-button{background-color:unset;border:0;cursor:pointer;padding:0}.ag-tab{align-items:center;background-color:var(--ag-tab-background-color);border-left:var(--ag-tab-selected-border-width) solid transparent;border-right:var(--ag-tab-selected-border-width) solid transparent;color:var(--ag-tab-text-color);cursor:pointer;display:flex;flex:1;justify-content:center;padding:var(--ag-tab-top-padding) var(--ag-tab-horizontal-padding) var(--ag-tab-bottom-padding);position:relative;&:hover{background-color:var(--ag-tab-hover-background-color);color:var(--ag-tab-hover-text-color)}&.ag-tab-selected{background-color:var(--ag-tab-selected-background-color);color:var(--ag-tab-selected-text-color)}&:after{background-color:var(--ag-tab-selected-underline-color);bottom:0;content:"";display:block;height:var(--ag-tab-selected-underline-width);left:0;opacity:0;position:absolute;right:0;transition:opacity var(--ag-tab-selected-underline-transition-duration)}&.ag-tab-selected:after{opacity:1}}:where(.ag-ltr) .ag-tab{&.ag-tab-selected{&:where(:not(:first-of-type)){border-left-color:var(--ag-tab-selected-border-color)}&:where(:not(:last-of-type)){border-right-color:var(--ag-tab-selected-border-color)}}}:where(.ag-rtl) .ag-tab{&.ag-tab-selected{&:where(:not(:first-of-type)){border-right-color:var(--ag-tab-selected-border-color)}&:where(:not(:last-of-type)){border-left-color:var(--ag-tab-selected-border-color)}}}`;
var baseParams4 = {
	tabBarBackgroundColor: "transparent",
	tabBarHorizontalPadding: 0,
	tabBarTopPadding: 0,
	tabBackgroundColor: "transparent",
	tabTextColor: { ref: "textColor" },
	tabHorizontalPadding: { ref: "spacing" },
	tabTopPadding: { ref: "spacing" },
	tabBottomPadding: { ref: "spacing" },
	tabSpacing: "0",
	tabHoverBackgroundColor: { ref: "tabBackgroundColor" },
	tabHoverTextColor: { ref: "tabTextColor" },
	tabSelectedBackgroundColor: { ref: "tabBackgroundColor" },
	tabSelectedTextColor: { ref: "tabTextColor" },
	tabSelectedBorderWidth: { ref: "borderWidth" },
	tabSelectedBorderColor: "transparent",
	tabSelectedUnderlineColor: "transparent",
	tabSelectedUnderlineWidth: 0,
	tabSelectedUnderlineTransitionDuration: 0,
	tabBarBorder: false
};
var makeTabStyleQuartzTreeShakeable = () => createPart({
	feature: "tabStyle",
	params: {
		...baseParams4,
		tabBarBorder: true,
		tabBarBackgroundColor: foregroundMix(.05),
		tabTextColor: {
			ref: "textColor",
			mix: .7
		},
		tabSelectedTextColor: { ref: "textColor" },
		tabHoverTextColor: { ref: "textColor" },
		tabSelectedBorderColor: { ref: "borderColor" },
		tabSelectedBackgroundColor: backgroundColor
	},
	css: tabStyleBaseCSS
});
var tabStyleQuartz = /* @__PURE__ */ makeTabStyleQuartzTreeShakeable();
var makeThemeQuartzTreeShakeable = () => createTheme().withPart(checkboxStyleDefault).withPart(colorSchemeVariable).withPart(iconSetQuartzRegular).withPart(tabStyleQuartz).withPart(inputStyleBordered).withPart(columnDropStyleBordered).withParams({ fontFamily: [
	{ googleFont: "IBM Plex Sans" },
	"-apple-system",
	"BlinkMacSystemFont",
	"Segoe UI",
	"Roboto",
	"Oxygen-Sans",
	"Ubuntu"
] });
var themeQuartz = /* @__PURE__ */ makeThemeQuartzTreeShakeable();
var CELL_HORIZONTAL_PADDING = {
	cssName: "--ag-cell-horizontal-padding",
	changeKey: "cellHorizontalPaddingChanged",
	defaultValue: 16
};
var INDENTATION_LEVEL = {
	cssName: "--ag-indentation-level",
	changeKey: "indentationLevelChanged",
	defaultValue: 0,
	noWarn: true,
	cacheDefault: true
};
var ROW_GROUP_INDENT_SIZE = {
	cssName: "--ag-row-group-indent-size",
	changeKey: "rowGroupIndentSizeChanged",
	defaultValue: 0
};
var ROW_HEIGHT = {
	cssName: "--ag-row-height",
	changeKey: "rowHeightChanged",
	defaultValue: 42
};
var HEADER_HEIGHT = {
	cssName: "--ag-header-height",
	changeKey: "headerHeightChanged",
	defaultValue: 48
};
var LIST_ITEM_HEIGHT = {
	cssName: "--ag-list-item-height",
	changeKey: "listItemHeightChanged",
	defaultValue: 24
};
var ROW_BORDER_WIDTH = {
	cssName: "--ag-row-border",
	changeKey: "rowBorderWidthChanged",
	defaultValue: 1,
	border: true
};
var PINNED_BORDER_WIDTH = {
	cssName: "--ag-pinned-row-border",
	changeKey: "pinnedRowBorderWidthChanged",
	defaultValue: 1,
	border: true
};
var paramsId = 0;
var Environment = class extends BeanStub {
	constructor() {
		super(...arguments);
		this.beanName = "environment";
		this.sizeEls = /* @__PURE__ */ new Map();
		this.lastKnownValues = /* @__PURE__ */ new Map();
		this.sizesMeasured = false;
		this.paramsClass = `ag-theme-params-${++paramsId}`;
		this.globalCSS = [];
	}
	wireBeans(beans) {
		const { eGridDiv, gridOptions } = beans;
		this.eGridDiv = eGridDiv;
		this.eStyleContainer = gridOptions.themeStyleContainer ?? (eGridDiv.getRootNode() === document ? document.head : eGridDiv);
		this.cssLayer = gridOptions.themeCssLayer;
		this.styleNonce = gridOptions.styleNonce;
	}
	postConstruct() {
		this.addManagedPropertyListener("theme", () => this.handleThemeGridOptionChange());
		this.handleThemeGridOptionChange();
		this.addManagedPropertyListener("rowHeight", () => this.refreshRowHeightVariable());
		this.getSizeEl(ROW_HEIGHT);
		this.getSizeEl(HEADER_HEIGHT);
		this.getSizeEl(LIST_ITEM_HEIGHT);
		this.getSizeEl(ROW_BORDER_WIDTH);
		this.getSizeEl(PINNED_BORDER_WIDTH);
		this.refreshRowBorderWidthVariable();
		this.addDestroyFunc(() => _unregisterGridUsingThemingAPI(this));
		this.mutationObserver = new MutationObserver(() => {
			this.fireGridStylesChangedEvent("themeChanged");
		});
		this.addDestroyFunc(() => this.mutationObserver.disconnect());
	}
	getPinnedRowBorderWidth() {
		return this.getCSSVariablePixelValue(PINNED_BORDER_WIDTH);
	}
	getRowBorderWidth() {
		return this.getCSSVariablePixelValue(ROW_BORDER_WIDTH);
	}
	getDefaultRowHeight() {
		return this.getCSSVariablePixelValue(ROW_HEIGHT);
	}
	getDefaultHeaderHeight() {
		return this.getCSSVariablePixelValue(HEADER_HEIGHT);
	}
	getDefaultCellHorizontalPadding() {
		return this.getCSSVariablePixelValue(CELL_HORIZONTAL_PADDING);
	}
	getCellPaddingLeft() {
		const cellHorizontalPadding = this.getDefaultCellHorizontalPadding();
		const indentationLevel = this.getCSSVariablePixelValue(INDENTATION_LEVEL);
		const rowGroupIndentSize = this.getCSSVariablePixelValue(ROW_GROUP_INDENT_SIZE);
		return cellHorizontalPadding - 1 + rowGroupIndentSize * indentationLevel;
	}
	getCellPadding() {
		const cellPaddingRight = this.getDefaultCellHorizontalPadding() - 1;
		return this.getCellPaddingLeft() + cellPaddingRight;
	}
	getDefaultColumnMinWidth() {
		return Math.min(36, this.getDefaultRowHeight());
	}
	getDefaultListItemHeight() {
		return this.getCSSVariablePixelValue(LIST_ITEM_HEIGHT);
	}
	applyThemeClasses(el) {
		const { gridTheme } = this;
		let themeClass = "";
		if (gridTheme) themeClass = `${this.paramsClass} ${gridTheme._getCssClass()}`;
		else {
			this.mutationObserver.disconnect();
			let node = this.eGridDiv;
			while (node) {
				let isThemeEl = false;
				for (const className of Array.from(node.classList)) if (className.startsWith("ag-theme-")) {
					isThemeEl = true;
					themeClass = themeClass ? `${themeClass} ${className}` : className;
				}
				if (isThemeEl) this.mutationObserver.observe(node, {
					attributes: true,
					attributeFilter: ["class"]
				});
				node = node.parentElement;
			}
		}
		for (const className of Array.from(el.classList)) if (className.startsWith("ag-theme-")) el.classList.remove(className);
		if (themeClass) {
			const oldClass = el.className;
			el.className = oldClass + (oldClass ? " " : "") + themeClass;
		}
	}
	refreshRowHeightVariable() {
		const { eGridDiv } = this;
		const oldRowHeight = eGridDiv.style.getPropertyValue("--ag-line-height").trim();
		const height = this.gos.get("rowHeight");
		if (height == null || isNaN(height) || !isFinite(height)) {
			if (oldRowHeight !== null) eGridDiv.style.setProperty("--ag-line-height", null);
			return -1;
		}
		const newRowHeight = `${height}px`;
		if (oldRowHeight != newRowHeight) {
			eGridDiv.style.setProperty("--ag-line-height", newRowHeight);
			return height;
		}
		return oldRowHeight != "" ? parseFloat(oldRowHeight) : -1;
	}
	addGlobalCSS(css, debugId) {
		if (this.gridTheme) _injectGlobalCSS(css, this.eStyleContainer, debugId, this.cssLayer, 0, this.styleNonce);
		else this.globalCSS.push([css, debugId]);
	}
	getCSSVariablePixelValue(variable) {
		const cached = this.lastKnownValues.get(variable);
		if (cached != null) return cached;
		const measurement = this.measureSizeEl(variable);
		if (measurement === "detached" || measurement === "no-styles") {
			if (variable.cacheDefault) this.lastKnownValues.set(variable, variable.defaultValue);
			return variable.defaultValue;
		}
		this.lastKnownValues.set(variable, measurement);
		return measurement;
	}
	measureSizeEl(variable) {
		const sizeEl = this.getSizeEl(variable);
		if (sizeEl.offsetParent == null) return "detached";
		const newSize = sizeEl.offsetWidth;
		if (newSize === NO_VALUE_SENTINEL) return "no-styles";
		this.sizesMeasured = true;
		return newSize;
	}
	getMeasurementContainer() {
		let container = this.eMeasurementContainer;
		if (!container) {
			container = this.eMeasurementContainer = _createElement({
				tag: "div",
				cls: "ag-measurement-container"
			});
			this.eGridDiv.appendChild(container);
		}
		return container;
	}
	getSizeEl(variable) {
		let sizeEl = this.sizeEls.get(variable);
		if (sizeEl) return sizeEl;
		const container = this.getMeasurementContainer();
		sizeEl = _createElement({ tag: "div" });
		const { border, noWarn } = variable;
		if (border) {
			sizeEl.className = "ag-measurement-element-border";
			sizeEl.style.setProperty("--ag-internal-measurement-border", `var(${variable.cssName}, solid ${NO_VALUE_SENTINEL}px)`);
		} else sizeEl.style.width = `var(${variable.cssName}, ${NO_VALUE_SENTINEL}px)`;
		container.appendChild(sizeEl);
		this.sizeEls.set(variable, sizeEl);
		let lastMeasurement = this.measureSizeEl(variable);
		if (lastMeasurement === "no-styles" && !noWarn) _warn(9, { variable });
		const unsubscribe = _observeResize(this.beans, sizeEl, () => {
			const newMeasurement = this.measureSizeEl(variable);
			if (newMeasurement === "detached" || newMeasurement === "no-styles") return;
			this.lastKnownValues.set(variable, newMeasurement);
			if (newMeasurement !== lastMeasurement) {
				lastMeasurement = newMeasurement;
				this.fireGridStylesChangedEvent(variable.changeKey);
			}
		});
		this.addDestroyFunc(() => unsubscribe());
		return sizeEl;
	}
	fireGridStylesChangedEvent(change) {
		if (change === "rowBorderWidthChanged") this.refreshRowBorderWidthVariable();
		this.eventSvc.dispatchEvent({
			type: "gridStylesChanged",
			[change]: true
		});
	}
	refreshRowBorderWidthVariable() {
		const width = this.getCSSVariablePixelValue(ROW_BORDER_WIDTH);
		this.eGridDiv.style.setProperty("--ag-internal-row-border-width", `${width}px`);
	}
	handleThemeGridOptionChange() {
		const { gos, eGridDiv, globalCSS, gridTheme: oldGridTheme } = this;
		const themeGridOption = gos.get("theme");
		let newGridTheme;
		if (themeGridOption === "legacy") newGridTheme = void 0;
		else {
			const themeOrDefault = themeGridOption ?? themeQuartz;
			if (themeOrDefault instanceof ThemeImpl) newGridTheme = themeOrDefault;
			else _error(240, { theme: themeOrDefault });
		}
		if (newGridTheme !== oldGridTheme) {
			if (newGridTheme) {
				_registerGridUsingThemingAPI(this);
				_injectCoreAndModuleCSS(this.eStyleContainer, this.cssLayer, this.styleNonce);
				for (const [css, debugId] of globalCSS) _injectGlobalCSS(css, this.eStyleContainer, debugId, this.cssLayer, 0, this.styleNonce);
				globalCSS.length = 0;
			}
			this.gridTheme = newGridTheme;
			newGridTheme?._startUse({
				loadThemeGoogleFonts: gos.get("loadThemeGoogleFonts"),
				styleContainer: this.eStyleContainer,
				cssLayer: this.cssLayer,
				nonce: this.styleNonce
			});
			let eParamsStyle = this.eParamsStyle;
			if (!eParamsStyle) {
				eParamsStyle = this.eParamsStyle = _createElement({ tag: "style" });
				const styleNonce = this.gos.get("styleNonce");
				if (styleNonce) eParamsStyle.setAttribute("nonce", styleNonce);
				eGridDiv.appendChild(eParamsStyle);
			}
			if (!IS_SSR) eParamsStyle.textContent = newGridTheme?._getPerGridCss(this.paramsClass) || "";
			this.applyThemeClasses(eGridDiv);
			this.fireGridStylesChangedEvent("themeChanged");
		}
		if (newGridTheme && getComputedStyle(this.getMeasurementContainer()).getPropertyValue("--ag-legacy-styles-loaded")) if (themeGridOption) _error(106);
		else _error(239);
	}
};
var NO_VALUE_SENTINEL = 15538;
var EventService = class extends BeanStub {
	constructor() {
		super(...arguments);
		this.beanName = "eventSvc";
		this.globalSvc = new LocalEventService();
	}
	postConstruct() {
		const { globalListener, globalSyncListener } = this.beans;
		if (globalListener) this.addGlobalListener(globalListener, true);
		if (globalSyncListener) this.addGlobalListener(globalSyncListener, false);
	}
	addEventListener(eventType, listener, async) {
		this.globalSvc.addEventListener(eventType, listener, async);
	}
	removeEventListener(eventType, listener, async) {
		this.globalSvc.removeEventListener(eventType, listener, async);
	}
	addGlobalListener(listener, async = false) {
		this.globalSvc.addGlobalListener(listener, async);
	}
	removeGlobalListener(listener, async = false) {
		this.globalSvc.removeGlobalListener(listener, async);
	}
	dispatchLocalEvent() {}
	dispatchEvent(event) {
		this.globalSvc.dispatchEvent(_addGridCommonParams(this.gos, event));
	}
	dispatchEventOnce(event) {
		this.globalSvc.dispatchEventOnce(_addGridCommonParams(this.gos, event));
	}
};
function getHeaderIndexToFocus(beans, column, level) {
	const columnRowIndex = beans.visibleCols.headerGroupRowCount;
	if (level >= columnRowIndex) return {
		column,
		headerRowIndex: level
	};
	let parent = column.getParent();
	while (parent && parent.getProvidedColumnGroup().getLevel() > level) parent = parent.getParent();
	const isColSpanning = column.isSpanHeaderHeight();
	if (!parent || isColSpanning && parent.isPadding()) return {
		column,
		headerRowIndex: columnRowIndex
	};
	return {
		column: parent,
		headerRowIndex: parent.getProvidedColumnGroup().getLevel()
	};
}
var HeaderNavigationService = class extends BeanStub {
	constructor() {
		super(...arguments);
		this.beanName = "headerNavigation";
		this.currentHeaderRowWithoutSpan = -1;
	}
	postConstruct() {
		const beans = this.beans;
		beans.ctrlsSvc.whenReady(this, (p) => {
			this.gridBodyCon = p.gridBodyCtrl;
		});
		const eDocument = _getDocument(beans);
		this.addManagedElementListeners(eDocument, { mousedown: () => {
			this.currentHeaderRowWithoutSpan = -1;
		} });
	}
	getHeaderPositionForColumn(colKey, floatingFilter) {
		let column;
		const { colModel, colGroupSvc, ctrlsSvc } = this.beans;
		if (typeof colKey === "string") {
			column = colModel.getCol(colKey);
			if (!column) column = colGroupSvc?.getColumnGroup(colKey) ?? null;
		} else column = colKey;
		if (!column) return null;
		const allCtrls = ctrlsSvc.getHeaderRowContainerCtrl()?.getAllCtrls();
		const isFloatingFilterVisible = _last(allCtrls || []).type === "filter";
		const headerRowCount = getFocusHeaderRowCount(this.beans) - 1;
		let row = -1;
		let col = column;
		while (col) {
			row++;
			col = col.getParent();
		}
		let headerRowIndex = row;
		if (floatingFilter && isFloatingFilterVisible && headerRowIndex === headerRowCount - 1) headerRowIndex++;
		return headerRowIndex === -1 ? null : {
			headerRowIndex,
			column
		};
	}
	navigateVertically(direction, event) {
		const { focusSvc, visibleCols } = this.beans;
		const { focusedHeader } = focusSvc;
		if (!focusedHeader) return false;
		const { headerRowIndex } = focusedHeader;
		const column = focusedHeader.column;
		const rowLen = getFocusHeaderRowCount(this.beans);
		const currentRowType = this.getHeaderRowType(headerRowIndex);
		const columnHeaderRowIndex = visibleCols.headerGroupRowCount;
		let { headerRowIndex: nextRow, column: nextFocusColumn, headerRowIndexWithoutSpan } = direction === "UP" ? getColumnVisibleParent(currentRowType, column, headerRowIndex) : getColumnVisibleChild(column, headerRowIndex, columnHeaderRowIndex);
		let skipColumn = false;
		if (nextRow < 0) {
			nextRow = 0;
			nextFocusColumn = column;
			skipColumn = true;
		}
		if (nextRow >= rowLen) {
			nextRow = -1;
			this.currentHeaderRowWithoutSpan = -1;
		} else if (headerRowIndexWithoutSpan !== void 0) this.currentHeaderRowWithoutSpan = headerRowIndexWithoutSpan;
		if (!skipColumn && !nextFocusColumn) return false;
		return focusSvc.focusHeaderPosition({
			headerPosition: {
				headerRowIndex: nextRow,
				column: nextFocusColumn
			},
			allowUserOverride: true,
			event
		});
	}
	navigateHorizontally(direction, fromTab = false, event) {
		const { focusSvc, gos } = this.beans;
		const focusedHeader = { ...focusSvc.focusedHeader };
		let nextHeader;
		let normalisedDirection;
		if (this.currentHeaderRowWithoutSpan !== -1) focusedHeader.headerRowIndex = this.currentHeaderRowWithoutSpan;
		else this.currentHeaderRowWithoutSpan = focusedHeader.headerRowIndex;
		if (direction === "LEFT" !== gos.get("enableRtl")) {
			normalisedDirection = "Before";
			nextHeader = this.findHeader(focusedHeader, normalisedDirection);
		} else {
			normalisedDirection = "After";
			nextHeader = this.findHeader(focusedHeader, normalisedDirection);
		}
		const userFunc = gos.getCallback("tabToNextHeader");
		if (fromTab && userFunc) {
			const wasFocusedFromUserFunc = focusSvc.focusHeaderPositionFromUserFunc({
				userFunc,
				headerPosition: nextHeader,
				direction: normalisedDirection
			});
			if (wasFocusedFromUserFunc) {
				const { headerRowIndex } = focusSvc.focusedHeader || {};
				if (headerRowIndex != null && headerRowIndex != focusedHeader.headerRowIndex) this.currentHeaderRowWithoutSpan = headerRowIndex;
			}
			return wasFocusedFromUserFunc;
		}
		if (nextHeader || !fromTab) return focusSvc.focusHeaderPosition({
			headerPosition: nextHeader,
			direction: normalisedDirection,
			fromTab,
			allowUserOverride: true,
			event
		});
		return this.focusNextHeaderRow(focusedHeader, normalisedDirection, event);
	}
	focusNextHeaderRow(focusedHeader, direction, event) {
		const beans = this.beans;
		const currentIndex = focusedHeader.headerRowIndex;
		let nextFocusedCol = null;
		let nextRowIndex;
		const headerRowCount = getFocusHeaderRowCount(beans);
		const allVisibleCols = this.beans.visibleCols.allCols;
		if (direction === "Before") {
			if (currentIndex <= 0) return false;
			nextFocusedCol = _last(allVisibleCols);
			nextRowIndex = currentIndex - 1;
			this.currentHeaderRowWithoutSpan -= 1;
		} else {
			nextFocusedCol = allVisibleCols[0];
			nextRowIndex = currentIndex + 1;
			if (this.currentHeaderRowWithoutSpan < headerRowCount) this.currentHeaderRowWithoutSpan += 1;
			else this.currentHeaderRowWithoutSpan = -1;
		}
		let { column, headerRowIndex } = getHeaderIndexToFocus(this.beans, nextFocusedCol, nextRowIndex);
		if (headerRowIndex >= headerRowCount) headerRowIndex = -1;
		return beans.focusSvc.focusHeaderPosition({
			headerPosition: {
				column,
				headerRowIndex
			},
			direction,
			fromTab: true,
			allowUserOverride: true,
			event
		});
	}
	scrollToColumn(column, direction = "After") {
		if (column.getPinned()) return;
		let columnToScrollTo;
		if (isColumnGroup(column)) {
			const columns = column.getDisplayedLeafColumns();
			columnToScrollTo = direction === "Before" ? _last(columns) : columns[0];
		} else columnToScrollTo = column;
		this.gridBodyCon.scrollFeature.ensureColumnVisible(columnToScrollTo);
	}
	findHeader(focusedHeader, direction) {
		const { colGroupSvc, visibleCols } = this.beans;
		let currentFocusedColumn = focusedHeader.column;
		if (currentFocusedColumn instanceof AgColumnGroup) {
			const leafChildren = currentFocusedColumn.getDisplayedLeafColumns();
			currentFocusedColumn = direction === "Before" ? leafChildren[0] : leafChildren[leafChildren.length - 1];
		}
		const nextFocusedCol = direction === "Before" ? visibleCols.getColBefore(currentFocusedColumn) : visibleCols.getColAfter(currentFocusedColumn);
		if (!nextFocusedCol) return;
		const headerGroupRowIndex = visibleCols.headerGroupRowCount;
		if (focusedHeader.headerRowIndex >= headerGroupRowIndex) return {
			headerRowIndex: focusedHeader.headerRowIndex,
			column: nextFocusedCol
		};
		const groupAtLevel = colGroupSvc?.getColGroupAtLevel(nextFocusedCol, focusedHeader.headerRowIndex);
		if (!groupAtLevel) return {
			headerRowIndex: nextFocusedCol instanceof AgColumn && nextFocusedCol.isSpanHeaderHeight() ? visibleCols.headerGroupRowCount : focusedHeader.headerRowIndex,
			column: nextFocusedCol
		};
		if (groupAtLevel.isPadding() && nextFocusedCol.isSpanHeaderHeight()) return {
			headerRowIndex: visibleCols.headerGroupRowCount,
			column: nextFocusedCol
		};
		return {
			headerRowIndex: focusedHeader.headerRowIndex,
			column: groupAtLevel ?? nextFocusedCol
		};
	}
	getHeaderRowType(rowIndex) {
		const centerHeaderContainer = this.beans.ctrlsSvc.getHeaderRowContainerCtrl();
		if (centerHeaderContainer) return centerHeaderContainer.getRowType(rowIndex);
	}
};
function getColumnVisibleParent(currentRowType, currentColumn, currentIndex) {
	const optimisticNextIndex = currentIndex - 1;
	if (currentRowType !== "filter") {
		const isSpanningCol = currentColumn instanceof AgColumn && currentColumn.isSpanHeaderHeight();
		let nextVisibleParent = currentColumn.getParent();
		while (nextVisibleParent && (nextVisibleParent.getProvidedColumnGroup().getLevel() > optimisticNextIndex || isSpanningCol && nextVisibleParent.isPadding())) nextVisibleParent = nextVisibleParent.getParent();
		if (nextVisibleParent) if (isSpanningCol) return {
			column: nextVisibleParent,
			headerRowIndex: nextVisibleParent.getProvidedColumnGroup().getLevel(),
			headerRowIndexWithoutSpan: optimisticNextIndex
		};
		else return {
			column: nextVisibleParent,
			headerRowIndex: optimisticNextIndex,
			headerRowIndexWithoutSpan: optimisticNextIndex
		};
	}
	return {
		column: currentColumn,
		headerRowIndex: optimisticNextIndex,
		headerRowIndexWithoutSpan: optimisticNextIndex
	};
}
function getColumnVisibleChild(column, currentIndex, columnHeaderRowIndex) {
	const optimisticNextIndex = currentIndex + 1;
	const result = {
		column,
		headerRowIndex: optimisticNextIndex,
		headerRowIndexWithoutSpan: optimisticNextIndex
	};
	if (column instanceof AgColumnGroup) {
		if (optimisticNextIndex >= columnHeaderRowIndex) return {
			column: column.getDisplayedLeafColumns()[0],
			headerRowIndex: columnHeaderRowIndex,
			headerRowIndexWithoutSpan: optimisticNextIndex
		};
		let firstChild = column.getDisplayedChildren()[0];
		if (firstChild instanceof AgColumnGroup && firstChild.isPadding()) {
			const firstCol = firstChild.getDisplayedLeafColumns()[0];
			if (firstCol.isSpanHeaderHeight()) firstChild = firstCol;
		}
		result.column = firstChild;
		if (firstChild instanceof AgColumn && firstChild.isSpanHeaderHeight()) {
			result.headerRowIndex = columnHeaderRowIndex;
			result.headerRowIndexWithoutSpan = optimisticNextIndex;
		}
	}
	return result;
}
var FocusService = class extends BeanStub {
	constructor() {
		super(...arguments);
		this.beanName = "focusSvc";
		this.focusFallbackTimeout = null;
		this.needsFocusRestored = false;
	}
	wireBeans(beans) {
		this.colModel = beans.colModel;
		this.visibleCols = beans.visibleCols;
		this.rowRenderer = beans.rowRenderer;
		this.navigation = beans.navigation;
		this.filterManager = beans.filterManager;
		this.overlays = beans.overlays;
	}
	postConstruct() {
		const clearFocusedCellListener = this.clearFocusedCell.bind(this);
		this.addManagedEventListeners({
			columnPivotModeChanged: clearFocusedCellListener,
			newColumnsLoaded: this.onColumnEverythingChanged.bind(this),
			columnGroupOpened: clearFocusedCellListener,
			columnRowGroupChanged: clearFocusedCellListener
		});
		this.addDestroyFunc(_registerKeyboardFocusEvents(this.beans));
	}
	attemptToRecoverFocus() {
		this.needsFocusRestored = true;
		if (this.focusFallbackTimeout != null) clearTimeout(this.focusFallbackTimeout);
		this.focusFallbackTimeout = window.setTimeout(this.setFocusRecovered.bind(this), 100);
	}
	setFocusRecovered() {
		this.needsFocusRestored = false;
		if (this.focusFallbackTimeout != null) {
			clearTimeout(this.focusFallbackTimeout);
			this.focusFallbackTimeout = null;
		}
	}
	shouldTakeFocus() {
		if (this.gos.get("suppressFocusAfterRefresh")) {
			this.setFocusRecovered();
			return false;
		}
		if (this.needsFocusRestored) {
			this.setFocusRecovered();
			return true;
		}
		return this.doesRowOrCellHaveBrowserFocus();
	}
	onColumnEverythingChanged() {
		if (!this.focusedCell) return;
		const col = this.focusedCell.column;
		if (col !== this.colModel.getCol(col.getId())) this.clearFocusedCell();
	}
	getFocusCellToUseAfterRefresh() {
		const { gos, focusedCell } = this;
		if (gos.get("suppressFocusAfterRefresh") || gos.get("suppressCellFocus") || !focusedCell) return null;
		if (!this.doesRowOrCellHaveBrowserFocus()) return null;
		return focusedCell;
	}
	getFocusHeaderToUseAfterRefresh() {
		if (this.gos.get("suppressFocusAfterRefresh") || !this.focusedHeader) return null;
		if (!this.isDomDataPresentInHierarchy(_getActiveDomElement(this.beans), DOM_DATA_KEY_HEADER_CTRL)) return null;
		return this.focusedHeader;
	}
	doesRowOrCellHaveBrowserFocus() {
		const activeElement = _getActiveDomElement(this.beans);
		if (this.isDomDataPresentInHierarchy(activeElement, DOM_DATA_KEY_CELL_CTRL)) return true;
		return this.isDomDataPresentInHierarchy(activeElement, DOM_DATA_KEY_ROW_CTRL);
	}
	isDomDataPresentInHierarchy(eBrowserCell, key) {
		let ePointer = eBrowserCell;
		while (ePointer) {
			if (_getDomData(this.gos, ePointer, key)) return true;
			ePointer = ePointer.parentNode;
		}
		return false;
	}
	getFocusedCell() {
		return this.focusedCell;
	}
	getFocusEventParams(focusedCellPosition) {
		const { rowIndex, rowPinned, column } = focusedCellPosition;
		const params = {
			rowIndex,
			rowPinned,
			column,
			isFullWidthCell: false
		};
		const rowCtrl = this.rowRenderer.getRowByPosition({
			rowIndex,
			rowPinned
		});
		if (rowCtrl) params.isFullWidthCell = rowCtrl.isFullWidth();
		return params;
	}
	clearFocusedCell() {
		if (this.focusedCell == null) return;
		const focusEventParams = this.getFocusEventParams(this.focusedCell);
		this.focusedCell = null;
		this.eventSvc.dispatchEvent({
			type: "cellFocusCleared",
			...focusEventParams
		});
	}
	setFocusedCell(params) {
		this.setFocusRecovered();
		const { column, rowIndex, rowPinned, forceBrowserFocus = false, preventScrollOnBrowserFocus = false, sourceEvent } = params;
		const gridColumn = this.colModel.getCol(column);
		if (!gridColumn) {
			this.focusedCell = null;
			return;
		}
		this.focusedCell = {
			rowIndex,
			rowPinned: _makeNull(rowPinned),
			column: gridColumn
		};
		const focusEventParams = this.getFocusEventParams(this.focusedCell);
		this.eventSvc.dispatchEvent({
			type: "cellFocused",
			...focusEventParams,
			...this.previousCellFocusParams && { previousParams: this.previousCellFocusParams },
			forceBrowserFocus,
			preventScrollOnBrowserFocus,
			sourceEvent
		});
		this.previousCellFocusParams = focusEventParams;
	}
	isCellFocused(cellPosition) {
		if (this.focusedCell == null) return false;
		return _areCellsEqual(cellPosition, this.focusedCell);
	}
	isHeaderWrapperFocused(headerCtrl) {
		if (this.focusedHeader == null) return false;
		const { column, rowCtrl: { rowIndex: headerRowIndex, pinned } } = headerCtrl;
		const { column: focusedColumn, headerRowIndex: focusedHeaderRowIndex } = this.focusedHeader;
		return column === focusedColumn && headerRowIndex === focusedHeaderRowIndex && pinned == focusedColumn.getPinned();
	}
	focusHeaderPosition(params) {
		this.setFocusRecovered();
		if (_isHeaderFocusSuppressed(this.beans)) return false;
		const { direction, fromTab, allowUserOverride, event, fromCell, rowWithoutSpanValue } = params;
		let { headerPosition } = params;
		if (fromCell && this.filterManager?.isAdvFilterHeaderActive()) return this.focusAdvancedFilter(headerPosition);
		if (allowUserOverride) {
			const currentPosition = this.focusedHeader;
			const headerRowCount = getFocusHeaderRowCount(this.beans);
			if (fromTab) {
				const userFunc = this.gos.getCallback("tabToNextHeader");
				if (userFunc) headerPosition = this.getHeaderPositionFromUserFunc({
					userFunc,
					direction,
					currentPosition,
					headerPosition,
					headerRowCount
				});
			} else {
				const userFunc = this.gos.getCallback("navigateToNextHeader");
				if (userFunc && event) headerPosition = userFunc({
					key: event.key,
					previousHeaderPosition: currentPosition,
					nextHeaderPosition: headerPosition,
					headerRowCount,
					event
				});
			}
		}
		if (!headerPosition) return false;
		return this.focusProvidedHeaderPosition({
			headerPosition,
			direction,
			event,
			fromCell,
			rowWithoutSpanValue
		});
	}
	focusHeaderPositionFromUserFunc(params) {
		if (_isHeaderFocusSuppressed(this.beans)) return false;
		const { userFunc, headerPosition, direction, event } = params;
		const currentPosition = this.focusedHeader;
		const headerRowCount = getFocusHeaderRowCount(this.beans);
		const newHeaderPosition = this.getHeaderPositionFromUserFunc({
			userFunc,
			direction,
			currentPosition,
			headerPosition,
			headerRowCount
		});
		return !!newHeaderPosition && this.focusProvidedHeaderPosition({
			headerPosition: newHeaderPosition,
			direction,
			event
		});
	}
	getHeaderPositionFromUserFunc(params) {
		const { userFunc, direction, currentPosition, headerPosition, headerRowCount } = params;
		const userResult = userFunc({
			backwards: direction === "Before",
			previousHeaderPosition: currentPosition,
			nextHeaderPosition: headerPosition,
			headerRowCount
		});
		if (userResult === true) return currentPosition;
		if (userResult === false) return null;
		return userResult;
	}
	focusProvidedHeaderPosition(params) {
		const { headerPosition, direction, fromCell, rowWithoutSpanValue, event } = params;
		const { column, headerRowIndex } = headerPosition;
		const { filterManager, ctrlsSvc, headerNavigation } = this.beans;
		if (headerRowIndex === -1) {
			if (filterManager?.isAdvFilterHeaderActive()) return this.focusAdvancedFilter(headerPosition);
			return this.focusGridView({
				column,
				event
			});
		}
		headerNavigation?.scrollToColumn(column, direction);
		const focusSuccess = ctrlsSvc.getHeaderRowContainerCtrl(column.getPinned())?.focusHeader(headerPosition.headerRowIndex, column, event) || false;
		if (headerNavigation && focusSuccess && (rowWithoutSpanValue != null || fromCell)) headerNavigation.currentHeaderRowWithoutSpan = rowWithoutSpanValue ?? -1;
		return focusSuccess;
	}
	focusFirstHeader() {
		if (this.overlays?.isExclusive() && this.focusOverlay()) return true;
		const firstColumn = this.visibleCols.allCols[0];
		if (!firstColumn) return false;
		const headerPosition = getHeaderIndexToFocus(this.beans, firstColumn, 0);
		return this.focusHeaderPosition({
			headerPosition,
			rowWithoutSpanValue: 0
		});
	}
	focusLastHeader(event) {
		if (this.overlays?.isExclusive() && this.focusOverlay(true)) return true;
		const headerRowIndex = getFocusHeaderRowCount(this.beans) - 1;
		const column = _last(this.visibleCols.allCols);
		return this.focusHeaderPosition({
			headerPosition: {
				headerRowIndex,
				column
			},
			rowWithoutSpanValue: -1,
			event
		});
	}
	focusPreviousFromFirstCell(event) {
		if (this.filterManager?.isAdvFilterHeaderActive()) return this.focusAdvancedFilter(null);
		return this.focusLastHeader(event);
	}
	isAnyCellFocused() {
		return !!this.focusedCell;
	}
	isRowFocused(rowIndex, rowPinnedType) {
		if (this.focusedCell == null) return false;
		return this.focusedCell.rowIndex === rowIndex && this.focusedCell.rowPinned === _makeNull(rowPinnedType);
	}
	focusOverlay(backwards) {
		const overlayGui = this.overlays?.isVisible() && this.overlays.eWrapper?.getGui();
		return !!overlayGui && _focusInto(overlayGui, backwards);
	}
	focusGridView(params) {
		const { backwards = false, canFocusOverlay = true, event } = params;
		if (this.overlays?.isExclusive()) return canFocusOverlay && this.focusOverlay(backwards);
		if (_isCellFocusSuppressed(this.beans)) {
			if (backwards) {
				if (!_isHeaderFocusSuppressed(this.beans)) return this.focusLastHeader();
			}
			if (canFocusOverlay && this.focusOverlay(backwards)) return true;
			if (backwards) return false;
			return _focusNextGridCoreContainer(this.beans, backwards);
		}
		const nextRow = backwards ? _getLastRow(this.beans) : _getFirstRow(this.beans);
		if (nextRow) {
			const column = params.column ?? this.focusedHeader?.column;
			const { rowIndex, rowPinned } = nextRow;
			const rowNode = _getRowNode(this.beans, nextRow);
			if (!column || !rowNode || rowIndex == null) return false;
			if (column.isSuppressNavigable(rowNode)) {
				const isRtl = this.gos.get("enableRtl");
				let key;
				if (!event || event.key === KeyCode.TAB) key = isRtl ? KeyCode.LEFT : KeyCode.RIGHT;
				else key = event.key;
				this.beans.navigation?.navigateToNextCell(null, key, {
					rowIndex,
					column,
					rowPinned: rowPinned || null
				}, true);
				return true;
			}
			this.navigation?.ensureCellVisible({
				rowIndex,
				column,
				rowPinned
			});
			if (backwards) {
				if (this.rowRenderer.getRowByPosition(nextRow)?.isFullWidth() && this.navigation?.tryToFocusFullWidthRow(nextRow, backwards)) return true;
			}
			this.setFocusedCell({
				rowIndex,
				column,
				rowPinned: _makeNull(rowPinned),
				forceBrowserFocus: true
			});
			this.beans.rangeSvc?.setRangeToCell({
				rowIndex,
				rowPinned,
				column
			});
			return true;
		}
		if (canFocusOverlay && this.focusOverlay(backwards)) return true;
		if (backwards && this.focusLastHeader()) return true;
		return false;
	}
	focusAdvancedFilter(position) {
		this.advFilterFocusColumn = position?.column;
		return this.beans.advancedFilter?.getCtrl().focusHeaderComp() ?? false;
	}
	focusNextFromAdvancedFilter(backwards, forceFirstColumn) {
		const column = (forceFirstColumn ? void 0 : this.advFilterFocusColumn) ?? this.visibleCols.allCols?.[0];
		if (backwards) return this.focusHeaderPosition({ headerPosition: {
			column,
			headerRowIndex: getFocusHeaderRowCount(this.beans) - 1
		} });
		else return this.focusGridView({ column });
	}
	clearAdvancedFilterColumn() {
		this.advFilterFocusColumn = void 0;
	}
};
var ScrollVisibleService = class extends BeanStub {
	constructor() {
		super(...arguments);
		this.beanName = "scrollVisibleSvc";
	}
	wireBeans(beans) {
		this.ctrlsSvc = beans.ctrlsSvc;
		this.colAnimation = beans.colAnimation;
	}
	postConstruct() {
		this.getScrollbarWidth();
		this.addManagedEventListeners({
			displayedColumnsChanged: this.updateScrollVisible.bind(this),
			displayedColumnsWidthChanged: this.updateScrollVisible.bind(this)
		});
	}
	updateScrollVisible() {
		const { colAnimation } = this;
		if (colAnimation?.isActive()) colAnimation.executeLaterVMTurn(() => {
			colAnimation.executeLaterVMTurn(() => this.updateScrollVisibleImpl());
		});
		else this.updateScrollVisibleImpl();
	}
	updateScrollVisibleImpl() {
		const centerRowCtrl = this.ctrlsSvc.get("center");
		if (!centerRowCtrl || this.colAnimation?.isActive()) return;
		const params = {
			horizontalScrollShowing: centerRowCtrl.isHorizontalScrollShowing(),
			verticalScrollShowing: this.verticalScrollShowing
		};
		this.setScrollsVisible(params);
		this.updateScrollGap();
	}
	updateScrollGap() {
		const centerRowCtrl = this.ctrlsSvc.get("center");
		const horizontalGap = centerRowCtrl.hasHorizontalScrollGap();
		const verticalGap = centerRowCtrl.hasVerticalScrollGap();
		if (this.horizontalScrollGap !== horizontalGap || this.verticalScrollGap !== verticalGap) {
			this.horizontalScrollGap = horizontalGap;
			this.verticalScrollGap = verticalGap;
			this.eventSvc.dispatchEvent({ type: "scrollGapChanged" });
		}
	}
	setScrollsVisible(params) {
		if (this.horizontalScrollShowing !== params.horizontalScrollShowing || this.verticalScrollShowing !== params.verticalScrollShowing) {
			this.horizontalScrollShowing = params.horizontalScrollShowing;
			this.verticalScrollShowing = params.verticalScrollShowing;
			this.eventSvc.dispatchEvent({ type: "scrollVisibilityChanged" });
		}
	}
	getScrollbarWidth() {
		if (this.scrollbarWidth == null) {
			const gridOptionsScrollbarWidth = this.gos.get("scrollbarWidth");
			const scrollbarWidth = typeof gridOptionsScrollbarWidth === "number" && gridOptionsScrollbarWidth >= 0 ? gridOptionsScrollbarWidth : _getScrollbarWidth();
			if (scrollbarWidth != null) {
				this.scrollbarWidth = scrollbarWidth;
				this.eventSvc.dispatchEvent({ type: "scrollbarWidthChanged" });
			}
		}
		return this.scrollbarWidth;
	}
};
var GridDestroyService = class extends BeanStub {
	constructor() {
		super(...arguments);
		this.beanName = "gridDestroySvc";
		this.destroyCalled = false;
	}
	destroy() {
		if (this.destroyCalled) return;
		const { stateSvc, ctrlsSvc, context } = this.beans;
		this.eventSvc.dispatchEvent({
			type: "gridPreDestroyed",
			state: stateSvc?.getState() ?? {}
		});
		this.destroyCalled = true;
		ctrlsSvc.get("gridCtrl")?.destroyGridUi();
		context.destroy();
		super.destroy();
	}
};
var ALWAYS_SYNC_GLOBAL_EVENTS = /* @__PURE__ */ new Set([
	"gridPreDestroyed",
	"fillStart",
	"pasteStart"
]);
var _PUBLIC_EVENT_HANDLERS_MAP = [
	"columnEverythingChanged",
	"newColumnsLoaded",
	"columnPivotModeChanged",
	"pivotMaxColumnsExceeded",
	"columnRowGroupChanged",
	"expandOrCollapseAll",
	"columnPivotChanged",
	"gridColumnsChanged",
	"columnValueChanged",
	"columnMoved",
	"columnVisible",
	"columnPinned",
	"columnGroupOpened",
	"columnResized",
	"displayedColumnsChanged",
	"virtualColumnsChanged",
	"columnHeaderMouseOver",
	"columnHeaderMouseLeave",
	"columnHeaderClicked",
	"columnHeaderContextMenu",
	"asyncTransactionsFlushed",
	"rowGroupOpened",
	"rowDataUpdated",
	"pinnedRowDataChanged",
	"pinnedRowsChanged",
	"rangeSelectionChanged",
	"cellSelectionChanged",
	"chartCreated",
	"chartRangeSelectionChanged",
	"chartOptionsChanged",
	"chartDestroyed",
	"toolPanelVisibleChanged",
	"toolPanelSizeChanged",
	"modelUpdated",
	"cutStart",
	"cutEnd",
	"pasteStart",
	"pasteEnd",
	"fillStart",
	"fillEnd",
	"cellSelectionDeleteStart",
	"cellSelectionDeleteEnd",
	"rangeDeleteStart",
	"rangeDeleteEnd",
	"undoStarted",
	"undoEnded",
	"redoStarted",
	"redoEnded",
	"cellClicked",
	"cellDoubleClicked",
	"cellMouseDown",
	"cellContextMenu",
	"cellValueChanged",
	"cellEditRequest",
	"rowValueChanged",
	"headerFocused",
	"cellFocused",
	"rowSelected",
	"selectionChanged",
	"tooltipShow",
	"tooltipHide",
	"cellKeyDown",
	"cellMouseOver",
	"cellMouseOut",
	"filterChanged",
	"filterModified",
	"filterUiChanged",
	"filterOpened",
	"floatingFilterUiChanged",
	"advancedFilterBuilderVisibleChanged",
	"sortChanged",
	"virtualRowRemoved",
	"rowClicked",
	"rowDoubleClicked",
	"gridReady",
	"gridPreDestroyed",
	"gridSizeChanged",
	"viewportChanged",
	"firstDataRendered",
	"dragStarted",
	"dragStopped",
	"dragCancelled",
	"rowEditingStarted",
	"rowEditingStopped",
	"cellEditingStarted",
	"cellEditingStopped",
	"bodyScroll",
	"bodyScrollEnd",
	"paginationChanged",
	"componentStateChanged",
	"storeRefreshed",
	"stateUpdated",
	"columnMenuVisibleChanged",
	"contextMenuVisibleChanged",
	"rowDragEnter",
	"rowDragMove",
	"rowDragLeave",
	"rowDragEnd",
	"rowDragCancel",
	"findChanged",
	"rowResizeStarted",
	"rowResizeEnded",
	"columnsReset",
	"bulkEditingStarted",
	"bulkEditingStopped",
	"batchEditingStarted",
	"batchEditingStopped"
].reduce((mem, ev) => {
	mem[ev] = _getCallbackForEvent(ev);
	return mem;
}, {});
var makeIconParams = (dataRefSuffix, classSuffix) => ({
	tag: "span",
	ref: `eSort${dataRefSuffix}`,
	cls: `ag-sort-indicator-icon ag-sort-${classSuffix} ag-hidden`,
	attrs: { "aria-hidden": "true" }
});
var SortIndicatorElement = {
	tag: "span",
	cls: "ag-sort-indicator-container",
	children: [
		makeIconParams("Order", "order"),
		makeIconParams("Asc", "ascending-icon"),
		makeIconParams("Desc", "descending-icon"),
		makeIconParams("Mixed", "mixed-icon"),
		makeIconParams("None", "none-icon")
	]
};
var SortIndicatorComp = class extends Component {
	constructor(skipTemplate) {
		super();
		this.eSortOrder = null;
		this.eSortAsc = null;
		this.eSortDesc = null;
		this.eSortMixed = null;
		this.eSortNone = null;
		if (!skipTemplate) this.setTemplate(SortIndicatorElement);
	}
	attachCustomElements(eSortOrder, eSortAsc, eSortDesc, eSortMixed, eSortNone) {
		this.eSortOrder = eSortOrder;
		this.eSortAsc = eSortAsc;
		this.eSortDesc = eSortDesc;
		this.eSortMixed = eSortMixed;
		this.eSortNone = eSortNone;
	}
	setupSort(column, suppressOrder = false) {
		this.column = column;
		this.suppressOrder = suppressOrder;
		this.setupMultiSortIndicator();
		if (!column.isSortable() && !column.getColDef().showRowGroup) return;
		this.addInIcon("sortAscending", this.eSortAsc, column);
		this.addInIcon("sortDescending", this.eSortDesc, column);
		this.addInIcon("sortUnSort", this.eSortNone, column);
		const updateIcons = this.updateIcons.bind(this);
		const sortUpdated = this.onSortChanged.bind(this);
		this.addManagedPropertyListener("unSortIcon", updateIcons);
		this.addManagedEventListeners({
			newColumnsLoaded: updateIcons,
			sortChanged: sortUpdated,
			columnRowGroupChanged: sortUpdated
		});
		this.onSortChanged();
	}
	addInIcon(iconName, eParent, column) {
		if (eParent == null) return;
		const eIcon = _createIconNoSpan(iconName, this.beans, column);
		if (eIcon) eParent.appendChild(eIcon);
	}
	onSortChanged() {
		this.updateIcons();
		if (!this.suppressOrder) this.updateSortOrder();
	}
	updateIcons() {
		const { eSortAsc, eSortDesc, eSortNone, column, gos, beans } = this;
		const sortDirection = beans.sortSvc.getDisplaySortForColumn(column);
		if (eSortAsc) _setDisplayed(eSortAsc, sortDirection === "asc", { skipAriaHidden: true });
		if (eSortDesc) _setDisplayed(eSortDesc, sortDirection === "desc", { skipAriaHidden: true });
		if (eSortNone) _setDisplayed(eSortNone, !(!column.getColDef().unSortIcon && !gos.get("unSortIcon")) && (sortDirection === null || sortDirection === void 0), { skipAriaHidden: true });
	}
	setupMultiSortIndicator() {
		const { eSortMixed, column, gos } = this;
		this.addInIcon("sortUnSort", eSortMixed, column);
		const isColumnShowingRowGroup = column.getColDef().showRowGroup;
		if (_isColumnsSortingCoupledToGroup(gos) && isColumnShowingRowGroup) {
			this.addManagedEventListeners({
				sortChanged: this.updateMultiSortIndicator.bind(this),
				columnRowGroupChanged: this.updateMultiSortIndicator.bind(this)
			});
			this.updateMultiSortIndicator();
		}
	}
	updateMultiSortIndicator() {
		const { eSortMixed, beans, column } = this;
		if (eSortMixed) _setDisplayed(eSortMixed, beans.sortSvc.getDisplaySortForColumn(column) === "mixed", { skipAriaHidden: true });
	}
	updateSortOrder() {
		const { eSortOrder, column, beans: { sortSvc } } = this;
		if (!eSortOrder) return;
		const allColumnsWithSorting = sortSvc.getColumnsWithSortingOrdered();
		const indexThisCol = sortSvc.getDisplaySortIndexForColumn(column) ?? -1;
		const moreThanOneColSorting = allColumnsWithSorting.some((col) => sortSvc.getDisplaySortIndexForColumn(col) ?? false);
		_setDisplayed(eSortOrder, indexThisCol >= 0 && moreThanOneColSorting, { skipAriaHidden: true });
		if (indexThisCol >= 0) eSortOrder.textContent = (indexThisCol + 1).toString();
		else _clearElement(eSortOrder);
	}
};
var SortIndicatorSelector = {
	selector: "AG-SORT-INDICATOR",
	component: SortIndicatorComp
};
var DEFAULT_SORTING_ORDER = [
	"asc",
	"desc",
	null
];
var SortService = class extends BeanStub {
	constructor() {
		super(...arguments);
		this.beanName = "sortSvc";
	}
	progressSort(column, multiSort, source) {
		const nextDirection = this.getNextSortDirection(column);
		this.setSortForColumn(column, nextDirection, multiSort, source);
	}
	progressSortFromEvent(column, event) {
		const multiSort = this.gos.get("multiSortKey") === "ctrl" ? event.ctrlKey || event.metaKey : event.shiftKey;
		this.progressSort(column, multiSort, "uiColumnSorted");
	}
	setSortForColumn(column, sort, multiSort, source) {
		if (sort !== "asc" && sort !== "desc") sort = null;
		const { gos, showRowGroupCols } = this.beans;
		const isColumnsSortingCoupledToGroup = _isColumnsSortingCoupledToGroup(gos);
		let columnsToUpdate = [column];
		if (isColumnsSortingCoupledToGroup) {
			if (column.getColDef().showRowGroup) {
				const sortableRowGroupColumns = (showRowGroupCols?.getSourceColumnsForGroupColumn?.(column))?.filter((col) => col.isSortable());
				if (sortableRowGroupColumns) columnsToUpdate = [column, ...sortableRowGroupColumns];
			}
		}
		columnsToUpdate.forEach((col) => this.setColSort(col, sort, source));
		const doingMultiSort = (multiSort || gos.get("alwaysMultiSort")) && !gos.get("suppressMultiSort");
		const updatedColumns = [];
		if (!doingMultiSort) {
			const clearedColumns = this.clearSortBarTheseColumns(columnsToUpdate, source);
			updatedColumns.push(...clearedColumns);
		}
		this.updateSortIndex(column);
		updatedColumns.push(...columnsToUpdate);
		this.dispatchSortChangedEvents(source, updatedColumns);
	}
	updateSortIndex(lastColToChange) {
		const { gos, colModel, showRowGroupCols } = this.beans;
		const isCoupled = _isColumnsSortingCoupledToGroup(gos);
		const groupParent = showRowGroupCols?.getShowRowGroupCol(lastColToChange.getId());
		const lastSortIndexCol = isCoupled ? groupParent || lastColToChange : lastColToChange;
		const allSortedCols = this.getColumnsWithSortingOrdered();
		colModel.forAllCols((col) => this.setColSortIndex(col, null));
		const allSortedColsWithoutChangesOrGroups = allSortedCols.filter((col) => {
			if (isCoupled && col.getColDef().showRowGroup) return false;
			return col !== lastSortIndexCol;
		});
		(lastSortIndexCol.getSort() ? [...allSortedColsWithoutChangesOrGroups, lastSortIndexCol] : allSortedColsWithoutChangesOrGroups).forEach((col, idx) => this.setColSortIndex(col, idx));
	}
	onSortChanged(source, columns) {
		this.dispatchSortChangedEvents(source, columns);
	}
	isSortActive() {
		let isSorting = false;
		this.beans.colModel.forAllCols((col) => {
			if (col.getSort()) isSorting = true;
		});
		return isSorting;
	}
	dispatchSortChangedEvents(source, columns) {
		const event = {
			type: "sortChanged",
			source
		};
		if (columns) event.columns = columns;
		this.eventSvc.dispatchEvent(event);
	}
	clearSortBarTheseColumns(columnsToSkip, source) {
		const clearedColumns = [];
		this.beans.colModel.forAllCols((columnToClear) => {
			if (!columnsToSkip.includes(columnToClear)) {
				if (columnToClear.getSort()) clearedColumns.push(columnToClear);
				this.setColSort(columnToClear, void 0, source);
			}
		});
		return clearedColumns;
	}
	getNextSortDirection(column) {
		const sortingOrder = column.getColDef().sortingOrder ?? this.gos.get("sortingOrder") ?? DEFAULT_SORTING_ORDER;
		const currentIndex = sortingOrder.indexOf(column.getSort());
		const notInArray = currentIndex < 0;
		const lastItemInArray = currentIndex == sortingOrder.length - 1;
		return notInArray || lastItemInArray ? sortingOrder[0] : sortingOrder[currentIndex + 1];
	}
	getIndexedSortMap() {
		const { gos, colModel, showRowGroupCols, rowGroupColsSvc } = this.beans;
		let allSortedCols = [];
		colModel.forAllCols((col) => {
			if (col.getSort()) allSortedCols.push(col);
		});
		if (colModel.isPivotMode()) {
			const isSortingLinked = _isColumnsSortingCoupledToGroup(gos);
			allSortedCols = allSortedCols.filter((col) => {
				const isAggregated = !!col.getAggFunc();
				const isSecondary = !col.isPrimary();
				const isGroup = isSortingLinked ? showRowGroupCols?.getShowRowGroupCol(col.getId()) : col.getColDef().showRowGroup;
				return isAggregated || isSecondary || isGroup;
			});
		}
		const sortedRowGroupCols = rowGroupColsSvc?.columns.filter((col) => !!col.getSort()) ?? [];
		const allColsIndexes = {};
		allSortedCols.forEach((col, index) => allColsIndexes[col.getId()] = index);
		allSortedCols.sort((a, b) => {
			const iA = a.getSortIndex();
			const iB = b.getSortIndex();
			if (iA != null && iB != null) return iA - iB;
			else if (iA == null && iB == null) return allColsIndexes[a.getId()] > allColsIndexes[b.getId()] ? 1 : -1;
			else if (iB == null) return -1;
			else return 1;
		});
		const isSortLinked = _isColumnsSortingCoupledToGroup(gos) && !!sortedRowGroupCols.length;
		if (isSortLinked) allSortedCols = [...new Set(allSortedCols.map((col) => showRowGroupCols?.getShowRowGroupCol(col.getId()) ?? col))];
		const indexMap = /* @__PURE__ */ new Map();
		allSortedCols.forEach((col, idx) => indexMap.set(col, idx));
		if (isSortLinked) sortedRowGroupCols.forEach((col) => {
			const groupDisplayCol = showRowGroupCols.getShowRowGroupCol(col.getId());
			indexMap.set(col, indexMap.get(groupDisplayCol));
		});
		return indexMap;
	}
	getColumnsWithSortingOrdered() {
		return [...this.getIndexedSortMap().entries()].sort(([, idx1], [, idx2]) => idx1 - idx2).map(([col]) => col);
	}
	getSortModel() {
		return this.getColumnsWithSortingOrdered().filter((column) => column.getSort()).map((column) => ({
			sort: column.getSort(),
			colId: column.getId()
		}));
	}
	getSortOptions() {
		return this.getColumnsWithSortingOrdered().filter((column) => column.getSort()).map((column) => ({
			sort: column.getSort(),
			column
		}));
	}
	canColumnDisplayMixedSort(column) {
		const isColumnSortCouplingActive = _isColumnsSortingCoupledToGroup(this.gos);
		const isGroupDisplayColumn = !!column.getColDef().showRowGroup;
		return isColumnSortCouplingActive && isGroupDisplayColumn;
	}
	getDisplaySortForColumn(column) {
		const linkedColumns = this.beans.showRowGroupCols?.getSourceColumnsForGroupColumn(column);
		if (!this.canColumnDisplayMixedSort(column) || !linkedColumns?.length) return column.getSort();
		const sortableColumns = column.getColDef().field != null || !!column.getColDef().valueGetter ? [column, ...linkedColumns] : linkedColumns;
		const firstSort = sortableColumns[0].getSort();
		if (!sortableColumns.every((col) => col.getSort() == firstSort)) return "mixed";
		return firstSort;
	}
	getDisplaySortIndexForColumn(column) {
		return this.getIndexedSortMap().get(column);
	}
	setupHeader(comp, column, clickElement) {
		let lastMovingChanged = 0;
		comp.addManagedListeners(column, { movingChanged: () => {
			lastMovingChanged = Date.now();
		} });
		if (clickElement) comp.addManagedElementListeners(clickElement, { click: (event) => {
			const moving = column.isMoving();
			const movedRecently = Date.now() - lastMovingChanged < 50;
			if (!(moving || movedRecently)) this.progressSortFromEvent(column, event);
		} });
		const onSortingChanged = () => {
			const sort = column.getSort();
			comp.toggleCss("ag-header-cell-sorted-asc", sort === "asc");
			comp.toggleCss("ag-header-cell-sorted-desc", sort === "desc");
			comp.toggleCss("ag-header-cell-sorted-none", !sort);
			if (column.getColDef().showRowGroup) {
				const isMultiSorting = !(this.beans.showRowGroupCols?.getSourceColumnsForGroupColumn(column))?.every((sourceCol) => column.getSort() == sourceCol.getSort());
				comp.toggleCss("ag-header-cell-sorted-mixed", isMultiSorting);
			}
		};
		comp.addManagedEventListeners({
			sortChanged: onSortingChanged,
			columnRowGroupChanged: onSortingChanged
		});
	}
	initCol(column) {
		const { sort, initialSort, sortIndex, initialSortIndex } = column.colDef;
		if (sort !== void 0) {
			if (sort === "asc" || sort === "desc") column.sort = sort;
		} else if (initialSort === "asc" || initialSort === "desc") column.sort = initialSort;
		if (sortIndex !== void 0) {
			if (sortIndex !== null) column.sortIndex = sortIndex;
		} else if (initialSortIndex !== null) column.sortIndex = initialSortIndex;
	}
	updateColSort(column, sort, source) {
		if (sort !== void 0) if (sort === "desc" || sort === "asc") this.setColSort(column, sort, source);
		else this.setColSort(column, void 0, source);
	}
	setColSort(column, sort, source) {
		if (column.sort !== sort) {
			column.sort = sort;
			column.dispatchColEvent("sortChanged", source);
		}
		column.dispatchStateUpdatedEvent("sort");
	}
	setColSortIndex(column, sortOrder) {
		column.sortIndex = sortOrder;
		column.dispatchStateUpdatedEvent("sortIndex");
	}
	createSortIndicator(skipTemplate) {
		return new SortIndicatorComp(skipTemplate);
	}
	getSortIndicatorSelector() {
		return SortIndicatorSelector;
	}
};
var USER_COMP_MODULES = {
	agSetColumnFilter: "SetFilter",
	agSetColumnFloatingFilter: "SetFilter",
	agMultiColumnFilter: "MultiFilter",
	agMultiColumnFloatingFilter: "MultiFilter",
	agGroupColumnFilter: "GroupFilter",
	agGroupColumnFloatingFilter: "GroupFilter",
	agGroupCellRenderer: "GroupCellRenderer",
	agGroupRowRenderer: "GroupCellRenderer",
	agRichSelect: "RichSelect",
	agRichSelectCellEditor: "RichSelect",
	agDetailCellRenderer: "SharedMasterDetail",
	agSparklineCellRenderer: "Sparklines",
	agDragAndDropImage: "SharedDragAndDrop",
	agColumnHeader: "ColumnHeaderComp",
	agColumnGroupHeader: "ColumnGroupHeaderComp",
	agSortIndicator: "Sort",
	agAnimateShowChangeCellRenderer: "HighlightChanges",
	agAnimateSlideCellRenderer: "HighlightChanges",
	agLoadingCellRenderer: "LoadingCellRenderer",
	agSkeletonCellRenderer: "SkeletonCellRenderer",
	agCheckboxCellRenderer: "CheckboxCellRenderer",
	agLoadingOverlay: "Overlay",
	agNoRowsOverlay: "Overlay",
	agTooltipComponent: "Tooltip",
	agReadOnlyFloatingFilter: "CustomFilter",
	agTextColumnFilter: "TextFilter",
	agNumberColumnFilter: "NumberFilter",
	agDateColumnFilter: "DateFilter",
	agDateInput: "DateFilter",
	agTextColumnFloatingFilter: "TextFilter",
	agNumberColumnFloatingFilter: "NumberFilter",
	agDateColumnFloatingFilter: "DateFilter",
	agCellEditor: "TextEditor",
	agSelectCellEditor: "SelectEditor",
	agTextCellEditor: "TextEditor",
	agNumberCellEditor: "NumberEditor",
	agDateCellEditor: "DateEditor",
	agDateStringCellEditor: "DateEditor",
	agCheckboxCellEditor: "CheckboxEditor",
	agLargeTextCellEditor: "LargeTextEditor",
	agMenuItem: "MenuItem",
	agColumnsToolPanel: "ColumnsToolPanel",
	agFiltersToolPanel: "FiltersToolPanel",
	agNewFiltersToolPanel: "NewFiltersToolPanel",
	agAggregationComponent: "StatusBar",
	agSelectedRowCountComponent: "StatusBar",
	agTotalRowCountComponent: "StatusBar",
	agFilteredRowCountComponent: "StatusBar",
	agTotalAndFilteredRowCountComponent: "StatusBar",
	agFindCellRenderer: "Find"
};
var COLUMN_DEFINITION_DEPRECATIONS = () => ({
	checkboxSelection: {
		version: "32.2",
		message: "Use `rowSelection.checkboxes` in `GridOptions` instead."
	},
	headerCheckboxSelection: {
		version: "32.2",
		message: "Use `rowSelection.headerCheckbox = true` in `GridOptions` instead."
	},
	headerCheckboxSelectionFilteredOnly: {
		version: "32.2",
		message: "Use `rowSelection.selectAll = \"filtered\"` in `GridOptions` instead."
	},
	headerCheckboxSelectionCurrentPageOnly: {
		version: "32.2",
		message: "Use `rowSelection.selectAll = \"currentPage\"` in `GridOptions` instead."
	},
	showDisabledCheckboxes: {
		version: "32.2",
		message: "Use `rowSelection.hideDisabledCheckboxes = true` in `GridOptions` instead."
	}
});
var COLUMN_DEFINITION_MOD_VALIDATIONS = {
	aggFunc: "SharedAggregation",
	autoHeight: "RowAutoHeight",
	cellClass: "CellStyle",
	cellClassRules: "CellStyle",
	cellEditor: ({ cellEditor, editable }) => {
		if (!editable) return null;
		if (typeof cellEditor === "string") return USER_COMP_MODULES[cellEditor] ?? "CustomEditor";
		return "CustomEditor";
	},
	cellRenderer: ({ cellRenderer }) => {
		if (typeof cellRenderer !== "string") return null;
		return USER_COMP_MODULES[cellRenderer];
	},
	cellStyle: "CellStyle",
	columnChooserParams: "ColumnMenu",
	contextMenuItems: "ContextMenu",
	dndSource: "DragAndDrop",
	dndSourceOnRowDrag: "DragAndDrop",
	editable: ({ editable, cellEditor }) => {
		if (editable && !cellEditor) return "TextEditor";
		return null;
	},
	enableCellChangeFlash: "HighlightChanges",
	enablePivot: "SharedPivot",
	enableRowGroup: "SharedRowGrouping",
	enableValue: "SharedAggregation",
	filter: ({ filter }) => {
		if (filter && typeof filter !== "string" && typeof filter !== "boolean") return "CustomFilter";
		if (typeof filter === "string") return USER_COMP_MODULES[filter] ?? "ColumnFilter";
		return "ColumnFilter";
	},
	floatingFilter: "ColumnFilter",
	getQuickFilterText: "QuickFilter",
	headerTooltip: "Tooltip",
	mainMenuItems: "ColumnMenu",
	menuTabs: (options) => {
		const enterpriseMenuTabs = ["columnsMenuTab", "generalMenuTab"];
		if (options.menuTabs?.some((tab) => enterpriseMenuTabs.includes(tab))) return "ColumnMenu";
		return null;
	},
	pivot: "SharedPivot",
	pivotIndex: "SharedPivot",
	rowDrag: "RowDrag",
	rowGroup: "SharedRowGrouping",
	rowGroupIndex: "SharedRowGrouping",
	tooltipField: "Tooltip",
	tooltipValueGetter: "Tooltip",
	spanRows: "CellSpan"
};
var COLUMN_DEFINITION_VALIDATIONS = () => {
	return {
		autoHeight: {
			supportedRowModels: ["clientSide", "serverSide"],
			validate: (_colDef, { paginationAutoPageSize }) => {
				if (paginationAutoPageSize) return "colDef.autoHeight is not supported with paginationAutoPageSize.";
				return null;
			}
		},
		cellRendererParams: { validate: (colDef) => {
			if ((colDef.rowGroup != null || colDef.rowGroupIndex != null || colDef.cellRenderer === "agGroupCellRenderer") && "checkbox" in colDef.cellRendererParams) return "Since v33.0, `cellRendererParams.checkbox` has been deprecated. Use `rowSelection.checkboxLocation = \"autoGroupColumn\"` instead.";
			return null;
		} },
		flex: { validate: (_options, gridOptions) => {
			if (gridOptions.autoSizeStrategy) return "colDef.flex is not supported with gridOptions.autoSizeStrategy";
			return null;
		} },
		headerCheckboxSelection: {
			supportedRowModels: ["clientSide", "serverSide"],
			validate: (_options, { rowSelection }) => rowSelection === "multiple" ? null : "headerCheckboxSelection is only supported with rowSelection=multiple"
		},
		headerCheckboxSelectionCurrentPageOnly: {
			supportedRowModels: ["clientSide"],
			validate: (_options, { rowSelection }) => rowSelection === "multiple" ? null : "headerCheckboxSelectionCurrentPageOnly is only supported with rowSelection=multiple"
		},
		headerCheckboxSelectionFilteredOnly: {
			supportedRowModels: ["clientSide"],
			validate: (_options, { rowSelection }) => rowSelection === "multiple" ? null : "headerCheckboxSelectionFilteredOnly is only supported with rowSelection=multiple"
		},
		headerValueGetter: { validate: (_options) => {
			const headerValueGetter = _options.headerValueGetter;
			if (typeof headerValueGetter === "function" || typeof headerValueGetter === "string") return null;
			return "headerValueGetter must be a function or a valid string expression";
		} },
		icons: { validate: ({ icons }) => {
			if (icons) {
				if (icons["smallDown"]) return _errMsg(262);
				if (icons["smallLeft"]) return _errMsg(263);
				if (icons["smallRight"]) return _errMsg(264);
			}
			return null;
		} },
		sortingOrder: { validate: (_options) => {
			const sortingOrder = _options.sortingOrder;
			if (Array.isArray(sortingOrder) && sortingOrder.length > 0) {
				const invalidItems = sortingOrder.filter((a) => !DEFAULT_SORTING_ORDER.includes(a));
				if (invalidItems.length > 0) return `sortingOrder must be an array with elements from [${DEFAULT_SORTING_ORDER.map(toStringWithNullUndefined).join()}], currently it includes [${invalidItems.map(toStringWithNullUndefined).join()}]`;
			} else if (!Array.isArray(sortingOrder) || sortingOrder.length <= 0) return `sortingOrder must be an array with at least one element, currently it's ${sortingOrder}`;
			return null;
		} },
		type: { validate: (_options) => {
			const type = _options.type;
			if (type instanceof Array) {
				if (type.some((a) => typeof a !== "string")) return "if colDef.type is supplied an array it should be of type 'string[]'";
				return null;
			}
			if (typeof type === "string") return null;
			return "colDef.type should be of type 'string' | 'string[]'";
		} },
		rowSpan: { validate: (_options, { suppressRowTransform }) => {
			if (!suppressRowTransform) return "colDef.rowSpan requires suppressRowTransform to be enabled.";
			return null;
		} },
		spanRows: {
			dependencies: {
				editable: { required: [false, void 0] },
				rowDrag: { required: [false, void 0] },
				colSpan: { required: [void 0] },
				rowSpan: { required: [void 0] }
			},
			validate: (_options, { rowSelection, cellSelection, suppressRowTransform, enableCellSpan, rowDragEntireRow, enableCellTextSelection }) => {
				if (typeof rowSelection === "object") {
					if (rowSelection?.mode === "singleRow" && rowSelection?.enableClickSelection) return "colDef.spanRows is not supported with rowSelection.clickSelection";
				}
				if (cellSelection) return "colDef.spanRows is not supported with cellSelection.";
				if (suppressRowTransform) return "colDef.spanRows is not supported with suppressRowTransform.";
				if (!enableCellSpan) return "colDef.spanRows requires enableCellSpan to be enabled.";
				if (rowDragEntireRow) return "colDef.spanRows is not supported with rowDragEntireRow.";
				if (enableCellTextSelection) return "colDef.spanRows is not supported with enableCellTextSelection.";
				return null;
			}
		}
	};
};
var colDefPropertyMap = {
	headerName: void 0,
	columnGroupShow: void 0,
	headerStyle: void 0,
	headerClass: void 0,
	toolPanelClass: void 0,
	headerValueGetter: void 0,
	pivotKeys: void 0,
	groupId: void 0,
	colId: void 0,
	sort: void 0,
	initialSort: void 0,
	field: void 0,
	type: void 0,
	cellDataType: void 0,
	tooltipComponent: void 0,
	tooltipField: void 0,
	headerTooltip: void 0,
	cellClass: void 0,
	showRowGroup: void 0,
	filter: void 0,
	initialAggFunc: void 0,
	defaultAggFunc: void 0,
	aggFunc: void 0,
	pinned: void 0,
	initialPinned: void 0,
	chartDataType: void 0,
	cellAriaRole: void 0,
	cellEditorPopupPosition: void 0,
	headerGroupComponent: void 0,
	headerGroupComponentParams: void 0,
	cellStyle: void 0,
	cellRenderer: void 0,
	cellRendererParams: void 0,
	cellEditor: void 0,
	cellEditorParams: void 0,
	filterParams: void 0,
	pivotValueColumn: void 0,
	headerComponent: void 0,
	headerComponentParams: void 0,
	floatingFilterComponent: void 0,
	floatingFilterComponentParams: void 0,
	tooltipComponentParams: void 0,
	refData: void 0,
	columnChooserParams: void 0,
	children: void 0,
	sortingOrder: void 0,
	allowedAggFuncs: void 0,
	menuTabs: void 0,
	pivotTotalColumnIds: void 0,
	cellClassRules: void 0,
	icons: void 0,
	sortIndex: void 0,
	initialSortIndex: void 0,
	flex: void 0,
	initialFlex: void 0,
	width: void 0,
	initialWidth: void 0,
	minWidth: void 0,
	maxWidth: void 0,
	rowGroupIndex: void 0,
	initialRowGroupIndex: void 0,
	pivotIndex: void 0,
	initialPivotIndex: void 0,
	suppressColumnsToolPanel: void 0,
	suppressFiltersToolPanel: void 0,
	openByDefault: void 0,
	marryChildren: void 0,
	suppressStickyLabel: void 0,
	hide: void 0,
	initialHide: void 0,
	rowGroup: void 0,
	initialRowGroup: void 0,
	pivot: void 0,
	initialPivot: void 0,
	checkboxSelection: void 0,
	showDisabledCheckboxes: void 0,
	headerCheckboxSelection: void 0,
	headerCheckboxSelectionFilteredOnly: void 0,
	headerCheckboxSelectionCurrentPageOnly: void 0,
	suppressHeaderMenuButton: void 0,
	suppressMovable: void 0,
	lockPosition: void 0,
	lockVisible: void 0,
	lockPinned: void 0,
	unSortIcon: void 0,
	suppressSizeToFit: void 0,
	suppressAutoSize: void 0,
	enableRowGroup: void 0,
	enablePivot: void 0,
	enableValue: void 0,
	editable: void 0,
	suppressPaste: void 0,
	suppressNavigable: void 0,
	enableCellChangeFlash: void 0,
	rowDrag: void 0,
	dndSource: void 0,
	autoHeight: void 0,
	wrapText: void 0,
	sortable: void 0,
	resizable: void 0,
	singleClickEdit: void 0,
	floatingFilter: void 0,
	cellEditorPopup: void 0,
	suppressFillHandle: void 0,
	wrapHeaderText: void 0,
	autoHeaderHeight: void 0,
	dndSourceOnRowDrag: void 0,
	valueGetter: void 0,
	valueSetter: void 0,
	filterValueGetter: void 0,
	keyCreator: void 0,
	valueFormatter: void 0,
	valueParser: void 0,
	comparator: void 0,
	equals: void 0,
	pivotComparator: void 0,
	suppressKeyboardEvent: void 0,
	suppressHeaderKeyboardEvent: void 0,
	colSpan: void 0,
	rowSpan: void 0,
	spanRows: void 0,
	getQuickFilterText: void 0,
	onCellValueChanged: void 0,
	onCellClicked: void 0,
	onCellDoubleClicked: void 0,
	onCellContextMenu: void 0,
	rowDragText: void 0,
	tooltipValueGetter: void 0,
	cellRendererSelector: void 0,
	cellEditorSelector: void 0,
	suppressSpanHeaderHeight: void 0,
	useValueFormatterForExport: void 0,
	useValueParserForImport: void 0,
	mainMenuItems: void 0,
	contextMenuItems: void 0,
	suppressFloatingFilterButton: void 0,
	suppressHeaderFilterButton: void 0,
	suppressHeaderContextMenu: void 0,
	loadingCellRenderer: void 0,
	loadingCellRendererParams: void 0,
	loadingCellRendererSelector: void 0,
	context: void 0,
	dateComponent: void 0,
	dateComponentParams: void 0,
	getFindText: void 0
};
var ALL_PROPERTIES = () => Object.keys(colDefPropertyMap);
var COL_DEF_VALIDATORS = () => ({
	objectName: "colDef",
	allProperties: ALL_PROPERTIES(),
	docsUrl: "column-properties/",
	deprecations: COLUMN_DEFINITION_DEPRECATIONS(),
	validations: COLUMN_DEFINITION_VALIDATIONS()
});
var STRING_GRID_OPTIONS = [
	"overlayLoadingTemplate",
	"overlayNoRowsTemplate",
	"gridId",
	"quickFilterText",
	"rowModelType",
	"editType",
	"domLayout",
	"clipboardDelimiter",
	"rowGroupPanelShow",
	"multiSortKey",
	"pivotColumnGroupTotals",
	"pivotRowTotals",
	"pivotPanelShow",
	"fillHandleDirection",
	"groupDisplayType",
	"treeDataDisplayType",
	"treeDataChildrenField",
	"treeDataParentIdField",
	"colResizeDefault",
	"tooltipTrigger",
	"serverSidePivotResultFieldSeparator",
	"columnMenu",
	"tooltipShowMode",
	"invalidEditValueMode",
	"grandTotalRow",
	"themeCssLayer",
	"findSearchValue",
	"styleNonce",
	"renderingMode"
];
var OBJECT_GRID_OPTIONS = [
	"components",
	"rowStyle",
	"context",
	"autoGroupColumnDef",
	"localeText",
	"icons",
	"datasource",
	"dragAndDropImageComponentParams",
	"serverSideDatasource",
	"viewportDatasource",
	"groupRowRendererParams",
	"aggFuncs",
	"fullWidthCellRendererParams",
	"defaultColGroupDef",
	"defaultColDef",
	"defaultCsvExportParams",
	"defaultExcelExportParams",
	"columnTypes",
	"rowClassRules",
	"detailCellRendererParams",
	"loadingCellRendererParams",
	"loadingOverlayComponentParams",
	"noRowsOverlayComponentParams",
	"popupParent",
	"themeStyleContainer",
	"statusBar",
	"chartThemeOverrides",
	"customChartThemes",
	"chartToolPanelsDef",
	"dataTypeDefinitions",
	"advancedFilterParent",
	"advancedFilterBuilderParams",
	"advancedFilterParams",
	"initialState",
	"autoSizeStrategy",
	"selectionColumnDef",
	"findOptions",
	"filterHandlers"
];
var ARRAY_GRID_OPTIONS = [
	"sortingOrder",
	"alignedGrids",
	"rowData",
	"columnDefs",
	"excelStyles",
	"pinnedTopRowData",
	"pinnedBottomRowData",
	"chartThemes",
	"rowClass",
	"paginationPageSizeSelector"
];
var _NUMBER_GRID_OPTIONS = [
	"rowHeight",
	"detailRowHeight",
	"rowBuffer",
	"headerHeight",
	"groupHeaderHeight",
	"groupLockGroupColumns",
	"floatingFiltersHeight",
	"pivotHeaderHeight",
	"pivotGroupHeaderHeight",
	"groupDefaultExpanded",
	"pivotDefaultExpanded",
	"viewportRowModelPageSize",
	"viewportRowModelBufferSize",
	"autoSizePadding",
	"maxBlocksInCache",
	"maxConcurrentDatasourceRequests",
	"tooltipShowDelay",
	"tooltipHideDelay",
	"cacheOverflowSize",
	"paginationPageSize",
	"cacheBlockSize",
	"infiniteInitialRowCount",
	"serverSideInitialRowCount",
	"scrollbarWidth",
	"asyncTransactionWaitMillis",
	"blockLoadDebounceMillis",
	"keepDetailRowsCount",
	"undoRedoCellEditingLimit",
	"cellFlashDuration",
	"cellFadeDuration",
	"tabIndex",
	"pivotMaxGeneratedColumns",
	"rowDragInsertDelay"
];
var OTHER_GRID_OPTIONS = ["theme", "rowSelection"];
var _BOOLEAN_MIXED_GRID_OPTIONS = [
	"cellSelection",
	"sideBar",
	"rowNumbers",
	"suppressGroupChangesColumnVisibility",
	"groupAggFiltering",
	"suppressStickyTotalRow",
	"groupHideParentOfSingleChild",
	"enableRowPinning"
];
var _BOOLEAN_GRID_OPTIONS = [
	"loadThemeGoogleFonts",
	"suppressMakeColumnVisibleAfterUnGroup",
	"suppressRowClickSelection",
	"suppressCellFocus",
	"suppressHeaderFocus",
	"suppressHorizontalScroll",
	"groupSelectsChildren",
	"alwaysShowHorizontalScroll",
	"alwaysShowVerticalScroll",
	"debug",
	"enableBrowserTooltips",
	"enableCellExpressions",
	"groupSuppressBlankHeader",
	"suppressMenuHide",
	"suppressRowDeselection",
	"unSortIcon",
	"suppressMultiSort",
	"alwaysMultiSort",
	"singleClickEdit",
	"suppressLoadingOverlay",
	"suppressNoRowsOverlay",
	"suppressAutoSize",
	"skipHeaderOnAutoSize",
	"suppressColumnMoveAnimation",
	"suppressMoveWhenColumnDragging",
	"suppressMovableColumns",
	"suppressFieldDotNotation",
	"enableRangeSelection",
	"enableRangeHandle",
	"enableFillHandle",
	"suppressClearOnFillReduction",
	"deltaSort",
	"suppressTouch",
	"allowContextMenuWithControlKey",
	"suppressContextMenu",
	"suppressDragLeaveHidesColumns",
	"suppressRowGroupHidesColumns",
	"suppressMiddleClickScrolls",
	"suppressPreventDefaultOnMouseWheel",
	"suppressCopyRowsToClipboard",
	"copyHeadersToClipboard",
	"copyGroupHeadersToClipboard",
	"pivotMode",
	"suppressAggFuncInHeader",
	"suppressColumnVirtualisation",
	"alwaysAggregateAtRootLevel",
	"suppressFocusAfterRefresh",
	"functionsReadOnly",
	"animateRows",
	"groupSelectsFiltered",
	"groupRemoveSingleChildren",
	"groupRemoveLowestSingleChildren",
	"enableRtl",
	"enableCellSpan",
	"suppressClickEdit",
	"rowDragEntireRow",
	"rowDragManaged",
	"suppressRowDrag",
	"suppressMoveWhenRowDragging",
	"rowDragMultiRow",
	"enableGroupEdit",
	"embedFullWidthRows",
	"suppressPaginationPanel",
	"groupHideOpenParents",
	"groupAllowUnbalanced",
	"pagination",
	"paginationAutoPageSize",
	"suppressScrollOnNewData",
	"suppressScrollWhenPopupsAreOpen",
	"purgeClosedRowNodes",
	"cacheQuickFilter",
	"includeHiddenColumnsInQuickFilter",
	"ensureDomOrder",
	"accentedSort",
	"suppressChangeDetection",
	"valueCache",
	"valueCacheNeverExpires",
	"aggregateOnlyChangedColumns",
	"suppressAnimationFrame",
	"suppressExcelExport",
	"suppressCsvExport",
	"includeHiddenColumnsInAdvancedFilter",
	"suppressMultiRangeSelection",
	"enterNavigatesVerticallyAfterEdit",
	"enterNavigatesVertically",
	"suppressPropertyNamesCheck",
	"rowMultiSelectWithClick",
	"suppressRowHoverHighlight",
	"suppressRowTransform",
	"suppressClipboardPaste",
	"suppressLastEmptyLineOnPaste",
	"enableCharts",
	"suppressMaintainUnsortedOrder",
	"enableCellTextSelection",
	"suppressBrowserResizeObserver",
	"suppressMaxRenderedRowRestriction",
	"excludeChildrenWhenTreeDataFiltering",
	"tooltipMouseTrack",
	"tooltipInteraction",
	"keepDetailRows",
	"paginateChildRows",
	"preventDefaultOnContextMenu",
	"undoRedoCellEditing",
	"allowDragFromColumnsToolPanel",
	"pivotSuppressAutoColumn",
	"suppressExpandablePivotGroups",
	"debounceVerticalScrollbar",
	"detailRowAutoHeight",
	"serverSideSortAllLevels",
	"serverSideEnableClientSideSort",
	"serverSideOnlyRefreshFilteredGroups",
	"suppressAggFilteredOnly",
	"showOpenedGroup",
	"suppressClipboardApi",
	"suppressModelUpdateAfterUpdateTransaction",
	"stopEditingWhenCellsLoseFocus",
	"groupMaintainOrder",
	"columnHoverHighlight",
	"readOnlyEdit",
	"suppressRowVirtualisation",
	"enableCellEditingOnBackspace",
	"resetRowDataOnUpdate",
	"removePivotHeaderRowWhenSingleValueColumn",
	"suppressCopySingleCellRanges",
	"suppressGroupRowsSticky",
	"suppressCutToClipboard",
	"rowGroupPanelSuppressSort",
	"allowShowChangeAfterFilter",
	"enableAdvancedFilter",
	"masterDetail",
	"treeData",
	"reactiveCustomComponents",
	"applyQuickFilterBeforePivotOrAgg",
	"suppressServerSideFullWidthLoadingRow",
	"suppressAdvancedFilterEval",
	"loading",
	"maintainColumnOrder",
	"enableStrictPivotColumnOrder",
	"suppressSetFilterByDefault",
	"enableFilterHandlers",
	"suppressStartEditOnTab",
	"hidePaddedHeaderRows"
];
var _FUNCTION_GRID_OPTIONS = [
	"doesExternalFilterPass",
	"processPivotResultColDef",
	"processPivotResultColGroupDef",
	"getBusinessKeyForNode",
	"isRowSelectable",
	"rowDragText",
	"groupRowRenderer",
	"dragAndDropImageComponent",
	"fullWidthCellRenderer",
	"loadingCellRenderer",
	"loadingOverlayComponent",
	"noRowsOverlayComponent",
	"detailCellRenderer",
	"quickFilterParser",
	"quickFilterMatcher",
	"getLocaleText",
	"isExternalFilterPresent",
	"getRowHeight",
	"getRowClass",
	"getRowStyle",
	"getFullRowEditValidationErrors",
	"getContextMenuItems",
	"getMainMenuItems",
	"processRowPostCreate",
	"processCellForClipboard",
	"getGroupRowAgg",
	"isFullWidthRow",
	"sendToClipboard",
	"focusGridInnerElement",
	"navigateToNextHeader",
	"tabToNextHeader",
	"navigateToNextCell",
	"tabToNextCell",
	"processCellFromClipboard",
	"getDocument",
	"postProcessPopup",
	"getChildCount",
	"getDataPath",
	"isRowMaster",
	"postSortRows",
	"processHeaderForClipboard",
	"processUnpinnedColumns",
	"processGroupHeaderForClipboard",
	"paginationNumberFormatter",
	"processDataFromClipboard",
	"getServerSideGroupKey",
	"isServerSideGroup",
	"createChartContainer",
	"getChartToolbarItems",
	"fillOperation",
	"isApplyServerSideTransaction",
	"getServerSideGroupLevelParams",
	"isServerSideGroupOpenByDefault",
	"isGroupOpenByDefault",
	"initialGroupOrderComparator",
	"loadingCellRendererSelector",
	"getRowId",
	"chartMenuItems",
	"groupTotalRow",
	"alwaysPassFilter",
	"isRowPinnable",
	"isRowPinned",
	"isRowValidDropPosition"
];
var _GET_ALL_GRID_OPTIONS = () => [
	...ARRAY_GRID_OPTIONS,
	...OBJECT_GRID_OPTIONS,
	...STRING_GRID_OPTIONS,
	..._NUMBER_GRID_OPTIONS,
	..._FUNCTION_GRID_OPTIONS,
	..._BOOLEAN_GRID_OPTIONS,
	..._BOOLEAN_MIXED_GRID_OPTIONS,
	...OTHER_GRID_OPTIONS
];
var GRID_OPTION_DEPRECATIONS = () => ({
	suppressLoadingOverlay: {
		version: "32",
		message: "Use `loading`=false instead."
	},
	enableFillHandle: {
		version: "32.2",
		message: "Use `cellSelection.handle` instead."
	},
	enableRangeHandle: {
		version: "32.2",
		message: "Use `cellSelection.handle` instead."
	},
	enableRangeSelection: {
		version: "32.2",
		message: "Use `cellSelection = true` instead."
	},
	suppressMultiRangeSelection: {
		version: "32.2",
		message: "Use `cellSelection.suppressMultiRanges` instead."
	},
	suppressClearOnFillReduction: {
		version: "32.2",
		message: "Use `cellSelection.handle.suppressClearOnFillReduction` instead."
	},
	fillHandleDirection: {
		version: "32.2",
		message: "Use `cellSelection.handle.direction` instead."
	},
	fillOperation: {
		version: "32.2",
		message: "Use `cellSelection.handle.setFillValue` instead."
	},
	suppressRowClickSelection: {
		version: "32.2",
		message: "Use `rowSelection.enableClickSelection` instead."
	},
	suppressRowDeselection: {
		version: "32.2",
		message: "Use `rowSelection.enableClickSelection` instead."
	},
	rowMultiSelectWithClick: {
		version: "32.2",
		message: "Use `rowSelection.enableSelectionWithoutKeys` instead."
	},
	groupSelectsChildren: {
		version: "32.2",
		message: "Use `rowSelection.groupSelects = \"descendants\"` instead."
	},
	groupSelectsFiltered: {
		version: "32.2",
		message: "Use `rowSelection.groupSelects = \"filteredDescendants\"` instead."
	},
	isRowSelectable: {
		version: "32.2",
		message: "Use `selectionOptions.isRowSelectable` instead."
	},
	suppressCopySingleCellRanges: {
		version: "32.2",
		message: "Use `rowSelection.copySelectedRows` instead."
	},
	suppressCopyRowsToClipboard: {
		version: "32.2",
		message: "Use `rowSelection.copySelectedRows` instead."
	},
	onRangeSelectionChanged: {
		version: "32.2",
		message: "Use `onCellSelectionChanged` instead."
	},
	onRangeDeleteStart: {
		version: "32.2",
		message: "Use `onCellSelectionDeleteStart` instead."
	},
	onRangeDeleteEnd: {
		version: "32.2",
		message: "Use `onCellSelectionDeleteEnd` instead."
	},
	suppressBrowserResizeObserver: {
		version: "32.2",
		message: "The grid always uses the browser's ResizeObserver, this grid option has no effect."
	},
	onColumnEverythingChanged: {
		version: "32.2",
		message: "Either use `onDisplayedColumnsChanged` which is fired at the same time, or use one of the more specific column events."
	},
	groupRemoveSingleChildren: {
		version: "33",
		message: "Use `groupHideParentOfSingleChild` instead."
	},
	groupRemoveLowestSingleChildren: {
		version: "33",
		message: "Use `groupHideParentOfSingleChild: \"leafGroupsOnly\"` instead."
	},
	suppressRowGroupHidesColumns: {
		version: "33",
		message: "Use `suppressGroupChangesColumnVisibility: \"suppressHideOnGroup\"` instead."
	},
	suppressMakeColumnVisibleAfterUnGroup: {
		version: "33",
		message: "Use `suppressGroupChangesColumnVisibility: \"suppressShowOnUngroup\"` instead."
	},
	unSortIcon: {
		version: "33",
		message: "Use `defaultColDef.unSortIcon` instead."
	},
	sortingOrder: {
		version: "33",
		message: "Use `defaultColDef.sortingOrder` instead."
	},
	suppressPropertyNamesCheck: {
		version: "33",
		message: "`gridOptions` and `columnDefs` both have a `context` property that should be used for arbitrary user data. This means that column definitions and gridOptions should only contain valid properties making this property redundant."
	},
	suppressAdvancedFilterEval: {
		version: "34",
		message: "Advanced filter no longer uses function evaluation, so this option has no effect."
	}
});
function toConstrainedNum(key, value, min) {
	if (typeof value === "number" || value == null) {
		if (value == null) return null;
		return value >= min ? null : `${key}: value should be greater than or equal to ${min}`;
	}
	return `${key}: value should be a number`;
}
var GRID_OPTIONS_MODULES = {
	alignedGrids: "AlignedGrids",
	allowContextMenuWithControlKey: "ContextMenu",
	autoSizeStrategy: "ColumnAutoSize",
	cellSelection: "CellSelection",
	columnHoverHighlight: "ColumnHover",
	datasource: "InfiniteRowModel",
	doesExternalFilterPass: "ExternalFilter",
	editType: "EditCore",
	invalidEditValueMode: "EditCore",
	enableAdvancedFilter: "AdvancedFilter",
	enableCellSpan: "CellSpan",
	enableCharts: "IntegratedCharts",
	enableRangeSelection: "CellSelection",
	enableRowPinning: "PinnedRow",
	findSearchValue: "Find",
	getFullRowEditValidationErrors: "EditCore",
	getContextMenuItems: "ContextMenu",
	getLocaleText: "Locale",
	getMainMenuItems: "ColumnMenu",
	getRowClass: "RowStyle",
	getRowStyle: "RowStyle",
	groupTotalRow: "SharedRowGrouping",
	grandTotalRow: "SharedRowGrouping",
	initialState: "GridState",
	isExternalFilterPresent: "ExternalFilter",
	isRowPinnable: "PinnedRow",
	isRowPinned: "PinnedRow",
	localeText: "Locale",
	masterDetail: "SharedMasterDetail",
	pagination: "Pagination",
	pinnedBottomRowData: "PinnedRow",
	pinnedTopRowData: "PinnedRow",
	pivotMode: "SharedPivot",
	pivotPanelShow: "RowGroupingPanel",
	quickFilterText: "QuickFilter",
	rowClass: "RowStyle",
	rowClassRules: "RowStyle",
	rowData: "ClientSideRowModel",
	rowDragManaged: "RowDrag",
	rowGroupPanelShow: "RowGroupingPanel",
	rowNumbers: "RowNumbers",
	rowSelection: "SharedRowSelection",
	rowStyle: "RowStyle",
	serverSideDatasource: "ServerSideRowModel",
	sideBar: "SideBar",
	statusBar: "StatusBar",
	treeData: "SharedTreeData",
	undoRedoCellEditing: "UndoRedoEdit",
	valueCache: "ValueCache",
	viewportDatasource: "ViewportRowModel"
};
var GRID_OPTION_VALIDATIONS = () => {
	const definedValidations = {
		autoSizePadding: { validate({ autoSizePadding }) {
			return toConstrainedNum("autoSizePadding", autoSizePadding, 0);
		} },
		cacheBlockSize: {
			supportedRowModels: ["serverSide", "infinite"],
			validate({ cacheBlockSize }) {
				return toConstrainedNum("cacheBlockSize", cacheBlockSize, 1);
			}
		},
		cacheOverflowSize: { validate({ cacheOverflowSize }) {
			return toConstrainedNum("cacheOverflowSize", cacheOverflowSize, 1);
		} },
		datasource: { supportedRowModels: ["infinite"] },
		domLayout: { validate: (options) => {
			const domLayout = options.domLayout;
			const validLayouts = [
				"autoHeight",
				"normal",
				"print"
			];
			if (domLayout && !validLayouts.includes(domLayout)) return `domLayout must be one of [${validLayouts.join()}], currently it's ${domLayout}`;
			return null;
		} },
		enableFillHandle: { dependencies: { enableRangeSelection: { required: [true] } } },
		enableRangeHandle: { dependencies: { enableRangeSelection: { required: [true] } } },
		enableRangeSelection: { dependencies: { rowDragEntireRow: { required: [false, void 0] } } },
		enableRowPinning: {
			supportedRowModels: ["clientSide"],
			validate({ enableRowPinning, pinnedTopRowData, pinnedBottomRowData }) {
				if (enableRowPinning && (pinnedTopRowData || pinnedBottomRowData)) return "Manual row pinning cannot be used together with pinned row data. Either set `enableRowPinning` to `false`, or remove `pinnedTopRowData` and `pinnedBottomRowData`.";
				return null;
			}
		},
		isRowPinnable: {
			supportedRowModels: ["clientSide"],
			validate({ enableRowPinning, isRowPinnable, pinnedTopRowData, pinnedBottomRowData }) {
				if (isRowPinnable && (pinnedTopRowData || pinnedBottomRowData)) return "Manual row pinning cannot be used together with pinned row data. Either remove `isRowPinnable`, or remove `pinnedTopRowData` and `pinnedBottomRowData`.";
				if (!enableRowPinning && isRowPinnable) return "`isRowPinnable` requires `enableRowPinning` to be set.";
				return null;
			}
		},
		isRowPinned: {
			supportedRowModels: ["clientSide"],
			validate({ enableRowPinning, isRowPinned, pinnedTopRowData, pinnedBottomRowData }) {
				if (isRowPinned && (pinnedTopRowData || pinnedBottomRowData)) return "Manual row pinning cannot be used together with pinned row data. Either remove `isRowPinned`, or remove `pinnedTopRowData` and `pinnedBottomRowData`.";
				if (!enableRowPinning && isRowPinned) return "`isRowPinned` requires `enableRowPinning` to be set.";
				return null;
			}
		},
		groupDefaultExpanded: { supportedRowModels: ["clientSide"] },
		groupHideOpenParents: {
			supportedRowModels: ["clientSide", "serverSide"],
			dependencies: {
				groupTotalRow: { required: [void 0, "bottom"] },
				treeData: {
					required: [void 0, false],
					reason: "Tree Data has values at the group level so it doesn't make sense to hide them."
				}
			}
		},
		groupHideParentOfSingleChild: { dependencies: { groupHideOpenParents: { required: [void 0, false] } } },
		groupRemoveLowestSingleChildren: { dependencies: {
			groupHideOpenParents: { required: [void 0, false] },
			groupRemoveSingleChildren: { required: [void 0, false] }
		} },
		groupRemoveSingleChildren: { dependencies: {
			groupHideOpenParents: { required: [void 0, false] },
			groupRemoveLowestSingleChildren: { required: [void 0, false] }
		} },
		groupSelectsChildren: { dependencies: { rowSelection: { required: ["multiple"] } } },
		icons: { validate: ({ icons }) => {
			if (icons) {
				if (icons["smallDown"]) return _errMsg(262);
				if (icons["smallLeft"]) return _errMsg(263);
				if (icons["smallRight"]) return _errMsg(264);
			}
			return null;
		} },
		infiniteInitialRowCount: { validate({ infiniteInitialRowCount }) {
			return toConstrainedNum("infiniteInitialRowCount", infiniteInitialRowCount, 1);
		} },
		initialGroupOrderComparator: { supportedRowModels: ["clientSide"] },
		keepDetailRowsCount: { validate({ keepDetailRowsCount }) {
			return toConstrainedNum("keepDetailRowsCount", keepDetailRowsCount, 1);
		} },
		paginationPageSize: { validate({ paginationPageSize }) {
			return toConstrainedNum("paginationPageSize", paginationPageSize, 1);
		} },
		paginationPageSizeSelector: { validate: (options) => {
			const values = options.paginationPageSizeSelector;
			if (typeof values === "boolean" || values == null) return null;
			if (!values.length) return `'paginationPageSizeSelector' cannot be an empty array.
                    If you want to hide the page size selector, set paginationPageSizeSelector to false.`;
			return null;
		} },
		pivotMode: { dependencies: { treeData: {
			required: [false, void 0],
			reason: "Pivot Mode is not supported with Tree Data."
		} } },
		quickFilterText: { supportedRowModels: ["clientSide"] },
		rowBuffer: { validate({ rowBuffer }) {
			return toConstrainedNum("rowBuffer", rowBuffer, 0);
		} },
		rowClass: { validate: (options) => {
			if (typeof options.rowClass === "function") return "rowClass should not be a function, please use getRowClass instead";
			return null;
		} },
		rowData: { supportedRowModels: ["clientSide"] },
		rowDragManaged: {
			supportedRowModels: ["clientSide"],
			dependencies: { pagination: { required: [false, void 0] } }
		},
		rowSelection: { validate({ rowSelection }) {
			if (rowSelection && typeof rowSelection === "string") return "As of version 32.2.1, using `rowSelection` with the values \"single\" or \"multiple\" has been deprecated. Use the object value instead.";
			if (rowSelection && typeof rowSelection !== "object") return "Expected `RowSelectionOptions` object for the `rowSelection` property.";
			if (rowSelection && rowSelection.mode !== "multiRow" && rowSelection.mode !== "singleRow") return `Selection mode "${rowSelection.mode}" is invalid. Use one of 'singleRow' or 'multiRow'.`;
			return null;
		} },
		rowStyle: { validate: (options) => {
			const rowStyle = options.rowStyle;
			if (rowStyle && typeof rowStyle === "function") return "rowStyle should be an object of key/value styles, not be a function, use getRowStyle() instead";
			return null;
		} },
		serverSideDatasource: { supportedRowModels: ["serverSide"] },
		serverSideInitialRowCount: {
			supportedRowModels: ["serverSide"],
			validate({ serverSideInitialRowCount }) {
				return toConstrainedNum("serverSideInitialRowCount", serverSideInitialRowCount, 1);
			}
		},
		serverSideOnlyRefreshFilteredGroups: { supportedRowModels: ["serverSide"] },
		serverSideSortAllLevels: { supportedRowModels: ["serverSide"] },
		sortingOrder: { validate: (_options) => {
			const sortingOrder = _options.sortingOrder;
			if (Array.isArray(sortingOrder) && sortingOrder.length > 0) {
				const invalidItems = sortingOrder.filter((a) => !DEFAULT_SORTING_ORDER.includes(a));
				if (invalidItems.length > 0) return `sortingOrder must be an array with elements from [${DEFAULT_SORTING_ORDER.map(toStringWithNullUndefined).join()}], currently it includes [${invalidItems.map(toStringWithNullUndefined).join()}]`;
			} else if (!Array.isArray(sortingOrder) || sortingOrder.length <= 0) return `sortingOrder must be an array with at least one element, currently it's ${sortingOrder}`;
			return null;
		} },
		tooltipHideDelay: { validate: (options) => {
			if (options.tooltipHideDelay && options.tooltipHideDelay < 0) return "tooltipHideDelay should not be lower than 0";
			return null;
		} },
		tooltipShowDelay: { validate: (options) => {
			if (options.tooltipShowDelay && options.tooltipShowDelay < 0) return "tooltipShowDelay should not be lower than 0";
			return null;
		} },
		treeData: {
			supportedRowModels: ["clientSide", "serverSide"],
			validate: (options) => {
				const rowModel = options.rowModelType ?? "clientSide";
				switch (rowModel) {
					case "clientSide": {
						const { treeDataChildrenField, treeDataParentIdField, getDataPath, getRowId } = options;
						if (!treeDataChildrenField && !treeDataParentIdField && !getDataPath) return "treeData requires either 'treeDataChildrenField' or 'treeDataParentIdField' or 'getDataPath' in the clientSide row model.";
						if (treeDataChildrenField) {
							if (getDataPath) return "Cannot use both 'treeDataChildrenField' and 'getDataPath' at the same time.";
							if (treeDataParentIdField) return "Cannot use both 'treeDataChildrenField' and 'treeDataParentIdField' at the same time.";
						}
						if (treeDataParentIdField) {
							if (!getRowId) return "getRowId callback not provided, tree data with parent id cannot be built.";
							if (getDataPath) return "Cannot use both 'treeDataParentIdField' and 'getDataPath' at the same time.";
						}
						return null;
					}
					case "serverSide": {
						const ssrmWarning = `treeData requires 'isServerSideGroup' and 'getServerSideGroupKey' in the ${rowModel} row model.`;
						return options.isServerSideGroup && options.getServerSideGroupKey ? null : ssrmWarning;
					}
				}
				return null;
			}
		},
		viewportDatasource: { supportedRowModels: ["viewport"] },
		viewportRowModelBufferSize: { validate({ viewportRowModelBufferSize }) {
			return toConstrainedNum("viewportRowModelBufferSize", viewportRowModelBufferSize, 0);
		} },
		viewportRowModelPageSize: { validate({ viewportRowModelPageSize }) {
			return toConstrainedNum("viewportRowModelPageSize", viewportRowModelPageSize, 1);
		} },
		rowDragEntireRow: { dependencies: { cellSelection: { required: [void 0] } } },
		autoGroupColumnDef: { validate({ autoGroupColumnDef, showOpenedGroup }) {
			if (autoGroupColumnDef?.field && showOpenedGroup) return "autoGroupColumnDef.field and showOpenedGroup are not supported when used together.";
			if (autoGroupColumnDef?.valueGetter && showOpenedGroup) return "autoGroupColumnDef.valueGetter and showOpenedGroup are not supported when used together.";
			return null;
		} },
		renderingMode: { validate: (options) => {
			const renderingMode = options.renderingMode;
			const validModes = ["default", "legacy"];
			if (renderingMode && !validModes.includes(renderingMode)) return `renderingMode must be one of [${validModes.join()}], currently it's ${renderingMode}`;
			return null;
		} }
	};
	const validations = {};
	_BOOLEAN_GRID_OPTIONS.forEach((key) => {
		validations[key] = { expectedType: "boolean" };
	});
	_NUMBER_GRID_OPTIONS.forEach((key) => {
		validations[key] = { expectedType: "number" };
	});
	_mergeDeep(validations, definedValidations);
	return validations;
};
var GRID_OPTIONS_VALIDATORS = () => ({
	objectName: "gridOptions",
	allProperties: [..._GET_ALL_GRID_OPTIONS(), ...Object.values(_PUBLIC_EVENT_HANDLERS_MAP)],
	propertyExceptions: ["api"],
	docsUrl: "grid-options/",
	deprecations: GRID_OPTION_DEPRECATIONS(),
	validations: GRID_OPTION_VALIDATIONS()
});
var changeSetId = 0;
var gridInstanceSequence = 0;
var GridOptionsService = class extends BeanStub {
	constructor() {
		super(...arguments);
		this.beanName = "gos";
		this.domDataKey = "__AG_" + Math.random().toString();
		this.gridInstanceId = gridInstanceSequence++;
		this.gridReadyFired = false;
		this.queueEvents = [];
		this.propEventSvc = new LocalEventService();
		this.globalEventHandlerFactory = (restrictToSyncOnly) => {
			return (eventName, event) => {
				if (!this.isAlive()) return;
				const alwaysSync = ALWAYS_SYNC_GLOBAL_EVENTS.has(eventName);
				if (alwaysSync && !restrictToSyncOnly || !alwaysSync && restrictToSyncOnly) return;
				if (!isPublicEventHandler(eventName)) return;
				const fireEvent = (name, e) => {
					const eventHandlerName = _PUBLIC_EVENT_HANDLERS_MAP[name];
					const eventHandler = this.gridOptions[eventHandlerName];
					if (typeof eventHandler === "function") this.beans.frameworkOverrides.wrapOutgoing(() => eventHandler(e));
				};
				if (this.gridReadyFired) fireEvent(eventName, event);
				else if (eventName === "gridReady") {
					fireEvent(eventName, event);
					this.gridReadyFired = true;
					for (const q of this.queueEvents) fireEvent(q.eventName, q.event);
					this.queueEvents = [];
				} else this.queueEvents.push({
					eventName,
					event
				});
			};
		};
	}
	wireBeans(beans) {
		this.gridOptions = beans.gridOptions;
		this.validation = beans.validation;
		this.api = beans.gridApi;
		this.gridId = beans.context.getGridId();
	}
	get gridOptionsContext() {
		return this.gridOptions["context"];
	}
	postConstruct() {
		this.validateGridOptions(this.gridOptions);
		this.eventSvc.addGlobalListener(this.globalEventHandlerFactory().bind(this), true);
		this.eventSvc.addGlobalListener(this.globalEventHandlerFactory(true).bind(this), false);
		this.propEventSvc.setFrameworkOverrides(this.beans.frameworkOverrides);
		this.addManagedEventListeners({ gridOptionsChanged: ({ options }) => {
			this.updateGridOptions({
				options,
				force: true,
				source: "gridOptionsUpdated"
			});
		} });
	}
	destroy() {
		super.destroy();
		this.queueEvents = [];
	}
	get(property) {
		return this.gridOptions[property] ?? GRID_OPTION_DEFAULTS[property];
	}
	getCallback(property) {
		return this.mergeGridCommonParams(this.gridOptions[property]);
	}
	exists(property) {
		return _exists(this.gridOptions[property]);
	}
	mergeGridCommonParams(callback) {
		if (callback) {
			const wrapped = (callbackParams) => {
				return callback(this.addGridCommonParams(callbackParams));
			};
			return wrapped;
		}
		return callback;
	}
	updateGridOptions({ options, force, source = "api" }) {
		const changeSet = {
			id: changeSetId++,
			properties: []
		};
		const events = [];
		const { gridOptions, validation: validation2 } = this;
		for (const key of Object.keys(options)) {
			const value = options[key];
			validation2?.warnOnInitialPropertyUpdate(source, key);
			const shouldForce = force || typeof value === "object" && source === "api";
			const previousValue = gridOptions[key];
			if (shouldForce || previousValue !== value) {
				gridOptions[key] = value;
				const event = {
					type: key,
					currentValue: value,
					previousValue,
					changeSet,
					source
				};
				events.push(event);
			}
		}
		this.validateGridOptions(this.gridOptions);
		changeSet.properties = events.map((event) => event.type);
		events.forEach((event) => {
			_logIfDebug(this, `Updated property ${event.type} from`, event.previousValue, ` to `, event.currentValue);
			this.propEventSvc.dispatchEvent(event);
		});
	}
	addPropertyEventListener(key, listener) {
		this.propEventSvc.addEventListener(key, listener);
	}
	removePropertyEventListener(key, listener) {
		this.propEventSvc.removeEventListener(key, listener);
	}
	getDomDataKey() {
		return this.domDataKey;
	}
	addGridCommonParams(params) {
		params.api = this.api;
		params.context = this.gridOptionsContext;
		return params;
	}
	validateOptions(options, modValidations) {
		for (const key of Object.keys(options)) {
			const value = options[key];
			if (value == null || value === false) continue;
			let moduleToCheck = modValidations[key];
			if (typeof moduleToCheck === "function") moduleToCheck = moduleToCheck(options, this.gridOptions, this.beans);
			if (moduleToCheck) this.assertModuleRegistered(moduleToCheck, key);
		}
	}
	validateGridOptions(gridOptions) {
		this.validateOptions(gridOptions, GRID_OPTIONS_MODULES);
		this.validation?.processGridOptions(gridOptions);
	}
	validateColDef(colDef, colId, skipInferenceCheck) {
		if (skipInferenceCheck || !this.beans.dataTypeSvc?.isColPendingInference(colId)) {
			this.validateOptions(colDef, COLUMN_DEFINITION_MOD_VALIDATIONS);
			this.validation?.validateColDef(colDef);
		}
	}
	assertModuleRegistered(moduleName, reasonOrId) {
		const registered = Array.isArray(moduleName) ? moduleName.some((modName) => this.isModuleRegistered(modName)) : this.isModuleRegistered(moduleName);
		if (!registered) _error(200, {
			...this.getModuleErrorParams(),
			moduleName,
			reasonOrId
		});
		return registered;
	}
	getModuleErrorParams() {
		return {
			gridId: this.gridId,
			gridScoped: _areModulesGridScoped(),
			rowModelType: this.get("rowModelType"),
			isUmd: _isUmd()
		};
	}
	isModuleRegistered(moduleName) {
		return _isModuleRegistered(moduleName, this.gridId, this.get("rowModelType"));
	}
};
function isPublicEventHandler(eventName) {
	return !!_PUBLIC_EVENT_HANDLERS_MAP[eventName];
}
function getHeaderCompElementParams(includeSortIndicator) {
	const hiddenAttrs = { "aria-hidden": "true" };
	return {
		tag: "div",
		cls: "ag-cell-label-container",
		role: "presentation",
		children: [
			{
				tag: "span",
				ref: "eMenu",
				cls: "ag-header-icon ag-header-cell-menu-button",
				attrs: hiddenAttrs
			},
			{
				tag: "span",
				ref: "eFilterButton",
				cls: "ag-header-icon ag-header-cell-filter-button",
				attrs: hiddenAttrs
			},
			{
				tag: "div",
				ref: "eLabel",
				cls: "ag-header-cell-label",
				role: "presentation",
				children: [
					{
						tag: "span",
						ref: "eText",
						cls: "ag-header-cell-text"
					},
					{
						tag: "span",
						ref: "eFilter",
						cls: "ag-header-icon ag-header-label-icon ag-filter-icon",
						attrs: hiddenAttrs
					},
					includeSortIndicator ? {
						tag: "ag-sort-indicator",
						ref: "eSortIndicator"
					} : null
				]
			}
		]
	};
}
var HeaderCompElement = getHeaderCompElementParams(true);
var HeaderCompElementNoSort = getHeaderCompElementParams(false);
var HeaderComp = class extends Component {
	constructor() {
		super(...arguments);
		this.eFilter = null;
		this.eFilterButton = null;
		this.eSortIndicator = null;
		this.eMenu = null;
		this.eLabel = null;
		this.eText = null;
		this.eSortOrder = null;
		this.eSortAsc = null;
		this.eSortDesc = null;
		this.eSortMixed = null;
		this.eSortNone = null;
		this.isLoadingInnerComponent = false;
	}
	refresh(params) {
		const oldParams = this.params;
		this.params = params;
		if (this.workOutTemplate(params, !!this.beans?.sortSvc) != this.currentTemplate || this.workOutShowMenu() != this.currentShowMenu || params.enableSorting != this.currentSort || this.currentSuppressMenuHide != null && this.shouldSuppressMenuHide() != this.currentSuppressMenuHide || oldParams.enableFilterButton != params.enableFilterButton || oldParams.enableFilterIcon != params.enableFilterIcon) return false;
		if (this.innerHeaderComponent) {
			const mergedParams = { ...params };
			_mergeDeep(mergedParams, params.innerHeaderComponentParams);
			this.innerHeaderComponent.refresh?.(mergedParams);
		} else this.setDisplayName(params);
		return true;
	}
	workOutTemplate(params, isSorting) {
		const paramsTemplate = params.template;
		if (paramsTemplate) return paramsTemplate?.trim ? paramsTemplate.trim() : paramsTemplate;
		else return isSorting ? HeaderCompElement : HeaderCompElementNoSort;
	}
	init(params) {
		this.params = params;
		const { sortSvc, touchSvc, rowNumbersSvc, userCompFactory } = this.beans;
		const sortComp = sortSvc?.getSortIndicatorSelector();
		this.currentTemplate = this.workOutTemplate(params, !!sortComp);
		this.setTemplate(this.currentTemplate, sortComp ? [sortComp] : void 0);
		touchSvc?.setupForHeader(this);
		this.setMenu();
		this.setupSort();
		rowNumbersSvc?.setupForHeader(this);
		this.setupFilterIcon();
		this.setupFilterButton();
		this.workOutInnerHeaderComponent(userCompFactory, params);
		this.setDisplayName(params);
	}
	workOutInnerHeaderComponent(userCompFactory, params) {
		const userCompDetails = _getInnerHeaderCompDetails(userCompFactory, params, params);
		if (!userCompDetails) return;
		this.isLoadingInnerComponent = true;
		userCompDetails.newAgStackInstance().then((comp) => {
			this.isLoadingInnerComponent = false;
			if (!comp) return;
			if (this.isAlive()) {
				this.innerHeaderComponent = comp;
				if (this.eText) this.eText.appendChild(comp.getGui());
			} else this.destroyBean(comp);
		});
	}
	setDisplayName(params) {
		const { displayName } = params;
		const oldDisplayName = this.currentDisplayName;
		this.currentDisplayName = displayName;
		if (!this.eText || oldDisplayName === displayName || this.innerHeaderComponent || this.isLoadingInnerComponent) return;
		this.eText.textContent = _toString(displayName);
	}
	addInIcon(iconName, eParent, column) {
		const eIcon = _createIconNoSpan(iconName, this.beans, column);
		if (eIcon) eParent.appendChild(eIcon);
	}
	workOutShowMenu() {
		return this.params.enableMenu && !!this.beans.menuSvc?.isHeaderMenuButtonEnabled();
	}
	shouldSuppressMenuHide() {
		return !!this.beans.menuSvc?.isHeaderMenuButtonAlwaysShowEnabled();
	}
	setMenu() {
		if (!this.eMenu) return;
		this.currentShowMenu = this.workOutShowMenu();
		if (!this.currentShowMenu) {
			_removeFromParent(this.eMenu);
			this.eMenu = void 0;
			return;
		}
		const { gos, eMenu, params } = this;
		const isLegacyMenu = _isLegacyMenuEnabled(gos);
		this.addInIcon(isLegacyMenu ? "menu" : "menuAlt", eMenu, params.column);
		eMenu.classList.toggle("ag-header-menu-icon", !isLegacyMenu);
		const currentSuppressMenuHide = this.shouldSuppressMenuHide();
		this.currentSuppressMenuHide = currentSuppressMenuHide;
		this.addManagedElementListeners(eMenu, { click: () => this.showColumnMenu(this.eMenu) });
		this.toggleMenuAlwaysShow(currentSuppressMenuHide);
	}
	toggleMenuAlwaysShow(alwaysShow) {
		this.eMenu?.classList.toggle("ag-header-menu-always-show", alwaysShow);
	}
	showColumnMenu(element) {
		const { currentSuppressMenuHide, params } = this;
		if (!currentSuppressMenuHide) this.toggleMenuAlwaysShow(true);
		params.showColumnMenu(element, () => {
			if (!currentSuppressMenuHide) this.toggleMenuAlwaysShow(false);
		});
	}
	onMenuKeyboardShortcut(isFilterShortcut) {
		const { params, gos, beans, eMenu, eFilterButton } = this;
		const column = params.column;
		const isLegacyMenuEnabled = _isLegacyMenuEnabled(gos);
		if (isFilterShortcut && !isLegacyMenuEnabled) {
			if (beans.menuSvc?.isFilterMenuInHeaderEnabled(column)) {
				params.showFilter(eFilterButton ?? eMenu ?? this.getGui());
				return true;
			}
		} else if (params.enableMenu) {
			this.showColumnMenu(eMenu ?? eFilterButton ?? this.getGui());
			return true;
		}
		return false;
	}
	setupSort() {
		const { sortSvc } = this.beans;
		if (!sortSvc) return;
		const { enableSorting, column } = this.params;
		this.currentSort = enableSorting;
		if (!this.eSortIndicator) {
			this.eSortIndicator = this.createBean(sortSvc.createSortIndicator(true));
			const { eSortIndicator, eSortOrder, eSortAsc, eSortDesc, eSortMixed, eSortNone } = this;
			eSortIndicator.attachCustomElements(eSortOrder, eSortAsc, eSortDesc, eSortMixed, eSortNone);
		}
		this.eSortIndicator.setupSort(column);
		if (!this.currentSort) return;
		sortSvc.setupHeader(this, column, this.eLabel);
	}
	setupFilterIcon() {
		const { eFilter, params } = this;
		if (!eFilter) return;
		const onFilterChangedIcon = () => {
			_setDisplayed(eFilter, params.column.isFilterActive(), { skipAriaHidden: true });
		};
		this.configureFilter(params.enableFilterIcon, eFilter, onFilterChangedIcon, "filterActive");
	}
	setupFilterButton() {
		const { eFilterButton, params } = this;
		if (!eFilterButton) return;
		if (this.configureFilter(params.enableFilterButton, eFilterButton, this.onFilterChangedButton.bind(this), "filter")) this.addManagedElementListeners(eFilterButton, { click: () => params.showFilter(eFilterButton) });
		else this.eFilterButton = void 0;
	}
	configureFilter(enabled, element, filterChangedCallback, icon) {
		if (!enabled) {
			_removeFromParent(element);
			return false;
		}
		const column = this.params.column;
		this.addInIcon(icon, element, column);
		this.addManagedListeners(column, { filterChanged: filterChangedCallback });
		filterChangedCallback();
		return true;
	}
	onFilterChangedButton() {
		const filterPresent = this.params.column.isFilterActive();
		this.eFilterButton.classList.toggle("ag-filter-active", filterPresent);
	}
	getAnchorElementForMenu(isFilter) {
		const { eFilterButton, eMenu } = this;
		if (isFilter) return eFilterButton ?? eMenu ?? this.getGui();
		return eMenu ?? eFilterButton ?? this.getGui();
	}
	destroy() {
		super.destroy();
		if (this.innerHeaderComponent) {
			this.destroyBean(this.innerHeaderComponent);
			this.innerHeaderComponent = void 0;
		}
	}
};
var HeaderGroupCompElement = {
	tag: "div",
	cls: "ag-header-group-cell-label",
	role: "presentation",
	children: [
		{
			tag: "span",
			ref: "agLabel",
			cls: "ag-header-group-text",
			role: "presentation"
		},
		{
			tag: "span",
			ref: "agOpened",
			cls: `ag-header-icon ag-header-expand-icon ag-header-expand-icon-expanded`
		},
		{
			tag: "span",
			ref: "agClosed",
			cls: `ag-header-icon ag-header-expand-icon ag-header-expand-icon-collapsed`
		}
	]
};
var HeaderGroupComp = class extends Component {
	constructor() {
		super(HeaderGroupCompElement);
		this.agOpened = null;
		this.agClosed = null;
		this.agLabel = null;
		this.isLoadingInnerComponent = false;
	}
	init(params) {
		const { userCompFactory, touchSvc } = this.beans;
		this.params = params;
		this.checkWarnings();
		this.workOutInnerHeaderGroupComponent(userCompFactory, params);
		this.setupLabel(params);
		this.addGroupExpandIcon(params);
		this.setupExpandIcons();
		touchSvc?.setupForHeaderGroup(this);
	}
	checkWarnings() {
		if (this.params.template) _warn(89);
	}
	workOutInnerHeaderGroupComponent(userCompFactory, params) {
		const userCompDetails = _getInnerHeaderGroupCompDetails(userCompFactory, params, params);
		if (!userCompDetails) return;
		this.isLoadingInnerComponent = true;
		userCompDetails.newAgStackInstance().then((comp) => {
			this.isLoadingInnerComponent = false;
			if (!comp) return;
			if (this.isAlive()) {
				this.innerHeaderGroupComponent = comp;
				this.agLabel.appendChild(comp.getGui());
			} else this.destroyBean(comp);
		});
	}
	setupExpandIcons() {
		const { agOpened, agClosed, params: { columnGroup }, beans } = this;
		this.addInIcon("columnGroupOpened", agOpened);
		this.addInIcon("columnGroupClosed", agClosed);
		const expandAction = (event) => {
			if (_isStopPropagationForAgGrid(event)) return;
			const newExpandedValue = !columnGroup.isExpanded();
			beans.colGroupSvc.setColumnGroupOpened(columnGroup.getProvidedColumnGroup(), newExpandedValue, "uiColumnExpanded");
		};
		this.addTouchAndClickListeners(beans, agClosed, expandAction);
		this.addTouchAndClickListeners(beans, agOpened, expandAction);
		const stopPropagationAction = (event) => {
			_stopPropagationForAgGrid(event);
		};
		this.addManagedElementListeners(agClosed, { dblclick: stopPropagationAction });
		this.addManagedElementListeners(agOpened, { dblclick: stopPropagationAction });
		this.addManagedElementListeners(this.getGui(), { dblclick: expandAction });
		this.updateIconVisibility();
		const providedColumnGroup = columnGroup.getProvidedColumnGroup();
		const updateIcon = this.updateIconVisibility.bind(this);
		this.addManagedListeners(providedColumnGroup, {
			expandedChanged: updateIcon,
			expandableChanged: updateIcon
		});
	}
	addTouchAndClickListeners(beans, eElement, action) {
		beans.touchSvc?.setupForHeaderGroupElement(this, eElement, action);
		this.addManagedElementListeners(eElement, { click: action });
	}
	updateIconVisibility() {
		const { agOpened, agClosed, params: { columnGroup } } = this;
		if (columnGroup.isExpandable()) {
			const expanded = columnGroup.isExpanded();
			_setDisplayed(agOpened, expanded);
			_setDisplayed(agClosed, !expanded);
		} else {
			_setDisplayed(agOpened, false);
			_setDisplayed(agClosed, false);
		}
	}
	addInIcon(iconName, element) {
		const eIcon = _createIconNoSpan(iconName, this.beans, null);
		if (eIcon) element.appendChild(eIcon);
	}
	addGroupExpandIcon(params) {
		if (!params.columnGroup.isExpandable()) {
			const { agOpened, agClosed } = this;
			_setDisplayed(agOpened, false);
			_setDisplayed(agClosed, false);
			return;
		}
	}
	setupLabel(params) {
		const { displayName, columnGroup } = params;
		const hasInnerComponent = this.innerHeaderGroupComponent || this.isLoadingInnerComponent;
		if (_exists(displayName) && !hasInnerComponent) this.agLabel.textContent = _toString(displayName);
		this.toggleCss("ag-sticky-label", !columnGroup.getColGroupDef()?.suppressStickyLabel);
	}
	destroy() {
		super.destroy();
		if (this.innerHeaderGroupComponent) {
			this.destroyBean(this.innerHeaderGroupComponent);
			this.innerHeaderGroupComponent = void 0;
		}
	}
};
var ColumnHeaderCompModule = {
	moduleName: "ColumnHeaderComp",
	version: VERSION,
	userComponents: { agColumnHeader: HeaderComp },
	icons: {
		menu: "menu",
		menuAlt: "menu-alt"
	}
};
var ColumnGroupHeaderCompModule = {
	moduleName: "ColumnGroupHeaderComp",
	version: VERSION,
	userComponents: { agColumnGroupHeader: HeaderGroupComp },
	icons: {
		columnGroupOpened: "expanded",
		columnGroupClosed: "contracted"
	}
};
var AnimationFrameService = class extends BeanStub {
	constructor() {
		super(...arguments);
		this.beanName = "animationFrameSvc";
		this.p1 = {
			list: [],
			sorted: false
		};
		this.p2 = {
			list: [],
			sorted: false
		};
		this.f1 = {
			list: [],
			sorted: false
		};
		this.destroyTasks = [];
		this.ticking = false;
		this.scrollGoingDown = true;
		this.lastScrollTop = 0;
		this.taskCount = 0;
	}
	setScrollTop(scrollTop) {
		this.scrollGoingDown = scrollTop >= this.lastScrollTop;
		if (scrollTop === 0) this.scrollGoingDown = true;
		this.lastScrollTop = scrollTop;
	}
	postConstruct() {
		this.active = !this.gos.get("suppressAnimationFrame");
		this.batchFrameworkComps = this.beans.frameworkOverrides.batchFrameworkComps;
	}
	verify() {
		if (this.active === false) _warn(92);
	}
	createTask(task, index, list, isFramework, isDeferred = false) {
		this.verify();
		let taskList = list;
		if (isFramework && this.batchFrameworkComps) taskList = "f1";
		const taskItem = {
			task,
			index,
			createOrder: ++this.taskCount,
			deferred: isDeferred
		};
		this.addTaskToList(this[taskList], taskItem);
		this.schedule();
	}
	addTaskToList(taskList, task) {
		taskList.list.push(task);
		taskList.sorted = false;
	}
	sortTaskList(taskList) {
		if (taskList.sorted) return;
		const sortDirection = this.scrollGoingDown ? 1 : -1;
		taskList.list.sort((a, b) => {
			if (a.deferred !== b.deferred) return a.deferred ? -1 : 1;
			if (a.index !== b.index) return sortDirection * (b.index - a.index);
			return b.createOrder - a.createOrder;
		});
		taskList.sorted = true;
	}
	addDestroyTask(task) {
		this.verify();
		this.destroyTasks.push(task);
		this.schedule();
	}
	executeFrame(millis) {
		const { p1, p2, f1, destroyTasks, beans } = this;
		const { ctrlsSvc, frameworkOverrides } = beans;
		const p1Tasks = p1.list;
		const p2Tasks = p2.list;
		const f1Tasks = f1.list;
		const frameStart = Date.now();
		let duration = 0;
		const noMaxMillis = millis <= 0;
		const scrollFeature = ctrlsSvc.getScrollFeature();
		while (noMaxMillis || duration < millis) {
			if (!scrollFeature.scrollGridIfNeeded()) {
				let task;
				if (p1Tasks.length) {
					this.sortTaskList(p1);
					task = p1Tasks.pop().task;
				} else if (p2Tasks.length) {
					this.sortTaskList(p2);
					task = p2Tasks.pop().task;
				} else if (f1Tasks.length) {
					frameworkOverrides.wrapOutgoing(() => {
						while (noMaxMillis || duration < millis) {
							if (!scrollFeature.scrollGridIfNeeded()) if (f1Tasks.length) {
								this.sortTaskList(f1);
								task = f1Tasks.pop().task;
								task();
							} else break;
							else break;
							duration = Date.now() - frameStart;
						}
					});
					task = () => {};
				} else if (destroyTasks.length) task = destroyTasks.pop();
				else break;
				task();
			}
			duration = Date.now() - frameStart;
		}
		if (p1Tasks.length || p2Tasks.length || f1Tasks.length || destroyTasks.length) this.requestFrame();
		else this.ticking = false;
	}
	flushAllFrames() {
		if (!this.active) return;
		this.executeFrame(-1);
	}
	schedule() {
		if (!this.active) return;
		if (!this.ticking) {
			this.ticking = true;
			this.requestFrame();
		}
	}
	requestFrame() {
		const callback = this.executeFrame.bind(this, 60);
		_requestAnimationFrame(this.beans, callback);
	}
	isQueueEmpty() {
		return !this.ticking;
	}
};
var AnimationFrameModule = {
	moduleName: "AnimationFrame",
	version: VERSION,
	beans: [AnimationFrameService]
};
var TouchService = class extends BeanStub {
	constructor() {
		super(...arguments);
		this.beanName = "touchSvc";
	}
	mockBodyContextMenu(ctrl, listener) {
		this.mockContextMenu(ctrl, ctrl.eBodyViewport, listener);
	}
	mockHeaderContextMenu(ctrl, listener) {
		this.mockContextMenu(ctrl, ctrl.eGui, listener);
	}
	mockRowContextMenu(ctrl) {
		if (!_isIOSUserAgent()) return;
		const listener = (mouseListener, touch, touchEvent) => {
			const { rowCtrl, cellCtrl } = ctrl.getControlsForEventTarget(touchEvent?.target ?? null);
			if (cellCtrl?.column) cellCtrl.dispatchCellContextMenuEvent(touchEvent ?? null);
			this.beans.contextMenuSvc?.handleContextMenuMouseEvent(void 0, touchEvent, rowCtrl, cellCtrl);
		};
		this.mockContextMenu(ctrl, ctrl.element, listener);
	}
	handleCellDoubleClick(ctrl, mouseEvent) {
		const isDoubleClickOnIPad = () => {
			if (!_isIOSUserAgent() || _isEventSupported("dblclick")) return false;
			const nowMillis = Date.now();
			const res = nowMillis - ctrl.lastIPadMouseClickEvent < 200;
			ctrl.lastIPadMouseClickEvent = nowMillis;
			return res;
		};
		if (isDoubleClickOnIPad()) {
			ctrl.onCellDoubleClicked(mouseEvent);
			mouseEvent.preventDefault();
			return true;
		}
		return false;
	}
	setupForHeader(comp) {
		const { gos, sortSvc, menuSvc } = this.beans;
		if (gos.get("suppressTouch")) return;
		const { params, eMenu, eFilterButton } = comp;
		const touchListener = new TouchListener(comp.getGui(), true);
		const suppressMenuHide = comp.shouldSuppressMenuHide();
		const tapMenuButton = suppressMenuHide && _exists(eMenu) && params.enableMenu;
		const menuTouchListener = tapMenuButton ? new TouchListener(eMenu, true) : touchListener;
		if (params.enableMenu || menuSvc?.isHeaderContextMenuEnabled(params.column)) {
			const eventType = tapMenuButton ? "tap" : "longTap";
			const showMenuFn = (event) => params.showColumnMenuAfterMouseClick(event.touchStart);
			comp.addManagedListeners(menuTouchListener, { [eventType]: showMenuFn });
		}
		if (params.enableSorting) {
			const tapListener = (event) => {
				const target = event.touchStart.target;
				if (suppressMenuHide && (eMenu?.contains(target) || eFilterButton?.contains(target))) return;
				sortSvc?.progressSort(params.column, false, "uiColumnSorted");
			};
			comp.addManagedListeners(touchListener, { tap: tapListener });
		}
		if (params.enableFilterButton && eFilterButton) {
			const filterButtonTouchListener = new TouchListener(eFilterButton, true);
			comp.addManagedListeners(filterButtonTouchListener, { tap: () => params.showFilter(eFilterButton) });
			comp.addDestroyFunc(() => filterButtonTouchListener.destroy());
		}
		comp.addDestroyFunc(() => touchListener.destroy());
		if (tapMenuButton) comp.addDestroyFunc(() => menuTouchListener.destroy());
	}
	setupForHeaderGroup(comp) {
		const params = comp.params;
		if (this.beans.menuSvc?.isHeaderContextMenuEnabled(params.columnGroup.getProvidedColumnGroup())) {
			const touchListener = new TouchListener(params.eGridHeader, true);
			const showMenuFn = (event) => params.showColumnMenuAfterMouseClick(event.touchStart);
			comp.addManagedListeners(touchListener, { longTap: showMenuFn });
			comp.addDestroyFunc(() => touchListener.destroy());
		}
	}
	setupForHeaderGroupElement(comp, eElement, action) {
		const touchListener = new TouchListener(eElement, true);
		comp.addManagedListeners(touchListener, { tap: action });
		comp.addDestroyFunc(() => touchListener.destroy());
	}
	mockContextMenu(ctrl, element, listener) {
		if (!_isIOSUserAgent()) return;
		const touchListener = new TouchListener(element);
		const longTapListener = (event) => {
			if (!_isEventFromThisGrid(this.gos, event.touchEvent)) return;
			listener(void 0, event.touchStart, event.touchEvent);
		};
		ctrl.addManagedListeners(touchListener, { longTap: longTapListener });
		ctrl.addDestroyFunc(() => touchListener.destroy());
	}
};
var TouchModule = {
	moduleName: "Touch",
	version: VERSION,
	beans: [TouchService]
};
var CellNavigationService = class extends BeanStub {
	constructor() {
		super(...arguments);
		this.beanName = "cellNavigation";
	}
	wireBeans(beans) {
		this.rowSpanSvc = beans.rowSpanSvc;
	}
	getNextCellToFocus(key, focusedCell, ctrlPressed = false) {
		if (ctrlPressed) return this.getNextCellToFocusWithCtrlPressed(key, focusedCell);
		return this.getNextCellToFocusWithoutCtrlPressed(key, focusedCell);
	}
	getNextCellToFocusWithCtrlPressed(key, focusedCell) {
		const upKey = key === KeyCode.UP;
		const downKey = key === KeyCode.DOWN;
		const leftKey = key === KeyCode.LEFT;
		let column;
		let rowIndex;
		const { pageBounds, gos, visibleCols, pinnedRowModel } = this.beans;
		const { rowPinned } = focusedCell;
		if (upKey || downKey) {
			if (rowPinned && pinnedRowModel) if (upKey) rowIndex = 0;
			else rowIndex = rowPinned === "top" ? pinnedRowModel.getPinnedTopRowCount() - 1 : pinnedRowModel.getPinnedBottomRowCount() - 1;
			else rowIndex = upKey ? pageBounds.getFirstRow() : pageBounds.getLastRow();
			column = focusedCell.column;
		} else {
			const isRtl = gos.get("enableRtl");
			rowIndex = focusedCell.rowIndex;
			column = (leftKey !== isRtl ? visibleCols.allCols : [...visibleCols.allCols].reverse()).find((col) => this.isCellGoodToFocusOn({
				rowIndex,
				rowPinned: null,
				column: col
			}));
		}
		return column ? {
			rowIndex,
			rowPinned,
			column
		} : null;
	}
	getNextCellToFocusWithoutCtrlPressed(key, focusedCell) {
		let pointer = focusedCell;
		let finished = false;
		while (!finished) {
			switch (key) {
				case KeyCode.UP:
					pointer = this.getCellAbove(pointer);
					break;
				case KeyCode.DOWN:
					pointer = this.getCellBelow(pointer);
					break;
				case KeyCode.RIGHT:
					pointer = this.gos.get("enableRtl") ? this.getCellToLeft(pointer) : this.getCellToRight(pointer);
					break;
				case KeyCode.LEFT:
					pointer = this.gos.get("enableRtl") ? this.getCellToRight(pointer) : this.getCellToLeft(pointer);
					break;
				default:
					pointer = null;
					_warn(8, { key });
					break;
			}
			if (pointer) finished = this.isCellGoodToFocusOn(pointer);
			else finished = true;
		}
		return pointer;
	}
	isCellGoodToFocusOn(gridCell) {
		const column = gridCell.column;
		let rowNode;
		const { pinnedRowModel, rowModel } = this.beans;
		switch (gridCell.rowPinned) {
			case "top":
				rowNode = pinnedRowModel?.getPinnedTopRow(gridCell.rowIndex);
				break;
			case "bottom":
				rowNode = pinnedRowModel?.getPinnedBottomRow(gridCell.rowIndex);
				break;
			default:
				rowNode = rowModel.getRow(gridCell.rowIndex);
				break;
		}
		if (!rowNode) return false;
		return !this.isSuppressNavigable(column, rowNode);
	}
	getCellToLeft(lastCell) {
		if (!lastCell) return null;
		const colToLeft = this.beans.visibleCols.getColBefore(lastCell.column);
		if (!colToLeft) return null;
		return {
			rowIndex: lastCell.rowIndex,
			column: colToLeft,
			rowPinned: lastCell.rowPinned
		};
	}
	getCellToRight(lastCell) {
		if (!lastCell) return null;
		const colToRight = this.beans.visibleCols.getColAfter(lastCell.column);
		if (!colToRight) return null;
		return {
			rowIndex: lastCell.rowIndex,
			column: colToRight,
			rowPinned: lastCell.rowPinned
		};
	}
	getCellBelow(lastCell) {
		if (!lastCell) return null;
		const adjustedLastCell = this.rowSpanSvc?.getCellEnd(lastCell) ?? lastCell;
		const rowBelow = _getRowBelow(this.beans, adjustedLastCell);
		if (rowBelow) return {
			rowIndex: rowBelow.rowIndex,
			column: lastCell.column,
			rowPinned: rowBelow.rowPinned
		};
		return null;
	}
	getCellAbove(lastCell) {
		if (!lastCell) return null;
		const adjustedLastCell = this.rowSpanSvc?.getCellStart(lastCell) ?? lastCell;
		const rowAbove = _getRowAbove(this.beans, {
			rowIndex: adjustedLastCell.rowIndex,
			rowPinned: adjustedLastCell.rowPinned
		});
		if (rowAbove) return {
			rowIndex: rowAbove.rowIndex,
			column: lastCell.column,
			rowPinned: rowAbove.rowPinned
		};
		return null;
	}
	getNextTabbedCell(gridCell, backwards) {
		if (backwards) return this.getNextTabbedCellBackwards(gridCell);
		return this.getNextTabbedCellForwards(gridCell);
	}
	getNextTabbedCellForwards(gridCell) {
		const { visibleCols, pagination } = this.beans;
		const displayedColumns = visibleCols.allCols;
		let newRowIndex = gridCell.rowIndex;
		let newFloating = gridCell.rowPinned;
		let newColumn = visibleCols.getColAfter(gridCell.column);
		if (!newColumn) {
			newColumn = displayedColumns[0];
			const rowBelow = _getRowBelow(this.beans, gridCell);
			if (_missing(rowBelow)) return null;
			if (!rowBelow.rowPinned && !(pagination?.isRowInPage(rowBelow.rowIndex) ?? true)) return null;
			newRowIndex = rowBelow ? rowBelow.rowIndex : null;
			newFloating = rowBelow ? rowBelow.rowPinned : null;
		}
		return {
			rowIndex: newRowIndex,
			column: newColumn,
			rowPinned: newFloating
		};
	}
	getNextTabbedCellBackwards(gridCell) {
		const { beans } = this;
		const { visibleCols, pagination } = beans;
		const displayedColumns = visibleCols.allCols;
		let newRowIndex = gridCell.rowIndex;
		let newFloating = gridCell.rowPinned;
		let newColumn = visibleCols.getColBefore(gridCell.column);
		if (!newColumn) {
			newColumn = _last(displayedColumns);
			const rowAbove = _getRowAbove(beans, {
				rowIndex: gridCell.rowIndex,
				rowPinned: gridCell.rowPinned
			});
			if (_missing(rowAbove)) return null;
			if (!rowAbove.rowPinned && !(pagination?.isRowInPage(rowAbove.rowIndex) ?? true)) return null;
			newRowIndex = rowAbove ? rowAbove.rowIndex : null;
			newFloating = rowAbove ? rowAbove.rowPinned : null;
		}
		return {
			rowIndex: newRowIndex,
			column: newColumn,
			rowPinned: newFloating
		};
	}
	isSuppressNavigable(column, rowNode) {
		const { suppressNavigable } = column.colDef;
		if (typeof suppressNavigable === "boolean") return suppressNavigable;
		if (typeof suppressNavigable === "function") return suppressNavigable(column.createColumnFunctionCallbackParams(rowNode));
		return false;
	}
};
function getFocusedCell(beans) {
	return beans.focusSvc.getFocusedCell();
}
function clearFocusedCell(beans) {
	return beans.focusSvc.clearFocusedCell();
}
function setFocusedCell(beans, rowIndex, colKey, rowPinned) {
	beans.focusSvc.setFocusedCell({
		rowIndex,
		column: colKey,
		rowPinned,
		forceBrowserFocus: true
	});
}
function tabToNextCell(beans, event) {
	return beans.navigation?.tabToNextCell(false, event) ?? false;
}
function tabToPreviousCell(beans, event) {
	return beans.navigation?.tabToNextCell(true, event) ?? false;
}
function setFocusedHeader(beans, colKey, floatingFilter = false) {
	const headerPosition = beans.headerNavigation?.getHeaderPositionForColumn(colKey, floatingFilter);
	if (!headerPosition) return;
	beans.focusSvc.focusHeaderPosition({ headerPosition });
}
var NavigationService = class extends BeanStub {
	constructor() {
		super();
		this.beanName = "navigation";
		this.onPageDown = _throttle(this.onPageDown, 100);
		this.onPageUp = _throttle(this.onPageUp, 100);
	}
	postConstruct() {
		this.beans.ctrlsSvc.whenReady(this, (p) => {
			this.gridBodyCon = p.gridBodyCtrl;
		});
	}
	handlePageScrollingKey(event, fromFullWidth = false) {
		const key = event.key;
		const alt = event.altKey;
		const ctrl = event.ctrlKey || event.metaKey;
		const rangeServiceShouldHandleShift = !!this.beans.rangeSvc && event.shiftKey;
		const currentCell = _getCellPositionForEvent(this.gos, event);
		let processed = false;
		switch (key) {
			case KeyCode.PAGE_HOME:
			case KeyCode.PAGE_END:
				if (!ctrl && !alt) {
					this.onHomeOrEndKey(key);
					processed = true;
				}
				break;
			case KeyCode.LEFT:
			case KeyCode.RIGHT:
			case KeyCode.UP:
			case KeyCode.DOWN:
				if (!currentCell) return false;
				if (ctrl && !alt && !rangeServiceShouldHandleShift) {
					this.onCtrlUpDownLeftRight(key, currentCell);
					processed = true;
				}
				break;
			case KeyCode.PAGE_DOWN:
			case KeyCode.PAGE_UP:
				if (!ctrl && !alt) processed = this.handlePageUpDown(key, currentCell, fromFullWidth);
				break;
		}
		if (processed) event.preventDefault();
		return processed;
	}
	handlePageUpDown(key, currentCell, fromFullWidth) {
		if (fromFullWidth) currentCell = this.beans.focusSvc.getFocusedCell();
		if (!currentCell) return false;
		if (key === KeyCode.PAGE_UP) this.onPageUp(currentCell);
		else this.onPageDown(currentCell);
		return true;
	}
	navigateTo({ scrollIndex, scrollType, scrollColumn, focusIndex, focusColumn, isAsync, rowPinned }) {
		const { scrollFeature } = this.gridBodyCon;
		if (_exists(scrollColumn) && !scrollColumn.isPinned()) scrollFeature.ensureColumnVisible(scrollColumn);
		if (_exists(scrollIndex)) scrollFeature.ensureIndexVisible(scrollIndex, scrollType);
		if (!isAsync) scrollFeature.ensureIndexVisible(focusIndex);
		const { focusSvc, rangeSvc } = this.beans;
		focusSvc.setFocusedCell({
			rowIndex: focusIndex,
			column: focusColumn,
			rowPinned,
			forceBrowserFocus: true
		});
		rangeSvc?.setRangeToCell({
			rowIndex: focusIndex,
			rowPinned,
			column: focusColumn
		});
	}
	onPageDown(gridCell) {
		const beans = this.beans;
		const scrollPosition = getVScroll(beans);
		const pixelsInOnePage = this.getViewportHeight();
		const { pageBounds, rowModel, rowAutoHeight } = beans;
		const pagingPixelOffset = pageBounds.getPixelOffset();
		const currentPageBottomPixel = scrollPosition.top + pixelsInOnePage;
		const currentPageBottomRow = rowModel.getRowIndexAtPixel(currentPageBottomPixel + pagingPixelOffset);
		if (rowAutoHeight?.active) this.navigateToNextPageWithAutoHeight(gridCell, currentPageBottomRow);
		else this.navigateToNextPage(gridCell, currentPageBottomRow);
	}
	onPageUp(gridCell) {
		const beans = this.beans;
		const scrollPosition = getVScroll(beans);
		const { pageBounds, rowModel, rowAutoHeight } = beans;
		const pagingPixelOffset = pageBounds.getPixelOffset();
		const currentPageTopPixel = scrollPosition.top;
		const currentPageTopRow = rowModel.getRowIndexAtPixel(currentPageTopPixel + pagingPixelOffset);
		if (rowAutoHeight?.active) this.navigateToNextPageWithAutoHeight(gridCell, currentPageTopRow, true);
		else this.navigateToNextPage(gridCell, currentPageTopRow, true);
	}
	navigateToNextPage(gridCell, scrollIndex, up = false) {
		const { pageBounds, rowModel } = this.beans;
		const pixelsInOnePage = this.getViewportHeight();
		const firstRow = pageBounds.getFirstRow();
		const lastRow = pageBounds.getLastRow();
		const pagingPixelOffset = pageBounds.getPixelOffset();
		const currentRowNode = rowModel.getRow(gridCell.rowIndex);
		const rowPixelDiff = up ? currentRowNode?.rowHeight - pixelsInOnePage - pagingPixelOffset : pixelsInOnePage - pagingPixelOffset;
		const nextCellPixel = currentRowNode?.rowTop + rowPixelDiff;
		let focusIndex = rowModel.getRowIndexAtPixel(nextCellPixel + pagingPixelOffset);
		if (focusIndex === gridCell.rowIndex) {
			const diff = up ? -1 : 1;
			scrollIndex = focusIndex = gridCell.rowIndex + diff;
		}
		let scrollType;
		if (up) {
			scrollType = "bottom";
			if (focusIndex < firstRow) focusIndex = firstRow;
			if (scrollIndex < firstRow) scrollIndex = firstRow;
		} else {
			scrollType = "top";
			if (focusIndex > lastRow) focusIndex = lastRow;
			if (scrollIndex > lastRow) scrollIndex = lastRow;
		}
		if (this.isRowTallerThanView(rowModel.getRow(focusIndex))) {
			scrollIndex = focusIndex;
			scrollType = "top";
		}
		this.navigateTo({
			scrollIndex,
			scrollType,
			scrollColumn: null,
			focusIndex,
			focusColumn: gridCell.column
		});
	}
	navigateToNextPageWithAutoHeight(gridCell, scrollIndex, up = false) {
		this.navigateTo({
			scrollIndex,
			scrollType: up ? "bottom" : "top",
			scrollColumn: null,
			focusIndex: scrollIndex,
			focusColumn: gridCell.column
		});
		setTimeout(() => {
			const focusIndex = this.getNextFocusIndexForAutoHeight(gridCell, up);
			this.navigateTo({
				scrollIndex,
				scrollType: up ? "bottom" : "top",
				scrollColumn: null,
				focusIndex,
				focusColumn: gridCell.column,
				isAsync: true
			});
		}, 50);
	}
	getNextFocusIndexForAutoHeight(gridCell, up = false) {
		const step = up ? -1 : 1;
		const pixelsInOnePage = this.getViewportHeight();
		const { pageBounds, rowModel } = this.beans;
		const lastRowIndex = pageBounds.getLastRow();
		let pixelSum = 0;
		let currentIndex = gridCell.rowIndex;
		while (currentIndex >= 0 && currentIndex <= lastRowIndex) {
			const currentCell = rowModel.getRow(currentIndex);
			if (currentCell) {
				const currentCellHeight = currentCell.rowHeight ?? 0;
				if (pixelSum + currentCellHeight > pixelsInOnePage) break;
				pixelSum += currentCellHeight;
			}
			currentIndex += step;
		}
		return Math.max(0, Math.min(currentIndex, lastRowIndex));
	}
	getViewportHeight() {
		const beans = this.beans;
		const scrollPosition = getVScroll(beans);
		const scrollbarWidth = this.beans.scrollVisibleSvc.getScrollbarWidth();
		let pixelsInOnePage = scrollPosition.bottom - scrollPosition.top;
		if (beans.ctrlsSvc.get("center").isHorizontalScrollShowing()) pixelsInOnePage -= scrollbarWidth;
		return pixelsInOnePage;
	}
	isRowTallerThanView(rowNode) {
		if (!rowNode) return false;
		const rowHeight = rowNode.rowHeight;
		if (typeof rowHeight !== "number") return false;
		return rowHeight > this.getViewportHeight();
	}
	onCtrlUpDownLeftRight(key, gridCell) {
		const cellToFocus = this.beans.cellNavigation.getNextCellToFocus(key, gridCell, true);
		const { rowIndex, rowPinned } = cellToFocus;
		const column = cellToFocus.column;
		this.navigateTo({
			scrollIndex: rowIndex,
			scrollType: null,
			scrollColumn: column,
			focusIndex: rowIndex,
			focusColumn: column,
			rowPinned
		});
	}
	onHomeOrEndKey(key) {
		const homeKey = key === KeyCode.PAGE_HOME;
		const { visibleCols, pageBounds, rowModel } = this.beans;
		const allColumns = visibleCols.allCols;
		const scrollIndex = homeKey ? pageBounds.getFirstRow() : pageBounds.getLastRow();
		const rowNode = rowModel.getRow(scrollIndex);
		if (!rowNode) return;
		const columnToSelect = (homeKey ? allColumns : [...allColumns].reverse()).find((col) => !col.isSuppressNavigable(rowNode));
		if (!columnToSelect) return;
		this.navigateTo({
			scrollIndex,
			scrollType: null,
			scrollColumn: columnToSelect,
			focusIndex: scrollIndex,
			focusColumn: columnToSelect
		});
	}
	onTabKeyDown(previous, keyboardEvent) {
		const backwards = keyboardEvent.shiftKey;
		const movedToNextCell = this.tabToNextCellCommon(previous, backwards, keyboardEvent);
		const beans = this.beans;
		const { ctrlsSvc, pageBounds, focusSvc, gos } = beans;
		if (movedToNextCell !== false) {
			if (movedToNextCell) keyboardEvent.preventDefault();
			else if (movedToNextCell === null) ctrlsSvc.get("gridCtrl").allowFocusForNextCoreContainer(backwards);
			return;
		}
		if (backwards) {
			const { rowIndex, rowPinned } = previous.getRowPosition();
			if (rowPinned ? rowIndex === 0 : rowIndex === pageBounds.getFirstRow()) if (gos.get("headerHeight") === 0 || _isHeaderFocusSuppressed(beans)) _focusNextGridCoreContainer(beans, true, true);
			else {
				keyboardEvent.preventDefault();
				focusSvc.focusPreviousFromFirstCell(keyboardEvent);
			}
		} else {
			if (previous instanceof CellCtrl) previous.focusCell(true);
			if (!backwards && focusSvc.focusOverlay(false) || _focusNextGridCoreContainer(beans, backwards)) keyboardEvent.preventDefault();
		}
	}
	tabToNextCell(backwards, event) {
		const beans = this.beans;
		const { focusSvc, rowRenderer } = beans;
		const focusedCell = focusSvc.getFocusedCell();
		if (!focusedCell) return false;
		let cellOrRow = _getCellByPosition(beans, focusedCell);
		if (!cellOrRow) {
			cellOrRow = rowRenderer.getRowByPosition(focusedCell);
			if (!cellOrRow || !cellOrRow.isFullWidth()) return false;
		}
		return !!this.tabToNextCellCommon(cellOrRow, backwards, event, "api");
	}
	tabToNextCellCommon(previous, backwards, event, source = "ui") {
		const { editSvc, focusSvc } = this.beans;
		let res = void 0;
		const cellCtrl = previous instanceof CellCtrl ? previous : previous.getAllCellCtrls()?.[0];
		if (editSvc?.isEditing()) res = editSvc?.moveToNextCell(cellCtrl, backwards, event, source);
		else res = this.moveToNextCellNotEditing(previous, backwards, event);
		if (res === null) return res;
		return res || !!focusSvc.focusedHeader;
	}
	moveToNextCellNotEditing(previousCell, backwards, event) {
		const displayedColumns = this.beans.visibleCols.allCols;
		let cellPos;
		if (previousCell instanceof RowCtrl) {
			cellPos = {
				...previousCell.getRowPosition(),
				column: backwards ? displayedColumns[0] : _last(displayedColumns)
			};
			if (this.gos.get("embedFullWidthRows") && event) {
				const focusedContainer = previousCell.findFullWidthInfoForEvent(event);
				if (focusedContainer) cellPos.column = focusedContainer.column;
			}
		} else cellPos = previousCell.getFocusedCellPosition();
		const nextCell = this.findNextCellToFocusOn(cellPos, {
			backwards,
			startEditing: false
		});
		if (nextCell === false) return null;
		if (nextCell instanceof CellCtrl) nextCell.focusCell(true);
		else if (nextCell) return this.tryToFocusFullWidthRow(nextCell, backwards);
		return _exists(nextCell);
	}
	findNextCellToFocusOn(previousPosition, { backwards, startEditing, skipToNextEditableCell }) {
		let nextPosition = previousPosition;
		const beans = this.beans;
		const { cellNavigation, gos, focusSvc, rowRenderer, rangeSvc } = beans;
		while (true) {
			if (previousPosition !== nextPosition) previousPosition = nextPosition;
			if (!backwards) nextPosition = this.getLastCellOfColSpan(nextPosition);
			nextPosition = cellNavigation.getNextTabbedCell(nextPosition, backwards);
			const userFunc = gos.getCallback("tabToNextCell");
			if (_exists(userFunc)) {
				const userResult = userFunc({
					backwards,
					editing: startEditing,
					previousCellPosition: previousPosition,
					nextCellPosition: nextPosition ? nextPosition : null
				});
				if (userResult === true) nextPosition = previousPosition;
				else if (userResult === false) return false;
				else nextPosition = {
					rowIndex: userResult.rowIndex,
					column: userResult.column,
					rowPinned: userResult.rowPinned
				};
			}
			if (!nextPosition) return null;
			if (nextPosition.rowIndex < 0) {
				const headerLen = getFocusHeaderRowCount(beans);
				focusSvc.focusHeaderPosition({
					headerPosition: {
						headerRowIndex: headerLen + nextPosition.rowIndex,
						column: nextPosition.column
					},
					fromCell: true
				});
				return null;
			}
			const fullRowEdit = gos.get("editType") === "fullRow";
			if (startEditing && (!fullRowEdit || skipToNextEditableCell)) {
				if (!this.isCellEditable(nextPosition)) continue;
			}
			this.ensureCellVisible(nextPosition);
			const nextCell = _getCellByPosition(beans, nextPosition);
			if (!nextCell) {
				const row = rowRenderer.getRowByPosition(nextPosition);
				if (!row || !row.isFullWidth() || startEditing) continue;
				return {
					...row.getRowPosition(),
					column: nextPosition?.column
				};
			}
			if (cellNavigation.isSuppressNavigable(nextCell.column, nextCell.rowNode)) continue;
			nextCell.setFocusedCellPosition(nextPosition);
			rangeSvc?.setRangeToCell(nextPosition);
			return nextCell;
		}
	}
	isCellEditable(cell) {
		const rowNode = this.lookupRowNodeForCell(cell);
		if (rowNode) return cell.column.isCellEditable(rowNode);
		return false;
	}
	lookupRowNodeForCell({ rowIndex, rowPinned }) {
		const { pinnedRowModel, rowModel } = this.beans;
		if (rowPinned === "top") return pinnedRowModel?.getPinnedTopRow(rowIndex);
		if (rowPinned === "bottom") return pinnedRowModel?.getPinnedBottomRow(rowIndex);
		return rowModel.getRow(rowIndex);
	}
	navigateToNextCell(event, key, currentCell, allowUserOverride) {
		let nextCell = currentCell;
		let hitEdgeOfGrid = false;
		const beans = this.beans;
		const { cellNavigation, focusSvc, gos } = beans;
		while (nextCell && (nextCell === currentCell || !this.isValidNavigateCell(nextCell))) {
			if (gos.get("enableRtl")) {
				if (key === KeyCode.LEFT) nextCell = this.getLastCellOfColSpan(nextCell);
			} else if (key === KeyCode.RIGHT) nextCell = this.getLastCellOfColSpan(nextCell);
			nextCell = cellNavigation.getNextCellToFocus(key, nextCell);
			hitEdgeOfGrid = _missing(nextCell);
		}
		if (hitEdgeOfGrid && event && event.key === KeyCode.UP) nextCell = {
			rowIndex: -1,
			rowPinned: null,
			column: currentCell.column
		};
		if (allowUserOverride) {
			const userFunc = gos.getCallback("navigateToNextCell");
			if (_exists(userFunc)) {
				const userCell = userFunc({
					key,
					previousCellPosition: currentCell,
					nextCellPosition: nextCell ? nextCell : null,
					event
				});
				if (_exists(userCell)) nextCell = {
					rowPinned: userCell.rowPinned,
					rowIndex: userCell.rowIndex,
					column: userCell.column
				};
				else nextCell = null;
			}
		}
		if (!nextCell) return;
		if (nextCell.rowIndex < 0) {
			const headerLen = getFocusHeaderRowCount(beans);
			focusSvc.focusHeaderPosition({
				headerPosition: {
					headerRowIndex: headerLen + nextCell.rowIndex,
					column: currentCell.column
				},
				event: event || void 0,
				fromCell: true
			});
			return;
		}
		const normalisedPosition = this.getNormalisedPosition(nextCell);
		if (normalisedPosition) this.focusPosition(normalisedPosition);
		else this.tryToFocusFullWidthRow(nextCell);
	}
	getNormalisedPosition(cellPosition) {
		if (!!this.beans.spannedRowRenderer?.getCellByPosition(cellPosition)) return cellPosition;
		this.ensureCellVisible(cellPosition);
		const cellCtrl = _getCellByPosition(this.beans, cellPosition);
		if (!cellCtrl) return null;
		cellPosition = cellCtrl.getFocusedCellPosition();
		this.ensureCellVisible(cellPosition);
		return cellPosition;
	}
	tryToFocusFullWidthRow(position, backwards) {
		const { visibleCols, rowRenderer, focusSvc, eventSvc } = this.beans;
		const displayedColumns = visibleCols.allCols;
		const rowComp = rowRenderer.getRowByPosition(position);
		if (!rowComp || !rowComp.isFullWidth()) return false;
		const currentCellFocused = focusSvc.getFocusedCell();
		const cellPosition = {
			rowIndex: position.rowIndex,
			rowPinned: position.rowPinned,
			column: position.column || (backwards ? _last(displayedColumns) : displayedColumns[0])
		};
		this.focusPosition(cellPosition);
		const fromBelow = backwards == null ? currentCellFocused != null && _isRowBefore(cellPosition, currentCellFocused) : backwards;
		eventSvc.dispatchEvent({
			type: "fullWidthRowFocused",
			rowIndex: cellPosition.rowIndex,
			rowPinned: cellPosition.rowPinned,
			column: cellPosition.column,
			isFullWidthCell: true,
			fromBelow
		});
		return true;
	}
	focusPosition(cellPosition) {
		const { focusSvc, rangeSvc } = this.beans;
		focusSvc.setFocusedCell({
			rowIndex: cellPosition.rowIndex,
			column: cellPosition.column,
			rowPinned: cellPosition.rowPinned,
			forceBrowserFocus: true
		});
		rangeSvc?.setRangeToCell(cellPosition);
	}
	isValidNavigateCell(cell) {
		return !!_getRowNode(this.beans, cell);
	}
	getLastCellOfColSpan(cell) {
		const cellCtrl = _getCellByPosition(this.beans, cell);
		if (!cellCtrl) return cell;
		const colSpanningList = cellCtrl.getColSpanningList();
		if (colSpanningList.length === 1) return cell;
		return {
			rowIndex: cell.rowIndex,
			column: _last(colSpanningList),
			rowPinned: cell.rowPinned
		};
	}
	ensureCellVisible(gridCell) {
		const isGroupStickyEnabled = _isGroupRowsSticky(this.gos);
		const rowNode = this.beans.rowModel.getRow(gridCell.rowIndex);
		const skipScrollToRow = isGroupStickyEnabled && rowNode?.sticky;
		const { scrollFeature } = this.gridBodyCon;
		if (!skipScrollToRow && _missing(gridCell.rowPinned)) scrollFeature.ensureIndexVisible(gridCell.rowIndex);
		if (!gridCell.column.isPinned()) scrollFeature.ensureColumnVisible(gridCell.column);
	}
	ensureColumnVisible(column) {
		const scrollFeature = this.gridBodyCon.scrollFeature;
		if (!column.isPinned()) scrollFeature.ensureColumnVisible(column);
	}
	ensureRowVisible(rowIndex) {
		this.gridBodyCon.scrollFeature.ensureIndexVisible(rowIndex);
	}
};
function getVScroll(beans) {
	return beans.ctrlsSvc.getScrollFeature().getVScrollPosition();
}
var KeyboardNavigationModule = {
	moduleName: "KeyboardNavigation",
	version: VERSION,
	beans: [
		NavigationService,
		CellNavigationService,
		HeaderNavigationService
	],
	apiFunctions: {
		getFocusedCell,
		clearFocusedCell,
		setFocusedCell,
		setFocusedHeader,
		tabToNextCell,
		tabToPreviousCell
	}
};
var PageBoundsListener = class extends BeanStub {
	constructor() {
		super(...arguments);
		this.beanName = "pageBoundsListener";
	}
	postConstruct() {
		this.addManagedEventListeners({
			modelUpdated: this.onModelUpdated.bind(this),
			recalculateRowBounds: this.calculatePages.bind(this)
		});
		this.onModelUpdated();
	}
	onModelUpdated(modelUpdatedEvent) {
		this.calculatePages();
		this.eventSvc.dispatchEvent({
			type: "paginationChanged",
			animate: modelUpdatedEvent?.animate ?? false,
			newData: modelUpdatedEvent?.newData ?? false,
			newPage: modelUpdatedEvent?.newPage ?? false,
			newPageSize: modelUpdatedEvent?.newPageSize ?? false,
			keepRenderedRows: modelUpdatedEvent?.keepRenderedRows ?? false
		});
	}
	calculatePages() {
		const { pageBounds, pagination, rowModel } = this.beans;
		if (pagination) pagination.calculatePages();
		else pageBounds.calculateBounds(0, rowModel.getRowCount() - 1);
	}
};
var PageBoundsService = class extends BeanStub {
	constructor() {
		super(...arguments);
		this.beanName = "pageBounds";
		this.pixelOffset = 0;
	}
	getFirstRow() {
		return this.topRowBounds?.rowIndex ?? -1;
	}
	getLastRow() {
		return this.bottomRowBounds?.rowIndex ?? -1;
	}
	getCurrentPageHeight() {
		const { topRowBounds, bottomRowBounds } = this;
		if (!topRowBounds || !bottomRowBounds) return 0;
		return Math.max(bottomRowBounds.rowTop + bottomRowBounds.rowHeight - topRowBounds.rowTop, 0);
	}
	getCurrentPagePixelRange() {
		const { topRowBounds, bottomRowBounds } = this;
		return {
			pageFirstPixel: topRowBounds?.rowTop ?? 0,
			pageLastPixel: bottomRowBounds ? bottomRowBounds.rowTop + bottomRowBounds.rowHeight : 0
		};
	}
	calculateBounds(topDisplayedRowIndex, bottomDisplayedRowIndex) {
		const { rowModel } = this.beans;
		const topRowBounds = rowModel.getRowBounds(topDisplayedRowIndex);
		if (topRowBounds) topRowBounds.rowIndex = topDisplayedRowIndex;
		this.topRowBounds = topRowBounds;
		const bottomRowBounds = rowModel.getRowBounds(bottomDisplayedRowIndex);
		if (bottomRowBounds) bottomRowBounds.rowIndex = bottomDisplayedRowIndex;
		this.bottomRowBounds = bottomRowBounds;
		this.calculatePixelOffset();
	}
	getPixelOffset() {
		return this.pixelOffset;
	}
	calculatePixelOffset() {
		const value = this.topRowBounds?.rowTop ?? 0;
		if (this.pixelOffset === value) return;
		this.pixelOffset = value;
		this.eventSvc.dispatchEvent({ type: "paginationPixelOffsetChanged" });
	}
};
var pinnedColumnModuleCSS = `.ag-pinned-left-floating-bottom,.ag-pinned-left-floating-top,.ag-pinned-right-floating-bottom,.ag-pinned-right-floating-top{min-width:0;overflow:hidden;position:relative}.ag-pinned-left-sticky-top,.ag-pinned-right-sticky-top{height:100%;overflow:hidden;position:relative}.ag-sticky-bottom-full-width-container,.ag-sticky-top-full-width-container{height:100%;overflow:hidden;width:100%}.ag-pinned-left-header,.ag-pinned-right-header{display:inline-block;height:100%;overflow:hidden;position:relative}.ag-body-horizontal-scroll:not(.ag-scrollbar-invisible){.ag-horizontal-left-spacer:not(.ag-scroller-corner){border-right:var(--ag-pinned-column-border)}.ag-horizontal-right-spacer:not(.ag-scroller-corner){border-left:var(--ag-pinned-column-border)}}.ag-pinned-right-header{border-left:var(--ag-pinned-column-border)}.ag-pinned-left-header{border-right:var(--ag-pinned-column-border)}.ag-cell.ag-cell-first-right-pinned:not(.ag-cell-range-left,.ag-cell-range-single-cell,.ag-cell-focus:not(.ag-cell-range-selected):focus-within){border-left:var(--ag-pinned-column-border)}.ag-cell.ag-cell-last-left-pinned:not(.ag-cell-range-right,.ag-cell-range-single-cell,.ag-cell-focus:not(.ag-cell-range-selected):focus-within){border-right:var(--ag-pinned-column-border)}.ag-pinned-left-header .ag-header-cell-resize:after{left:calc(50% - var(--ag-header-column-resize-handle-width))}.ag-pinned-right-header .ag-header-cell-resize:after{left:50%}.ag-pinned-left-header .ag-header-cell-resize{right:-3px}.ag-pinned-right-header .ag-header-cell-resize{left:-3px}`;
var SetPinnedWidthFeature = class extends BeanStub {
	constructor(isLeft, elements) {
		super();
		this.isLeft = isLeft;
		this.elements = elements;
		this.getWidth = isLeft ? () => this.beans.pinnedCols.leftWidth : () => this.beans.pinnedCols.rightWidth;
	}
	postConstruct() {
		this.addManagedEventListeners({ [`${this.isLeft ? "left" : "right"}PinnedWidthChanged`]: this.onPinnedWidthChanged.bind(this) });
	}
	onPinnedWidthChanged() {
		const width = this.getWidth();
		const displayed = width > 0;
		for (const element of this.elements) if (element) {
			_setDisplayed(element, displayed);
			_setFixedWidth(element, width);
		}
	}
};
var PinnedColumnService = class extends BeanStub {
	constructor() {
		super(...arguments);
		this.beanName = "pinnedCols";
	}
	postConstruct() {
		this.beans.ctrlsSvc.whenReady(this, (p) => {
			this.gridBodyCtrl = p.gridBodyCtrl;
		});
		const listener = this.checkContainerWidths.bind(this);
		this.addManagedEventListeners({
			displayedColumnsChanged: listener,
			displayedColumnsWidthChanged: listener
		});
		this.addManagedPropertyListener("domLayout", listener);
	}
	checkContainerWidths() {
		const { gos, visibleCols, eventSvc } = this.beans;
		const printLayout = _isDomLayout(gos, "print");
		const newLeftWidth = printLayout ? 0 : visibleCols.getColsLeftWidth();
		const newRightWidth = printLayout ? 0 : visibleCols.getDisplayedColumnsRightWidth();
		if (newLeftWidth != this.leftWidth) {
			this.leftWidth = newLeftWidth;
			eventSvc.dispatchEvent({ type: "leftPinnedWidthChanged" });
		}
		if (newRightWidth != this.rightWidth) {
			this.rightWidth = newRightWidth;
			eventSvc.dispatchEvent({ type: "rightPinnedWidthChanged" });
		}
	}
	keepPinnedColumnsNarrowerThanViewport() {
		const eBodyViewport = this.gridBodyCtrl.eBodyViewport;
		const bodyWidth = _getInnerWidth(eBodyViewport);
		if (bodyWidth <= 50) return;
		const processedColumnsToRemove = this.getPinnedColumnsOverflowingViewport(bodyWidth - 50);
		const processUnpinnedColumns = this.gos.getCallback("processUnpinnedColumns");
		const { columns, hasLockedPinned } = processedColumnsToRemove;
		let columnsToRemove = columns;
		if (!columnsToRemove.length && !hasLockedPinned) return;
		if (processUnpinnedColumns) columnsToRemove = processUnpinnedColumns({
			columns: columnsToRemove,
			viewportWidth: bodyWidth
		});
		if (!columnsToRemove || !columnsToRemove.length) return;
		columnsToRemove = columnsToRemove.filter((col) => !isRowNumberCol(col));
		this.setColsPinned(columnsToRemove, null, "viewportSizeFeature");
	}
	createPinnedWidthFeature(isLeft, ...elements) {
		return new SetPinnedWidthFeature(isLeft, elements);
	}
	setColsPinned(keys, pinned, source) {
		const { colModel, colAnimation, visibleCols, gos } = this.beans;
		if (!colModel.cols) return;
		if (!keys?.length) return;
		if (_isDomLayout(gos, "print")) {
			_warn(37);
			return;
		}
		colAnimation?.start();
		let actualPinned;
		if (pinned === true || pinned === "left") actualPinned = "left";
		else if (pinned === "right") actualPinned = "right";
		else actualPinned = null;
		const updatedCols = [];
		keys.forEach((key) => {
			if (!key) return;
			const column = colModel.getCol(key);
			if (!column) return;
			if (column.getPinned() !== actualPinned) {
				this.setColPinned(column, actualPinned);
				updatedCols.push(column);
			}
		});
		if (updatedCols.length) {
			visibleCols.refresh(source);
			dispatchColumnPinnedEvent(this.eventSvc, updatedCols, source);
		}
		colAnimation?.finish();
	}
	initCol(column) {
		const { pinned, initialPinned } = column.colDef;
		if (pinned !== void 0) this.setColPinned(column, pinned);
		else this.setColPinned(column, initialPinned);
	}
	setColPinned(column, pinned) {
		if (pinned === true || pinned === "left") column.pinned = "left";
		else if (pinned === "right") column.pinned = "right";
		else column.pinned = null;
		column.dispatchStateUpdatedEvent("pinned");
	}
	setupHeaderPinnedWidth(ctrl) {
		const { scrollVisibleSvc } = this.beans;
		if (ctrl.pinned == null) return;
		const pinningLeft = ctrl.pinned === "left";
		const pinningRight = ctrl.pinned === "right";
		ctrl.hidden = true;
		const listener = () => {
			const width = pinningLeft ? this.leftWidth : this.rightWidth;
			if (width == null) return;
			const hidden = width == 0;
			const hiddenChanged = ctrl.hidden !== hidden;
			const isRtl = this.gos.get("enableRtl");
			const scrollbarWidth = scrollVisibleSvc.getScrollbarWidth();
			const widthWithPadding = scrollVisibleSvc.verticalScrollShowing && (isRtl && pinningLeft || !isRtl && pinningRight) ? width + scrollbarWidth : width;
			ctrl.comp.setPinnedContainerWidth(`${widthWithPadding}px`);
			ctrl.comp.setDisplayed(!hidden);
			if (hiddenChanged) {
				ctrl.hidden = hidden;
				ctrl.refresh();
			}
		};
		ctrl.addManagedEventListeners({
			leftPinnedWidthChanged: listener,
			rightPinnedWidthChanged: listener,
			scrollVisibilityChanged: listener,
			scrollbarWidthChanged: listener
		});
	}
	getHeaderResizeDiff(diff, column) {
		if (column.getPinned()) {
			const { leftWidth, rightWidth } = this;
			const bodyWidth = _getInnerWidth(this.beans.ctrlsSvc.getGridBodyCtrl().eBodyViewport) - 50;
			if (leftWidth + rightWidth + diff > bodyWidth) if (bodyWidth > leftWidth + rightWidth) diff = bodyWidth - leftWidth - rightWidth;
			else return 0;
		}
		return diff;
	}
	getPinnedColumnsOverflowingViewport(viewportWidth) {
		const totalPinnedWidth = (this.rightWidth ?? 0) + (this.leftWidth ?? 0);
		let hasLockedPinned = false;
		if (totalPinnedWidth < viewportWidth) return {
			columns: [],
			hasLockedPinned
		};
		const { visibleCols } = this.beans;
		const pinnedLeftColumns = [...visibleCols.leftCols];
		const pinnedRightColumns = [...visibleCols.rightCols];
		let indexRight = 0;
		let indexLeft = 0;
		const totalWidthRemoved = 0;
		const columnsToRemove = [];
		let spaceNecessary = totalPinnedWidth - totalWidthRemoved - viewportWidth;
		while ((indexLeft < pinnedLeftColumns.length || indexRight < pinnedRightColumns.length) && spaceNecessary > 0) {
			if (indexRight < pinnedRightColumns.length) {
				const currentColumn = pinnedRightColumns[indexRight++];
				if (currentColumn.colDef.lockPinned) {
					hasLockedPinned = true;
					continue;
				}
				spaceNecessary -= currentColumn.getActualWidth();
				columnsToRemove.push(currentColumn);
			}
			if (indexLeft < pinnedLeftColumns.length && spaceNecessary > 0) {
				const currentColumn = pinnedLeftColumns[indexLeft++];
				if (currentColumn.colDef.lockPinned) {
					hasLockedPinned = true;
					continue;
				}
				spaceNecessary -= currentColumn.getActualWidth();
				columnsToRemove.push(currentColumn);
			}
		}
		return {
			columns: columnsToRemove,
			hasLockedPinned
		};
	}
};
var PinnedColumnModule = {
	moduleName: "PinnedColumn",
	version: VERSION,
	beans: [PinnedColumnService],
	css: [pinnedColumnModuleCSS]
};
var AriaAnnouncementService = class extends BeanStub {
	constructor() {
		super();
		this.beanName = "ariaAnnounce";
		this.descriptionContainer = null;
		this.pendingAnnouncements = /* @__PURE__ */ new Map();
		this.lastAnnouncement = "";
		this.updateAnnouncement = _debounce(this, this.updateAnnouncement.bind(this), 200);
	}
	postConstruct() {
		const beans = this.beans;
		const div = this.descriptionContainer = _getDocument(beans).createElement("div");
		div.classList.add("ag-aria-description-container");
		_setAriaLive(div, "polite");
		_setAriaRelevant(div, "additions text");
		_setAriaAtomic(div, true);
		beans.eGridDiv.appendChild(div);
	}
	announceValue(value, key) {
		this.pendingAnnouncements.set(key, value);
		this.updateAnnouncement();
	}
	updateAnnouncement() {
		if (!this.descriptionContainer) return;
		const value = Array.from(this.pendingAnnouncements.values()).join(". ");
		this.pendingAnnouncements.clear();
		this.descriptionContainer.textContent = "";
		setTimeout(() => {
			this.handleAnnouncementUpdate(value);
		}, 50);
	}
	handleAnnouncementUpdate(value) {
		if (!this.isAlive() || !this.descriptionContainer) return;
		let valueToAnnounce = value;
		if (valueToAnnounce == null || valueToAnnounce.replace(/[ .]/g, "") == "") {
			this.lastAnnouncement = "";
			return;
		}
		if (this.lastAnnouncement === valueToAnnounce) valueToAnnounce = `${valueToAnnounce}\u200B`;
		this.lastAnnouncement = valueToAnnounce;
		this.descriptionContainer.textContent = valueToAnnounce;
	}
	destroy() {
		super.destroy();
		const { descriptionContainer } = this;
		if (descriptionContainer) {
			_clearElement(descriptionContainer);
			descriptionContainer.parentElement?.removeChild(descriptionContainer);
		}
		this.descriptionContainer = null;
		this.pendingAnnouncements.clear();
	}
};
var AriaModule = {
	moduleName: "Aria",
	version: VERSION,
	beans: [AriaAnnouncementService]
};
function showLoadingOverlay(beans) {
	beans.overlays?.showLoadingOverlay();
}
function showNoRowsOverlay(beans) {
	beans.overlays?.showNoRowsOverlay();
}
function hideOverlay(beans) {
	beans.overlays?.hideOverlay();
}
var overlayWrapperComponentCSS = `.ag-overlay{inset:0;pointer-events:none;position:absolute;z-index:2}.ag-overlay-panel,.ag-overlay-wrapper{display:flex;height:100%;width:100%}.ag-overlay-wrapper{align-items:center;flex:none;justify-content:center;text-align:center}.ag-overlay-loading-wrapper{pointer-events:all}.ag-overlay-loading-center{background:var(--ag-background-color);border:solid var(--ag-border-width) var(--ag-border-color);border-radius:var(--ag-border-radius);box-shadow:var(--ag-popup-shadow);padding:var(--ag-spacing)}`;
var OverlayWrapperElement = {
	tag: "div",
	cls: "ag-overlay",
	role: "presentation",
	children: [{
		tag: "div",
		cls: "ag-overlay-panel",
		role: "presentation",
		children: [{
			tag: "div",
			ref: "eOverlayWrapper",
			cls: "ag-overlay-wrapper",
			role: "presentation"
		}]
	}]
};
var OverlayWrapperComponent = class extends Component {
	constructor() {
		super(OverlayWrapperElement);
		this.eOverlayWrapper = null;
		this.activePromise = null;
		this.activeOverlay = null;
		this.updateListenerDestroyFunc = null;
		this.activeCssClass = null;
		this.elToFocusAfter = null;
		this.registerCSS(overlayWrapperComponentCSS);
	}
	handleKeyDown(e) {
		if (e.key !== KeyCode.TAB || e.defaultPrevented || _isStopPropagationForAgGrid(e)) return;
		const beans = this.beans;
		if (_findNextFocusableElement(beans, this.eOverlayWrapper, false, e.shiftKey)) return;
		let isFocused = false;
		if (e.shiftKey) isFocused = beans.focusSvc.focusGridView({
			column: _last(beans.visibleCols.allCols),
			backwards: true,
			canFocusOverlay: false
		});
		else isFocused = _focusNextGridCoreContainer(beans, false);
		if (isFocused) e.preventDefault();
	}
	updateLayoutClasses(cssClass, params) {
		const overlayWrapperClassList = this.eOverlayWrapper.classList;
		const { AUTO_HEIGHT, NORMAL, PRINT } = LayoutCssClasses;
		overlayWrapperClassList.toggle(AUTO_HEIGHT, params.autoHeight);
		overlayWrapperClassList.toggle(NORMAL, params.normal);
		overlayWrapperClassList.toggle(PRINT, params.print);
	}
	postConstruct() {
		this.createManagedBean(new LayoutFeature(this));
		this.setDisplayed(false, { skipAriaHidden: true });
		this.beans.overlays.setOverlayWrapperComp(this);
		this.addManagedElementListeners(this.getFocusableElement(), { keydown: this.handleKeyDown.bind(this) });
	}
	setWrapperTypeClass(overlayWrapperCssClass) {
		const overlayWrapperClassList = this.eOverlayWrapper.classList;
		if (this.activeCssClass) overlayWrapperClassList.toggle(this.activeCssClass, false);
		this.activeCssClass = overlayWrapperCssClass;
		overlayWrapperClassList.toggle(overlayWrapperCssClass, true);
	}
	showOverlay(overlayComponentPromise, overlayWrapperCssClass, exclusive, gridOption) {
		this.setWrapperTypeClass(overlayWrapperCssClass);
		this.destroyActiveOverlay();
		this.elToFocusAfter = null;
		this.activePromise = overlayComponentPromise;
		if (!overlayComponentPromise) return;
		this.setDisplayed(true, { skipAriaHidden: true });
		if (exclusive && this.isGridFocused()) {
			const activeElement = _getActiveDomElement(this.beans);
			if (activeElement && !_isNothingFocused(this.beans)) this.elToFocusAfter = activeElement;
		}
		overlayComponentPromise.then((comp) => {
			if (this.activePromise !== overlayComponentPromise) {
				if (this.activeOverlay !== comp) {
					this.destroyBean(comp);
					comp = null;
				}
				return;
			}
			this.activePromise = null;
			if (!comp) return;
			if (this.activeOverlay !== comp) {
				this.eOverlayWrapper.appendChild(comp.getGui());
				this.activeOverlay = comp;
				if (gridOption) {
					const component = comp;
					this.updateListenerDestroyFunc = this.addManagedPropertyListener(gridOption, ({ currentValue }) => {
						component.refresh?.(_addGridCommonParams(this.gos, { ...currentValue ?? {} }));
					});
				}
			}
			if (exclusive && this.isGridFocused()) _focusInto(this.eOverlayWrapper);
		});
	}
	updateOverlayWrapperPaddingTop(padding) {
		this.eOverlayWrapper.style.setProperty("padding-top", `${padding}px`);
	}
	destroyActiveOverlay() {
		this.activePromise = null;
		const activeOverlay = this.activeOverlay;
		if (!activeOverlay) return;
		let elementToFocus = this.elToFocusAfter;
		this.activeOverlay = null;
		this.elToFocusAfter = null;
		if (elementToFocus && !this.isGridFocused()) elementToFocus = null;
		const updateListenerDestroyFunc = this.updateListenerDestroyFunc;
		if (updateListenerDestroyFunc) {
			updateListenerDestroyFunc();
			this.updateListenerDestroyFunc = null;
		}
		this.destroyBean(activeOverlay);
		_clearElement(this.eOverlayWrapper);
		elementToFocus?.focus?.({ preventScroll: true });
	}
	hideOverlay() {
		this.destroyActiveOverlay();
		this.setDisplayed(false, { skipAriaHidden: true });
	}
	isGridFocused() {
		const activeEl = _getActiveDomElement(this.beans);
		return !!activeEl && this.beans.eGridDiv.contains(activeEl);
	}
	destroy() {
		this.elToFocusAfter = null;
		this.destroyActiveOverlay();
		this.beans.overlays.setOverlayWrapperComp(void 0);
		super.destroy();
	}
};
var OverlayWrapperSelector = {
	selector: "AG-OVERLAY-WRAPPER",
	component: OverlayWrapperComponent
};
var OverlayService = class extends BeanStub {
	constructor() {
		super(...arguments);
		this.beanName = "overlays";
		this.state = 0;
		this.showInitialOverlay = true;
		this.wrapperPadding = 0;
	}
	postConstruct() {
		this.isClientSide = _isClientSideRowModel(this.gos);
		this.isServerSide = !this.isClientSide && _isServerSideRowModel(this.gos);
		const updateOverlayVisibility = () => this.updateOverlayVisibility();
		this.addManagedEventListeners({
			newColumnsLoaded: updateOverlayVisibility,
			rowDataUpdated: updateOverlayVisibility,
			gridSizeChanged: this.refreshWrapperPadding.bind(this),
			rowCountReady: () => {
				this.showInitialOverlay = false;
				this.updateOverlayVisibility();
			}
		});
		this.addManagedPropertyListener("loading", updateOverlayVisibility);
	}
	setOverlayWrapperComp(overlayWrapperComp) {
		this.eWrapper = overlayWrapperComp;
		this.updateOverlayVisibility();
	}
	isVisible() {
		return this.state !== 0 && !!this.eWrapper;
	}
	isExclusive() {
		return this.state === 1 && !!this.eWrapper;
	}
	showLoadingOverlay() {
		this.showInitialOverlay = false;
		const gos = this.gos;
		const loading = gos.get("loading");
		if (!loading && (loading !== void 0 || gos.get("suppressLoadingOverlay"))) return;
		this.doShowLoadingOverlay();
	}
	showNoRowsOverlay() {
		this.showInitialOverlay = false;
		const gos = this.gos;
		if (gos.get("loading") || gos.get("suppressNoRowsOverlay")) return;
		this.doShowNoRowsOverlay();
	}
	hideOverlay() {
		this.showInitialOverlay = false;
		if (this.gos.get("loading")) {
			_warn(99);
			return;
		}
		this.doHideOverlay();
	}
	getOverlayWrapperSelector() {
		return OverlayWrapperSelector;
	}
	getOverlayWrapperCompClass() {
		return OverlayWrapperComponent;
	}
	updateOverlayVisibility() {
		if (!this.eWrapper) {
			this.state = 0;
			return;
		}
		const { state, isClientSide, isServerSide, beans: { gos, colModel, rowModel } } = this;
		let loading = this.gos.get("loading");
		if (loading !== void 0) this.showInitialOverlay = false;
		if (this.showInitialOverlay && loading === void 0 && !gos.get("suppressLoadingOverlay")) loading = !gos.get("columnDefs") || !colModel.ready || !gos.get("rowData") && isClientSide;
		if (loading) {
			if (state !== 1) this.doShowLoadingOverlay();
		} else {
			this.showInitialOverlay = false;
			if (isClientSide && rowModel.isEmpty() && !gos.get("suppressNoRowsOverlay")) {
				if (state !== 2) this.doShowNoRowsOverlay();
			} else if (state === 1 || !isServerSide && state !== 0) this.doHideOverlay();
		}
	}
	doShowLoadingOverlay() {
		if (!this.eWrapper) return;
		this.state = 1;
		this.showOverlay(_getLoadingOverlayCompDetails(this.beans.userCompFactory, _addGridCommonParams(this.gos, {})), "ag-overlay-loading-wrapper", "loadingOverlayComponentParams");
		this.updateExclusive();
	}
	doShowNoRowsOverlay() {
		if (!this.eWrapper) return;
		this.state = 2;
		this.showOverlay(_getNoRowsOverlayCompDetails(this.beans.userCompFactory, _addGridCommonParams(this.gos, {})), "ag-overlay-no-rows-wrapper", "noRowsOverlayComponentParams");
		this.updateExclusive();
	}
	doHideOverlay() {
		if (!this.eWrapper) return;
		this.state = 0;
		this.eWrapper.hideOverlay();
		this.updateExclusive();
	}
	showOverlay(compDetails, wrapperCssClass, gridOption) {
		const promise = compDetails?.newAgStackInstance() ?? null;
		this.eWrapper?.showOverlay(promise, wrapperCssClass, this.isExclusive(), gridOption);
		this.refreshWrapperPadding();
	}
	updateExclusive() {
		const wasExclusive = this.exclusive;
		this.exclusive = this.isExclusive();
		if (this.exclusive !== wasExclusive) this.eventSvc.dispatchEvent({ type: "overlayExclusiveChanged" });
	}
	refreshWrapperPadding() {
		const eWrapper = this.eWrapper;
		if (!eWrapper) return;
		let newPadding = 0;
		if (this.state === 2) newPadding = this.beans.ctrlsSvc.get("gridHeaderCtrl")?.headerHeight || 0;
		else if (this.wrapperPadding !== 0) newPadding = 0;
		if (this.wrapperPadding === newPadding) return;
		this.wrapperPadding = newPadding;
		eWrapper.updateOverlayWrapperPaddingTop(newPadding);
	}
};
var OverlayModule = {
	moduleName: "Overlay",
	version: VERSION,
	userComponents: {
		agLoadingOverlay: LoadingOverlayComponent2,
		agNoRowsOverlay: NoRowsOverlayComponent2
	},
	apiFunctions: {
		showLoadingOverlay,
		showNoRowsOverlay,
		hideOverlay
	},
	beans: [OverlayService]
};
var RowContainerHeightService = class extends BeanStub {
	constructor() {
		super(...arguments);
		this.beanName = "rowContainerHeight";
		this.scrollY = 0;
		this.uiBodyHeight = 0;
	}
	postConstruct() {
		this.addManagedEventListeners({ bodyHeightChanged: this.updateOffset.bind(this) });
		this.maxDivHeight = _getMaxDivHeight();
		_logIfDebug(this.gos, "RowContainerHeightService - maxDivHeight = " + this.maxDivHeight);
	}
	updateOffset() {
		if (!this.stretching) return;
		const newScrollY = this.beans.ctrlsSvc.getScrollFeature().getVScrollPosition().top;
		const newBodyHeight = this.getUiBodyHeight();
		if (newScrollY !== this.scrollY || newBodyHeight !== this.uiBodyHeight) {
			this.scrollY = newScrollY;
			this.uiBodyHeight = newBodyHeight;
			this.calculateOffset();
		}
	}
	calculateOffset() {
		this.setUiContainerHeight(this.maxDivHeight);
		this.pixelsToShave = this.modelHeight - this.uiContainerHeight;
		this.maxScrollY = this.uiContainerHeight - this.uiBodyHeight;
		const scrollPercent = this.scrollY / this.maxScrollY;
		const divStretchOffset = scrollPercent * this.pixelsToShave;
		_logIfDebug(this.gos, `RowContainerHeightService - Div Stretch Offset = ${divStretchOffset} (${this.pixelsToShave} * ${scrollPercent})`);
		this.setDivStretchOffset(divStretchOffset);
	}
	setUiContainerHeight(height) {
		if (height !== this.uiContainerHeight) {
			this.uiContainerHeight = height;
			this.eventSvc.dispatchEvent({ type: "rowContainerHeightChanged" });
		}
	}
	clearOffset() {
		this.setUiContainerHeight(this.modelHeight);
		this.pixelsToShave = 0;
		this.setDivStretchOffset(0);
	}
	setDivStretchOffset(newOffset) {
		const newOffsetFloor = typeof newOffset === "number" ? Math.floor(newOffset) : null;
		if (this.divStretchOffset === newOffsetFloor) return;
		this.divStretchOffset = newOffsetFloor;
		this.eventSvc.dispatchEvent({ type: "heightScaleChanged" });
	}
	setModelHeight(modelHeight) {
		this.modelHeight = modelHeight;
		this.stretching = modelHeight != null && this.maxDivHeight > 0 && modelHeight > this.maxDivHeight;
		if (this.stretching) this.calculateOffset();
		else this.clearOffset();
	}
	getRealPixelPosition(modelPixel) {
		return modelPixel - this.divStretchOffset;
	}
	getUiBodyHeight() {
		const pos = this.beans.ctrlsSvc.getScrollFeature().getVScrollPosition();
		return pos.bottom - pos.top;
	}
	getScrollPositionForPixel(rowTop) {
		if (this.pixelsToShave <= 0) return rowTop;
		const scrollPercent = rowTop / (this.modelHeight - this.getUiBodyHeight());
		return this.maxScrollY * scrollPercent;
	}
};
var ROW_ANIMATION_TIMEOUT = 400;
var RowRenderer = class extends BeanStub {
	constructor() {
		super(...arguments);
		this.beanName = "rowRenderer";
		this.destroyFuncsForColumnListeners = [];
		this.rowCtrlsByRowIndex = {};
		this.zombieRowCtrls = {};
		this.allRowCtrls = [];
		this.topRowCtrls = [];
		this.bottomRowCtrls = [];
		this.refreshInProgress = false;
		this.dataFirstRenderedFired = false;
		this.setupRangeSelectionListeners = () => {
			const onCellSelectionChanged = () => {
				this.getAllCellCtrls().forEach((cellCtrl) => cellCtrl.onCellSelectionChanged());
			};
			const onColumnMovedPinnedVisible = () => {
				this.getAllCellCtrls().forEach((cellCtrl) => cellCtrl.updateRangeBordersIfRangeCount());
			};
			const addCellSelectionListeners = () => {
				this.eventSvc.addEventListener("cellSelectionChanged", onCellSelectionChanged);
				this.eventSvc.addEventListener("columnMoved", onColumnMovedPinnedVisible);
				this.eventSvc.addEventListener("columnPinned", onColumnMovedPinnedVisible);
				this.eventSvc.addEventListener("columnVisible", onColumnMovedPinnedVisible);
			};
			const removeCellSelectionListeners = () => {
				this.eventSvc.removeEventListener("cellSelectionChanged", onCellSelectionChanged);
				this.eventSvc.removeEventListener("columnMoved", onColumnMovedPinnedVisible);
				this.eventSvc.removeEventListener("columnPinned", onColumnMovedPinnedVisible);
				this.eventSvc.removeEventListener("columnVisible", onColumnMovedPinnedVisible);
			};
			this.addDestroyFunc(() => removeCellSelectionListeners());
			this.addManagedPropertyListeners(["enableRangeSelection", "cellSelection"], () => {
				if (_isCellSelectionEnabled(this.gos)) addCellSelectionListeners();
				else removeCellSelectionListeners();
			});
			if (_isCellSelectionEnabled(this.gos)) addCellSelectionListeners();
		};
	}
	wireBeans(beans) {
		this.pageBounds = beans.pageBounds;
		this.colModel = beans.colModel;
		this.pinnedRowModel = beans.pinnedRowModel;
		this.rowModel = beans.rowModel;
		this.focusSvc = beans.focusSvc;
		this.rowContainerHeight = beans.rowContainerHeight;
		this.ctrlsSvc = beans.ctrlsSvc;
		this.editSvc = beans.editSvc;
	}
	postConstruct() {
		this.ctrlsSvc.whenReady(this, (p) => {
			this.gridBodyCtrl = p.gridBodyCtrl;
			this.initialise();
		});
	}
	initialise() {
		this.addManagedEventListeners({
			paginationChanged: this.onPageLoaded.bind(this),
			pinnedRowDataChanged: this.onPinnedRowDataChanged.bind(this),
			pinnedRowsChanged: this.onPinnedRowsChanged.bind(this),
			displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this),
			bodyScroll: this.onBodyScroll.bind(this),
			bodyHeightChanged: this.redraw.bind(this, {})
		});
		this.addManagedPropertyListeners(["domLayout", "embedFullWidthRows"], () => this.onDomLayoutChanged());
		this.addManagedPropertyListeners(["suppressMaxRenderedRowRestriction", "rowBuffer"], () => this.redraw());
		this.addManagedPropertyListener("suppressCellFocus", (e) => this.onSuppressCellFocusChanged(e.currentValue));
		this.addManagedPropertyListeners([
			"groupSuppressBlankHeader",
			"getBusinessKeyForNode",
			"fullWidthCellRenderer",
			"fullWidthCellRendererParams",
			"suppressStickyTotalRow",
			"groupRowRenderer",
			"groupRowRendererParams",
			"loadingCellRenderer",
			"loadingCellRendererParams",
			"detailCellRenderer",
			"detailCellRendererParams",
			"enableRangeSelection",
			"enableCellTextSelection"
		], () => this.redrawRows());
		this.addManagedPropertyListener("cellSelection", ({ currentValue, previousValue }) => {
			if (!previousValue && currentValue || previousValue && !currentValue) this.redrawRows();
		});
		const { stickyRowSvc, gos, showRowGroupCols } = this.beans;
		if (showRowGroupCols) this.addManagedPropertyListener("showOpenedGroup", () => {
			const columns = showRowGroupCols.getShowRowGroupCols();
			if (columns.length) this.refreshCells({
				columns,
				force: true
			});
		});
		if (stickyRowSvc) this.stickyRowFeature = stickyRowSvc.createStickyRowFeature(this, this.createRowCon.bind(this), this.destroyRowCtrls.bind(this));
		else {
			const gridBodyCtrl = this.gridBodyCtrl;
			gridBodyCtrl.setStickyTopHeight(0);
			gridBodyCtrl.setStickyBottomHeight(0);
		}
		this.registerCellEventListeners();
		this.initialiseCache();
		this.printLayout = _isDomLayout(gos, "print");
		this.embedFullWidthRows = this.printLayout || gos.get("embedFullWidthRows");
		this.redrawAfterModelUpdate();
	}
	initialiseCache() {
		if (this.gos.get("keepDetailRows")) {
			const countProp = this.getKeepDetailRowsCount();
			this.cachedRowCtrls = new RowCtrlCache(countProp != null ? countProp : 3);
		}
	}
	getKeepDetailRowsCount() {
		return this.gos.get("keepDetailRowsCount");
	}
	getStickyTopRowCtrls() {
		return this.stickyRowFeature?.stickyTopRowCtrls ?? [];
	}
	getStickyBottomRowCtrls() {
		return this.stickyRowFeature?.stickyBottomRowCtrls ?? [];
	}
	updateAllRowCtrls() {
		const liveList = Object.values(this.rowCtrlsByRowIndex);
		const zombieList = Object.values(this.zombieRowCtrls);
		const cachedList = this.cachedRowCtrls?.getEntries() ?? [];
		if (zombieList.length > 0 || cachedList.length > 0) this.allRowCtrls = [
			...liveList,
			...zombieList,
			...cachedList
		];
		else this.allRowCtrls = liveList;
	}
	isCellBeingRendered(rowIndex, column) {
		const rowCtrl = this.rowCtrlsByRowIndex[rowIndex];
		if (!column || !rowCtrl) return !!rowCtrl;
		if (rowCtrl.isFullWidth()) return true;
		return !!this.beans.spannedRowRenderer?.getCellByPosition({
			rowIndex,
			column,
			rowPinned: null
		}) || !!rowCtrl.getCellCtrl(column) || !rowCtrl.isRowRendered();
	}
	updateCellFocus(event) {
		this.getAllCellCtrls().forEach((cellCtrl) => cellCtrl.onCellFocused(event));
		this.getFullWidthRowCtrls().forEach((rowCtrl) => rowCtrl.onFullWidthRowFocused(event));
	}
	onCellFocusChanged(event) {
		if (event && event.rowIndex != null && !event.rowPinned) {
			const col = this.beans.colModel.getCol(event.column) ?? void 0;
			if (!this.isCellBeingRendered(event.rowIndex, col)) this.redraw();
		}
		this.updateCellFocus(event);
	}
	onSuppressCellFocusChanged(suppressCellFocus) {
		this.getAllCellCtrls().forEach((cellCtrl) => cellCtrl.onSuppressCellFocusChanged(suppressCellFocus));
		this.getFullWidthRowCtrls().forEach((rowCtrl) => rowCtrl.onSuppressCellFocusChanged(suppressCellFocus));
	}
	registerCellEventListeners() {
		this.addManagedEventListeners({
			cellFocused: (event) => this.onCellFocusChanged(event),
			cellFocusCleared: () => this.updateCellFocus(),
			flashCells: (event) => {
				const { cellFlashSvc } = this.beans;
				if (cellFlashSvc) this.getAllCellCtrls().forEach((cellCtrl) => cellFlashSvc.onFlashCells(cellCtrl, event));
			},
			columnHoverChanged: () => {
				this.getAllCellCtrls().forEach((cellCtrl) => cellCtrl.onColumnHover());
			},
			displayedColumnsChanged: () => {
				this.getAllCellCtrls().forEach((cellCtrl) => cellCtrl.onDisplayedColumnsChanged());
			},
			displayedColumnsWidthChanged: () => {
				if (this.printLayout) this.getAllCellCtrls().forEach((cellCtrl) => cellCtrl.onLeftChanged());
			}
		});
		this.setupRangeSelectionListeners();
		this.refreshListenersToColumnsForCellComps();
		this.addManagedEventListeners({ gridColumnsChanged: this.refreshListenersToColumnsForCellComps.bind(this) });
		this.addDestroyFunc(this.removeGridColumnListeners.bind(this));
	}
	removeGridColumnListeners() {
		this.destroyFuncsForColumnListeners.forEach((func) => func());
		this.destroyFuncsForColumnListeners.length = 0;
	}
	refreshListenersToColumnsForCellComps() {
		this.removeGridColumnListeners();
		this.colModel.getCols().forEach((col) => {
			const forEachCellWithThisCol = (callback) => {
				this.getAllCellCtrls().forEach((cellCtrl) => {
					if (cellCtrl.column === col) callback(cellCtrl);
				});
			};
			const leftChangedListener = () => {
				forEachCellWithThisCol((cellCtrl) => cellCtrl.onLeftChanged());
			};
			const widthChangedListener = () => {
				forEachCellWithThisCol((cellCtrl) => cellCtrl.onWidthChanged());
			};
			const firstRightPinnedChangedListener = () => {
				forEachCellWithThisCol((cellCtrl) => cellCtrl.onFirstRightPinnedChanged());
			};
			const lastLeftPinnedChangedListener = () => {
				forEachCellWithThisCol((cellCtrl) => cellCtrl.onLastLeftPinnedChanged());
			};
			const colDefChangedListener = () => {
				forEachCellWithThisCol((cellCtrl) => cellCtrl.onColDefChanged());
			};
			col.__addEventListener("leftChanged", leftChangedListener);
			col.__addEventListener("widthChanged", widthChangedListener);
			col.__addEventListener("firstRightPinnedChanged", firstRightPinnedChangedListener);
			col.__addEventListener("lastLeftPinnedChanged", lastLeftPinnedChangedListener);
			col.__addEventListener("colDefChanged", colDefChangedListener);
			this.destroyFuncsForColumnListeners.push(() => {
				col.__removeEventListener("leftChanged", leftChangedListener);
				col.__removeEventListener("widthChanged", widthChangedListener);
				col.__removeEventListener("firstRightPinnedChanged", firstRightPinnedChangedListener);
				col.__removeEventListener("lastLeftPinnedChanged", lastLeftPinnedChangedListener);
				col.__removeEventListener("colDefChanged", colDefChangedListener);
			});
		});
	}
	onDomLayoutChanged() {
		const printLayout = _isDomLayout(this.gos, "print");
		const embedFullWidthRows = printLayout || this.gos.get("embedFullWidthRows");
		const destroyRows = embedFullWidthRows !== this.embedFullWidthRows || this.printLayout !== printLayout;
		this.printLayout = printLayout;
		this.embedFullWidthRows = embedFullWidthRows;
		if (destroyRows) this.redrawAfterModelUpdate({ domLayoutChanged: true });
	}
	datasourceChanged() {
		this.firstRenderedRow = 0;
		this.lastRenderedRow = -1;
		const rowIndexesToRemove = Object.keys(this.rowCtrlsByRowIndex);
		this.removeRowCtrls(rowIndexesToRemove);
	}
	onPageLoaded(event) {
		const params = {
			recycleRows: event.keepRenderedRows,
			animate: event.animate,
			newData: event.newData,
			newPage: event.newPage,
			onlyBody: true
		};
		this.redrawAfterModelUpdate(params);
	}
	getAllCellsNotSpanningForColumn(column) {
		const res = [];
		this.getAllRowCtrls().forEach((rowCtrl) => {
			const eCell = rowCtrl.getCellCtrl(column, true)?.eGui;
			if (eCell) res.push(eCell);
		});
		return res;
	}
	refreshFloatingRowComps(recycleRows = true) {
		this.refreshFloatingRows(this.topRowCtrls, "top", recycleRows);
		this.refreshFloatingRows(this.bottomRowCtrls, "bottom", recycleRows);
	}
	refreshFloatingRows(rowCtrls, floating, recycleRows) {
		const { pinnedRowModel, beans, printLayout } = this;
		const rowCtrlMap = Object.fromEntries(rowCtrls.map((ctrl) => [ctrl.rowNode.id, ctrl]));
		pinnedRowModel?.forEachPinnedRow(floating, (node, i) => {
			const rowCtrl = rowCtrls[i];
			if (rowCtrl && pinnedRowModel.getPinnedRowById(rowCtrl.rowNode.id, floating) === void 0) {
				rowCtrl.destroyFirstPass();
				rowCtrl.destroySecondPass();
			}
			if (node.id in rowCtrlMap && recycleRows) {
				rowCtrls[i] = rowCtrlMap[node.id];
				delete rowCtrlMap[node.id];
			} else rowCtrls[i] = new RowCtrl(node, beans, false, false, printLayout);
		});
		rowCtrls.length = (floating === "top" ? pinnedRowModel?.getPinnedTopRowCount() : pinnedRowModel?.getPinnedBottomRowCount()) ?? 0;
	}
	onPinnedRowDataChanged() {
		this.redrawAfterModelUpdate({ recycleRows: true });
	}
	onPinnedRowsChanged() {
		this.redrawAfterModelUpdate({ recycleRows: true });
	}
	redrawRow(rowNode, suppressEvent = false) {
		if (rowNode.sticky) this.stickyRowFeature?.refreshStickyNode(rowNode);
		else if (this.cachedRowCtrls?.has(rowNode)) {
			this.cachedRowCtrls.removeRow(rowNode);
			return;
		} else {
			const destroyAndRecreateCtrl = (dataStruct) => {
				const ctrl = dataStruct[rowNode.rowIndex];
				if (!ctrl) return;
				if (ctrl.rowNode !== rowNode) return;
				ctrl.destroyFirstPass();
				ctrl.destroySecondPass();
				dataStruct[rowNode.rowIndex] = this.createRowCon(rowNode, false, false);
			};
			switch (rowNode.rowPinned) {
				case "top":
					destroyAndRecreateCtrl(this.topRowCtrls);
					break;
				case "bottom":
					destroyAndRecreateCtrl(this.bottomRowCtrls);
					break;
				default:
					destroyAndRecreateCtrl(this.rowCtrlsByRowIndex);
					this.updateAllRowCtrls();
			}
		}
		if (!suppressEvent) this.dispatchDisplayedRowsChanged(false);
	}
	redrawRows(rowNodes) {
		const { editSvc } = this.beans;
		if (editSvc?.isEditing()) if (editSvc.isBatchEditing()) editSvc.cleanupEditors();
		else editSvc.stopEditing(void 0, { source: "api" });
		if (rowNodes != null) {
			rowNodes?.forEach((node) => this.redrawRow(node, true));
			this.dispatchDisplayedRowsChanged(false);
			return;
		}
		this.redrawAfterModelUpdate();
	}
	redrawAfterModelUpdate(params = {}) {
		this.getLockOnRefresh();
		const focusedCell = this.beans.focusSvc?.getFocusCellToUseAfterRefresh();
		this.updateContainerHeights();
		this.scrollToTopIfNewData(params);
		const recycleRows = !params.domLayoutChanged && !!params.recycleRows;
		const animate = params.animate && _isAnimateRows(this.gos);
		const rowsToRecycle = recycleRows ? this.getRowsToRecycle() : null;
		if (!recycleRows) this.removeAllRowComps();
		this.workOutFirstAndLastRowsToRender();
		const { stickyRowFeature, gos } = this;
		if (stickyRowFeature) {
			stickyRowFeature.checkStickyRows();
			const extraHeight = stickyRowFeature.extraTopHeight + stickyRowFeature.extraBottomHeight;
			if (extraHeight) this.updateContainerHeights(extraHeight);
		}
		this.recycleRows(rowsToRecycle, animate);
		this.gridBodyCtrl.updateRowCount();
		if (!params.onlyBody) this.refreshFloatingRowComps(gos.get("enableRowPinning") ? recycleRows : void 0);
		this.dispatchDisplayedRowsChanged();
		if (focusedCell != null) this.restoreFocusedCell(focusedCell);
		this.releaseLockOnRefresh();
	}
	scrollToTopIfNewData(params) {
		const scrollToTop = params.newData || params.newPage;
		const suppressScrollToTop = this.gos.get("suppressScrollOnNewData");
		if (scrollToTop && !suppressScrollToTop) {
			this.gridBodyCtrl.scrollFeature.scrollToTop();
			this.stickyRowFeature?.resetOffsets();
		}
	}
	updateContainerHeights(additionalHeight = 0) {
		const { rowContainerHeight } = this;
		if (this.printLayout) {
			rowContainerHeight.setModelHeight(null);
			return;
		}
		let containerHeight = this.pageBounds.getCurrentPageHeight();
		if (containerHeight === 0) containerHeight = 1;
		rowContainerHeight.setModelHeight(containerHeight + additionalHeight);
	}
	getLockOnRefresh() {
		if (this.refreshInProgress) throw new Error(_errMsg(252));
		this.refreshInProgress = true;
		this.beans.frameworkOverrides.getLockOnRefresh?.();
	}
	releaseLockOnRefresh() {
		this.refreshInProgress = false;
		this.beans.frameworkOverrides.releaseLockOnRefresh?.();
	}
	isRefreshInProgress() {
		return this.refreshInProgress;
	}
	restoreFocusedCell(cellPosition) {
		if (!cellPosition) return;
		const focusSvc = this.beans.focusSvc;
		const cellToFocus = this.findPositionToFocus(cellPosition);
		if (!cellToFocus) {
			focusSvc.focusHeaderPosition({ headerPosition: {
				headerRowIndex: getFocusHeaderRowCount(this.beans) - 1,
				column: cellPosition.column
			} });
			return;
		}
		if (cellPosition.rowIndex !== cellToFocus.rowIndex || cellPosition.rowPinned != cellToFocus.rowPinned) {
			focusSvc.setFocusedCell({
				...cellToFocus,
				preventScrollOnBrowserFocus: true,
				forceBrowserFocus: true
			});
			return;
		}
		if (!focusSvc.doesRowOrCellHaveBrowserFocus()) this.updateCellFocus(_addGridCommonParams(this.gos, {
			...cellToFocus,
			forceBrowserFocus: true,
			preventScrollOnBrowserFocus: true,
			type: "cellFocused"
		}));
	}
	findPositionToFocus(cellPosition) {
		const { pagination, pageBounds } = this.beans;
		let rowPosition = cellPosition;
		if (rowPosition.rowPinned == null && pagination && pageBounds && !pagination.isRowInPage(rowPosition.rowIndex)) rowPosition = {
			rowPinned: null,
			rowIndex: pageBounds.getFirstRow()
		};
		while (rowPosition) {
			if (rowPosition.rowPinned == null && pageBounds) {
				if (rowPosition.rowIndex < pageBounds.getFirstRow()) {
					rowPosition = _getRowAbove(this.beans, {
						rowPinned: null,
						rowIndex: 0
					});
					if (!rowPosition) return null;
				} else if (rowPosition.rowIndex > pageBounds.getLastRow()) rowPosition = {
					rowPinned: null,
					rowIndex: pageBounds.getLastRow()
				};
			}
			const row = this.getRowByPosition(rowPosition);
			if (row?.isAlive()) return {
				...row.getRowPosition(),
				column: cellPosition.column
			};
			rowPosition = _getRowAbove(this.beans, rowPosition);
		}
		return null;
	}
	getAllCellCtrls() {
		const res = [];
		const rowCtrls = this.getAllRowCtrls();
		const rowCtrlsLength = rowCtrls.length;
		for (let i = 0; i < rowCtrlsLength; i++) {
			const cellCtrls = rowCtrls[i].getAllCellCtrls();
			const cellCtrlsLength = cellCtrls.length;
			for (let j = 0; j < cellCtrlsLength; j++) res.push(cellCtrls[j]);
		}
		return res;
	}
	getAllRowCtrls() {
		const { spannedRowRenderer } = this.beans;
		const stickyTopRowCtrls = this.getStickyTopRowCtrls();
		const stickyBottomRowCtrls = this.getStickyBottomRowCtrls();
		return [
			...this.topRowCtrls,
			...this.bottomRowCtrls,
			...stickyTopRowCtrls,
			...stickyBottomRowCtrls,
			...spannedRowRenderer?.getCtrls("top") ?? [],
			...spannedRowRenderer?.getCtrls("bottom") ?? [],
			...spannedRowRenderer?.getCtrls("center") ?? [],
			...Object.values(this.rowCtrlsByRowIndex)
		];
	}
	addRenderedRowListener(eventName, rowIndex, callback) {
		const rowComp = this.rowCtrlsByRowIndex[rowIndex];
		if (rowComp) rowComp.addEventListener(eventName, callback);
	}
	refreshCells({ rowNodes, columns, force, suppressFlash } = {}) {
		const refreshCellParams = {
			force,
			newData: false,
			suppressFlash
		};
		for (const cellCtrl of this.getCellCtrls(rowNodes, columns)) cellCtrl.refreshOrDestroyCell(refreshCellParams);
		this.refreshFullWidth(rowNodes);
	}
	refreshRows(params = {}) {
		this.getRowCtrls(params.rowNodes).forEach((rowCtrl) => rowCtrl.refreshRow(params));
		this.refreshFullWidth(params.rowNodes);
	}
	refreshFullWidth(rowNodes) {
		if (!rowNodes) return;
		let rowRedrawn = false;
		for (const rowCtrl of this.getRowCtrls(rowNodes)) {
			if (!rowCtrl.isFullWidth()) continue;
			if (!rowCtrl.refreshFullWidth()) {
				rowRedrawn = true;
				this.redrawRow(rowCtrl.rowNode, true);
			}
		}
		if (rowRedrawn) this.dispatchDisplayedRowsChanged(false);
	}
	getRowCtrls(rowNodes) {
		const rowIdsMap = mapRowNodes(rowNodes);
		const allRowCtrls = this.getAllRowCtrls();
		if (!rowNodes || !rowIdsMap) return allRowCtrls;
		return allRowCtrls.filter((rowCtrl) => {
			const rowNode = rowCtrl.rowNode;
			return isRowInMap(rowNode, rowIdsMap);
		});
	}
	getCellCtrls(rowNodes, columns) {
		let colIdsMap;
		if (_exists(columns)) {
			colIdsMap = {};
			columns.forEach((colKey) => {
				const column = this.colModel.getCol(colKey);
				if (_exists(column)) colIdsMap[column.getId()] = true;
			});
		}
		const res = [];
		this.getRowCtrls(rowNodes).forEach((rowCtrl) => {
			rowCtrl.getAllCellCtrls().forEach((cellCtrl) => {
				const colId = cellCtrl.column.getId();
				if (colIdsMap && !colIdsMap[colId]) return;
				res.push(cellCtrl);
			});
		});
		return res;
	}
	destroy() {
		this.removeAllRowComps(true);
		super.destroy();
	}
	removeAllRowComps(suppressAnimation = false) {
		const rowIndexesToRemove = Object.keys(this.rowCtrlsByRowIndex);
		this.removeRowCtrls(rowIndexesToRemove, suppressAnimation);
		this.stickyRowFeature?.destroyStickyCtrls();
	}
	getRowsToRecycle() {
		const stubNodeIndexes = [];
		for (const index of Object.keys(this.rowCtrlsByRowIndex)) if (this.rowCtrlsByRowIndex[index].rowNode.id == null) stubNodeIndexes.push(index);
		this.removeRowCtrls(stubNodeIndexes);
		const ctrlsByIdMap = {};
		for (const rowCtrl of Object.values(this.rowCtrlsByRowIndex)) {
			const rowNode = rowCtrl.rowNode;
			ctrlsByIdMap[rowNode.id] = rowCtrl;
		}
		this.rowCtrlsByRowIndex = {};
		return ctrlsByIdMap;
	}
	removeRowCtrls(rowsToRemove, suppressAnimation = false) {
		rowsToRemove.forEach((indexToRemove) => {
			const rowCtrl = this.rowCtrlsByRowIndex[indexToRemove];
			if (rowCtrl) {
				rowCtrl.destroyFirstPass(suppressAnimation);
				rowCtrl.destroySecondPass();
			}
			delete this.rowCtrlsByRowIndex[indexToRemove];
		});
	}
	onBodyScroll(e) {
		if (e.direction !== "vertical") return;
		this.redraw({ afterScroll: true });
	}
	redraw(params = {}) {
		const { focusSvc, animationFrameSvc } = this.beans;
		const { afterScroll } = params;
		let cellFocused;
		const stickyRowFeature = this.stickyRowFeature;
		if (stickyRowFeature) cellFocused = focusSvc?.getFocusCellToUseAfterRefresh() || void 0;
		const oldFirstRow = this.firstRenderedRow;
		const oldLastRow = this.lastRenderedRow;
		this.workOutFirstAndLastRowsToRender();
		let hasStickyRowChanges = false;
		if (stickyRowFeature) {
			hasStickyRowChanges = stickyRowFeature.checkStickyRows();
			const extraHeight = stickyRowFeature.extraTopHeight + stickyRowFeature.extraBottomHeight;
			if (extraHeight) this.updateContainerHeights(extraHeight);
		}
		const rangeChanged = this.firstRenderedRow !== oldFirstRow || this.lastRenderedRow !== oldLastRow;
		if (afterScroll && !hasStickyRowChanges && !rangeChanged) return;
		this.getLockOnRefresh();
		this.recycleRows(null, false, afterScroll);
		this.releaseLockOnRefresh();
		this.dispatchDisplayedRowsChanged(afterScroll && !hasStickyRowChanges);
		if (cellFocused != null) {
			const newFocusedCell = focusSvc?.getFocusCellToUseAfterRefresh();
			if (cellFocused != null && newFocusedCell == null) {
				animationFrameSvc?.flushAllFrames();
				this.restoreFocusedCell(cellFocused);
			}
		}
	}
	removeRowCompsNotToDraw(indexesToDraw, suppressAnimation) {
		const indexesToDrawMap = {};
		indexesToDraw.forEach((index) => indexesToDrawMap[index] = true);
		const indexesNotToDraw = Object.keys(this.rowCtrlsByRowIndex).filter((index) => !indexesToDrawMap[index]);
		this.removeRowCtrls(indexesNotToDraw, suppressAnimation);
	}
	calculateIndexesToDraw(rowsToRecycle) {
		const indexesToDraw = [];
		for (let i = this.firstRenderedRow; i <= this.lastRenderedRow; i++) indexesToDraw.push(i);
		const pagination = this.beans.pagination;
		const focusedRowIndex = this.beans.focusSvc?.getFocusedCell()?.rowIndex;
		if (focusedRowIndex != null && (focusedRowIndex < this.firstRenderedRow || focusedRowIndex > this.lastRenderedRow) && (!pagination || pagination.isRowInPage(focusedRowIndex)) && focusedRowIndex < this.rowModel.getRowCount()) indexesToDraw.push(focusedRowIndex);
		const checkRowToDraw = (rowComp) => {
			const index = rowComp.rowNode.rowIndex;
			if (index == null || index === focusedRowIndex) return;
			if (index < this.firstRenderedRow || index > this.lastRenderedRow) {
				if (this.doNotUnVirtualiseRow(rowComp)) indexesToDraw.push(index);
			}
		};
		for (const rowCtrl of Object.values(this.rowCtrlsByRowIndex)) checkRowToDraw(rowCtrl);
		if (rowsToRecycle) for (const rowCtrl of Object.values(rowsToRecycle)) checkRowToDraw(rowCtrl);
		indexesToDraw.sort((a, b) => a - b);
		const ret = [];
		for (let i = 0; i < indexesToDraw.length; i++) {
			const currRow = indexesToDraw[i];
			const rowNode = this.rowModel.getRow(currRow);
			if (rowNode && !rowNode.sticky) ret.push(currRow);
		}
		return ret;
	}
	recycleRows(rowsToRecycle, animate = false, afterScroll = false) {
		const indexesToDraw = this.calculateIndexesToDraw(rowsToRecycle);
		if (this.printLayout || afterScroll) animate = false;
		this.removeRowCompsNotToDraw(indexesToDraw, !animate);
		const rowCtrls = [];
		indexesToDraw.forEach((rowIndex) => {
			const rowCtrl = this.createOrUpdateRowCtrl(rowIndex, rowsToRecycle, animate, afterScroll);
			if (_exists(rowCtrl)) rowCtrls.push(rowCtrl);
		});
		if (rowsToRecycle) {
			const { animationFrameSvc } = this.beans;
			if (animationFrameSvc?.active && afterScroll && !this.printLayout) animationFrameSvc.addDestroyTask(() => {
				this.destroyRowCtrls(rowsToRecycle, animate);
				this.updateAllRowCtrls();
				this.dispatchDisplayedRowsChanged();
			});
			else this.destroyRowCtrls(rowsToRecycle, animate);
		}
		this.updateAllRowCtrls();
	}
	dispatchDisplayedRowsChanged(afterScroll = false) {
		this.eventSvc.dispatchEvent({
			type: "displayedRowsChanged",
			afterScroll
		});
	}
	onDisplayedColumnsChanged() {
		const { visibleCols } = this.beans;
		const pinningLeft = visibleCols.isPinningLeft();
		const pinningRight = visibleCols.isPinningRight();
		if (this.pinningLeft !== pinningLeft || pinningRight !== this.pinningRight) {
			this.pinningLeft = pinningLeft;
			this.pinningRight = pinningRight;
			if (this.embedFullWidthRows) this.redrawFullWidthEmbeddedRows();
		}
	}
	redrawFullWidthEmbeddedRows() {
		const rowsToRemove = [];
		this.getFullWidthRowCtrls().forEach((fullWidthCtrl) => {
			const rowIndex = fullWidthCtrl.rowNode.rowIndex;
			rowsToRemove.push(rowIndex.toString());
		});
		this.refreshFloatingRowComps();
		this.removeRowCtrls(rowsToRemove);
		this.redraw({ afterScroll: true });
	}
	getFullWidthRowCtrls(rowNodes) {
		const rowNodesMap = mapRowNodes(rowNodes);
		return this.getAllRowCtrls().filter((rowCtrl) => {
			if (!rowCtrl.isFullWidth()) return false;
			const rowNode = rowCtrl.rowNode;
			if (rowNodesMap != null && !isRowInMap(rowNode, rowNodesMap)) return false;
			return true;
		});
	}
	createOrUpdateRowCtrl(rowIndex, rowsToRecycle, animate, afterScroll) {
		let rowNode;
		let rowCtrl = this.rowCtrlsByRowIndex[rowIndex];
		if (!rowCtrl) {
			rowNode = this.rowModel.getRow(rowIndex);
			if (_exists(rowNode) && _exists(rowsToRecycle) && rowsToRecycle[rowNode.id] && rowNode.alreadyRendered) {
				rowCtrl = rowsToRecycle[rowNode.id];
				rowsToRecycle[rowNode.id] = null;
			}
		}
		if (!rowCtrl) {
			if (!rowNode) rowNode = this.rowModel.getRow(rowIndex);
			if (_exists(rowNode)) rowCtrl = this.createRowCon(rowNode, animate, afterScroll);
			else return;
		}
		if (rowNode) rowNode.alreadyRendered = true;
		this.rowCtrlsByRowIndex[rowIndex] = rowCtrl;
		return rowCtrl;
	}
	destroyRowCtrls(rowCtrlsMap, animate) {
		const executeInAWhileFuncs = [];
		if (rowCtrlsMap) for (const rowCtrl of Object.values(rowCtrlsMap)) {
			if (!rowCtrl) continue;
			if (this.cachedRowCtrls && rowCtrl.isCacheable()) {
				this.cachedRowCtrls.addRow(rowCtrl);
				continue;
			}
			rowCtrl.destroyFirstPass(!animate);
			if (animate) {
				const instanceId = rowCtrl.instanceId;
				this.zombieRowCtrls[instanceId] = rowCtrl;
				executeInAWhileFuncs.push(() => {
					rowCtrl.destroySecondPass();
					delete this.zombieRowCtrls[instanceId];
				});
			} else rowCtrl.destroySecondPass();
		}
		if (animate) {
			executeInAWhileFuncs.push(() => {
				this.updateAllRowCtrls();
				this.dispatchDisplayedRowsChanged();
			});
			window.setTimeout(() => executeInAWhileFuncs.forEach((func) => func()), ROW_ANIMATION_TIMEOUT);
		}
	}
	getRowBuffer() {
		return this.gos.get("rowBuffer");
	}
	getRowBufferInPixels() {
		return this.getRowBuffer() * _getRowHeightAsNumber(this.beans);
	}
	workOutFirstAndLastRowsToRender() {
		const { rowContainerHeight, pageBounds, rowModel } = this;
		rowContainerHeight.updateOffset();
		let newFirst;
		let newLast;
		if (!rowModel.isRowsToRender()) {
			newFirst = 0;
			newLast = -1;
		} else if (this.printLayout) {
			this.beans.environment.refreshRowHeightVariable();
			newFirst = pageBounds.getFirstRow();
			newLast = pageBounds.getLastRow();
		} else {
			const bufferPixels = this.getRowBufferInPixels();
			const scrollFeature = this.ctrlsSvc.getScrollFeature();
			const suppressRowVirtualisation = this.gos.get("suppressRowVirtualisation");
			let rowHeightsChanged = false;
			let firstPixel;
			let lastPixel;
			do {
				const paginationOffset = pageBounds.getPixelOffset();
				const { pageFirstPixel, pageLastPixel } = pageBounds.getCurrentPagePixelRange();
				const divStretchOffset = rowContainerHeight.divStretchOffset;
				const bodyVRange = scrollFeature.getVScrollPosition();
				const bodyTopPixel = bodyVRange.top;
				const bodyBottomPixel = bodyVRange.bottom;
				if (suppressRowVirtualisation) {
					firstPixel = pageFirstPixel + divStretchOffset;
					lastPixel = pageLastPixel + divStretchOffset;
				} else {
					firstPixel = Math.max(bodyTopPixel + paginationOffset - bufferPixels, pageFirstPixel) + divStretchOffset;
					lastPixel = Math.min(bodyBottomPixel + paginationOffset + bufferPixels, pageLastPixel) + divStretchOffset;
				}
				this.firstVisibleVPixel = Math.max(bodyTopPixel + paginationOffset, pageFirstPixel) + divStretchOffset;
				this.lastVisibleVPixel = Math.min(bodyBottomPixel + paginationOffset, pageLastPixel) + divStretchOffset;
				rowHeightsChanged = this.ensureAllRowsInRangeHaveHeightsCalculated(firstPixel, lastPixel);
			} while (rowHeightsChanged);
			let firstRowIndex = rowModel.getRowIndexAtPixel(firstPixel);
			let lastRowIndex = rowModel.getRowIndexAtPixel(lastPixel);
			const pageFirstRow = pageBounds.getFirstRow();
			const pageLastRow = pageBounds.getLastRow();
			if (firstRowIndex < pageFirstRow) firstRowIndex = pageFirstRow;
			if (lastRowIndex > pageLastRow) lastRowIndex = pageLastRow;
			newFirst = firstRowIndex;
			newLast = lastRowIndex;
		}
		const rowLayoutNormal = _isDomLayout(this.gos, "normal");
		const suppressRowCountRestriction = this.gos.get("suppressMaxRenderedRowRestriction");
		const rowBufferMaxSize = Math.max(this.getRowBuffer(), 500);
		if (rowLayoutNormal && !suppressRowCountRestriction) {
			if (newLast - newFirst > rowBufferMaxSize) newLast = newFirst + rowBufferMaxSize;
		}
		const firstDiffers = newFirst !== this.firstRenderedRow;
		const lastDiffers = newLast !== this.lastRenderedRow;
		if (firstDiffers || lastDiffers) {
			this.firstRenderedRow = newFirst;
			this.lastRenderedRow = newLast;
			this.eventSvc.dispatchEvent({
				type: "viewportChanged",
				firstRow: newFirst,
				lastRow: newLast
			});
		}
	}
	dispatchFirstDataRenderedEvent() {
		if (this.dataFirstRenderedFired) return;
		this.dataFirstRenderedFired = true;
		_requestAnimationFrame(this.beans, () => {
			this.beans.eventSvc.dispatchEvent({
				type: "firstDataRendered",
				firstRow: this.firstRenderedRow,
				lastRow: this.lastRenderedRow
			});
		});
	}
	ensureAllRowsInRangeHaveHeightsCalculated(topPixel, bottomPixel) {
		const pinnedRowHeightsChanged = this.pinnedRowModel?.ensureRowHeightsValid();
		const stickyHeightsChanged = this.stickyRowFeature?.ensureRowHeightsValid();
		const { pageBounds, rowModel } = this;
		const rowModelHeightsChanged = rowModel.ensureRowHeightsValid(topPixel, bottomPixel, pageBounds.getFirstRow(), pageBounds.getLastRow());
		if (rowModelHeightsChanged || stickyHeightsChanged) this.eventSvc.dispatchEvent({ type: "recalculateRowBounds" });
		if (stickyHeightsChanged || rowModelHeightsChanged || pinnedRowHeightsChanged) {
			this.updateContainerHeights();
			return true;
		}
		return false;
	}
	doNotUnVirtualiseRow(rowCtrl) {
		const REMOVE_ROW = false;
		const KEEP_ROW = true;
		const rowNode = rowCtrl.rowNode;
		const rowHasFocus = this.focusSvc.isRowFocused(rowNode.rowIndex, rowNode.rowPinned);
		const rowIsEditing = this.editSvc?.isEditing(rowCtrl);
		const rowIsDetail = rowNode.detail;
		if (!(rowHasFocus || rowIsEditing || rowIsDetail)) return REMOVE_ROW;
		return this.isRowPresent(rowNode) ? KEEP_ROW : REMOVE_ROW;
	}
	isRowPresent(rowNode) {
		if (!this.rowModel.isRowPresent(rowNode)) return false;
		return this.beans.pagination?.isRowInPage(rowNode.rowIndex) ?? true;
	}
	createRowCon(rowNode, animate, afterScroll) {
		const rowCtrlFromCache = this.cachedRowCtrls?.getRow(rowNode) ?? null;
		if (rowCtrlFromCache) return rowCtrlFromCache;
		const useAnimationFrameForCreate = afterScroll && !this.printLayout && !!this.beans.animationFrameSvc?.active;
		return new RowCtrl(rowNode, this.beans, animate, useAnimationFrameForCreate, this.printLayout);
	}
	getRenderedNodes() {
		const viewportRows = Object.values(this.rowCtrlsByRowIndex).map((rowCtrl) => rowCtrl.rowNode);
		const stickyTopRows = this.getStickyTopRowCtrls().map((rowCtrl) => rowCtrl.rowNode);
		const stickyBottomRows = this.getStickyBottomRowCtrls().map((rowCtrl) => rowCtrl.rowNode);
		return [
			...stickyTopRows,
			...viewportRows,
			...stickyBottomRows
		];
	}
	getRowByPosition(rowPosition) {
		let rowCtrl;
		const { rowIndex } = rowPosition;
		switch (rowPosition.rowPinned) {
			case "top":
				rowCtrl = this.topRowCtrls[rowIndex];
				break;
			case "bottom":
				rowCtrl = this.bottomRowCtrls[rowIndex];
				break;
			default:
				rowCtrl = this.rowCtrlsByRowIndex[rowIndex];
				if (!rowCtrl) {
					rowCtrl = this.getStickyTopRowCtrls().find((ctrl) => ctrl.rowNode.rowIndex === rowIndex) || null;
					if (!rowCtrl) rowCtrl = this.getStickyBottomRowCtrls().find((ctrl) => ctrl.rowNode.rowIndex === rowIndex) || null;
				}
				break;
		}
		return rowCtrl;
	}
	isRangeInRenderedViewport(startIndex, endIndex) {
		if (startIndex == null || endIndex == null) return false;
		const blockAfterViewport = startIndex > this.lastRenderedRow;
		return !(endIndex < this.firstRenderedRow) && !blockAfterViewport;
	}
};
var RowCtrlCache = class {
	constructor(maxCount) {
		this.entriesMap = {};
		this.entriesList = [];
		this.maxCount = maxCount;
	}
	addRow(rowCtrl) {
		this.entriesMap[rowCtrl.rowNode.id] = rowCtrl;
		this.entriesList.push(rowCtrl);
		rowCtrl.setCached(true);
		if (this.entriesList.length > this.maxCount) {
			const rowCtrlToDestroy = this.entriesList[0];
			rowCtrlToDestroy.destroyFirstPass();
			rowCtrlToDestroy.destroySecondPass();
			this.removeFromCache(rowCtrlToDestroy);
		}
	}
	getRow(rowNode) {
		if (rowNode == null || rowNode.id == null) return null;
		const res = this.entriesMap[rowNode.id];
		if (!res) return null;
		this.removeFromCache(res);
		res.setCached(false);
		return res.rowNode != rowNode ? null : res;
	}
	has(rowNode) {
		return this.entriesMap[rowNode.id] != null;
	}
	removeRow(rowNode) {
		const rowNodeId = rowNode.id;
		const ctrl = this.entriesMap[rowNodeId];
		delete this.entriesMap[rowNodeId];
		_removeFromArray(this.entriesList, ctrl);
	}
	removeFromCache(rowCtrl) {
		const rowNodeId = rowCtrl.rowNode.id;
		delete this.entriesMap[rowNodeId];
		_removeFromArray(this.entriesList, rowCtrl);
	}
	getEntries() {
		return this.entriesList;
	}
};
function mapRowNodes(rowNodes) {
	if (!rowNodes) return;
	const res = {
		top: {},
		bottom: {},
		normal: {}
	};
	rowNodes.forEach((rowNode) => {
		const id = rowNode.id;
		switch (rowNode.rowPinned) {
			case "top":
				res.top[id] = rowNode;
				break;
			case "bottom":
				res.bottom[id] = rowNode;
				break;
			default:
				res.normal[id] = rowNode;
				break;
		}
	});
	return res;
}
function isRowInMap(rowNode, rowIdsMap) {
	const id = rowNode.id;
	switch (rowNode.rowPinned) {
		case "top": return rowIdsMap.top[id] != null;
		case "bottom": return rowIdsMap.bottom[id] != null;
		default: return rowIdsMap.normal[id] != null;
	}
}
var RowNodeSorter = class extends BeanStub {
	constructor() {
		super(...arguments);
		this.beanName = "rowNodeSorter";
	}
	postConstruct() {
		const { gos } = this;
		this.isAccentedSort = gos.get("accentedSort");
		this.primaryColumnsSortGroups = _isColumnsSortingCoupledToGroup(gos);
		this.addManagedPropertyListener("accentedSort", (propChange) => this.isAccentedSort = propChange.currentValue);
		this.addManagedPropertyListener("autoGroupColumnDef", () => this.primaryColumnsSortGroups = _isColumnsSortingCoupledToGroup(gos));
	}
	doFullSort(rowNodes, sortOptions) {
		const sortedRowNodes = rowNodes.map((rowNode, currentPos) => ({
			currentPos,
			rowNode
		}));
		sortedRowNodes.sort(this.compareRowNodes.bind(this, sortOptions));
		return sortedRowNodes.map((item) => item.rowNode);
	}
	compareRowNodes(sortOptions, sortedNodeA, sortedNodeB) {
		const nodeA = sortedNodeA.rowNode;
		const nodeB = sortedNodeB.rowNode;
		for (let i = 0, len = sortOptions.length; i < len; i++) {
			const sortOption = sortOptions[i];
			const isDescending = sortOption.sort === "desc";
			const valueA = this.getValue(nodeA, sortOption.column);
			const valueB = this.getValue(nodeB, sortOption.column);
			let comparatorResult;
			const providedComparator = this.getComparator(sortOption, nodeA);
			if (providedComparator) comparatorResult = providedComparator(valueA, valueB, nodeA, nodeB, isDescending);
			else comparatorResult = _defaultComparator(valueA, valueB, this.isAccentedSort);
			if (!isNaN(comparatorResult) && comparatorResult !== 0) return sortOption.sort === "asc" ? comparatorResult : comparatorResult * -1;
		}
		return sortedNodeA.currentPos - sortedNodeB.currentPos;
	}
	getComparator(sortOption, rowNode) {
		const column = sortOption.column;
		const comparatorOnCol = column.getColDef().comparator;
		if (comparatorOnCol != null) return comparatorOnCol;
		if (!column.getColDef().showRowGroup) return;
		const groupLeafField = !rowNode.group && column.getColDef().field;
		if (!groupLeafField) return;
		const primaryColumn = this.beans.colModel.getColDefCol(groupLeafField);
		if (!primaryColumn) return;
		return primaryColumn.getColDef().comparator;
	}
	getValue(node, column) {
		const { valueSvc, colModel, showRowGroupCols, gos } = this.beans;
		if (!this.primaryColumnsSortGroups) return valueSvc.getValue(column, node, false);
		if (node.rowGroupColumn === column) {
			if (_isGroupUseEntireRow(gos, colModel.isPivotActive())) {
				const leafChild = node.allLeafChildren?.[0];
				if (leafChild) return valueSvc.getValue(column, leafChild, false);
				return;
			}
			const displayCol = showRowGroupCols?.getShowRowGroupCol(column.getId());
			if (!displayCol) return;
			return node.groupData?.[displayCol.getId()];
		}
		if (node.group && column.getColDef().showRowGroup) return;
		return valueSvc.getValue(column, node, false);
	}
};
function onSortChanged(beans) {
	beans.sortSvc?.onSortChanged("api");
}
var SortModule = {
	moduleName: "Sort",
	version: VERSION,
	beans: [SortService, RowNodeSorter],
	apiFunctions: { onSortChanged },
	userComponents: { agSortIndicator: SortIndicatorComp },
	icons: {
		sortAscending: "asc",
		sortDescending: "desc",
		sortUnSort: "none"
	}
};
var SyncService = class extends BeanStub {
	constructor() {
		super(...arguments);
		this.beanName = "syncSvc";
		this.waitingForColumns = false;
	}
	postConstruct() {
		this.addManagedPropertyListener("columnDefs", (event) => this.setColumnDefs(event));
	}
	start() {
		this.beans.ctrlsSvc.whenReady(this, () => {
			const columnDefs = this.gos.get("columnDefs");
			if (columnDefs) this.setColumnsAndData(columnDefs);
			else this.waitingForColumns = true;
			this.gridReady();
		});
	}
	setColumnsAndData(columnDefs) {
		const { colModel, rowModel } = this.beans;
		colModel.setColumnDefs(columnDefs ?? [], "gridInitializing");
		rowModel.start();
	}
	gridReady() {
		const { eventSvc, gos } = this;
		eventSvc.dispatchEvent({ type: "gridReady" });
		_logIfDebug(gos, `initialised successfully, enterprise = ${gos.isModuleRegistered("EnterpriseCore")}`);
	}
	setColumnDefs(event) {
		const columnDefs = this.gos.get("columnDefs");
		if (!columnDefs) return;
		if (this.waitingForColumns) {
			this.waitingForColumns = false;
			this.setColumnsAndData(columnDefs);
			return;
		}
		this.beans.colModel.setColumnDefs(columnDefs, _convertColumnEventSourceType(event.source));
	}
};
var SOURCE_PASTE = "paste";
var ChangeDetectionService = class extends BeanStub {
	constructor() {
		super(...arguments);
		this.beanName = "changeDetectionSvc";
		this.clientSideRowModel = null;
	}
	postConstruct() {
		const { gos, rowModel } = this.beans;
		if (_isClientSideRowModel(gos, rowModel)) this.clientSideRowModel = rowModel;
		this.addManagedEventListeners({ cellValueChanged: this.onCellValueChanged.bind(this) });
	}
	onCellValueChanged(event) {
		const { gos, rowRenderer } = this.beans;
		if (event.source === SOURCE_PASTE || gos.get("suppressChangeDetection")) return;
		const rowNode = event.node;
		const nodesToRefresh = [rowNode];
		const clientSideRowModel = this.clientSideRowModel;
		const rootNode = clientSideRowModel?.rootNode;
		if (rootNode && !rowNode.isRowPinned()) {
			const changedPath = new ChangedPath(gos.get("aggregateOnlyChangedColumns"), rootNode);
			changedPath.addParentNode(rowNode.parent, [event.column]);
			clientSideRowModel.doAggregate(changedPath);
			changedPath.forEachChangedNodeDepthFirst((rowNode2) => {
				nodesToRefresh.push(rowNode2);
				if (rowNode2.sibling) nodesToRefresh.push(rowNode2.sibling);
			});
		}
		rowRenderer.refreshCells({ rowNodes: nodesToRefresh });
	}
};
var ExpressionService = class extends BeanStub {
	constructor() {
		super(...arguments);
		this.beanName = "expressionSvc";
		this.cache = {};
	}
	evaluate(expression, params) {
		if (typeof expression === "string") return this.evaluateExpression(expression, params);
		else _error(15, { expression });
	}
	evaluateExpression(expression, params) {
		try {
			return this.createExpressionFunction(expression)(params.value, params.context, params.oldValue, params.newValue, params.value, params.node, params.data, params.colDef, params.rowIndex, params.api, params.getValue, params.column, params.columnGroup);
		} catch (e) {
			_error(16, {
				expression,
				params,
				e
			});
			return null;
		}
	}
	createExpressionFunction(expression) {
		const expressionToFunctionCache = this.cache;
		if (expressionToFunctionCache[expression]) return expressionToFunctionCache[expression];
		const functionBody = this.createFunctionBody(expression);
		const theFunction = new Function("x, ctx, oldValue, newValue, value, node, data, colDef, rowIndex, api, getValue, column, columnGroup", functionBody);
		expressionToFunctionCache[expression] = theFunction;
		return theFunction;
	}
	createFunctionBody(expression) {
		if (expression.indexOf("return") >= 0) return expression;
		else return "return " + expression + ";";
	}
};
var ExpressionModule = {
	moduleName: "Expression",
	version: VERSION,
	beans: [ExpressionService]
};
var ChangeDetectionModule = {
	moduleName: "ChangeDetection",
	version: VERSION,
	beans: [ChangeDetectionService]
};
var EDITING_CHECK_SIBLINGS = { checkSiblings: true };
var ValueService = class extends BeanStub {
	constructor() {
		super(...arguments);
		this.beanName = "valueSvc";
		this.hasEdit = false;
		this.initialised = false;
		this.isSsrm = false;
	}
	wireBeans(beans) {
		this.expressionSvc = beans.expressionSvc;
		this.colModel = beans.colModel;
		this.valueCache = beans.valueCache;
		this.dataTypeSvc = beans.dataTypeSvc;
		this.editSvc = beans.editSvc;
		this.hasEdit = !!beans.editSvc;
	}
	postConstruct() {
		if (!this.initialised) this.init();
	}
	init() {
		this.executeValueGetter = this.valueCache ? this.executeValueGetterWithValueCache.bind(this) : this.executeValueGetterWithoutValueCache.bind(this);
		this.isSsrm = _isServerSideRowModel(this.gos);
		this.cellExpressions = this.gos.get("enableCellExpressions");
		this.isTreeData = this.gos.get("treeData");
		this.initialised = true;
		const listener = (event) => this.callColumnCellValueChangedHandler(event);
		this.eventSvc.addEventListener("cellValueChanged", listener, true);
		this.addDestroyFunc(() => this.eventSvc.removeEventListener("cellValueChanged", listener, true));
		this.addManagedPropertyListener("treeData", (propChange) => this.isTreeData = propChange.currentValue);
	}
	getValueForDisplay(column, node, includeValueFormatted = false, exporting = false, source = "ui") {
		const { showRowGroupColValueSvc } = this.beans;
		const isFullWidthGroup = !column && node.group;
		const isGroupCol = column?.colDef.showRowGroup;
		const processTreeDataAsGroup = !this.isTreeData || node.footer;
		if (showRowGroupColValueSvc && processTreeDataAsGroup && (isFullWidthGroup || isGroupCol)) {
			const groupValue = showRowGroupColValueSvc.getGroupValue(node, column);
			if (groupValue == null) return {
				value: null,
				valueFormatted: null
			};
			if (!includeValueFormatted) return {
				value: groupValue.value,
				valueFormatted: null
			};
			const valueFormatted = showRowGroupColValueSvc.formatAndPrefixGroupColValue(groupValue, column, exporting);
			return {
				value: groupValue.value,
				valueFormatted
			};
		}
		if (!column) return {
			value: node.key,
			valueFormatted: null
		};
		const isPivotLeaf = node.leafGroup && this.colModel.isPivotMode();
		const isOpenedGroup = node.group && node.expanded && !node.footer && !isPivotLeaf;
		const groupShowsAggData = this.gos.get("groupSuppressBlankHeader") || !node.sibling;
		const ignoreAggData = isOpenedGroup && !groupShowsAggData;
		const value = this.getValue(column, node, ignoreAggData, source);
		return {
			value,
			valueFormatted: includeValueFormatted && !(exporting && column.colDef.useValueFormatterForExport === false) ? this.formatValue(column, node, value) : null
		};
	}
	getValue(column, rowNode, ignoreAggData = false, source = "ui") {
		if (!this.initialised) this.init();
		if (!rowNode) return;
		const colDef = column.getColDef();
		const field = colDef.field;
		const colId = column.getColId();
		let data = rowNode.data;
		if (this.hasEdit && source === "ui") {
			const editSvc = this.editSvc;
			if (editSvc.isRowEditing(rowNode, EDITING_CHECK_SIBLINGS)) data = editSvc.getRowDataValue(rowNode, EDITING_CHECK_SIBLINGS);
			if (editSvc.isEditing()) {
				const newValue = editSvc.getCellDataValue({
					rowNode,
					column
				}, true);
				if (newValue !== void 0) return newValue;
			}
		}
		let result;
		const rowGroupColId = colDef.showRowGroup;
		if (typeof rowGroupColId === "string") {
			if ((this.beans.rowGroupColsSvc?.getColumnIndex(rowGroupColId) ?? -1) > rowNode.level) return null;
		}
		const allowUserValuesForCell = typeof rowGroupColId !== "string" || !rowNode.group;
		const groupDataExists = rowNode.groupData && colId in rowNode.groupData;
		const aggDataExists = !ignoreAggData && rowNode.aggData && rowNode.aggData[colId] !== void 0;
		const ignoreSsrmAggData = this.isSsrm && ignoreAggData && !!colDef.aggFunc;
		const ssrmFooterGroupCol = this.isSsrm && rowNode.footer && rowNode.field && (colDef.showRowGroup === true || colDef.showRowGroup === rowNode.field);
		if (this.isTreeData && aggDataExists) result = rowNode.aggData[colId];
		else if (this.isTreeData && colDef.valueGetter) result = this.executeValueGetter(colDef.valueGetter, data, column, rowNode);
		else if (this.isTreeData && field && data) result = _getValueUsingField(data, field, column.isFieldContainsDots());
		else if (groupDataExists) result = rowNode.groupData[colId];
		else if (aggDataExists) result = rowNode.aggData[colId];
		else if (colDef.valueGetter && !ignoreSsrmAggData) {
			if (!allowUserValuesForCell) return result;
			result = this.executeValueGetter(colDef.valueGetter, data, column, rowNode);
		} else if (ssrmFooterGroupCol) result = _getValueUsingField(data, rowNode.field, column.isFieldContainsDots());
		else if (field && data && !ignoreSsrmAggData) {
			if (!allowUserValuesForCell) return result;
			result = _getValueUsingField(data, field, column.isFieldContainsDots());
		}
		if (this.cellExpressions && typeof result === "string" && result.indexOf("=") === 0) {
			const cellValueGetter = result.substring(1);
			result = this.executeValueGetter(cellValueGetter, data, column, rowNode);
		}
		return result;
	}
	parseValue(column, rowNode, newValue, oldValue) {
		const colDef = column.getColDef();
		const valueParser = colDef.valueParser;
		if (_exists(valueParser)) {
			const params = _addGridCommonParams(this.gos, {
				node: rowNode,
				data: rowNode?.data,
				oldValue,
				newValue,
				colDef,
				column
			});
			if (typeof valueParser === "function") return valueParser(params);
			return this.expressionSvc?.evaluate(valueParser, params);
		}
		return newValue;
	}
	getDeleteValue(column, rowNode) {
		if (_exists(column.getColDef().valueParser)) return this.parseValue(column, rowNode, "", this.getValueForDisplay(column, rowNode).value) ?? null;
		return null;
	}
	formatValue(column, node, value, suppliedFormatter, useFormatterFromColumn = true) {
		const { expressionSvc } = this.beans;
		let result = null;
		let formatter;
		const colDef = column.getColDef();
		if (suppliedFormatter) formatter = suppliedFormatter;
		else if (useFormatterFromColumn) formatter = colDef.valueFormatter;
		if (formatter) {
			let data = node ? node.data : null;
			if (node) {
				const position = { rowNode: node };
				if (this.hasEdit) {
					const editSvc = this.editSvc;
					if (editSvc.isEditing(position, EDITING_CHECK_SIBLINGS)) data = editSvc.getRowDataValue(node, EDITING_CHECK_SIBLINGS);
				}
			}
			const params = _addGridCommonParams(this.gos, {
				value,
				node,
				data,
				colDef,
				column
			});
			if (typeof formatter === "function") result = formatter(params);
			else result = expressionSvc ? expressionSvc.evaluate(formatter, params) : null;
		} else if (colDef.refData) return colDef.refData[value] || "";
		if (result == null && Array.isArray(value)) result = value.join(", ");
		return result;
	}
	setValue(rowNode, colKey, newValue, eventSource) {
		const column = this.colModel.getColDefCol(colKey);
		if (!rowNode || !column) return false;
		if (_missing(rowNode.data)) rowNode.data = {};
		const { field, valueSetter } = column.getColDef();
		if (_missing(field) && _missing(valueSetter)) {
			_warn(17);
			return false;
		}
		if (this.dataTypeSvc && !this.dataTypeSvc.checkType(column, newValue)) {
			_warn(135);
			return false;
		}
		const params = _addGridCommonParams(this.gos, {
			node: rowNode,
			data: rowNode.data,
			oldValue: this.getValue(column, rowNode, void 0, eventSource),
			newValue,
			colDef: column.getColDef(),
			column
		});
		params.newValue = newValue;
		let valueWasDifferent;
		if (_exists(valueSetter)) if (typeof valueSetter === "function") valueWasDifferent = valueSetter(params);
		else valueWasDifferent = this.expressionSvc?.evaluate(valueSetter, params);
		else valueWasDifferent = this.setValueUsingField(rowNode.data, field, newValue, column.isFieldContainsDots());
		if (valueWasDifferent === void 0) valueWasDifferent = true;
		if (!valueWasDifferent) return false;
		rowNode.resetQuickFilterAggregateText();
		this.valueCache?.onDataChanged();
		const savedValue = this.getValue(column, rowNode);
		this.dispatchCellValueChangedEvent(rowNode, params, savedValue, eventSource);
		if (rowNode.pinnedSibling) this.dispatchCellValueChangedEvent(rowNode.pinnedSibling, params, savedValue, eventSource);
		return true;
	}
	dispatchCellValueChangedEvent(rowNode, params, value, source) {
		this.eventSvc.dispatchEvent({
			type: "cellValueChanged",
			event: null,
			rowIndex: rowNode.rowIndex,
			rowPinned: rowNode.rowPinned,
			column: params.column,
			colDef: params.colDef,
			data: rowNode.data,
			node: rowNode,
			oldValue: params.oldValue,
			newValue: value,
			value,
			source
		});
	}
	callColumnCellValueChangedHandler(event) {
		const onCellValueChanged = event.colDef.onCellValueChanged;
		if (typeof onCellValueChanged === "function") this.beans.frameworkOverrides.wrapOutgoing(() => {
			onCellValueChanged({
				node: event.node,
				data: event.data,
				oldValue: event.oldValue,
				newValue: event.newValue,
				colDef: event.colDef,
				column: event.column,
				api: event.api,
				context: event.context
			});
		});
	}
	setValueUsingField(data, field, newValue, isFieldContainsDots) {
		if (!field) return false;
		let valuesAreSame = false;
		if (!isFieldContainsDots) {
			valuesAreSame = data[field] === newValue;
			if (!valuesAreSame) data[field] = newValue;
		} else {
			const fieldPieces = field.split(".");
			let currentObject = data;
			while (fieldPieces.length > 0 && currentObject) {
				const fieldPiece = fieldPieces.shift();
				if (fieldPieces.length === 0) {
					valuesAreSame = currentObject[fieldPiece] === newValue;
					if (!valuesAreSame) currentObject[fieldPiece] = newValue;
				} else currentObject = currentObject[fieldPiece];
			}
		}
		return !valuesAreSame;
	}
	executeValueGetterWithValueCache(valueGetter, data, column, rowNode) {
		const colId = column.getColId();
		const valueFromCache = this.valueCache.getValue(rowNode, colId);
		if (valueFromCache !== void 0) return valueFromCache;
		const result = this.executeValueGetterWithoutValueCache(valueGetter, data, column, rowNode);
		this.valueCache.setValue(rowNode, colId, result);
		return result;
	}
	executeValueGetterWithoutValueCache(valueGetter, data, column, rowNode) {
		const params = _addGridCommonParams(this.gos, {
			data,
			node: rowNode,
			column,
			colDef: column.getColDef(),
			getValue: this.getValueCallback.bind(this, rowNode)
		});
		let result;
		if (typeof valueGetter === "function") result = valueGetter(params);
		else result = this.expressionSvc?.evaluate(valueGetter, params);
		return result;
	}
	getValueCallback(node, field) {
		const otherColumn = this.colModel.getColDefCol(field);
		if (otherColumn) return this.getValue(otherColumn, node);
		return null;
	}
	getKeyForNode(col, rowNode) {
		const value = this.getValue(col, rowNode);
		const keyCreator = col.getColDef().keyCreator;
		let result = value;
		if (keyCreator) result = keyCreator(_addGridCommonParams(this.gos, {
			value,
			colDef: col.getColDef(),
			column: col,
			node: rowNode,
			data: rowNode.data
		}));
		if (typeof result === "string" || result == null) return result;
		result = String(result);
		if (result === "[object Object]") _warn(121);
		return result;
	}
};
var CommunityCoreModule = {
	moduleName: "CommunityCore",
	version: VERSION,
	beans: [
		GridDestroyService,
		ApiFunctionService,
		Registry,
		UserComponentFactory,
		RowContainerHeightService,
		VisibleColsService,
		EventService,
		GridOptionsService,
		ColumnModel,
		PageBoundsService,
		PageBoundsListener,
		RowRenderer,
		ValueService,
		FocusService,
		Environment,
		ScrollVisibleService,
		CtrlsService,
		SyncService,
		ColumnNameService,
		ColumnViewportService
	],
	icons: {
		selectOpen: "small-down",
		smallDown: "small-down",
		colorPicker: "color-picker",
		smallUp: "small-up",
		checkboxChecked: "small-up",
		checkboxIndeterminate: "checkbox-indeterminate",
		checkboxUnchecked: "checkbox-unchecked",
		radioButtonOn: "radio-button-on",
		radioButtonOff: "radio-button-off",
		smallLeft: "small-left",
		smallRight: "small-right"
	},
	apiFunctions: {
		getGridId,
		destroy,
		isDestroyed,
		getGridOption,
		setGridOption,
		updateGridOptions,
		isModuleRegistered
	},
	dependsOn: [
		DataTypeModule,
		ColumnMoveModule,
		ColumnResizeModule,
		SortModule,
		ColumnHeaderCompModule,
		ColumnGroupModule,
		ColumnGroupHeaderCompModule,
		OverlayModule,
		ChangeDetectionModule,
		AnimationFrameModule,
		KeyboardNavigationModule,
		PinnedColumnModule,
		AriaModule,
		TouchModule,
		CellRendererFunctionModule,
		ColumnFlexModule,
		ExpressionModule,
		SkeletonCellRendererModule
	]
};
function _fuzzySuggestions(params) {
	const { inputValue, allSuggestions, hideIrrelevant, filterByPercentageOfBestMatch } = params;
	let thisSuggestions = (allSuggestions ?? []).map((text, idx) => ({
		value: text,
		relevance: _getLevenshteinSimilarityDistance(inputValue, text),
		idx
	}));
	thisSuggestions.sort((a, b) => a.relevance - b.relevance);
	if (hideIrrelevant) thisSuggestions = thisSuggestions.filter((suggestion) => suggestion.relevance < Math.max(suggestion.value.length, inputValue.length));
	if (thisSuggestions.length > 0 && filterByPercentageOfBestMatch && filterByPercentageOfBestMatch > 0) {
		const limit = thisSuggestions[0].relevance * filterByPercentageOfBestMatch;
		thisSuggestions = thisSuggestions.filter((suggestion) => limit - suggestion.relevance < 0);
	}
	const values = [];
	const indices = [];
	for (const suggestion of thisSuggestions) {
		values.push(suggestion.value);
		indices.push(suggestion.idx);
	}
	return {
		values,
		indices
	};
}
function _getLevenshteinSimilarityDistance(inputText, suggestion) {
	if (inputText.length < suggestion.length) [inputText, suggestion] = [suggestion, inputText];
	let previousRow = [];
	let currentRow = [];
	const sourceLength = inputText.length;
	const targetLength = suggestion.length;
	for (let j = 0; j <= targetLength; j++) previousRow[j] = j;
	let secondaryScore = 0;
	for (let i = 1; i <= sourceLength; i++) {
		currentRow[0] = i;
		for (let j = 1; j <= targetLength; j++) {
			const sourceChar = inputText[i - 1];
			const targetChar = suggestion[j - 1];
			if (sourceChar.toLocaleLowerCase() === targetChar.toLocaleLowerCase()) {
				++secondaryScore;
				if (sourceChar === targetChar) ++secondaryScore;
				if (i > 1 && j > 1) {
					if (inputText[i - 2].toLocaleLowerCase() === suggestion[j - 2].toLocaleLowerCase()) {
						++secondaryScore;
						if (inputText[i - 2] === suggestion[j - 2]) ++secondaryScore;
					}
				}
				if (i < sourceLength / 2 - 10) ++secondaryScore;
				currentRow[j] = previousRow[j - 1];
			} else {
				const insertCost = currentRow[j - 1];
				const deleteCost = previousRow[j];
				const replaceCost = previousRow[j - 1];
				currentRow[j] = 1 + Math.min(insertCost, deleteCost, replaceCost);
			}
		}
		[previousRow, currentRow] = [currentRow, previousRow];
	}
	return previousRow[targetLength] / (secondaryScore + 1);
}
var ENTERPRISE_MODULE_NAMES = {
	AdvancedFilter: 1,
	AllEnterprise: 1,
	BatchEdit: 1,
	CellSelection: 1,
	Clipboard: 1,
	ColumnMenu: 1,
	ColumnsToolPanel: 1,
	ContextMenu: 1,
	ExcelExport: 1,
	FiltersToolPanel: 1,
	Find: 1,
	GridCharts: 1,
	IntegratedCharts: 1,
	GroupFilter: 1,
	MasterDetail: 1,
	Menu: 1,
	MultiFilter: 1,
	NewFiltersToolPanel: 1,
	Pivot: 1,
	RangeSelection: 1,
	RichSelect: 1,
	RowNumbers: 1,
	RowGrouping: 1,
	RowGroupingPanel: 1,
	ServerSideRowModelApi: 1,
	ServerSideRowModel: 1,
	SetFilter: 1,
	SideBar: 1,
	Sparklines: 1,
	StatusBar: 1,
	TreeData: 1,
	ViewportRowModel: 1
};
var ALL_COLUMN_FILTERS = [
	"TextFilter",
	"NumberFilter",
	"DateFilter",
	"SetFilter",
	"MultiFilter",
	"GroupFilter",
	"CustomFilter"
];
var RESOLVABLE_MODULE_NAMES = {
	EditCore: [
		"TextEditor",
		"NumberEditor",
		"DateEditor",
		"CheckboxEditor",
		"LargeTextEditor",
		"SelectEditor",
		"RichSelect",
		"CustomEditor"
	],
	CheckboxCellRenderer: ["AllCommunity"],
	ClientSideRowModelHierarchy: [
		"RowGrouping",
		"Pivot",
		"TreeData"
	],
	ColumnFilter: ALL_COLUMN_FILTERS,
	ColumnGroupHeaderComp: ["AllCommunity"],
	ColumnGroup: ["AllCommunity"],
	ColumnHeaderComp: ["AllCommunity"],
	ColumnMove: ["AllCommunity"],
	ColumnResize: ["AllCommunity"],
	CommunityCore: ["AllCommunity"],
	CsrmSsrmSharedApi: ["ClientSideRowModelApi", "ServerSideRowModelApi"],
	EnterpriseCore: ["AllEnterprise"],
	FilterCore: [
		...ALL_COLUMN_FILTERS,
		"QuickFilter",
		"ExternalFilter",
		"AdvancedFilter"
	],
	GroupCellRenderer: [
		"RowGrouping",
		"Pivot",
		"TreeData",
		"MasterDetail",
		"ServerSideRowModel"
	],
	KeyboardNavigation: ["AllCommunity"],
	LoadingCellRenderer: ["ServerSideRowModel"],
	MenuCore: ["ColumnMenu", "ContextMenu"],
	MenuItem: [
		"ColumnMenu",
		"ContextMenu",
		"MultiFilter",
		"IntegratedCharts",
		"ColumnsToolPanel"
	],
	Overlay: ["AllCommunity"],
	PinnedColumn: ["AllCommunity"],
	SharedAggregation: [
		"RowGrouping",
		"Pivot",
		"TreeData",
		"ServerSideRowModel"
	],
	SharedDragAndDrop: ["AllCommunity"],
	SharedMasterDetail: ["MasterDetail", "ServerSideRowModel"],
	SharedMenu: [
		...ALL_COLUMN_FILTERS,
		"ColumnMenu",
		"ContextMenu"
	],
	SharedPivot: ["Pivot", "ServerSideRowModel"],
	SharedRowGrouping: ["RowGrouping", "ServerSideRowModel"],
	SharedRowSelection: ["RowSelection", "ServerSideRowModel"],
	SkeletonCellRenderer: ["ServerSideRowModel"],
	Sort: ["AllCommunity"],
	SsrmInfiniteSharedApi: ["InfiniteRowModel", "ServerSideRowModelApi"],
	SharedTreeData: ["TreeData", "ServerSideRowModel"]
};
var MODULES_FOR_ROW_MODELS = {
	InfiniteRowModel: "infinite",
	ClientSideRowModelApi: "clientSide",
	ClientSideRowModel: "clientSide",
	ServerSideRowModelApi: "serverSide",
	ServerSideRowModel: "serverSide",
	ViewportRowModel: "viewport"
};
function resolveModuleNames(moduleName, rowModelType) {
	const resolvedModuleNames = [];
	(Array.isArray(moduleName) ? moduleName : [moduleName]).forEach((modName) => {
		const resolved = RESOLVABLE_MODULE_NAMES[modName];
		if (resolved) resolved.forEach((resolvedModName) => {
			const rowModelForModule = MODULES_FOR_ROW_MODELS[resolvedModName];
			if (!rowModelForModule || rowModelForModule === rowModelType) resolvedModuleNames.push(resolvedModName);
		});
		else resolvedModuleNames.push(modName);
	});
	return resolvedModuleNames;
}
var NoModulesRegisteredError = () => `No AG Grid modules are registered! It is recommended to start with all Community features via the AllCommunityModule:
                    
    import { ModuleRegistry, AllCommunityModule } from 'ag-grid-community';
    
    ModuleRegistry.registerModules([ AllCommunityModule ]);
    `;
var moduleImportMsg = (moduleNames) => {
	const imports = moduleNames.map((moduleName) => `import { ${convertToUserModuleName(moduleName)} } from '${ENTERPRISE_MODULE_NAMES[moduleName] ? "ag-grid-enterprise" : "ag-grid-community"}';`);
	if (moduleNames.some((m) => m === "IntegratedCharts" || m === "Sparklines")) imports.push(`import { AgChartsEnterpriseModule } from 'ag-charts-enterprise';`);
	return `import { ModuleRegistry } from 'ag-grid-community'; 
${imports.join(" \n")} 

ModuleRegistry.registerModules([ ${moduleNames.map((m) => convertToUserModuleName(m, true)).join(", ")} ]); 

For more info see: ${baseDocLink}/modules/`;
};
function convertToUserModuleName(moduleName, inModuleRegistration = false) {
	if (inModuleRegistration && (moduleName === "IntegratedCharts" || moduleName === "Sparklines")) return `${moduleName}Module.with(AgChartsEnterpriseModule)`;
	return `${moduleName}Module`;
}
function umdMissingModule(reasonOrId, moduleNames) {
	const chartModules = moduleNames.filter((m) => m === "IntegratedCharts" || m === "Sparklines");
	let message = "";
	if (!globalThis?.agCharts && chartModules.length > 0) message = `Unable to use ${reasonOrId} as either the ag-charts-community or ag-charts-enterprise script needs to be included alongside ag-grid-enterprise.
`;
	else if (moduleNames.some((m) => ENTERPRISE_MODULE_NAMES[m])) message = message + `Unable to use ${reasonOrId} as that requires the ag-grid-enterprise script to be included.
`;
	return message;
}
function missingRowModelTypeError({ moduleName, rowModelType }) {
	return `To use the ${moduleName}Module you must set the gridOption "rowModelType='${rowModelType}'"`;
}
var missingModule = ({ reasonOrId, moduleName, gridScoped, gridId, rowModelType, additionalText, isUmd: isUmd2 }) => {
	const resolvedModuleNames = resolveModuleNames(moduleName, rowModelType);
	const reason = typeof reasonOrId === "string" ? reasonOrId : MISSING_MODULE_REASONS[reasonOrId];
	if (isUmd2) return umdMissingModule(reason, resolvedModuleNames);
	const chartModules = resolvedModuleNames.filter((m) => m === "IntegratedCharts" || m === "Sparklines");
	const chartImportRequired = chartModules.length > 0 ? `${chartModules.map((m) => convertToUserModuleName(m)).join()} must be initialised with an AG Charts module. One of 'AgChartsCommunityModule' / 'AgChartsEnterpriseModule'.` : "";
	return `${`Unable to use ${reason} as ${resolvedModuleNames.length > 1 ? "one of " + resolvedModuleNames.map((m) => convertToUserModuleName(m)).join(", ") : convertToUserModuleName(resolvedModuleNames[0])} is not registered${gridScoped ? " for gridId: " + gridId : ""}. ${chartImportRequired} Check if you have registered the module:
`}
${moduleImportMsg(resolvedModuleNames)}` + (additionalText ? ` 

${additionalText}` : "");
};
var missingChartsWithModule = (gridModule) => {
	return `${gridModule} must be initialised with an AG Charts module. One of 'AgChartsCommunityModule' / 'AgChartsEnterpriseModule'.

import { AgChartsEnterpriseModule } from 'ag-charts-enterprise';
import { ModuleRegistry } from 'ag-grid-community';
import { ${gridModule} } from 'ag-grid-enterprise';
    
ModuleRegistry.registerModules([${gridModule}.with(AgChartsEnterpriseModule)]);
    `;
};
var clipboardApiError = (method) => `AG Grid: Unable to use the Clipboard API (navigator.clipboard.${method}()). The reason why it could not be used has been logged in the previous line. For this reason the grid has defaulted to using a workaround which doesn't perform as well. Either fix why Clipboard API is blocked, OR stop this message from appearing by setting grid property suppressClipboardApi=true (which will default the grid to using the workaround rather than the API.`;
var AG_GRID_ERRORS = {
	1: () => "`rowData` must be an array",
	2: ({ nodeId }) => `Duplicate node id '${nodeId}' detected from getRowId callback, this could cause issues in your grid.`,
	3: () => "Calling gridApi.resetRowHeights() makes no sense when using Auto Row Height.",
	4: ({ id }) => `Could not find row id=${id}, data item was not found for this id`,
	5: ({ data }) => [
		`Could not find data item as object was not found.`,
		data,
		" Consider using getRowId to help the Grid find matching row data"
	],
	6: () => `'groupHideOpenParents' only works when specifying specific columns for 'colDef.showRowGroup'`,
	7: () => "Pivoting is not supported with aligned grids as it may produce different columns in each grid.",
	8: ({ key }) => `Unknown key for navigation ${key}`,
	9: ({ variable }) => `No value for ${variable?.cssName}. This usually means that the grid has been initialised before styles have been loaded. The default value of ${variable?.defaultValue} will be used and updated when styles load.`,
	10: ({ eventType }) => `As of v33, the '${eventType}' event is deprecated. Use the global 'modelUpdated' event to determine when row children have changed.`,
	11: () => "No gridOptions provided to createGrid",
	12: ({ colKey }) => [
		"column ",
		colKey,
		" not found"
	],
	13: () => "Could not find rowIndex, this means tasks are being executed on a rowNode that has been removed from the grid.",
	14: ({ groupPrefix }) => `Row IDs cannot start with ${groupPrefix}, this is a reserved prefix for AG Grid's row grouping feature.`,
	15: ({ expression }) => ["value should be either a string or a function", expression],
	16: ({ expression, params, e }) => [
		"Processing of the expression failed",
		"Expression = ",
		expression,
		"Params = ",
		params,
		"Exception = ",
		e
	],
	17: () => "you need either field or valueSetter set on colDef for editing to work",
	18: () => `alignedGrids contains an undefined option.`,
	19: () => `alignedGrids - No api found on the linked grid.`,
	20: () => `You may want to configure via a callback to avoid setup race conditions:
                     "alignedGrids: () => [linkedGrid]"`,
	21: () => "pivoting is not supported with aligned grids. You can only use one of these features at a time in a grid.",
	22: ({ key }) => `${key} is an initial property and cannot be updated.`,
	23: () => "The return of `getRowHeight` cannot be zero. If the intention is to hide rows, use a filter instead.",
	24: () => "row height must be a number if not using standard row model",
	25: ({ id }) => [
		`The getRowId callback must return a string. The ID `,
		id,
		` is being cast to a string.`
	],
	26: ({ fnName, preDestroyLink }) => {
		return `Grid API function ${fnName}() cannot be called as the grid has been destroyed.
 Either clear local references to the grid api, when it is destroyed, or check gridApi.isDestroyed() to avoid calling methods against a destroyed grid.
 To run logic when the grid is about to be destroyed use the gridPreDestroy event. See: ${preDestroyLink}`;
	},
	27: ({ fnName, module }) => `API function '${fnName}' not registered to module '${module}'`,
	28: () => "setRowCount cannot be used while using row grouping.",
	29: () => "tried to call sizeColumnsToFit() but the grid is coming back with zero width, maybe the grid is not visible yet on the screen?",
	30: ({ toIndex }) => [
		"tried to insert columns in invalid location, toIndex = ",
		toIndex,
		"remember that you should not count the moving columns when calculating the new index"
	],
	31: () => "infinite loop in resizeColumnSets",
	32: () => "applyColumnState() - the state attribute should be an array, however an array was not found. Please provide an array of items (one for each col you want to change) for state.",
	33: () => "stateItem.aggFunc must be a string. if using your own aggregation functions, register the functions first before using them in get/set state. This is because it is intended for the column state to be stored and retrieved as simple JSON.",
	34: ({ key }) => `the column type '${key}' is a default column type and cannot be overridden.`,
	35: () => `Column type definitions 'columnTypes' with a 'type' attribute are not supported because a column type cannot refer to another column type. Only column definitions 'columnDefs' can use the 'type' attribute to refer to a column type.`,
	36: ({ t }) => "colDef.type '" + t + "' does not correspond to defined gridOptions.columnTypes",
	37: () => `Changing the column pinning status is not allowed with domLayout='print'`,
	38: ({ iconName }) => `provided icon '${iconName}' needs to be a string or a function`,
	39: () => "Applying column order broke a group where columns should be married together. Applying new order has been discarded.",
	40: ({ e, method }) => `${e}
${clipboardApiError(method)}`,
	41: () => "Browser did not allow document.execCommand('copy'). Ensure 'api.copySelectedRowsToClipboard() is invoked via a user event, i.e. button click, otherwise the browser will prevent it for security reasons.",
	42: () => "Browser does not support document.execCommand('copy') for clipboard operations",
	43: ({ iconName }) => `As of v33, icon '${iconName}' is deprecated. Use the icon CSS name instead.`,
	44: () => "Data type definition hierarchies (via the \"extendsDataType\" property) cannot contain circular references.",
	45: ({ parentCellDataType }) => `The data type definition ${parentCellDataType} does not exist.`,
	46: () => "The \"baseDataType\" property of a data type definition must match that of its parent.",
	47: ({ cellDataType }) => `Missing data type definition - "${cellDataType}"`,
	48: ({ property }) => `Cell data type is "object" but no Value ${property} has been provided. Please either provide an object data type definition with a Value ${property}, or set "colDef.value${property}"`,
	49: ({ methodName }) => `Framework component is missing the method ${methodName}()`,
	50: ({ compName }) => `Could not find component ${compName}, did you forget to configure this component?`,
	51: () => `Export cancelled. Export is not allowed as per your configuration.`,
	52: () => "There is no `window` associated with the current `document`",
	53: () => `unknown value type during csv conversion`,
	54: () => "Could not find document body, it is needed for drag and drop and context menu.",
	55: () => "addRowDropZone - A container target needs to be provided",
	56: () => "addRowDropZone - target already exists in the list of DropZones. Use `removeRowDropZone` before adding it again.",
	57: () => "unable to show popup filter, filter instantiation failed",
	58: () => "no values found for select cellEditor",
	59: () => "cannot select pinned rows",
	60: () => "cannot select node until it has finished loading",
	61: () => "since version v32.2.0, rowNode.isFullWidthCell() has been deprecated. Instead check `rowNode.detail` followed by the user provided `isFullWidthRow` grid option.",
	62: ({ colId }) => `setFilterModel() - no column found for colId: ${colId}`,
	63: ({ colId }) => `setFilterModel() - unable to fully apply model, filtering disabled for colId: ${colId}`,
	64: ({ colId }) => `setFilterModel() - unable to fully apply model, unable to create filter for colId: ${colId}`,
	65: () => "filter missing setModel method, which is needed for setFilterModel",
	66: () => "filter API missing getModel method, which is needed for getFilterModel",
	67: () => "Filter is missing isFilterActive() method",
	68: () => "Column Filter API methods have been disabled as Advanced Filters are enabled.",
	69: ({ guiFromFilter }) => `getGui method from filter returned ${guiFromFilter}; it should be a DOM element.`,
	70: ({ newFilter }) => `Grid option quickFilterText only supports string inputs, received: ${typeof newFilter}`,
	71: () => "debounceMs is ignored when apply button is present",
	72: ({ keys }) => [`ignoring FilterOptionDef as it doesn't contain one of `, keys],
	73: () => `invalid FilterOptionDef supplied as it doesn't contain a 'displayKey'`,
	74: () => "no filter options for filter",
	75: () => "Unknown button type specified",
	76: ({ filterModelType }) => [
		"Unexpected type of filter \"",
		filterModelType,
		"\", it looks like the filter was configured with incorrect Filter Options"
	],
	77: () => `Filter model is missing 'conditions'`,
	78: () => "Filter Model contains more conditions than \"filterParams.maxNumConditions\". Additional conditions have been ignored.",
	79: () => "\"filterParams.maxNumConditions\" must be greater than or equal to zero.",
	80: () => "\"filterParams.numAlwaysVisibleConditions\" must be greater than or equal to zero.",
	81: () => "\"filterParams.numAlwaysVisibleConditions\" cannot be greater than \"filterParams.maxNumConditions\".",
	82: ({ param }) => `DateFilter ${param} is not a number`,
	83: () => `DateFilter minValidYear should be <= maxValidYear`,
	84: () => `DateFilter minValidDate should be <= maxValidDate`,
	85: () => "DateFilter should not have both minValidDate and minValidYear parameters set at the same time! minValidYear will be ignored.",
	86: () => "DateFilter should not have both maxValidDate and maxValidYear parameters set at the same time! maxValidYear will be ignored.",
	87: () => "DateFilter parameter minValidDate should always be lower than or equal to parameter maxValidDate.",
	88: ({ index }) => `Invalid row index for ensureIndexVisible: ${index}`,
	89: () => `A template was provided for Header Group Comp - templates are only supported for Header Comps (not groups)`,
	90: () => `datasource is missing getRows method`,
	91: () => "Filter is missing method doesFilterPass",
	92: () => `AnimationFrameService called but animation frames are off`,
	93: () => "cannot add multiple ranges when `cellSelection.suppressMultiRanges = true`",
	94: ({ paginationPageSizeOption, pageSizeSet, pageSizesSet, pageSizeOptions }) => `'paginationPageSize=${paginationPageSizeOption}'${pageSizeSet ? "" : " (default value)"}, but ${paginationPageSizeOption} is not included in${pageSizesSet ? "" : " the default"} paginationPageSizeSelector=[${pageSizeOptions?.join(", ")}].`,
	95: ({ paginationPageSizeOption, paginationPageSizeSelector: paginationPageSizeSelector2 }) => `Either set '${paginationPageSizeSelector2}' to an array that includes ${paginationPageSizeOption} or to 'false' to disable the page size selector.`,
	96: ({ id, data }) => [
		"Duplicate ID",
		id,
		"found for pinned row with data",
		data,
		"When `getRowId` is defined, it must return unique IDs for all pinned rows. Use the `rowPinned` parameter."
	],
	97: ({ colId }) => `cellEditor for column ${colId} is missing getGui() method`,
	98: () => "popup cellEditor does not work with fullRowEdit - you cannot use them both - either turn off fullRowEdit, or stop using popup editors.",
	99: () => "Since v32, `api.hideOverlay()` does not hide the loading overlay when `loading=true`. Set `loading=false` instead.",
	101: ({ propertyName, componentName, agGridDefaults, jsComps }) => {
		const textOutput = [];
		const suggestions = _fuzzySuggestions({
			inputValue: componentName,
			allSuggestions: [...Object.keys(agGridDefaults ?? []).filter((k) => ![
				"agCellEditor",
				"agGroupRowRenderer",
				"agSortIndicator"
			].includes(k)), ...Object.keys(jsComps ?? []).filter((k) => !!jsComps[k])],
			hideIrrelevant: true,
			filterByPercentageOfBestMatch: .8
		}).values;
		textOutput.push(`Could not find '${componentName}' component. It was configured as "${propertyName}: '${componentName}'" but it wasn't found in the list of registered components.
`);
		if (suggestions.length > 0) textOutput.push(`         Did you mean: [${suggestions.slice(0, 3)}]?
`);
		textOutput.push(`If using a custom component check it has been registered correctly.`);
		return textOutput;
	},
	102: () => "selectAll: 'filtered' only works when gridOptions.rowModelType='clientSide'",
	103: () => "Invalid selection state. When using client-side row model, the state must conform to `string[]`.",
	104: ({ value, param }) => `Numeric value ${value} passed to ${param} param will be interpreted as ${value} seconds. If this is intentional use "${value}s" to silence this warning.`,
	105: ({ e }) => [`chart rendering failed`, e],
	106: () => `Theming API and Legacy Themes are both used in the same page. A Theming API theme has been provided to the 'theme' grid option, but the file (ag-grid.css) is also included and will cause styling issues. Remove ag-grid.css from the page. See the migration guide: ${baseDocLink}/theming-migration/`,
	107: ({ key, value }) => `Invalid value for theme param ${key} - ${value}`,
	108: ({ e }) => ["chart update failed", e],
	109: ({ inputValue, allSuggestions }) => {
		const suggestions = _fuzzySuggestions({
			inputValue,
			allSuggestions,
			hideIrrelevant: true,
			filterByPercentageOfBestMatch: .8
		}).values;
		return [
			`Could not find '${inputValue}' aggregate function. It was configured as "aggFunc: '${inputValue}'" but it wasn't found in the list of registered aggregations.`,
			suggestions.length > 0 ? `         Did you mean: [${suggestions.slice(0, 3)}]?` : "",
			`If using a custom aggregation function check it has been registered correctly.`
		].join("\n");
	},
	110: () => "groupHideOpenParents only works when specifying specific columns for colDef.showRowGroup",
	111: () => "Invalid selection state. When `groupSelects` is enabled, the state must conform to `IServerSideGroupSelectionState`.",
	113: () => "Set Filter cannot initialise because you are using a row model that does not contain all rows in the browser. Either use a different filter type, or configure Set Filter such that you provide it with values",
	114: ({ component }) => `Could not find component with name of ${component}. Is it in Vue.components?`,
	116: () => "Invalid selection state. The state must conform to `IServerSideSelectionState`.",
	117: () => "selectAll must be of boolean type.",
	118: () => "Infinite scrolling must be enabled in order to set the row count.",
	119: () => "Unable to instantiate filter",
	120: () => "MultiFloatingFilterComp expects MultiFilter as its parent",
	121: () => "a column you are grouping or pivoting by has objects as values. If you want to group by complex objects then either a) use a colDef.keyCreator (see AG Grid docs) or b) to toString() on the object to return a key",
	122: () => "could not find the document, document is empty",
	123: () => "Advanced Filter is only supported with the Client-Side Row Model or Server-Side Row Model.",
	124: () => "No active charts to update.",
	125: ({ chartId }) => `Unable to update chart. No active chart found with ID: ${chartId}.`,
	126: () => "unable to restore chart as no chart model is provided",
	127: ({ allRange }) => `unable to create chart as ${allRange ? "there are no columns in the grid" : "no range is selected"}.`,
	128: ({ feature }) => `${feature} is only available if using 'multiRow' selection mode.`,
	129: ({ feature, rowModel }) => `${feature} is only available if using 'clientSide' or 'serverSide' rowModelType, you are using ${rowModel}.`,
	130: () => "cannot multi select unless selection mode is \"multiRow\"",
	132: () => "Row selection features are not available unless `rowSelection` is enabled.",
	133: ({ iconName }) => `icon '${iconName}' function should return back a string or a dom object`,
	134: ({ iconName }) => `Did not find icon '${iconName}'`,
	135: () => `Data type of the new value does not match the cell data type of the column`,
	136: () => `Unable to update chart as the 'type' is missing. It must be either 'rangeChartUpdate', 'pivotChartUpdate', or 'crossFilterChartUpdate'.`,
	137: ({ type, currentChartType }) => `Unable to update chart as a '${type}' update type is not permitted on a ${currentChartType}.`,
	138: ({ chartType }) => `invalid chart type supplied: ${chartType}`,
	139: ({ customThemeName }) => `a custom chart theme with the name ${customThemeName} has been supplied but not added to the 'chartThemes' list`,
	140: ({ name }) => `no stock theme exists with the name '${name}' and no custom chart theme with that name was supplied to 'customChartThemes'`,
	141: () => "cross filtering with row grouping is not supported.",
	142: () => "cross filtering is only supported in the client side row model.",
	143: ({ panel }) => `'${panel}' is not a valid Chart Tool Panel name`,
	144: ({ type }) => `Invalid charts data panel group name supplied: '${type}'`,
	145: ({ group }) => `As of v32, only one charts customize panel group can be expanded at a time. '${group}' will not be expanded.`,
	146: ({ comp }) => `Unable to instantiate component '${comp}' as its module hasn't been loaded. Add 'ValidationModule' to see which module is required.`,
	147: ({ group }) => `Invalid charts customize panel group name supplied: '${group}'`,
	148: ({ group }) => `invalid chartGroupsDef config '${group}'`,
	149: ({ group, chartType }) => `invalid chartGroupsDef config '${group}.${chartType}'`,
	150: () => `'seriesChartTypes' are required when the 'customCombo' chart type is specified.`,
	151: ({ chartType }) => `invalid chartType '${chartType}' supplied in 'seriesChartTypes', converting to 'line' instead.`,
	152: ({ colId }) => `no 'seriesChartType' found for colId = '${colId}', defaulting to 'line'.`,
	153: ({ chartDataType }) => `unexpected chartDataType value '${chartDataType}' supplied, instead use 'category', 'series' or 'excluded'`,
	154: ({ colId }) => `cross filtering requires a 'agSetColumnFilter' or 'agMultiColumnFilter' to be defined on the column with id: ${colId}`,
	155: ({ option }) => `'${option}' is not a valid Chart Toolbar Option`,
	156: ({ panel }) => `Invalid panel in chartToolPanelsDef.panels: '${panel}'`,
	157: ({ unrecognisedGroupIds }) => ["unable to find group(s) for supplied groupIds:", unrecognisedGroupIds],
	158: () => "can not expand a column item that does not represent a column group header",
	159: () => "Invalid params supplied to createExcelFileForExcel() - `ExcelExportParams.data` is empty.",
	160: () => `Export cancelled. Export is not allowed as per your configuration.`,
	161: () => "The Excel Exporter is currently on Multi Sheet mode. End that operation by calling 'api.getMultipleSheetAsExcel()' or 'api.exportMultipleSheetsAsExcel()'",
	162: ({ id, dataType }) => `Unrecognized data type for excel export [${id}.dataType=${dataType}]`,
	163: ({ featureName }) => `Excel table export does not work with ${featureName}. The exported Excel file will not contain any Excel tables.
 Please turn off ${featureName} to enable Excel table exports.`,
	164: () => "Unable to add data table to Excel sheet: A table already exists.",
	165: () => "Unable to add data table to Excel sheet: Missing required parameters.",
	166: ({ unrecognisedGroupIds }) => ["unable to find groups for these supplied groupIds:", unrecognisedGroupIds],
	167: ({ unrecognisedColIds }) => ["unable to find columns for these supplied colIds:", unrecognisedColIds],
	168: () => "detailCellRendererParams.template should be function or string",
	169: () => "Reference to eDetailGrid was missing from the details template. Please add data-ref=\"eDetailGrid\" to the template.",
	170: ({ providedStrategy }) => `invalid cellRendererParams.refreshStrategy = ${providedStrategy} supplied, defaulting to refreshStrategy = 'rows'.`,
	171: () => "could not find detail grid options for master detail, please set gridOptions.detailCellRendererParams.detailGridOptions",
	172: () => "could not find getDetailRowData for master / detail, please set gridOptions.detailCellRendererParams.getDetailRowData",
	173: ({ group }) => `invalid chartGroupsDef config '${group}'`,
	174: ({ group, chartType }) => `invalid chartGroupsDef config '${group}.${chartType}'`,
	175: ({ menuTabName, itemsToConsider }) => [`Trying to render an invalid menu item '${menuTabName}'. Check that your 'menuTabs' contains one of `, itemsToConsider],
	176: ({ key }) => `unknown menu item type ${key}`,
	177: () => `valid values for cellSelection.handle.direction are 'x', 'y' and 'xy'. Default to 'xy'.`,
	178: ({ colId }) => `column ${colId} is not visible`,
	179: () => "totalValueGetter should be either a function or a string (expression)",
	180: () => "agRichSelectCellEditor requires cellEditorParams.values to be set",
	181: () => "agRichSelectCellEditor cannot have `multiSelect` and `allowTyping` set to `true`. AllowTyping has been turned off.",
	182: () => "you cannot mix groupDisplayType = \"multipleColumns\" with treeData, only one column can be used to display groups when doing tree data",
	183: () => "Group Column Filter only works on group columns. Please use a different filter.",
	184: ({ parentGroupData, childNodeData }) => [`duplicate group keys for row data, keys should be unique`, [parentGroupData, childNodeData]],
	185: ({ data }) => [`getDataPath() should not return an empty path`, [data]],
	186: ({ rowId, rowData, duplicateRowsData }) => [
		`duplicate group keys for row data, keys should be unique`,
		rowId,
		rowData,
		...duplicateRowsData ?? []
	],
	187: ({ rowId, firstData, secondData }) => [
		`Duplicate node id ${rowId}. Row IDs are provided via the getRowId() callback. Please modify the getRowId() callback code to provide unique row id values.`,
		"first instance",
		firstData,
		"second instance",
		secondData
	],
	188: () => `getRowId callback must be provided for Server Side Row Model selection to work correctly.`,
	189: ({ startRow }) => `invalid value ${startRow} for startRow, the value should be >= 0`,
	190: ({ rowGroupId, data }) => [
		`null and undefined values are not allowed for server side row model keys`,
		rowGroupId ? `column = ${rowGroupId}` : ``,
		`data is `,
		data
	],
	194: ({ method }) => `calling gridApi.${method}() is only possible when using rowModelType=\`clientSide\`.`,
	195: ({ justCurrentPage }) => `selecting just ${justCurrentPage ? "current page" : "filtered"} only works when gridOptions.rowModelType='clientSide'`,
	196: ({ key }) => `Provided ids must be of string type. Invalid id provided: ${key}`,
	197: () => "`toggledNodes` must be an array of string ids.",
	199: () => `getSelectedNodes and getSelectedRows functions cannot be used with select all functionality with the server-side row model. Use \`api.getServerSideSelectionState()\` instead.`,
	200: missingModule,
	201: ({ rowModelType }) => `Could not find row model for rowModelType = ${rowModelType}`,
	202: () => `\`getSelectedNodes\` and \`getSelectedRows\` functions cannot be used with \`groupSelectsChildren\` and the server-side row model. Use \`api.getServerSideSelectionState()\` instead.`,
	203: () => "Server Side Row Model does not support Dynamic Row Height and Cache Purging. Either a) remove getRowHeight() callback or b) remove maxBlocksInCache property. Purging has been disabled.",
	204: () => "Server Side Row Model does not support Auto Row Height and Cache Purging. Either a) remove colDef.autoHeight or b) remove maxBlocksInCache property. Purging has been disabled.",
	205: ({ duplicateIdText }) => `Unable to display rows as duplicate row ids (${duplicateIdText}) were returned by the getRowId callback. Please modify the getRowId callback to provide unique ids.`,
	206: () => "getRowId callback must be implemented for transactions to work. Transaction was ignored.",
	207: () => "The Set Filter Parameter \"defaultToNothingSelected\" value was ignored because it does not work when \"excelMode\" is used.",
	208: () => `Set Filter Value Formatter must return string values. Please ensure the Set Filter Value Formatter returns string values for complex objects.`,
	209: () => `Set Filter Key Creator is returning null for provided values and provided values are primitives. Please provide complex objects. See ${baseDocLink}/filter-set-filter-list/#filter-value-types`,
	210: () => "Set Filter has a Key Creator, but provided values are primitives. Did you mean to provide complex objects?",
	211: () => "property treeList=true for Set Filter params, but you did not provide a treeListPathGetter or values of type Date.",
	212: () => `please review all your toolPanel components, it seems like at least one of them doesn't have an id`,
	213: () => "Advanced Filter does not work with Filters Tool Panel. Filters Tool Panel has been disabled.",
	214: ({ key }) => `unable to lookup Tool Panel as invalid key supplied: ${key}`,
	215: ({ key, defaultByKey }) => `the key ${key} is not a valid key for specifying a tool panel, valid keys are: ${Object.keys(defaultByKey ?? {}).join(",")}`,
	216: ({ name }) => `Missing component for '${name}'`,
	217: ({ invalidColIds }) => ["unable to find grid columns for the supplied colDef(s):", invalidColIds],
	218: ({ property, defaultOffset }) => `${property} must be a number, the value you provided is not a valid number. Using the default of ${defaultOffset}px.`,
	219: ({ property }) => `Property ${property} does not exist on the target object.`,
	220: ({ lineDash }) => `'${lineDash}' is not a valid 'lineDash' option.`,
	221: () => `agAggregationComponent should only be used with the client and server side row model.`,
	222: () => `agFilteredRowCountComponent should only be used with the client side row model.`,
	223: () => `agSelectedRowCountComponent should only be used with the client and server side row model.`,
	224: () => `agTotalAndFilteredRowCountComponent should only be used with the client side row model.`,
	225: () => "agTotalRowCountComponent should only be used with the client side row model.",
	226: () => "viewport is missing init method.",
	227: () => "menu item icon must be DOM node or string",
	228: ({ menuItemOrString }) => `unrecognised menu item ${menuItemOrString}`,
	229: ({ index }) => ["invalid row index for ensureIndexVisible: ", index],
	230: () => "detailCellRendererParams.template is not supported by AG Grid React. To change the template, provide a Custom Detail Cell Renderer. See https://www.ag-grid.com/react-data-grid/master-detail-custom-detail/",
	231: () => "As of v32, using custom components with `reactiveCustomComponents = false` is deprecated.",
	232: () => "Using both rowData and v-model. rowData will be ignored.",
	233: ({ methodName }) => `Framework component is missing the method ${methodName}()`,
	234: () => "Group Column Filter does not work with the colDef property \"field\". This property will be ignored.",
	235: () => "Group Column Filter does not work with the colDef property \"filterValueGetter\". This property will be ignored.",
	236: () => "Group Column Filter does not work with the colDef property \"filterParams\". This property will be ignored.",
	237: () => "Group Column Filter does not work with Tree Data enabled. Please disable Tree Data, or use a different filter.",
	238: () => "setRowCount can only accept a positive row count.",
	239: () => "Theming API and CSS File Themes are both used in the same page. In v33 we released the Theming API as the new default method of styling the grid. See the migration docs https://www.ag-grid.com/react-data-grid/theming-migration/. Because no value was provided to the `theme` grid option it defaulted to themeQuartz. But the file (ag-grid.css) is also included and will cause styling issues. Either pass the string \"legacy\" to the theme grid option to use v32 style themes, or remove ag-grid.css from the page to use Theming API.",
	240: ({ theme }) => `theme grid option must be a Theming API theme object or the string "legacy", received: ${theme}`,
	243: () => "Failed to deserialize state - each provided state object must be an object.",
	244: () => "Failed to deserialize state - `selectAllChildren` must be a boolean value or undefined.",
	245: () => "Failed to deserialize state - `toggledNodes` must be an array.",
	246: () => "Failed to deserialize state - Every `toggledNode` requires an associated string id.",
	247: () => `Row selection state could not be parsed due to invalid data. Ensure all child state has toggledNodes or does not conform with the parent rule. 
Please rebuild the selection state and reapply it.`,
	248: () => "SetFloatingFilter expects SetFilter as its parent",
	249: () => "Must supply a Value Formatter in Set Filter params when using a Key Creator",
	250: () => "Must supply a Key Creator in Set Filter params when `treeList = true` on a group column, and Tree Data or Row Grouping is enabled.",
	251: ({ chartType }) => `AG Grid: Unable to create chart as an invalid chartType = '${chartType}' was supplied.`,
	252: () => "cannot get grid to draw rows when it is in the middle of drawing rows. \nYour code probably called a grid API method while the grid was in the render stage. \nTo overcome this, put the API call into a timeout, e.g. instead of api.redrawRows(), call setTimeout(function() { api.redrawRows(); }, 0). \nTo see what part of your code that caused the refresh check this stacktrace.",
	253: ({ version }) => ["Illegal version string: ", version],
	254: () => "Cannot create chart: no chart themes available.",
	255: ({ point }) => `Lone surrogate U+${point?.toString(16).toUpperCase()} is not a scalar value`,
	256: () => "Unable to initialise. See validation error, or load ValidationModule if missing.",
	257: () => missingChartsWithModule("IntegratedChartsModule"),
	258: () => missingChartsWithModule("SparklinesModule"),
	259: ({ part }) => `the argument to theme.withPart must be a Theming API part object, received: ${part}`,
	260: ({ propName, compName, gridScoped, gridId, rowModelType }) => missingModule({
		reasonOrId: `AG Grid '${propName}' component: ${compName}`,
		moduleName: USER_COMP_MODULES[compName],
		gridId,
		gridScoped,
		rowModelType
	}),
	261: () => "As of v33, `column.isHovered()` is deprecated. Use `api.isColumnHovered(column)` instead.",
	262: () => "As of v33, icon key \"smallDown\" is deprecated. Use \"advancedFilterBuilderSelect\" for Advanced Filter Builder dropdown, \"selectOpen\" for Select cell editor and dropdowns (e.g. Integrated Charts menu), \"richSelectOpen\" for Rich Select cell editor.",
	263: () => "As of v33, icon key \"smallLeft\" is deprecated. Use \"panelDelimiterRtl\" for Row Group Panel / Pivot Panel, \"subMenuOpenRtl\" for sub-menus.",
	264: () => "As of v33, icon key \"smallRight\" is deprecated. Use \"panelDelimiter\" for Row Group Panel / Pivot Panel, \"subMenuOpen\" for sub-menus.",
	265: ({ colId }) => `Unable to infer chart data type for column '${colId}' if first data entry is null. Please specify "chartDataType", or a "cellDataType" in the column definition. For more information, see ${baseDocLink}/integrated-charts-range-chart#coldefchartdatatype .`,
	266: () => "As of v33.1, using \"keyCreator\" with the Rich Select Editor has been deprecated. It now requires the \"formatValue\" callback to convert complex data to strings.",
	267: () => "Detail grids can not use a different theme to the master grid, the `theme` detail grid option will be ignored.",
	268: () => "Transactions aren't supported with tree data when using treeDataChildrenField",
	269: () => "When `masterSelects: 'detail'`, detail grids must be configured with multi-row selection",
	270: ({ id, parentId }) => `Cycle detected for row with id='${id}' and parent id='${parentId}'. Resetting the parent for row with id='${id}' and showing it as a root-level node.`,
	271: ({ id, parentId }) => `Parent row not found for row with id='${id}' and parent id='${parentId}'. Showing row with id='${id}' as a root-level node.`,
	272: () => NoModulesRegisteredError(),
	273: ({ providedId, usedId }) => `Provided column id '${providedId}' was already in use, ensure all column and group ids are unique. Using '${usedId}' instead.`,
	274: ({ prop }) => {
		let msg = `Since v33, ${prop} has been deprecated.`;
		switch (prop) {
			case "maxComponentCreationTimeMs":
				msg += " This property is no longer required and so will be removed in a future version.";
				break;
			case "setGridApi":
				msg += ` This method is not called by AG Grid. To access the GridApi see: https://ag-grid.com/react-data-grid/grid-interface/#grid-api `;
				break;
			case "children":
				msg += ` For multiple versions AgGridReact does not support children.`;
				break;
		}
		return msg;
	},
	275: missingRowModelTypeError,
	276: () => "Row Numbers Row Resizer cannot be used when Grid Columns have `autoHeight` enabled.",
	277: ({ colId }) => `'enableFilterHandlers' is set to true, but column '${colId}' does not have 'filter.doesFilterPass' or 'filter.handler' set.`,
	278: ({ colId }) => `Unable to create filter handler for column '${colId}'`,
	279: (_) => {},
	280: ({ colId }) => `'name' must be provided for custom filter components for column '${colId}`,
	281: ({ colId }) => `Filter for column '${colId}' does not have 'filterParams.buttons', but the new Filters Tool Panel has buttons configured. Either configure buttons for the filter, or disable buttons on the Filters Tool Panel.`,
	282: () => "New filter tool panel requires `enableFilterHandlers: true`.",
	283: () => "As of v34, use the same method on the filter handler (`api.getColumnFilterHandler(colKey)`) instead.",
	284: () => "As of v34, filters are active when they have a model. Use `api.getColumnFilterModel()` instead.",
	285: () => "As of v34, use (`api.getColumnFilterModel()`) instead.",
	286: () => "As of v34, use (`api.setColumnFilterModel()`) instead.",
	287: () => "`api.doFilterAction()` requires `enableFilterHandlers = true",
	288: () => "`api.getColumnFilterModel(key, true)` requires `enableFilterHandlers = true",
	289: ({ rowModelType }) => `Row Model '${rowModelType}' is not supported with Batch Editing`,
	290: ({ rowIndex, rowPinned }) => `Row with index '${rowIndex}' and pinned state '${rowPinned}' not found`
};
function getError(errorId, args) {
	const msgOrFunc = AG_GRID_ERRORS[errorId];
	if (!msgOrFunc) return [`Missing error text for error id ${errorId}!`];
	const errorBody = msgOrFunc(args);
	const errorSuffix = `
See ${getErrorLink(errorId, args)}`;
	return Array.isArray(errorBody) ? errorBody.concat(errorSuffix) : [errorBody, errorSuffix];
}
var MISSING_MODULE_REASONS = {
	1: "Charting Aggregation",
	2: "pivotResultFields",
	3: "setTooltip"
};
var _gridApiCache = /* @__PURE__ */ new WeakMap();
var _gridElementCache = /* @__PURE__ */ new WeakMap();
function createGrid(eGridDiv, gridOptions, params) {
	if (!gridOptions) {
		_error(11);
		return {};
	}
	const gridParams = params;
	let destroyCallback;
	if (!gridParams?.setThemeOnGridDiv) {
		const newGridDiv = _createElement({ tag: "div" });
		newGridDiv.style.height = "100%";
		eGridDiv.appendChild(newGridDiv);
		eGridDiv = newGridDiv;
		destroyCallback = () => eGridDiv.remove();
	}
	return new GridCoreCreator().create(eGridDiv, gridOptions, (context) => {
		const gridComp = new GridComp(eGridDiv);
		context.createBean(gridComp);
	}, void 0, params, destroyCallback);
}
var nextGridId = 1;
var GridCoreCreator = class {
	create(eGridDiv, providedOptions, createUi, acceptChanges, params, _destroyCallback) {
		const gridOptions = GlobalGridOptions.applyGlobalGridOptions(providedOptions);
		const gridId = gridOptions.gridId ?? String(nextGridId++);
		const registeredModules = this.getRegisteredModules(params, gridId, gridOptions.rowModelType);
		const beanClasses = this.createBeansList(gridOptions.rowModelType, registeredModules, gridId);
		const providedBeanInstances = this.createProvidedBeans(eGridDiv, gridOptions, params);
		if (!beanClasses) return;
		const destroyCallback = () => {
			_gridElementCache.delete(api);
			_gridApiCache.delete(eGridDiv);
			_destroyCallback?.();
		};
		const context = new Context({
			providedBeanInstances,
			beanClasses,
			gridId,
			beanInitComparator: gridBeanInitComparator,
			beanDestroyComparator: gridBeanDestroyComparator,
			derivedBeans: [createGridApi],
			destroyCallback
		});
		this.registerModuleFeatures(context, registeredModules);
		createUi(context);
		context.getBean("syncSvc").start();
		acceptChanges?.(context);
		const api = context.getBean("gridApi");
		_gridApiCache.set(eGridDiv, api);
		_gridElementCache.set(api, eGridDiv);
		return api;
	}
	getRegisteredModules(params, gridId, rowModelType) {
		_registerModule(CommunityCoreModule, void 0, true);
		params?.modules?.forEach((m) => _registerModule(m, gridId));
		return _getRegisteredModules(gridId, getDefaultRowModelType(rowModelType));
	}
	registerModuleFeatures(context, registeredModules) {
		const registry = context.getBean("registry");
		const apiFunctionSvc = context.getBean("apiFunctionSvc");
		registeredModules.forEach((module) => {
			registry.registerModule(module);
			const apiFunctions = module.apiFunctions;
			if (apiFunctions) Object.keys(apiFunctions).forEach((name) => {
				apiFunctionSvc?.addFunction(name, apiFunctions[name]);
			});
		});
	}
	createProvidedBeans(eGridDiv, gridOptions, params) {
		let frameworkOverrides = params ? params.frameworkOverrides : null;
		if (_missing(frameworkOverrides)) frameworkOverrides = new VanillaFrameworkOverrides();
		const seed = {
			gridOptions,
			eGridDiv,
			globalListener: params ? params.globalListener : null,
			globalSyncListener: params ? params.globalSyncListener : null,
			frameworkOverrides
		};
		if (params && params.providedBeanInstances) Object.assign(seed, params.providedBeanInstances);
		return seed;
	}
	createBeansList(userProvidedRowModelType, registeredModules, gridId) {
		const rowModelModuleNames = {
			clientSide: "ClientSideRowModel",
			infinite: "InfiniteRowModel",
			serverSide: "ServerSideRowModel",
			viewport: "ViewportRowModel"
		};
		const rowModelType = getDefaultRowModelType(userProvidedRowModelType);
		const rowModuleModelName = rowModelModuleNames[rowModelType];
		if (!rowModuleModelName) {
			_logPreInitErr(201, { rowModelType }, `Unknown rowModelType ${rowModelType}.`);
			return;
		}
		if (!_hasUserRegistered()) {
			_logPreInitErr(272, void 0, NoModulesRegisteredError());
			return;
		}
		if (!userProvidedRowModelType) {
			const registeredRowModelModules = Object.entries(rowModelModuleNames).filter(([rowModelType2, module]) => _isModuleRegistered(module, gridId, rowModelType2));
			if (registeredRowModelModules.length == 1) {
				const [userRowModelType, moduleName] = registeredRowModelModules[0];
				if (userRowModelType !== rowModelType) {
					const params = {
						moduleName,
						rowModelType: userRowModelType
					};
					_logPreInitErr(275, params, missingRowModelTypeError(params));
					return;
				}
			}
		}
		if (!_isModuleRegistered(rowModuleModelName, gridId, rowModelType)) {
			_logPreInitErr(200, {
				reasonOrId: `rowModelType = '${rowModelType}'`,
				moduleName: rowModuleModelName,
				gridScoped: _areModulesGridScoped(),
				gridId,
				rowModelType
			}, `Missing module ${rowModuleModelName}Module for rowModelType ${rowModelType}.`);
			return;
		}
		const beans = /* @__PURE__ */ new Set();
		registeredModules.forEach((module) => module.beans?.forEach((bean) => beans.add(bean)));
		return Array.from(beans);
	}
};
function getDefaultRowModelType(passedRowModelType) {
	return passedRowModelType ?? "clientSide";
}
function _getClientSideRowModel(beans) {
	const rowModel = beans.rowModel;
	return rowModel.getType() === "clientSide" ? rowModel : void 0;
}
function _getServerSideRowModel(beans) {
	const rowModel = beans.rowModel;
	return rowModel.getType() === "serverSide" ? rowModel : void 0;
}
var BaseComponentWrapper = class {
	wrap(OriginalConstructor, mandatoryMethods, optionalMethods, componentType) {
		const wrapper$1 = this.createWrapper(OriginalConstructor, componentType);
		mandatoryMethods?.forEach((methodName) => {
			this.createMethod(wrapper$1, methodName, true);
		});
		optionalMethods?.forEach((methodName) => {
			this.createMethod(wrapper$1, methodName, false);
		});
		return wrapper$1;
	}
	createMethod(wrapper$1, methodName, mandatory) {
		wrapper$1.addMethod(methodName, this.createMethodProxy(wrapper$1, methodName, mandatory));
	}
	createMethodProxy(wrapper$1, methodName, mandatory) {
		return function() {
			if (wrapper$1.hasMethod(methodName)) return wrapper$1.callMethod(methodName, arguments);
			if (mandatory) _warn(49, { methodName });
			return null;
		};
	}
};
var TooltipComponentElement = {
	tag: "div",
	cls: "ag-tooltip"
};
var TooltipComponent2 = class extends PopupComponent {
	constructor() {
		super(TooltipComponentElement);
	}
	init(params) {
		const { value } = params;
		const eGui = this.getGui();
		eGui.textContent = _toString(value);
		const locationKebabCase = params.location.replace(/([a-z])([A-Z0-9])/g, "$1-$2").toLowerCase();
		eGui.classList.add(`ag-${locationKebabCase}-tooltip`);
	}
};
var SHOW_QUICK_TOOLTIP_DIFF = 1e3;
var FADE_OUT_TOOLTIP_TIMEOUT = 1e3;
var INTERACTIVE_HIDE_DELAY = 100;
var lastTooltipHideTime;
var isLocked = false;
var TooltipStateManager = class extends BeanStub {
	constructor(tooltipCtrl, getTooltipValue) {
		super();
		this.tooltipCtrl = tooltipCtrl;
		this.getTooltipValue = getTooltipValue;
		this.interactionEnabled = false;
		this.isInteractingWithTooltip = false;
		this.state = 0;
		this.tooltipInstanceCount = 0;
		this.tooltipMouseTrack = false;
	}
	wireBeans(beans) {
		this.popupSvc = beans.popupSvc;
		this.userCompFactory = beans.userCompFactory;
	}
	postConstruct() {
		if (this.gos.get("tooltipInteraction")) this.interactionEnabled = true;
		this.tooltipTrigger = this.getTooltipTrigger();
		this.tooltipMouseTrack = this.gos.get("tooltipMouseTrack");
		const el = this.tooltipCtrl.getGui();
		if (this.tooltipTrigger === 0) this.addManagedListeners(el, {
			mouseenter: this.onMouseEnter.bind(this),
			mouseleave: this.onMouseLeave.bind(this)
		});
		if (this.tooltipTrigger === 1) this.addManagedListeners(el, {
			focusin: this.onFocusIn.bind(this),
			focusout: this.onFocusOut.bind(this)
		});
		this.addManagedListeners(el, { mousemove: this.onMouseMove.bind(this) });
		if (!this.interactionEnabled) this.addManagedListeners(el, {
			mousedown: this.onMouseDown.bind(this),
			keydown: this.onKeyDown.bind(this)
		});
	}
	getGridOptionsTooltipDelay(delayOption) {
		const delay = this.gos.get(delayOption);
		return Math.max(200, delay);
	}
	getTooltipDelay(type) {
		if (type === "show") return this.tooltipCtrl.getTooltipShowDelayOverride?.() ?? this.getGridOptionsTooltipDelay("tooltipShowDelay");
		return this.tooltipCtrl.getTooltipHideDelayOverride?.() ?? this.getGridOptionsTooltipDelay("tooltipHideDelay");
	}
	destroy() {
		this.setToDoNothing();
		super.destroy();
	}
	getTooltipTrigger() {
		const trigger = this.gos.get("tooltipTrigger");
		if (!trigger || trigger === "hover") return 0;
		return 1;
	}
	onMouseEnter(e) {
		if (this.interactionEnabled && this.interactiveTooltipTimeoutId) {
			this.unlockService();
			this.startHideTimeout();
		}
		if (_isIOSUserAgent()) return;
		if (isLocked) this.showTooltipTimeoutId = window.setTimeout(() => {
			this.prepareToShowTooltip(e);
		}, INTERACTIVE_HIDE_DELAY);
		else this.prepareToShowTooltip(e);
	}
	onMouseMove(e) {
		if (this.lastMouseEvent) this.lastMouseEvent = e;
		if (this.tooltipMouseTrack && this.state === 2 && this.tooltipComp) this.positionTooltip();
	}
	onMouseDown() {
		this.setToDoNothing();
	}
	onMouseLeave() {
		if (this.interactionEnabled) this.lockService();
		else this.setToDoNothing();
	}
	onFocusIn() {
		this.prepareToShowTooltip();
	}
	onFocusOut(e) {
		const relatedTarget = e.relatedTarget;
		const parentCompGui = this.tooltipCtrl.getGui();
		const tooltipGui = this.tooltipComp?.getGui();
		if (this.isInteractingWithTooltip || parentCompGui.contains(relatedTarget) || this.interactionEnabled && tooltipGui?.contains(relatedTarget)) return;
		this.setToDoNothing();
	}
	onKeyDown() {
		if (this.isInteractingWithTooltip) this.isInteractingWithTooltip = false;
		this.setToDoNothing();
	}
	prepareToShowTooltip(mouseEvent) {
		if (this.state != 0 || isLocked) return;
		let delay = 0;
		if (mouseEvent) delay = this.isLastTooltipHiddenRecently() ? 200 : this.getTooltipDelay("show");
		this.lastMouseEvent = mouseEvent || null;
		this.showTooltipTimeoutId = window.setTimeout(this.showTooltip.bind(this), delay);
		this.state = 1;
	}
	isLastTooltipHiddenRecently() {
		return Date.now() - lastTooltipHideTime < SHOW_QUICK_TOOLTIP_DIFF;
	}
	setToDoNothing(fromHideTooltip) {
		if (!fromHideTooltip && this.state === 2) this.hideTooltip();
		if (this.onBodyScrollEventCallback) {
			this.onBodyScrollEventCallback();
			this.onBodyScrollEventCallback = void 0;
		}
		if (this.onColumnMovedEventCallback) {
			this.onColumnMovedEventCallback();
			this.onColumnMovedEventCallback = void 0;
		}
		if (this.onDocumentKeyDownCallback) {
			this.onDocumentKeyDownCallback();
			this.onDocumentKeyDownCallback = void 0;
		}
		this.clearTimeouts();
		this.state = 0;
		this.lastMouseEvent = null;
	}
	showTooltip() {
		const value = this.getTooltipValue();
		const ctrl = this.tooltipCtrl;
		if (!_exists(value) || ctrl.shouldDisplayTooltip && !ctrl.shouldDisplayTooltip()) {
			this.setToDoNothing();
			return;
		}
		const rowNode = ctrl.getRowNode?.();
		const params = _addGridCommonParams(this.gos, {
			location: ctrl.getLocation?.() ?? "UNKNOWN",
			colDef: ctrl.getColDef?.(),
			column: ctrl.getColumn?.(),
			rowIndex: ctrl.getRowIndex?.(),
			node: rowNode,
			data: rowNode?.data,
			value,
			valueFormatted: ctrl.getValueFormatted?.(),
			hideTooltipCallback: () => this.hideTooltip(true),
			...ctrl.getAdditionalParams?.() ?? {}
		});
		this.state = 2;
		this.tooltipInstanceCount++;
		const callback = this.newTooltipComponentCallback.bind(this, this.tooltipInstanceCount);
		_getTooltipCompDetails(this.userCompFactory, params)?.newAgStackInstance().then(callback);
	}
	hideTooltip(forceHide) {
		if (!forceHide && this.isInteractingWithTooltip) return;
		if (this.tooltipComp) {
			this.destroyTooltipComp();
			lastTooltipHideTime = Date.now();
		}
		this.eventSvc.dispatchEvent({
			type: "tooltipHide",
			parentGui: this.tooltipCtrl.getGui()
		});
		if (forceHide) this.isInteractingWithTooltip = false;
		this.setToDoNothing(true);
	}
	newTooltipComponentCallback(tooltipInstanceCopy, tooltipComp) {
		if (this.state !== 2 || this.tooltipInstanceCount !== tooltipInstanceCopy) {
			this.destroyBean(tooltipComp);
			return;
		}
		const eGui = tooltipComp.getGui();
		this.tooltipComp = tooltipComp;
		if (!eGui.classList.contains("ag-tooltip")) eGui.classList.add("ag-tooltip-custom");
		if (this.tooltipTrigger === 0) eGui.classList.add("ag-tooltip-animate");
		if (this.interactionEnabled) eGui.classList.add("ag-tooltip-interactive");
		const translate = this.getLocaleTextFunc();
		const addPopupRes = this.popupSvc?.addPopup({
			eChild: eGui,
			ariaLabel: translate("ariaLabelTooltip", "Tooltip")
		});
		if (addPopupRes) this.tooltipPopupDestroyFunc = addPopupRes.hideFunc;
		this.positionTooltip();
		if (this.tooltipTrigger === 1) {
			const listener = () => this.setToDoNothing();
			[this.onBodyScrollEventCallback, this.onColumnMovedEventCallback] = this.addManagedEventListeners({
				bodyScroll: listener,
				columnMoved: listener
			});
		}
		if (this.interactionEnabled) {
			[this.tooltipMouseEnterListener, this.tooltipMouseLeaveListener] = this.addManagedElementListeners(eGui, {
				mouseenter: this.onTooltipMouseEnter.bind(this),
				mouseleave: this.onTooltipMouseLeave.bind(this)
			});
			[this.onDocumentKeyDownCallback] = this.addManagedElementListeners(_getDocument(this.beans), { keydown: (e) => {
				if (!eGui.contains(e?.target)) this.onKeyDown();
			} });
			if (this.tooltipTrigger === 1) [this.tooltipFocusInListener, this.tooltipFocusOutListener] = this.addManagedElementListeners(eGui, {
				focusin: this.onTooltipFocusIn.bind(this),
				focusout: this.onTooltipFocusOut.bind(this)
			});
		}
		this.eventSvc.dispatchEvent({
			type: "tooltipShow",
			tooltipGui: eGui,
			parentGui: this.tooltipCtrl.getGui()
		});
		this.startHideTimeout();
	}
	onTooltipMouseEnter() {
		this.isInteractingWithTooltip = true;
		this.unlockService();
	}
	onTooltipMouseLeave() {
		if (this.isTooltipFocused()) return;
		this.isInteractingWithTooltip = false;
		this.lockService();
	}
	onTooltipFocusIn() {
		this.isInteractingWithTooltip = true;
	}
	isTooltipFocused() {
		const tooltipGui = this.tooltipComp?.getGui();
		const activeEl = _getActiveDomElement(this.beans);
		return !!tooltipGui && tooltipGui.contains(activeEl);
	}
	onTooltipFocusOut(e) {
		const parentGui = this.tooltipCtrl.getGui();
		if (this.isTooltipFocused()) return;
		this.isInteractingWithTooltip = false;
		if (parentGui.contains(e.relatedTarget)) this.startHideTimeout();
		else this.hideTooltip();
	}
	positionTooltip() {
		const params = {
			type: "tooltip",
			ePopup: this.tooltipComp.getGui(),
			nudgeY: 18,
			skipObserver: this.tooltipMouseTrack
		};
		if (this.lastMouseEvent) this.popupSvc?.positionPopupUnderMouseEvent({
			...params,
			mouseEvent: this.lastMouseEvent
		});
		else this.popupSvc?.positionPopupByComponent({
			...params,
			eventSource: this.tooltipCtrl.getGui(),
			position: "under",
			keepWithinBounds: true,
			nudgeY: 5
		});
	}
	destroyTooltipComp() {
		this.tooltipComp.getGui().classList.add("ag-tooltip-hiding");
		const tooltipPopupDestroyFunc = this.tooltipPopupDestroyFunc;
		const tooltipComp = this.tooltipComp;
		const delay = this.tooltipTrigger === 0 ? FADE_OUT_TOOLTIP_TIMEOUT : 0;
		window.setTimeout(() => {
			tooltipPopupDestroyFunc();
			this.destroyBean(tooltipComp);
		}, delay);
		this.clearTooltipListeners();
		this.tooltipPopupDestroyFunc = void 0;
		this.tooltipComp = void 0;
	}
	clearTooltipListeners() {
		[
			this.tooltipMouseEnterListener,
			this.tooltipMouseLeaveListener,
			this.tooltipFocusInListener,
			this.tooltipFocusOutListener
		].forEach((listener) => {
			if (listener) listener();
		});
		this.tooltipMouseEnterListener = this.tooltipMouseLeaveListener = this.tooltipFocusInListener = this.tooltipFocusOutListener = null;
	}
	lockService() {
		isLocked = true;
		this.interactiveTooltipTimeoutId = window.setTimeout(() => {
			this.unlockService();
			this.setToDoNothing();
		}, INTERACTIVE_HIDE_DELAY);
	}
	unlockService() {
		isLocked = false;
		this.clearInteractiveTimeout();
	}
	startHideTimeout() {
		this.clearHideTimeout();
		this.hideTooltipTimeoutId = window.setTimeout(this.hideTooltip.bind(this), this.getTooltipDelay("hide"));
	}
	clearShowTimeout() {
		if (!this.showTooltipTimeoutId) return;
		window.clearTimeout(this.showTooltipTimeoutId);
		this.showTooltipTimeoutId = void 0;
	}
	clearHideTimeout() {
		if (!this.hideTooltipTimeoutId) return;
		window.clearTimeout(this.hideTooltipTimeoutId);
		this.hideTooltipTimeoutId = void 0;
	}
	clearInteractiveTimeout() {
		if (!this.interactiveTooltipTimeoutId) return;
		window.clearTimeout(this.interactiveTooltipTimeoutId);
		this.interactiveTooltipTimeoutId = void 0;
	}
	clearTimeouts() {
		this.clearShowTimeout();
		this.clearHideTimeout();
		this.clearInteractiveTimeout();
	}
};
function _isShowTooltipWhenTruncated(gos) {
	return gos.get("tooltipShowMode") === "whenTruncated";
}
var TooltipFeature = class extends BeanStub {
	constructor(ctrl, beans) {
		super();
		this.ctrl = ctrl;
		if (beans) this.beans = beans;
	}
	postConstruct() {
		this.refreshTooltip();
	}
	setBrowserTooltip(tooltip, allowEmptyString) {
		const name = "title";
		const eGui = this.ctrl.getGui();
		if (!eGui) return;
		if (tooltip != null && (tooltip != "" || allowEmptyString)) eGui.setAttribute(name, tooltip);
		else eGui.removeAttribute(name);
	}
	updateTooltipText() {
		const { getTooltipValue } = this.ctrl;
		if (getTooltipValue) this.tooltip = getTooltipValue();
	}
	createTooltipFeatureIfNeeded() {
		if (this.tooltipManager == null) this.tooltipManager = this.createBean(new TooltipStateManager(this.ctrl, () => this.tooltip), this.beans.context);
	}
	setTooltipAndRefresh(tooltip) {
		this.tooltip = tooltip;
		this.refreshTooltip();
	}
	refreshTooltip(clearWithEmptyString) {
		this.browserTooltips = this.beans.gos.get("enableBrowserTooltips");
		this.updateTooltipText();
		if (this.browserTooltips) {
			this.setBrowserTooltip(this.tooltip);
			this.tooltipManager = this.destroyBean(this.tooltipManager, this.beans.context);
		} else {
			this.setBrowserTooltip(clearWithEmptyString ? "" : null, clearWithEmptyString);
			this.createTooltipFeatureIfNeeded();
		}
	}
	destroy() {
		this.tooltipManager = this.destroyBean(this.tooltipManager, this.beans.context);
		super.destroy();
	}
};
var INITIAL_GRID_OPTION_KEYS = {
	enableBrowserTooltips: true,
	tooltipTrigger: true,
	tooltipMouseTrack: true,
	tooltipShowMode: true,
	tooltipInteraction: true,
	defaultColGroupDef: true,
	suppressAutoSize: true,
	skipHeaderOnAutoSize: true,
	autoSizeStrategy: true,
	components: true,
	stopEditingWhenCellsLoseFocus: true,
	undoRedoCellEditing: true,
	undoRedoCellEditingLimit: true,
	excelStyles: true,
	cacheQuickFilter: true,
	customChartThemes: true,
	chartThemeOverrides: true,
	chartToolPanelsDef: true,
	loadingCellRendererSelector: true,
	localeText: true,
	keepDetailRows: true,
	keepDetailRowsCount: true,
	detailRowHeight: true,
	detailRowAutoHeight: true,
	tabIndex: true,
	valueCache: true,
	valueCacheNeverExpires: true,
	enableCellExpressions: true,
	suppressTouch: true,
	suppressBrowserResizeObserver: true,
	suppressPropertyNamesCheck: true,
	debug: true,
	dragAndDropImageComponent: true,
	loadingOverlayComponent: true,
	suppressLoadingOverlay: true,
	noRowsOverlayComponent: true,
	paginationPageSizeSelector: true,
	paginateChildRows: true,
	pivotPanelShow: true,
	pivotSuppressAutoColumn: true,
	suppressExpandablePivotGroups: true,
	aggFuncs: true,
	allowShowChangeAfterFilter: true,
	ensureDomOrder: true,
	enableRtl: true,
	suppressColumnVirtualisation: true,
	suppressMaxRenderedRowRestriction: true,
	suppressRowVirtualisation: true,
	rowDragText: true,
	groupLockGroupColumns: true,
	suppressGroupRowsSticky: true,
	rowModelType: true,
	cacheOverflowSize: true,
	infiniteInitialRowCount: true,
	serverSideInitialRowCount: true,
	maxBlocksInCache: true,
	maxConcurrentDatasourceRequests: true,
	blockLoadDebounceMillis: true,
	serverSideOnlyRefreshFilteredGroups: true,
	serverSidePivotResultFieldSeparator: true,
	viewportRowModelPageSize: true,
	viewportRowModelBufferSize: true,
	debounceVerticalScrollbar: true,
	suppressAnimationFrame: true,
	suppressPreventDefaultOnMouseWheel: true,
	scrollbarWidth: true,
	icons: true,
	suppressRowTransform: true,
	gridId: true,
	enableGroupEdit: true,
	initialState: true,
	processUnpinnedColumns: true,
	createChartContainer: true,
	getLocaleText: true,
	getRowId: true,
	reactiveCustomComponents: true,
	renderingMode: true,
	columnMenu: true,
	suppressSetFilterByDefault: true,
	getDataPath: true,
	enableCellSpan: true,
	enableFilterHandlers: true,
	filterHandlers: true
};
var clientSide = "clientSide";
var serverSide = "serverSide";
var infinite = "infinite";
var functionRowModels = {
	onGroupExpandedOrCollapsed: [clientSide],
	refreshClientSideRowModel: [clientSide],
	isRowDataEmpty: [clientSide],
	forEachLeafNode: [clientSide],
	forEachNodeAfterFilter: [clientSide],
	forEachNodeAfterFilterAndSort: [clientSide],
	resetRowHeights: [clientSide],
	applyTransaction: [clientSide],
	applyTransactionAsync: [clientSide],
	flushAsyncTransactions: [clientSide],
	getBestCostNodeSelection: [clientSide],
	getServerSideSelectionState: [serverSide],
	setServerSideSelectionState: [serverSide],
	applyServerSideTransaction: [serverSide],
	applyServerSideTransactionAsync: [serverSide],
	applyServerSideRowData: [serverSide],
	retryServerSideLoads: [serverSide],
	flushServerSideAsyncTransactions: [serverSide],
	refreshServerSide: [serverSide],
	getServerSideGroupLevelState: [serverSide],
	refreshInfiniteCache: [infinite],
	purgeInfiniteCache: [infinite],
	getInfiniteRowCount: [infinite],
	isLastRowIndexKnown: [infinite, serverSide],
	expandAll: [clientSide, serverSide],
	collapseAll: [clientSide, serverSide],
	onRowHeightChanged: [clientSide, serverSide],
	setRowCount: [infinite, serverSide],
	getCacheBlockState: [infinite, serverSide]
};
var deprecatedFunctions = {
	showLoadingOverlay: {
		version: "v32",
		message: "`showLoadingOverlay` is deprecated. Use the grid option \"loading\"=true instead or setGridOption(\"loading\", true)."
	},
	clearRangeSelection: {
		version: "v32.2",
		message: "Use `clearCellSelection` instead."
	},
	getInfiniteRowCount: {
		version: "v32.2",
		old: "getInfiniteRowCount()",
		new: "getDisplayedRowCount()"
	},
	selectAllFiltered: {
		version: "v33",
		old: "selectAllFiltered()",
		new: "selectAll(\"filtered\")"
	},
	deselectAllFiltered: {
		version: "v33",
		old: "deselectAllFiltered()",
		new: "deselectAll(\"filtered\")"
	},
	selectAllOnCurrentPage: {
		version: "v33",
		old: "selectAllOnCurrentPage()",
		new: "selectAll(\"currentPage\")"
	},
	deselectAllOnCurrentPage: {
		version: "v33",
		old: "deselectAllOnCurrentPage()",
		new: "deselectAll(\"currentPage\")"
	}
};
function validateApiFunction(functionName, apiFunction, beans) {
	const deprecation = deprecatedFunctions[functionName];
	if (deprecation) {
		const { version, new: replacement, old, message } = deprecation;
		const apiMethod = old ?? functionName;
		return (...args) => {
			_warnOnce(`Since ${version} api.${apiMethod} is deprecated. ${replacement ? `Please use ${replacement} instead. ` : ""}${message ?? ""}`);
			return apiFunction.apply(apiFunction, args);
		};
	}
	const rowModels = functionRowModels[functionName];
	if (rowModels) return (...args) => {
		const rowModel = beans.rowModel.getType();
		if (!rowModels.includes(rowModel)) {
			_errorOnce(`api.${functionName} can only be called when gridOptions.rowModelType is ${rowModels.join(" or ")}`);
			return;
		}
		return apiFunction.apply(apiFunction, args);
	};
	return apiFunction;
}
var DYNAMIC_BEAN_MODULES = {
	detailCellRendererCtrl: "SharedMasterDetail",
	dndSourceComp: "DragAndDrop",
	fillHandle: "CellSelection",
	groupCellRendererCtrl: "GroupCellRenderer",
	headerFilterCellCtrl: "ColumnFilter",
	headerGroupCellCtrl: "ColumnGroup",
	rangeHandle: "CellSelection",
	tooltipFeature: "Tooltip",
	groupStrategy: "RowGrouping",
	treeGroupStrategy: "TreeData",
	rowNumberRowResizer: "RowNumbers",
	singleCell: "EditCore",
	fullRow: "EditCore",
	agSetColumnFilterHandler: "SetFilter",
	agMultiColumnFilterHandler: "MultiFilter",
	agGroupColumnFilterHandler: "GroupFilter",
	agNumberColumnFilterHandler: "NumberFilter",
	agDateColumnFilterHandler: "DateFilter",
	agTextColumnFilterHandler: "TextFilter"
};
var ICON_VALUES = {
	expanded: 1,
	contracted: 1,
	"tree-closed": 1,
	"tree-open": 1,
	"tree-indeterminate": 1,
	pin: 1,
	"eye-slash": 1,
	arrows: 1,
	left: 1,
	right: 1,
	group: 1,
	aggregation: 1,
	pivot: 1,
	"not-allowed": 1,
	chart: 1,
	cross: 1,
	cancel: 1,
	tick: 1,
	first: 1,
	previous: 1,
	next: 1,
	last: 1,
	linked: 1,
	unlinked: 1,
	"color-picker": 1,
	loading: 1,
	menu: 1,
	"menu-alt": 1,
	filter: 1,
	"filter-add": 1,
	columns: 1,
	maximize: 1,
	minimize: 1,
	copy: 1,
	cut: 1,
	paste: 1,
	grip: 1,
	save: 1,
	csv: 1,
	excel: 1,
	"small-down": 1,
	"small-left": 1,
	"small-right": 1,
	"small-up": 1,
	asc: 1,
	desc: 1,
	none: 1,
	up: 1,
	down: 1,
	plus: 1,
	minus: 1,
	settings: 1,
	"checkbox-checked": 1,
	"checkbox-indeterminate": 1,
	"checkbox-unchecked": 1,
	"radio-button-on": 1,
	"radio-button-off": 1,
	eye: 1,
	"column-arrow": 1,
	"un-pin": 1,
	"pinned-top": 1,
	"pinned-bottom": 1,
	"chevron-up": 1,
	"chevron-down": 1,
	"chevron-left": 1,
	"chevron-right": 1,
	edit: 1
};
var ICON_MODULES = {
	chart: "MenuCore",
	cancel: "EnterpriseCore",
	first: "Pagination",
	previous: "Pagination",
	next: "Pagination",
	last: "Pagination",
	linked: "IntegratedCharts",
	loadingMenuItems: "MenuCore",
	unlinked: "IntegratedCharts",
	menu: "ColumnHeaderComp",
	legacyMenu: "ColumnMenu",
	filter: "ColumnFilter",
	filterActive: "ColumnFilter",
	filterAdd: "NewFiltersToolPanel",
	filterCardCollapse: "NewFiltersToolPanel",
	filterCardExpand: "NewFiltersToolPanel",
	filterCardEditing: "NewFiltersToolPanel",
	filterTab: "ColumnMenu",
	filtersToolPanel: "FiltersToolPanel",
	columns: ["MenuCore"],
	columnsToolPanel: ["ColumnsToolPanel"],
	maximize: "EnterpriseCore",
	minimize: "EnterpriseCore",
	save: "MenuCore",
	columnGroupOpened: "ColumnGroupHeaderComp",
	columnGroupClosed: "ColumnGroupHeaderComp",
	accordionOpen: "EnterpriseCore",
	accordionClosed: "EnterpriseCore",
	accordionIndeterminate: "EnterpriseCore",
	columnSelectClosed: ["ColumnsToolPanel", "ColumnMenu"],
	columnSelectOpen: ["ColumnsToolPanel", "ColumnMenu"],
	columnSelectIndeterminate: ["ColumnsToolPanel", "ColumnMenu"],
	columnMovePin: "SharedDragAndDrop",
	columnMoveHide: "SharedDragAndDrop",
	columnMoveMove: "SharedDragAndDrop",
	columnMoveLeft: "SharedDragAndDrop",
	columnMoveRight: "SharedDragAndDrop",
	columnMoveGroup: "SharedDragAndDrop",
	columnMoveValue: "SharedDragAndDrop",
	columnMovePivot: "SharedDragAndDrop",
	dropNotAllowed: "SharedDragAndDrop",
	ensureColumnVisible: ["ColumnsToolPanel", "ColumnMenu"],
	groupContracted: "GroupCellRenderer",
	groupExpanded: "GroupCellRenderer",
	setFilterGroupClosed: "SetFilter",
	setFilterGroupOpen: "SetFilter",
	setFilterGroupIndeterminate: "SetFilter",
	setFilterLoading: "SetFilter",
	close: "EnterpriseCore",
	check: "MenuItem",
	colorPicker: "CommunityCore",
	groupLoading: "LoadingCellRenderer",
	menuAlt: "ColumnHeaderComp",
	menuPin: "MenuCore",
	menuValue: "MenuCore",
	menuAddRowGroup: ["MenuCore", "ColumnsToolPanel"],
	menuRemoveRowGroup: ["MenuCore", "ColumnsToolPanel"],
	clipboardCopy: "MenuCore",
	clipboardCut: "MenuCore",
	clipboardPaste: "MenuCore",
	pivotPanel: ["ColumnsToolPanel", "RowGroupingPanel"],
	rowGroupPanel: ["ColumnsToolPanel", "RowGroupingPanel"],
	valuePanel: "ColumnsToolPanel",
	columnDrag: "EnterpriseCore",
	rowDrag: ["RowDrag", "DragAndDrop"],
	csvExport: "MenuCore",
	excelExport: "MenuCore",
	smallDown: "CommunityCore",
	selectOpen: "CommunityCore",
	richSelectOpen: "RichSelect",
	richSelectRemove: "RichSelect",
	smallLeft: "CommunityCore",
	smallRight: "CommunityCore",
	subMenuOpen: "MenuItem",
	subMenuOpenRtl: "MenuItem",
	panelDelimiter: "RowGroupingPanel",
	panelDelimiterRtl: "RowGroupingPanel",
	smallUp: "CommunityCore",
	sortAscending: ["MenuCore", "Sort"],
	sortDescending: ["MenuCore", "Sort"],
	sortUnSort: ["MenuCore", "Sort"],
	advancedFilterBuilder: "AdvancedFilter",
	advancedFilterBuilderDrag: "AdvancedFilter",
	advancedFilterBuilderInvalid: "AdvancedFilter",
	advancedFilterBuilderMoveUp: "AdvancedFilter",
	advancedFilterBuilderMoveDown: "AdvancedFilter",
	advancedFilterBuilderAdd: "AdvancedFilter",
	advancedFilterBuilderRemove: "AdvancedFilter",
	advancedFilterBuilderSelectOpen: "AdvancedFilter",
	chartsMenu: "IntegratedCharts",
	chartsMenuEdit: "IntegratedCharts",
	chartsMenuAdvancedSettings: "IntegratedCharts",
	chartsMenuAdd: "IntegratedCharts",
	chartsColorPicker: "IntegratedCharts",
	chartsThemePrevious: "IntegratedCharts",
	chartsThemeNext: "IntegratedCharts",
	chartsDownload: "IntegratedCharts",
	checkboxChecked: "CommunityCore",
	checkboxIndeterminate: "CommunityCore",
	checkboxUnchecked: "CommunityCore",
	radioButtonOn: "CommunityCore",
	radioButtonOff: "CommunityCore",
	rowPin: "PinnedRow",
	rowUnpin: "PinnedRow",
	rowPinBottom: "PinnedRow",
	rowPinTop: "PinnedRow"
};
var DEPRECATED_ICONS_V33 = /* @__PURE__ */ new Set([
	"colorPicker",
	"smallUp",
	"checkboxChecked",
	"checkboxIndeterminate",
	"checkboxUnchecked",
	"radioButtonOn",
	"radioButtonOff",
	"smallDown",
	"smallLeft",
	"smallRight"
]);
var ValidationService = class extends BeanStub {
	constructor() {
		super(...arguments);
		this.beanName = "validation";
	}
	wireBeans(beans) {
		this.gridOptions = beans.gridOptions;
		provideValidationServiceLogger(this);
	}
	warnOnInitialPropertyUpdate(source, key) {
		if (source === "api" && INITIAL_GRID_OPTION_KEYS[key]) _warn(22, { key });
	}
	processGridOptions(options) {
		this.processOptions(options, GRID_OPTIONS_VALIDATORS());
	}
	validateApiFunction(functionName, apiFunction) {
		return validateApiFunction(functionName, apiFunction, this.beans);
	}
	missingUserComponent(propertyName, componentName, agGridDefaults, jsComps) {
		const moduleForComponent = USER_COMP_MODULES[componentName];
		if (moduleForComponent) this.gos.assertModuleRegistered(moduleForComponent, `AG Grid '${propertyName}' component: ${componentName}`);
		else _warn(101, {
			propertyName,
			componentName,
			agGridDefaults,
			jsComps
		});
	}
	missingDynamicBean(beanName) {
		const moduleName = DYNAMIC_BEAN_MODULES[beanName];
		return moduleName ? _errMsg(200, {
			...this.gos.getModuleErrorParams(),
			moduleName,
			reasonOrId: beanName
		}) : void 0;
	}
	checkRowEvents(eventType) {
		if (DEPRECATED_ROW_NODE_EVENTS.has(eventType)) _warn(10, { eventType });
	}
	validateIcon(iconName) {
		if (DEPRECATED_ICONS_V33.has(iconName)) _warn(43, { iconName });
		if (ICON_VALUES[iconName]) return;
		const moduleName = ICON_MODULES[iconName];
		if (moduleName) {
			_error(200, {
				reasonOrId: `icon '${iconName}'`,
				moduleName,
				gridScoped: _areModulesGridScoped(),
				gridId: this.beans.context.getGridId(),
				rowModelType: this.gos.get("rowModelType"),
				additionalText: "Alternatively, use the CSS icon name directly."
			});
			return;
		}
		_warn(134, { iconName });
	}
	isProvidedUserComp(compName) {
		return !!USER_COMP_MODULES[compName];
	}
	validateColDef(colDef) {
		this.processOptions(colDef, COL_DEF_VALIDATORS());
	}
	processOptions(options, validator) {
		const { validations, deprecations, allProperties, propertyExceptions, objectName, docsUrl } = validator;
		if (allProperties && this.gridOptions.suppressPropertyNamesCheck !== true) this.checkProperties(options, [...propertyExceptions ?? [], ...Object.keys(deprecations)], allProperties, objectName, docsUrl);
		const warnings = /* @__PURE__ */ new Set();
		Object.keys(options).forEach((key) => {
			const deprecation = deprecations[key];
			if (deprecation) {
				const { message, version } = deprecation;
				warnings.add(`As of v${version}, ${String(key)} is deprecated. ${message ?? ""}`);
			}
			const value = options[key];
			if (value == null || value === false) return;
			const rules = validations[key];
			if (!rules) return;
			const { dependencies, validate, supportedRowModels, expectedType } = rules;
			if (expectedType) {
				const actualType = typeof value;
				if (actualType !== expectedType) {
					warnings.add(`${String(key)} should be of type '${expectedType}' but received '${actualType}' (${value}).`);
					return;
				}
			}
			if (supportedRowModels) {
				const rowModel = this.gridOptions.rowModelType ?? "clientSide";
				if (!supportedRowModels.includes(rowModel)) {
					warnings.add(`${String(key)} is not supported with the '${rowModel}' row model. It is only valid with: ${supportedRowModels.join(", ")}.`);
					return;
				}
			}
			if (dependencies) {
				const warning = this.checkForRequiredDependencies(key, dependencies, options);
				if (warning) {
					warnings.add(warning);
					return;
				}
			}
			if (validate) {
				const warning = validate(options, this.gridOptions, this.beans);
				if (warning) {
					warnings.add(warning);
					return;
				}
			}
		});
		if (warnings.size > 0) warnings.forEach((warning) => {
			_warnOnce(warning);
		});
	}
	checkForRequiredDependencies(key, validator, options) {
		const failedOptions = Object.entries(validator).filter(([key2, value]) => {
			const gridOptionValue = options[key2];
			return !value.required.includes(gridOptionValue);
		});
		if (failedOptions.length === 0) return null;
		return failedOptions.map(([failedKey, possibleOptions]) => `'${String(key)}' requires '${failedKey}' to be one of [${possibleOptions.required.map((o) => {
			if (o === null) return "null";
			else if (o === void 0) return "undefined";
			return o;
		}).join(", ")}]. ${possibleOptions.reason ?? ""}`).join("\n           ");
	}
	checkProperties(object, exceptions, validProperties, containerName, docsUrl) {
		const invalidProperties = _fuzzyCheckStrings(Object.getOwnPropertyNames(object), [
			...[
				"__ob__",
				"__v_skip",
				"__metadata__"
			],
			...exceptions,
			...validProperties
		], validProperties);
		const invalidPropertiesKeys = Object.keys(invalidProperties);
		for (const key of invalidPropertiesKeys) {
			let message = `invalid ${containerName} property '${key}' did you mean any of these: ${invalidProperties[key].slice(0, 8).join(", ")}.`;
			if (validProperties.includes("context")) message += `
If you are trying to annotate ${containerName} with application data, use the '${containerName}.context' property instead.`;
			_warnOnce(message);
		}
		if (invalidPropertiesKeys.length > 0 && docsUrl) _warnOnce(`to see all the valid ${containerName} properties please check: ${this.beans.frameworkOverrides.getDocLink(docsUrl)}`);
	}
	getConsoleMessage(id, args) {
		return getError(id, args);
	}
};
function _fuzzyCheckStrings(inputValues, validValues, allSuggestions) {
	const fuzzyMatches = {};
	const invalidInputs = inputValues.filter((inputValue) => !validValues.some((validValue) => validValue === inputValue));
	if (invalidInputs.length > 0) invalidInputs.forEach((invalidInput) => fuzzyMatches[invalidInput] = _fuzzySuggestions({
		inputValue: invalidInput,
		allSuggestions
	}).values);
	return fuzzyMatches;
}
var DEPRECATED_ROW_NODE_EVENTS = /* @__PURE__ */ new Set([
	"firstChildChanged",
	"lastChildChanged",
	"childIndexChanged"
]);
var ValidationModule = {
	moduleName: "Validation",
	version: VERSION,
	beans: [ValidationService]
};
function updateRowNodeAfterFilter(rowNode) {
	if (rowNode.sibling) rowNode.sibling.childrenAfterFilter = rowNode.childrenAfterFilter;
}
var FilterStage = class extends BeanStub {
	constructor() {
		super(...arguments);
		this.beanName = "filterStage";
		this.refreshProps = /* @__PURE__ */ new Set(["excludeChildrenWhenTreeDataFiltering"]);
		this.step = "filter";
	}
	wireBeans(beans) {
		this.filterManager = beans.filterManager;
	}
	execute(params) {
		const { changedPath } = params;
		this.filter(changedPath);
	}
	filter(changedPath) {
		const filterActive = !!this.filterManager?.isChildFilterPresent();
		this.filterNodes(filterActive, changedPath);
	}
	filterNodes(filterActive, changedPath) {
		const filterCallback = (rowNode, includeChildNodes) => {
			if (rowNode.hasChildren()) if (filterActive && !includeChildNodes) rowNode.childrenAfterFilter = rowNode.childrenAfterGroup.filter((childNode) => {
				const passBecauseChildren = childNode.childrenAfterFilter && childNode.childrenAfterFilter.length > 0;
				const passBecauseDataPasses = childNode.data && this.filterManager.doesRowPassFilter({ rowNode: childNode });
				return passBecauseChildren || passBecauseDataPasses;
			});
			else rowNode.childrenAfterFilter = rowNode.childrenAfterGroup;
			else rowNode.childrenAfterFilter = rowNode.childrenAfterGroup;
			updateRowNodeAfterFilter(rowNode);
		};
		if (this.doingTreeDataFiltering()) {
			const treeDataDepthFirstFilter = (rowNode, alreadyFoundInParent) => {
				if (rowNode.childrenAfterGroup) for (let i = 0; i < rowNode.childrenAfterGroup.length; i++) {
					const childNode = rowNode.childrenAfterGroup[i];
					const foundInParent = alreadyFoundInParent || this.filterManager.doesRowPassFilter({ rowNode: childNode });
					if (childNode.childrenAfterGroup) treeDataDepthFirstFilter(rowNode.childrenAfterGroup[i], foundInParent);
					else filterCallback(childNode, foundInParent);
				}
				filterCallback(rowNode, alreadyFoundInParent);
			};
			const treeDataFilterCallback = (rowNode) => treeDataDepthFirstFilter(rowNode, false);
			changedPath.executeFromRootNode(treeDataFilterCallback);
		} else {
			const defaultFilterCallback = (rowNode) => filterCallback(rowNode, false);
			changedPath.forEachChangedNodeDepthFirst(defaultFilterCallback, true);
		}
	}
	doingTreeDataFiltering() {
		return this.gos.get("treeData") && !this.gos.get("excludeChildrenWhenTreeDataFiltering");
	}
};
var HeaderFilterCellCtrl = class extends AbstractHeaderCellCtrl {
	constructor() {
		super(...arguments);
		this.iconCreated = false;
	}
	setComp(comp, eGui, eButtonShowMainFilter, eFloatingFilterBody, compBeanInput) {
		this.comp = comp;
		const compBean = setupCompBean(this, this.beans.context, compBeanInput);
		this.eButtonShowMainFilter = eButtonShowMainFilter;
		this.eFloatingFilterBody = eFloatingFilterBody;
		this.setGui(eGui, compBean);
		this.setupActive();
		this.refreshHeaderStyles();
		this.setupWidth(compBean);
		this.setupLeft(compBean);
		this.setupHover(compBean);
		this.setupFocus(compBean);
		this.setupAria();
		this.setupFilterButton();
		this.setupUserComp();
		this.setupSyncWithFilter(compBean);
		this.setupUi();
		compBean.addManagedElementListeners(this.eButtonShowMainFilter, { click: this.showParentFilter.bind(this) });
		this.setupFilterChangedListener(compBean);
		const colDefChanged = () => this.onColDefChanged(compBean);
		compBean.addManagedListeners(this.column, { colDefChanged });
		compBean.addManagedEventListeners({ filterSwitched: ({ column }) => {
			if (column === this.column) colDefChanged();
		} });
		compBean.addDestroyFunc(() => {
			this.eButtonShowMainFilter = null;
			this.eFloatingFilterBody = null;
			this.userCompDetails = null;
			this.clearComponent();
		});
	}
	resizeHeader() {}
	moveHeader() {}
	getHeaderClassParams() {
		const { column, beans } = this;
		const colDef = column.colDef;
		return _addGridCommonParams(beans.gos, {
			colDef,
			column,
			floatingFilter: true
		});
	}
	setupActive() {
		const colDef = this.column.getColDef();
		const filterExists = !!colDef.filter;
		const floatingFilterExists = !!colDef.floatingFilter;
		this.active = filterExists && floatingFilterExists;
	}
	setupUi() {
		this.comp.setButtonWrapperDisplayed(!this.suppressFilterButton && this.active);
		this.comp.addOrRemoveBodyCssClass("ag-floating-filter-full-body", this.suppressFilterButton);
		this.comp.addOrRemoveBodyCssClass("ag-floating-filter-body", !this.suppressFilterButton);
		if (!this.active || this.iconCreated) return;
		const eMenuIcon = _createIconNoSpan("filter", this.beans, this.column);
		if (eMenuIcon) {
			this.iconCreated = true;
			this.eButtonShowMainFilter.appendChild(eMenuIcon);
		}
	}
	setupFocus(compBean) {
		compBean.createManagedBean(new ManagedFocusFeature(this.eGui, {
			shouldStopEventPropagation: this.shouldStopEventPropagation.bind(this),
			onTabKeyDown: this.onTabKeyDown.bind(this),
			handleKeyDown: this.handleKeyDown.bind(this),
			onFocusIn: this.onFocusIn.bind(this)
		}));
	}
	setupAria() {
		const localeTextFunc = this.getLocaleTextFunc();
		_setAriaLabel(this.eButtonShowMainFilter, localeTextFunc("ariaFilterMenuOpen", "Open Filter Menu"));
	}
	onTabKeyDown(e) {
		const { beans } = this;
		if (_getActiveDomElement(beans) === this.eGui) return;
		const nextFocusableEl = _findNextFocusableElement(beans, this.eGui, null, e.shiftKey);
		if (nextFocusableEl) {
			beans.headerNavigation?.scrollToColumn(this.column);
			e.preventDefault();
			nextFocusableEl.focus();
			return;
		}
		const nextFocusableColumn = this.findNextColumnWithFloatingFilter(e.shiftKey);
		if (!nextFocusableColumn) return;
		if (beans.focusSvc.focusHeaderPosition({
			headerPosition: {
				headerRowIndex: this.rowCtrl.rowIndex,
				column: nextFocusableColumn
			},
			event: e
		})) e.preventDefault();
	}
	findNextColumnWithFloatingFilter(backwards) {
		const presentedColsService = this.beans.visibleCols;
		let nextCol = this.column;
		do {
			nextCol = backwards ? presentedColsService.getColBefore(nextCol) : presentedColsService.getColAfter(nextCol);
			if (!nextCol) break;
		} while (!nextCol.getColDef().filter || !nextCol.getColDef().floatingFilter);
		return nextCol;
	}
	handleKeyDown(e) {
		super.handleKeyDown(e);
		const wrapperHasFocus = this.getWrapperHasFocus();
		switch (e.key) {
			case KeyCode.UP:
			case KeyCode.DOWN:
			case KeyCode.LEFT:
			case KeyCode.RIGHT:
				if (wrapperHasFocus) return;
				_stopPropagationForAgGrid(e);
			case KeyCode.ENTER:
				if (wrapperHasFocus) {
					if (_focusInto(this.eGui)) e.preventDefault();
				}
				break;
			case KeyCode.ESCAPE: if (!wrapperHasFocus) this.eGui.focus();
		}
	}
	onFocusIn(e) {
		if (this.eGui.contains(e.relatedTarget)) return;
		const notFromHeaderWrapper = !!e.relatedTarget && !e.relatedTarget.classList.contains("ag-floating-filter");
		const fromWithinHeader = !!e.relatedTarget && _isElementChildOfClass(e.relatedTarget, "ag-floating-filter");
		if (notFromHeaderWrapper && fromWithinHeader && e.target === this.eGui) {
			const lastFocusEvent = this.lastFocusEvent;
			const fromTab = !!(lastFocusEvent && lastFocusEvent.key === KeyCode.TAB);
			if (lastFocusEvent && fromTab) {
				const shouldFocusLast = lastFocusEvent.shiftKey;
				_focusInto(this.eGui, shouldFocusLast);
			}
		}
		this.focusThis();
	}
	setupHover(compBean) {
		this.beans.colHover?.addHeaderFilterColumnHoverListener(compBean, this.comp, this.column, this.eGui);
	}
	setupLeft(compBean) {
		const setLeftFeature = new SetLeftFeature(this.column, this.eGui, this.beans);
		compBean.createManagedBean(setLeftFeature);
	}
	setupFilterButton() {
		this.suppressFilterButton = !this.beans.menuSvc?.isFloatingFilterButtonEnabled(this.column);
		this.highlightFilterButtonWhenActive = !_isLegacyMenuEnabled(this.gos);
	}
	setupUserComp() {
		if (!this.active) return;
		const compDetails = this.beans.colFilter?.getFloatingFilterCompDetails(this.column, () => this.showParentFilter());
		if (compDetails) this.setCompDetails(compDetails);
	}
	setCompDetails(compDetails) {
		this.userCompDetails = compDetails;
		this.comp.setCompDetails(compDetails);
	}
	showParentFilter() {
		const eventSource = this.suppressFilterButton ? this.eFloatingFilterBody : this.eButtonShowMainFilter;
		this.beans.menuSvc?.showFilterMenu({
			column: this.column,
			buttonElement: eventSource,
			containerType: "floatingFilter",
			positionBy: "button"
		});
	}
	setupSyncWithFilter(compBean) {
		if (!this.active) return;
		const { beans: { colFilter }, column, gos } = this;
		const syncWithFilter = (event) => {
			if (event?.source === "filterDestroyed" && (!this.isAlive() || !colFilter?.isAlive())) return;
			const compPromise = this.comp.getFloatingFilterComp();
			if (!compPromise) return;
			compPromise.then((comp) => {
				if (comp) {
					if (gos.get("enableFilterHandlers")) {
						const eventWithParams = event;
						let source = "filter";
						if (eventWithParams?.afterFloatingFilter) source = "ui";
						else if (eventWithParams?.afterDataChange) source = "dataChanged";
						else if (event?.source === "api") source = "api";
						this.updateFloatingFilterParams(this.userCompDetails, source);
						return;
					}
					const parentModel = colFilter?.getCurrentFloatingFilterParentModel(column);
					const filterChangedEvent = event ? {
						...event,
						columns: event.columns ?? [],
						source: event.source === "api" ? "api" : "columnFilter"
					} : null;
					comp.onParentModelChanged(parentModel, filterChangedEvent);
				}
			});
		};
		[this.destroySyncListener] = compBean.addManagedListeners(column, { filterChanged: syncWithFilter });
		if (colFilter?.isFilterActive(column)) syncWithFilter(null);
	}
	setupWidth(compBean) {
		const listener = () => {
			const width = `${this.column.getActualWidth()}px`;
			this.comp.setWidth(width);
		};
		compBean.addManagedListeners(this.column, { widthChanged: listener });
		listener();
	}
	setupFilterChangedListener(compBean) {
		if (this.active) {
			[this.destroyFilterChangedListener] = compBean.addManagedListeners(this.column, { filterChanged: this.updateFilterButton.bind(this) });
			this.updateFilterButton();
		}
	}
	updateFilterButton() {
		if (!this.suppressFilterButton && this.comp) {
			const isFilterAllowed = !!this.beans.filterManager?.isFilterAllowed(this.column);
			this.comp.setButtonWrapperDisplayed(isFilterAllowed);
			if (this.highlightFilterButtonWhenActive && isFilterAllowed) this.eButtonShowMainFilter.classList.toggle("ag-filter-active", this.column.isFilterActive());
		}
	}
	onColDefChanged(compBean) {
		const wasActive = this.active;
		this.setupActive();
		const becomeActive = !wasActive && this.active;
		if (wasActive && !this.active) {
			this.destroySyncListener();
			this.destroyFilterChangedListener();
		}
		const colFilter = this.beans.colFilter;
		const newCompDetails = this.active ? colFilter?.getFloatingFilterCompDetails(this.column, () => this.showParentFilter()) : null;
		const compPromise = this.comp.getFloatingFilterComp();
		if (!compPromise || !newCompDetails) this.updateCompDetails(compBean, newCompDetails, becomeActive);
		else compPromise.then((compInstance) => {
			if (!compInstance || colFilter?.areFilterCompsDifferent(this.userCompDetails ?? null, newCompDetails)) this.updateCompDetails(compBean, newCompDetails, becomeActive);
			else this.updateFloatingFilterParams(newCompDetails, "colDef");
		});
	}
	updateCompDetails(compBean, compDetails, becomeActive) {
		if (!this.isAlive()) return;
		this.setCompDetails(compDetails);
		this.setupFilterButton();
		this.setupUi();
		if (becomeActive) {
			this.setupSyncWithFilter(compBean);
			this.setupFilterChangedListener(compBean);
		}
	}
	updateFloatingFilterParams(userCompDetails, source) {
		if (!userCompDetails) return;
		let params = userCompDetails.params;
		this.comp.getFloatingFilterComp()?.then((floatingFilter) => {
			if (typeof floatingFilter?.refresh === "function") {
				if (this.gos.get("enableFilterHandlers")) params = {
					...params,
					model: _getFilterModel(this.beans.colFilter?.model ?? {}, this.column.getColId()),
					source
				};
				floatingFilter.refresh(params);
			}
		});
	}
	addResizeAndMoveKeyboardListeners() {}
	destroy() {
		super.destroy();
		this.destroySyncListener = null;
		this.destroyFilterChangedListener = null;
	}
};
function showColumnMenu(beans, colKey) {
	const column = beans.colModel.getCol(colKey);
	if (!column) {
		_error(12, { colKey });
		return;
	}
	beans.menuSvc?.showColumnMenu({
		column,
		positionBy: "auto"
	});
}
function hidePopupMenu(beans) {
	beans.menuSvc?.hidePopupMenu();
}
var SharedMenuModule = {
	moduleName: "SharedMenu",
	version: VERSION,
	beans: [MenuService],
	apiFunctions: {
		showColumnMenu,
		hidePopupMenu
	}
};
var instanceIdSeq = 0;
var WAIT_FOR_POPUP_CONTENT_RESIZE = 200;
var PopupService = class extends BeanStub {
	constructor() {
		super(...arguments);
		this.beanName = "popupSvc";
		this.popupList = [];
	}
	postConstruct() {
		this.beans.ctrlsSvc.whenReady(this, (p) => {
			this.gridCtrl = p.gridCtrl;
		});
		this.addManagedEventListeners({ gridStylesChanged: this.handleThemeChange.bind(this) });
	}
	getPopupParent() {
		const ePopupParent = this.gos.get("popupParent");
		if (ePopupParent) return ePopupParent;
		return this.gridCtrl.getGui();
	}
	positionPopupForMenu(params) {
		const { eventSource, ePopup, column, node, event } = params;
		const sourceRect = eventSource.getBoundingClientRect();
		const parentRect = this.getParentRect();
		this.setAlignedTo(eventSource, ePopup);
		let minWidthSet = false;
		const updatePosition = () => {
			const y = this.keepXYWithinBounds(ePopup, sourceRect.top - parentRect.top, 0);
			const minWidth = ePopup.clientWidth > 0 ? ePopup.clientWidth : 200;
			if (!minWidthSet) {
				ePopup.style.minWidth = `${minWidth}px`;
				minWidthSet = true;
			}
			const maxX = parentRect.right - parentRect.left - minWidth;
			let x;
			if (this.gos.get("enableRtl")) {
				x = xLeftPosition();
				if (x < 0) {
					x = xRightPosition();
					this.setAlignedStyles(ePopup, "left");
				}
				if (x > maxX) {
					x = 0;
					this.setAlignedStyles(ePopup, "right");
				}
			} else {
				x = xRightPosition();
				if (x > maxX) {
					x = xLeftPosition();
					this.setAlignedStyles(ePopup, "right");
				}
				if (x < 0) {
					x = 0;
					this.setAlignedStyles(ePopup, "left");
				}
			}
			return {
				x,
				y
			};
			function xRightPosition() {
				return sourceRect.right - parentRect.left - 2;
			}
			function xLeftPosition() {
				return sourceRect.left - parentRect.left - minWidth;
			}
		};
		this.positionPopup({
			ePopup,
			keepWithinBounds: true,
			updatePosition,
			postProcessCallback: () => this.callPostProcessPopup("subMenu", ePopup, eventSource, event instanceof MouseEvent ? event : void 0, column, node)
		});
	}
	positionPopupUnderMouseEvent(params) {
		const { ePopup, nudgeX, nudgeY, skipObserver } = params;
		this.positionPopup({
			ePopup,
			nudgeX,
			nudgeY,
			keepWithinBounds: true,
			skipObserver,
			updatePosition: () => this.calculatePointerAlign(params.mouseEvent),
			postProcessCallback: () => this.callPostProcessPopup(params.type, params.ePopup, null, params.mouseEvent, params.column, params.rowNode)
		});
	}
	calculatePointerAlign(e) {
		const parentRect = this.getParentRect();
		return {
			x: e.clientX - parentRect.left,
			y: e.clientY - parentRect.top
		};
	}
	positionPopupByComponent(params) {
		const { ePopup, nudgeX, nudgeY, keepWithinBounds, eventSource, alignSide = "left", position = "over", column, rowNode, type } = params;
		const sourceRect = eventSource.getBoundingClientRect();
		const parentRect = this.getParentRect();
		this.setAlignedTo(eventSource, ePopup);
		const updatePosition = () => {
			let x = sourceRect.left - parentRect.left;
			if (alignSide === "right") x -= ePopup.offsetWidth - sourceRect.width;
			let y;
			if (position === "over") {
				y = sourceRect.top - parentRect.top;
				this.setAlignedStyles(ePopup, "over");
			} else {
				this.setAlignedStyles(ePopup, "under");
				if (this.shouldRenderUnderOrAbove(ePopup, sourceRect, parentRect, params.nudgeY || 0) === "under") y = sourceRect.top - parentRect.top + sourceRect.height;
				else y = sourceRect.top - ePopup.offsetHeight - (nudgeY || 0) * 2 - parentRect.top;
			}
			return {
				x,
				y
			};
		};
		this.positionPopup({
			ePopup,
			nudgeX,
			nudgeY,
			keepWithinBounds,
			updatePosition,
			postProcessCallback: () => this.callPostProcessPopup(type, ePopup, eventSource, null, column, rowNode)
		});
	}
	shouldRenderUnderOrAbove(ePopup, targetCompRect, parentRect, nudgeY) {
		const spaceAvailableUnder = parentRect.bottom - targetCompRect.bottom;
		const spaceAvailableAbove = targetCompRect.top - parentRect.top;
		const spaceRequired = ePopup.offsetHeight + nudgeY;
		if (spaceAvailableUnder > spaceRequired) return "under";
		if (spaceAvailableAbove > spaceRequired || spaceAvailableAbove > spaceAvailableUnder) return "above";
		return "under";
	}
	setAlignedStyles(ePopup, positioned) {
		const popupIdx = this.getPopupIndex(ePopup);
		if (popupIdx === -1) return;
		const { alignedToElement } = this.popupList[popupIdx];
		if (!alignedToElement) return;
		[
			"right",
			"left",
			"over",
			"above",
			"under"
		].forEach((position) => {
			alignedToElement.classList.remove(`ag-has-popup-positioned-${position}`);
			ePopup.classList.remove(`ag-popup-positioned-${position}`);
		});
		if (!positioned) return;
		alignedToElement.classList.add(`ag-has-popup-positioned-${positioned}`);
		ePopup.classList.add(`ag-popup-positioned-${positioned}`);
	}
	setAlignedTo(eventSource, ePopup) {
		const popupIdx = this.getPopupIndex(ePopup);
		if (popupIdx !== -1) {
			const popup = this.popupList[popupIdx];
			popup.alignedToElement = eventSource;
		}
	}
	callPostProcessPopup(type, ePopup, eventSource, mouseEvent, column, rowNode) {
		const callback = this.gos.getCallback("postProcessPopup");
		if (callback) callback({
			column,
			rowNode,
			ePopup,
			type,
			eventSource,
			mouseEvent
		});
	}
	positionPopup(params) {
		const { ePopup, keepWithinBounds, nudgeX, nudgeY, skipObserver, updatePosition } = params;
		const lastSize = {
			width: 0,
			height: 0
		};
		const updatePopupPosition = (fromResizeObserver = false) => {
			let { x, y } = updatePosition();
			if (fromResizeObserver && ePopup.clientWidth === lastSize.width && ePopup.clientHeight === lastSize.height) return;
			lastSize.width = ePopup.clientWidth;
			lastSize.height = ePopup.clientHeight;
			if (nudgeX) x += nudgeX;
			if (nudgeY) y += nudgeY;
			if (keepWithinBounds) {
				x = this.keepXYWithinBounds(ePopup, x, 1);
				y = this.keepXYWithinBounds(ePopup, y, 0);
			}
			ePopup.style.left = `${x}px`;
			ePopup.style.top = `${y}px`;
			if (params.postProcessCallback) params.postProcessCallback();
		};
		updatePopupPosition();
		if (!skipObserver) {
			const resizeObserverDestroyFunc = _observeResize(this.beans, ePopup, () => updatePopupPosition(true));
			setTimeout(() => resizeObserverDestroyFunc(), WAIT_FOR_POPUP_CONTENT_RESIZE);
		}
	}
	getActivePopups() {
		return this.popupList.map((popup) => popup.element);
	}
	getParentRect() {
		const eDocument = _getDocument(this.beans);
		let popupParent = this.getPopupParent();
		if (popupParent === eDocument.body) popupParent = eDocument.documentElement;
		else if (getComputedStyle(popupParent).position === "static") popupParent = popupParent.offsetParent;
		return _getElementRectWithOffset(popupParent);
	}
	keepXYWithinBounds(ePopup, position, direction) {
		const isVertical = direction === 0;
		const sizeProperty = isVertical ? "clientHeight" : "clientWidth";
		const anchorProperty = isVertical ? "top" : "left";
		const offsetProperty = isVertical ? "height" : "width";
		const scrollPositionProperty = isVertical ? "scrollTop" : "scrollLeft";
		const eDocument = _getDocument(this.beans);
		const docElement = eDocument.documentElement;
		const popupParent = this.getPopupParent();
		const popupRect = ePopup.getBoundingClientRect();
		const parentRect = popupParent.getBoundingClientRect();
		const documentRect = eDocument.documentElement.getBoundingClientRect();
		const isBody = popupParent === eDocument.body;
		const offsetSize = Math.ceil(popupRect[offsetProperty]);
		let sizeOfParent = isBody ? (isVertical ? _getAbsoluteHeight : _getAbsoluteWidth)(docElement) + docElement[scrollPositionProperty] : popupParent[sizeProperty];
		if (isBody) sizeOfParent -= Math.abs(documentRect[anchorProperty] - parentRect[anchorProperty]);
		const max = sizeOfParent - offsetSize;
		return Math.min(Math.max(position, 0), Math.abs(max));
	}
	addPopup(params) {
		const eDocument = _getDocument(this.beans);
		const { eChild, ariaLabel, ariaOwns, alwaysOnTop, positionCallback, anchorToElement } = params;
		if (!eDocument) {
			_warn(122);
			return { hideFunc: () => {} };
		}
		const pos = this.getPopupIndex(eChild);
		if (pos !== -1) return { hideFunc: this.popupList[pos].hideFunc };
		this.initialisePopupPosition(eChild);
		const wrapperEl = this.createPopupWrapper(eChild, !!alwaysOnTop, ariaLabel, ariaOwns);
		const removeListeners = this.addEventListenersToPopup({
			...params,
			wrapperEl
		});
		if (positionCallback) positionCallback();
		this.addPopupToPopupList(eChild, wrapperEl, removeListeners, anchorToElement);
		return { hideFunc: removeListeners };
	}
	initialisePopupPosition(element) {
		const ePopupParentRect = this.getPopupParent().getBoundingClientRect();
		if (!_exists(element.style.top)) element.style.top = `${ePopupParentRect.top * -1}px`;
		if (!_exists(element.style.left)) element.style.left = `${ePopupParentRect.left * -1}px`;
	}
	createPopupWrapper(element, alwaysOnTop, ariaLabel, ariaOwns) {
		const ePopupParent = this.getPopupParent();
		const { environment, gos } = this.beans;
		const eWrapper = _createElement({ tag: "div" });
		environment.applyThemeClasses(eWrapper);
		eWrapper.classList.add("ag-popup");
		element.classList.add(gos.get("enableRtl") ? "ag-rtl" : "ag-ltr", "ag-popup-child");
		if (!element.hasAttribute("role")) _setAriaRole(element, "dialog");
		if (ariaLabel) _setAriaLabel(element, ariaLabel);
		else if (ariaOwns) {
			element.id || (element.id = `popup-component-${instanceIdSeq}`);
			_setAriaOwns(ariaOwns, element.id);
		}
		eWrapper.appendChild(element);
		ePopupParent.appendChild(eWrapper);
		if (alwaysOnTop) this.setAlwaysOnTop(element, true);
		else this.bringPopupToFront(element);
		return eWrapper;
	}
	handleThemeChange(e) {
		if (e.themeChanged) {
			const environment = this.beans.environment;
			for (const popup of this.popupList) environment.applyThemeClasses(popup.wrapper);
		}
	}
	addEventListenersToPopup(params) {
		const beans = this.beans;
		const eDocument = _getDocument(beans);
		const ePopupParent = this.getPopupParent();
		const { wrapperEl, eChild: popupEl, closedCallback, afterGuiAttached, closeOnEsc, modal, ariaOwns } = params;
		let popupHidden = false;
		const hidePopupOnKeyboardEvent = (event) => {
			if (!wrapperEl.contains(_getActiveDomElement(beans))) return;
			if (event.key === KeyCode.ESCAPE && !_isStopPropagationForAgGrid(event)) removeListeners({ keyboardEvent: event });
		};
		const hidePopupOnMouseEvent = (event) => removeListeners({ mouseEvent: event });
		const hidePopupOnTouchEvent = (event) => removeListeners({ touchEvent: event });
		const removeListeners = (popupParams = {}) => {
			const { mouseEvent, touchEvent, keyboardEvent, forceHide } = popupParams;
			if (!forceHide && (this.isEventFromCurrentPopup({
				mouseEvent,
				touchEvent
			}, popupEl) || popupHidden)) return;
			popupHidden = true;
			ePopupParent.removeChild(wrapperEl);
			eDocument.removeEventListener("keydown", hidePopupOnKeyboardEvent);
			eDocument.removeEventListener("mousedown", hidePopupOnMouseEvent);
			eDocument.removeEventListener("touchstart", hidePopupOnTouchEvent);
			eDocument.removeEventListener("contextmenu", hidePopupOnMouseEvent);
			this.eventSvc.removeEventListener("dragStarted", hidePopupOnMouseEvent);
			if (closedCallback) closedCallback(mouseEvent || touchEvent || keyboardEvent);
			this.removePopupFromPopupList(popupEl, ariaOwns);
		};
		if (afterGuiAttached) afterGuiAttached({ hidePopup: removeListeners });
		window.setTimeout(() => {
			if (closeOnEsc) eDocument.addEventListener("keydown", hidePopupOnKeyboardEvent);
			if (modal) {
				eDocument.addEventListener("mousedown", hidePopupOnMouseEvent);
				this.eventSvc.addEventListener("dragStarted", hidePopupOnMouseEvent);
				eDocument.addEventListener("touchstart", hidePopupOnTouchEvent);
				eDocument.addEventListener("contextmenu", hidePopupOnMouseEvent);
			}
		}, 0);
		return removeListeners;
	}
	addPopupToPopupList(element, wrapperEl, removeListeners, anchorToElement) {
		this.popupList.push({
			element,
			wrapper: wrapperEl,
			hideFunc: removeListeners,
			instanceId: instanceIdSeq,
			isAnchored: !!anchorToElement
		});
		if (anchorToElement) this.setPopupPositionRelatedToElement(element, anchorToElement);
		instanceIdSeq = instanceIdSeq + 1;
	}
	getPopupIndex(el) {
		return this.popupList.findIndex((p) => p.element === el);
	}
	setPopupPositionRelatedToElement(popupEl, relativeElement) {
		const popupIndex = this.getPopupIndex(popupEl);
		if (popupIndex === -1) return;
		const popup = this.popupList[popupIndex];
		if (popup.stopAnchoringPromise) popup.stopAnchoringPromise.then((destroyFunc) => destroyFunc && destroyFunc());
		popup.stopAnchoringPromise = void 0;
		popup.isAnchored = false;
		if (!relativeElement) return;
		const destroyPositionTracker = this.keepPopupPositionedRelativeTo({
			element: relativeElement,
			ePopup: popupEl,
			hidePopup: popup.hideFunc
		});
		popup.stopAnchoringPromise = destroyPositionTracker;
		popup.isAnchored = true;
		return destroyPositionTracker;
	}
	removePopupFromPopupList(element, ariaOwns) {
		this.setAlignedStyles(element, null);
		this.setPopupPositionRelatedToElement(element, null);
		if (ariaOwns) _setAriaOwns(ariaOwns, null);
		this.popupList = this.popupList.filter((p) => p.element !== element);
	}
	keepPopupPositionedRelativeTo(params) {
		const eParent = this.getPopupParent();
		const parentRect = eParent.getBoundingClientRect();
		const { element, ePopup } = params;
		const sourceRect = element.getBoundingClientRect();
		const extractFromPixelValue = (pxSize) => parseInt(pxSize.substring(0, pxSize.length - 1), 10);
		const createPosition = (prop, direction) => {
			const initialDiff = parentRect[prop] - sourceRect[prop];
			const initial = extractFromPixelValue(ePopup.style[prop]);
			return {
				initialDiff,
				lastDiff: initialDiff,
				initial,
				last: initial,
				direction
			};
		};
		const topPosition = createPosition("top", 0);
		const leftPosition = createPosition("left", 1);
		const fwOverrides = this.beans.frameworkOverrides;
		return new AgPromise((resolve) => {
			fwOverrides.wrapIncoming(() => {
				fwOverrides.setInterval(() => {
					const pRect = eParent.getBoundingClientRect();
					const sRect = element.getBoundingClientRect();
					if (sRect.top == 0 && sRect.left == 0 && sRect.height == 0 && sRect.width == 0) {
						params.hidePopup();
						return;
					}
					const calculateNewPosition = (position, prop) => {
						const current = extractFromPixelValue(ePopup.style[prop]);
						if (position.last !== current) {
							position.initial = current;
							position.last = current;
						}
						const currentDiff = pRect[prop] - sRect[prop];
						if (currentDiff != position.lastDiff) {
							const newValue = this.keepXYWithinBounds(ePopup, position.initial + position.initialDiff - currentDiff, position.direction);
							ePopup.style[prop] = `${newValue}px`;
							position.last = newValue;
						}
						position.lastDiff = currentDiff;
					};
					calculateNewPosition(topPosition, "top");
					calculateNewPosition(leftPosition, "left");
				}, 200).then((intervalId) => {
					const result = () => {
						if (intervalId != null) window.clearInterval(intervalId);
					};
					resolve(result);
				});
			}, "popupPositioning");
		});
	}
	hasAnchoredPopup() {
		return this.popupList.some((popup) => popup.isAnchored);
	}
	isEventFromCurrentPopup(params, target) {
		const { mouseEvent, touchEvent } = params;
		const event = mouseEvent ? mouseEvent : touchEvent;
		if (!event) return false;
		const indexOfThisChild = this.getPopupIndex(target);
		if (indexOfThisChild === -1) return false;
		for (let i = indexOfThisChild; i < this.popupList.length; i++) {
			const popup = this.popupList[i];
			if (_isElementInEventPath(popup.element, event)) return true;
		}
		return this.isElementWithinCustomPopup(event.target);
	}
	isElementWithinCustomPopup(el) {
		const eDocument = _getDocument(this.beans);
		while (el && el !== eDocument.body) {
			if (el.classList.contains("ag-custom-component-popup") || el.parentElement === null) return true;
			el = el.parentElement;
		}
		return false;
	}
	getWrapper(ePopup) {
		while (!ePopup.classList.contains("ag-popup") && ePopup.parentElement) ePopup = ePopup.parentElement;
		return ePopup.classList.contains("ag-popup") ? ePopup : null;
	}
	setAlwaysOnTop(ePopup, alwaysOnTop) {
		const eWrapper = this.getWrapper(ePopup);
		if (!eWrapper) return;
		eWrapper.classList.toggle("ag-always-on-top", !!alwaysOnTop);
		if (alwaysOnTop) this.bringPopupToFront(eWrapper);
	}
	bringPopupToFront(ePopup) {
		const parent = this.getPopupParent();
		const popupList = Array.prototype.slice.call(parent.querySelectorAll(".ag-popup"));
		const popupLen = popupList.length;
		const eWrapper = this.getWrapper(ePopup);
		if (!eWrapper || popupLen <= 1 || !parent.contains(ePopup)) return;
		const standardPopupList = [];
		const alwaysOnTopList = [];
		for (const popup of popupList) {
			if (popup === eWrapper) continue;
			if (popup.classList.contains("ag-always-on-top")) alwaysOnTopList.push(popup);
			else standardPopupList.push(popup);
		}
		const innerElsScrollMap = [];
		const onTopLength = alwaysOnTopList.length;
		const targetList = eWrapper.classList.contains("ag-always-on-top") || !onTopLength ? [
			...standardPopupList,
			...alwaysOnTopList,
			eWrapper
		] : [
			...standardPopupList,
			eWrapper,
			...alwaysOnTopList
		];
		for (let i = 0; i <= popupLen; i++) {
			const currentPopup = targetList[i];
			if (popupList[i] === targetList[i] || currentPopup === eWrapper) continue;
			currentPopup.querySelectorAll("div").forEach((el) => {
				if (el.scrollTop !== 0) innerElsScrollMap.push([el, el.scrollTop]);
			});
			if (i === 0) parent.insertAdjacentElement("afterbegin", currentPopup);
			else targetList[i - 1].insertAdjacentElement("afterend", currentPopup);
		}
		while (innerElsScrollMap.length) {
			const currentEl = innerElsScrollMap.pop();
			currentEl[0].scrollTop = currentEl[1];
		}
	}
};
var PopupModule = {
	moduleName: "Popup",
	version: VERSION,
	beans: [PopupService]
};
var columnFiltersCSS = `.ag-set-filter{--ag-indentation-level:0}.ag-set-filter-item{align-items:center;display:flex;height:100%}:where(.ag-ltr) .ag-set-filter-item{padding-left:calc(var(--ag-widget-container-horizontal-padding) + var(--ag-indentation-level)*var(--ag-set-filter-indent-size))}:where(.ag-rtl) .ag-set-filter-item{padding-right:calc(var(--ag-widget-container-horizontal-padding) + var(--ag-indentation-level)*var(--ag-set-filter-indent-size))}.ag-set-filter-item-checkbox{display:flex;height:100%;width:100%}.ag-set-filter-group-icons{display:block;>*{cursor:pointer}}:where(.ag-ltr) .ag-set-filter-group-icons{margin-right:var(--ag-widget-container-horizontal-padding)}:where(.ag-rtl) .ag-set-filter-group-icons{margin-left:var(--ag-widget-container-horizontal-padding)}.ag-filter-body-wrapper{display:flex;flex-direction:column}:where(.ag-menu:not(.ag-tabs) .ag-filter) .ag-filter-body-wrapper,:where(.ag-menu:not(.ag-tabs) .ag-filter)>:not(.ag-filter-wrapper){min-width:180px}.ag-filter-filter{flex:1 1 0px}.ag-filter-condition{display:flex;justify-content:center}.ag-floating-filter-body{display:flex;flex:1 1 auto;height:100%;position:relative}.ag-floating-filter-full-body{align-items:center;display:flex;flex:1 1 auto;height:100%;overflow:hidden;width:100%}:where(.ag-floating-filter-full-body)>div{flex:1 1 auto}.ag-floating-filter-input{align-items:center;display:flex;width:100%;>*{flex:1 1 auto}:where(.ag-input-field-input[type=date]),:where(.ag-input-field-input[type=datetime-local]){width:1px}}.ag-floating-filter-button{display:flex;flex:none}.ag-date-floating-filter-wrapper{display:flex}.ag-set-floating-filter-input :where(input)[disabled]{pointer-events:none}.ag-floating-filter-button-button{-webkit-appearance:none;-moz-appearance:none;appearance:none;border:none;height:var(--ag-icon-size);width:var(--ag-icon-size)}.ag-filter-loading{align-items:unset;background-color:var(--ag-chrome-background-color);height:100%;padding:var(--ag-widget-container-vertical-padding) var(--ag-widget-container-horizontal-padding);position:absolute;width:100%;z-index:1;:where(.ag-menu) &{background-color:var(--ag-menu-background-color)}}.ag-filter-separator{border-top:solid var(--ag-border-width) var(--menu-separator-color)}:where(.ag-filter-select) .ag-picker-field-wrapper{width:0}.ag-filter-condition-operator{height:17px}:where(.ag-ltr) .ag-filter-condition-operator-or{margin-left:calc(var(--ag-spacing)*2)}:where(.ag-rtl) .ag-filter-condition-operator-or{margin-right:calc(var(--ag-spacing)*2)}.ag-set-filter-select-all{padding-top:var(--ag-widget-container-vertical-padding)}.ag-filter-no-matches,.ag-set-filter-list{height:calc(var(--ag-list-item-height)*6)}.ag-filter-no-matches{padding:var(--ag-widget-container-vertical-padding) var(--ag-widget-container-horizontal-padding)}.ag-set-filter-tree-list{height:calc(var(--ag-list-item-height)*10)}.ag-set-filter-filter{margin-left:var(--ag-widget-container-horizontal-padding);margin-right:var(--ag-widget-container-horizontal-padding);margin-top:var(--ag-widget-container-vertical-padding)}.ag-filter-to{margin-top:var(--ag-widget-vertical-spacing)}.ag-mini-filter{margin:var(--ag-widget-container-vertical-padding) var(--ag-widget-container-horizontal-padding)}:where(.ag-ltr) .ag-set-filter-add-group-indent{margin-left:calc(var(--ag-icon-size) + var(--ag-widget-container-horizontal-padding))}:where(.ag-rtl) .ag-set-filter-add-group-indent{margin-right:calc(var(--ag-icon-size) + var(--ag-widget-container-horizontal-padding))}:where(.ag-filter-menu) .ag-set-filter-list{min-width:200px}.ag-filter-virtual-list-item:focus-visible{box-shadow:inset var(--ag-focus-shadow)}.ag-filter-apply-panel{display:flex;justify-content:flex-end;overflow:hidden;padding:var(--ag-widget-vertical-spacing) var(--ag-widget-container-horizontal-padding) var(--ag-widget-container-vertical-padding)}.ag-filter-apply-panel-button{line-height:1.5}:where(.ag-ltr) .ag-filter-apply-panel-button{margin-left:calc(var(--ag-spacing)*2)}:where(.ag-rtl) .ag-filter-apply-panel-button{margin-right:calc(var(--ag-spacing)*2)}.ag-simple-filter-body-wrapper{display:flex;flex-direction:column;min-height:calc(var(--ag-list-item-height) + var(--ag-widget-container-vertical-padding) + var(--ag-widget-vertical-spacing));overflow-y:auto;padding:var(--ag-widget-container-vertical-padding) var(--ag-widget-container-horizontal-padding);padding-bottom:calc(var(--ag-widget-container-vertical-padding) - var(--ag-widget-vertical-spacing));&>*{margin-bottom:var(--ag-widget-vertical-spacing)}:where(.ag-resizer-wrapper){margin:0}}.ag-multi-filter-menu-item{margin:var(--ag-spacing) 0}.ag-multi-filter-group-title-bar{background-color:transparent;color:var(--ag-header-text-color);font-weight:500;padding:calc(var(--ag-spacing)*1.5) var(--ag-spacing)}.ag-group-filter-field-select-wrapper{display:flex;flex-direction:column;gap:var(--ag-widget-vertical-spacing);padding:var(--ag-widget-container-vertical-padding) var(--ag-widget-container-horizontal-padding)}`;
function isColumnFilterPresent(beans) {
	const filterManager = beans.filterManager;
	return !!filterManager?.isColumnFilterPresent() || !!filterManager?.isAggregateFilterPresent();
}
function getColumnFilterInstance(beans, key) {
	return beans.filterManager?.getColumnFilterInstance(key) ?? Promise.resolve(void 0);
}
function destroyFilter(beans, key) {
	const column = beans.colModel.getColDefCol(key);
	if (column) return beans.colFilter?.destroyFilter(column, "api");
}
function setFilterModel(beans, model) {
	beans.frameworkOverrides.wrapIncoming(() => beans.filterManager?.setFilterModel(model));
}
function getFilterModel(beans) {
	return beans.filterManager?.getFilterModel() ?? {};
}
function getColumnFilterModel(beans, key, useUnapplied) {
	const { gos, colModel, colFilter } = beans;
	if (useUnapplied && !gos.get("enableFilterHandlers")) {
		_warn(288);
		useUnapplied = false;
	}
	const column = colModel.getColDefCol(key);
	return column ? colFilter?.getModelForColumn(column, useUnapplied) ?? null : null;
}
function setColumnFilterModel(beans, column, model) {
	return beans.filterManager?.setColumnFilterModel(column, model) ?? Promise.resolve();
}
function showColumnFilter(beans, colKey) {
	const column = beans.colModel.getCol(colKey);
	if (!column) {
		_error(12, { colKey });
		return;
	}
	beans.menuSvc?.showFilterMenu({
		column,
		containerType: "columnFilter",
		positionBy: "auto"
	});
}
function hideColumnFilter(beans) {
	beans.menuSvc?.hideFilterMenu();
}
function getColumnFilterHandler(beans, colKey) {
	const column = beans.colModel.getCol(colKey);
	if (!column) {
		_error(12, { colKey });
		return;
	}
	return beans.colFilter?.getHandler(column, true);
}
function doFilterAction(beans, params) {
	const { colModel, colFilter, gos } = beans;
	if (!gos.get("enableFilterHandlers")) {
		_warn(287);
		return;
	}
	const { colId, action } = params;
	if (colId) {
		const column = colModel.getColById(colId);
		if (column) colFilter?.updateModel(column, action);
	} else colFilter?.updateAllModels(action);
}
var DUMMY_HANDLER = { filterHandler: () => ({ doesFilterPass: () => true }) };
var ColumnFilterService = class extends BeanStub {
	constructor() {
		super(...arguments);
		this.beanName = "colFilter";
		this.allColumnFilters = /* @__PURE__ */ new Map();
		this.allColumnListeners = /* @__PURE__ */ new Map();
		this.activeAggregateFilters = [];
		this.activeColumnFilters = [];
		this.processingFilterChange = false;
		this.modelUpdates = [];
		this.columnModelUpdates = [];
		this.state = /* @__PURE__ */ new Map();
		this.handlerMap = { ...FILTER_HANDLER_MAP };
		this.isGlobalButtons = false;
		this.activeFilterComps = /* @__PURE__ */ new Set();
	}
	postConstruct() {
		this.addManagedEventListeners({
			gridColumnsChanged: this.onColumnsChanged.bind(this),
			dataTypesInferred: this.processFilterModelUpdateQueue.bind(this)
		});
		const gos = this.gos;
		const initialFilterModel = { ...gos.get("initialState")?.filter?.filterModel ?? {} };
		this.initialModel = initialFilterModel;
		this.model = { ...initialFilterModel };
		if (!gos.get("enableFilterHandlers")) delete this.handlerMap["agMultiColumnFilter"];
	}
	refreshModel() {
		this.onNewRowsLoaded("rowDataUpdated");
	}
	setModel(model, source = "api") {
		const { colModel, dataTypeSvc, filterManager } = this.beans;
		if (dataTypeSvc?.isPendingInference) {
			this.modelUpdates.push({
				model,
				source
			});
			return;
		}
		const allPromises = [];
		const previousModel = this.getModel(true);
		if (model) {
			const modelKeys = new Set(Object.keys(model));
			this.allColumnFilters.forEach((filterWrapper, colId) => {
				const newModel = model[colId];
				allPromises.push(this.setModelOnFilterWrapper(filterWrapper, newModel));
				modelKeys.delete(colId);
			});
			modelKeys.forEach((colId) => {
				const column = colModel.getColDefCol(colId) || colModel.getCol(colId);
				if (!column) {
					_warn(62, { colId });
					return;
				}
				if (!column.isFilterAllowed()) {
					_warn(63, { colId });
					return;
				}
				const filterWrapper = this.getOrCreateFilterWrapper(column, true);
				if (!filterWrapper) {
					_warn(64, { colId });
					return;
				}
				allPromises.push(this.setModelOnFilterWrapper(filterWrapper, model[colId], true));
			});
		} else {
			this.model = {};
			this.allColumnFilters.forEach((filterWrapper) => {
				allPromises.push(this.setModelOnFilterWrapper(filterWrapper, null));
			});
		}
		AgPromise.all(allPromises).then(() => {
			const currentModel = this.getModel(true);
			const columns = [];
			this.allColumnFilters.forEach((filterWrapper, colId) => {
				if (!_jsonEquals(previousModel ? previousModel[colId] : null, currentModel ? currentModel[colId] : null)) columns.push(filterWrapper.column);
			});
			if (columns.length > 0) filterManager?.onFilterChanged({
				columns,
				source
			});
		});
	}
	getModel(excludeInitialState) {
		const result = {};
		const { allColumnFilters, initialModel, beans: { colModel } } = this;
		allColumnFilters.forEach((filterWrapper, key) => {
			const model = this.getModelFromFilterWrapper(filterWrapper);
			if (_exists(model)) result[key] = model;
		});
		if (!excludeInitialState) for (const colId of Object.keys(initialModel)) {
			const model = initialModel[colId];
			if (_exists(model) && !allColumnFilters.has(colId) && colModel.getCol(colId)?.isFilterAllowed()) result[colId] = model;
		}
		return result;
	}
	setState(model, state, source = "api") {
		this.state.clear();
		if (state) for (const colId of Object.keys(state)) {
			const newState = state[colId];
			this.state.set(colId, {
				model: _getFilterModel(this.model, colId),
				state: newState
			});
		}
		this.setModel(model, source);
	}
	getState() {
		const state = this.state;
		if (!state.size) return;
		const newState = {};
		let hasNewState = false;
		state.forEach((colState, colId) => {
			const actualState = colState.state;
			if (actualState != null) {
				hasNewState = true;
				newState[colId] = actualState;
			}
		});
		return hasNewState ? newState : void 0;
	}
	getModelFromFilterWrapper(filterWrapper) {
		const colId = filterWrapper.column.getColId();
		if (filterWrapper.isHandler) return _getFilterModel(this.model, colId);
		const filter = filterWrapper.filter;
		if (filter) {
			if (typeof filter.getModel !== "function") {
				_warn(66);
				return null;
			}
			return filter.getModel();
		}
		return _getFilterModel(this.initialModel, colId);
	}
	isFilterPresent() {
		return this.activeColumnFilters.length > 0;
	}
	isAggFilterPresent() {
		return !!this.activeAggregateFilters.length;
	}
	disableFilters() {
		this.initialModel = {};
		const { allColumnFilters } = this;
		if (allColumnFilters.size) {
			allColumnFilters.forEach((filterWrapper) => this.disposeFilterWrapper(filterWrapper, "advancedFilterEnabled"));
			return true;
		}
		return false;
	}
	updateActiveFilters() {
		const isFilterActive = (filter) => {
			if (!filter) return false;
			if (!filter.isFilterActive) {
				_warn(67);
				return false;
			}
			return filter.isFilterActive();
		};
		const { colModel, gos } = this.beans;
		const groupFilterEnabled = !!_getGroupAggFiltering(gos);
		const isAggFilter = (column) => {
			if (!column.isPrimary()) return true;
			const isShowingPrimaryColumns = !colModel.isPivotActive();
			if (!column.isValueActive() || !isShowingPrimaryColumns) return false;
			if (colModel.isPivotMode()) return true;
			return groupFilterEnabled;
		};
		const activeAggregateFilters = [];
		const activeColumnFilters = [];
		const addFilter = (column, filterActive, doesFilterPassWrapper) => {
			if (filterActive) if (isAggFilter(column)) activeAggregateFilters.push(doesFilterPassWrapper);
			else activeColumnFilters.push(doesFilterPassWrapper);
		};
		const promises = [];
		this.allColumnFilters.forEach((filterWrapper) => {
			const column = filterWrapper.column;
			const colId = column.getColId();
			if (filterWrapper.isHandler) promises.push(AgPromise.resolve().then(() => {
				addFilter(column, this.isHandlerActive(column), {
					colId,
					isHandler: true,
					handler: filterWrapper.handler,
					handlerParams: filterWrapper.handlerParams
				});
			}));
			else {
				const promise = getFilterUiFromWrapper(filterWrapper);
				if (promise) promises.push(promise.then((filter) => {
					addFilter(column, isFilterActive(filter), {
						colId,
						isHandler: false,
						comp: filter
					});
				}));
			}
		});
		return AgPromise.all(promises).then(() => {
			this.activeAggregateFilters = activeAggregateFilters;
			this.activeColumnFilters = activeColumnFilters;
		});
	}
	updateFilterFlagInColumns(source, additionalEventAttributes) {
		const promises = [];
		this.allColumnFilters.forEach((filterWrapper) => {
			const column = filterWrapper.column;
			if (filterWrapper.isHandler) promises.push(AgPromise.resolve().then(() => {
				this.setColFilterActive(column, this.isHandlerActive(column), source, additionalEventAttributes);
			}));
			else {
				const promise = getFilterUiFromWrapper(filterWrapper);
				if (promise) promises.push(promise.then((filter) => {
					this.setColFilterActive(column, filter.isFilterActive(), source, additionalEventAttributes);
				}));
			}
		});
		this.beans.groupFilter?.updateFilterFlags(source, additionalEventAttributes);
		return AgPromise.all(promises);
	}
	doFiltersPass(node, colIdToSkip, targetAggregates) {
		const { data, aggData } = node;
		const targetedFilters = targetAggregates ? this.activeAggregateFilters : this.activeColumnFilters;
		const targetedData = targetAggregates ? aggData : data;
		const model = this.model;
		for (let i = 0; i < targetedFilters.length; i++) {
			const filter = targetedFilters[i];
			const { colId, isHandler } = filter;
			if (colId === colIdToSkip) continue;
			if (isHandler) {
				const { handler, handlerParams } = filter;
				if (!handler.doesFilterPass({
					node,
					data: targetedData,
					model: _getFilterModel(model, colId),
					handlerParams
				})) return false;
			} else {
				const comp = filter.comp;
				if (typeof comp.doesFilterPass !== "function") {
					_error(91);
					continue;
				}
				if (!comp.doesFilterPass({
					node,
					data: targetedData
				})) return false;
			}
		}
		return true;
	}
	getHandlerParams(column) {
		const wrapper$1 = this.allColumnFilters.get(column.getColId());
		return wrapper$1?.isHandler ? wrapper$1.handlerParams : void 0;
	}
	callOnFilterChangedOutsideRenderCycle(params) {
		const { rowRenderer, filterManager } = this.beans;
		const action = () => {
			if (this.isAlive()) filterManager?.onFilterChanged(params);
		};
		if (rowRenderer.isRefreshInProgress()) setTimeout(action, 0);
		else action();
	}
	updateBeforeFilterChanged(params = {}) {
		const { column, additionalEventAttributes } = params;
		const colId = column?.getColId();
		return this.updateActiveFilters().then(() => this.updateFilterFlagInColumns("filterChanged", additionalEventAttributes).then(() => {
			this.allColumnFilters.forEach((filterWrapper) => {
				const { column: filterColumn, isHandler } = filterWrapper;
				if (colId === filterColumn.getColId()) return;
				if (isHandler) filterWrapper.handler.onAnyFilterChanged?.();
				getFilterUiFromWrapper(filterWrapper, isHandler)?.then((filter) => {
					if (typeof filter?.onAnyFilterChanged === "function") filter.onAnyFilterChanged();
				});
			});
			this.processingFilterChange = true;
		}));
	}
	updateAfterFilterChanged() {
		this.processingFilterChange = false;
	}
	isSuppressFlashingCellsBecauseFiltering() {
		return !(this.gos.get("allowShowChangeAfterFilter") ?? false) && this.processingFilterChange;
	}
	onNewRowsLoaded(source) {
		const promises = [];
		this.allColumnFilters.forEach((filterWrapper) => {
			const isHandler = filterWrapper.isHandler;
			if (isHandler) filterWrapper.handler.onNewRowsLoaded?.();
			const promise = getFilterUiFromWrapper(filterWrapper, isHandler);
			if (promise) promises.push(promise.then((filter) => {
				filter.onNewRowsLoaded?.();
			}));
		});
		AgPromise.all(promises).then(() => this.updateFilterFlagInColumns(source, { afterDataChange: true })).then(() => this.updateActiveFilters());
	}
	createGetValue(filterColumn, filterValueGetterOverride) {
		const { filterValueSvc, colModel } = this.beans;
		return (rowNode, column) => {
			const columnToUse = column ? colModel.getCol(column) : filterColumn;
			return columnToUse ? filterValueSvc.getValue(columnToUse, rowNode, filterValueGetterOverride) : void 0;
		};
	}
	isFilterActive(column) {
		const filterWrapper = this.cachedFilter(column);
		if (filterWrapper?.isHandler) return this.isHandlerActive(column);
		const filter = filterWrapper?.filter;
		if (filter) return filter.isFilterActive();
		return _getFilterModel(this.initialModel, column.getColId()) != null;
	}
	isHandlerActive(column) {
		const active = _exists(_getFilterModel(this.model, column.getColId()));
		if (active) return active;
		const groupFilter = this.beans.groupFilter;
		return groupFilter?.isGroupFilter(column) ? groupFilter.isFilterActive(column) : false;
	}
	getOrCreateFilterUi(column) {
		const filterWrapper = this.getOrCreateFilterWrapper(column, true);
		return filterWrapper ? getFilterUiFromWrapper(filterWrapper) : null;
	}
	getFilterUiForDisplay(column) {
		const filterWrapper = this.getOrCreateFilterWrapper(column, true);
		if (!filterWrapper) return null;
		const compPromise = getFilterUiFromWrapper(filterWrapper);
		if (!compPromise) return null;
		return compPromise.then((comp) => ({
			comp,
			params: filterWrapper.filterUi.filterParams,
			isHandler: filterWrapper.isHandler
		}));
	}
	getHandler(column, createIfMissing) {
		const filterWrapper = this.getOrCreateFilterWrapper(column, createIfMissing);
		return filterWrapper?.isHandler ? filterWrapper.handler : void 0;
	}
	getOrCreateFilterWrapper(column, createIfMissing) {
		if (!column.isFilterAllowed()) return;
		let filterWrapper = this.cachedFilter(column);
		if (!filterWrapper && createIfMissing) {
			filterWrapper = this.createFilterWrapper(column);
			this.setColumnFilterWrapper(column, filterWrapper);
		}
		return filterWrapper;
	}
	cachedFilter(column) {
		return this.allColumnFilters.get(column.getColId());
	}
	getDefaultFilter(column, isFloating = false) {
		return this.getDefaultFilterFromDataType(() => this.beans.dataTypeSvc?.getBaseDataType(column), isFloating);
	}
	getDefaultFilterFromDataType(getCellDataType, isFloating = false) {
		if (_isSetFilterByDefault(this.gos)) return isFloating ? "agSetColumnFloatingFilter" : "agSetColumnFilter";
		return _getDefaultSimpleFilter(getCellDataType(), isFloating);
	}
	getDefaultFloatingFilter(column) {
		return this.getDefaultFilter(column, true);
	}
	createFilterComp(column, filterDef, defaultFilter, getFilterParams, isHandler, source) {
		const createFilterCompDetails = () => {
			const updatedParams = getFilterParams(this.createFilterCompParams(column, isHandler, source), isHandler);
			return _getFilterDetails(this.beans.userCompFactory, filterDef, updatedParams, defaultFilter);
		};
		const compDetails = createFilterCompDetails();
		if (!compDetails) return null;
		const createFilterUi = (update) => {
			return (update ? createFilterCompDetails() : compDetails).newAgStackInstance();
		};
		return {
			compDetails,
			createFilterUi
		};
	}
	createFilterInstance(column, filterDef, defaultFilter, getFilterParams) {
		const selectableFilter = this.beans.selectableFilter;
		if (selectableFilter?.isSelectable(filterDef)) filterDef = selectableFilter.getFilterDef(column, filterDef);
		const { handler, handlerParams, handlerGenerator } = this.createHandler(column, filterDef, defaultFilter) ?? {};
		const filterCompDetails = this.createFilterComp(column, filterDef, defaultFilter, getFilterParams, !!handler, "init");
		if (!filterCompDetails) return {
			compDetails: null,
			createFilterUi: null,
			handler,
			handlerGenerator,
			handlerParams
		};
		const { compDetails, createFilterUi } = filterCompDetails;
		if (this.isGlobalButtons) {
			if (!!!compDetails.params?.buttons?.length) _warn(281, { colId: column.getColId() });
		}
		return {
			compDetails,
			handler,
			handlerGenerator,
			handlerParams,
			createFilterUi
		};
	}
	createBaseFilterParams(column, forFloatingFilter) {
		const { filterManager, rowModel } = this.beans;
		return _addGridCommonParams(this.gos, {
			column,
			colDef: column.getColDef(),
			getValue: this.createGetValue(column),
			doesRowPassOtherFilter: forFloatingFilter ? () => true : (node) => filterManager?.doesRowPassOtherFilters(column.getColId(), node) ?? true,
			rowModel
		});
	}
	createFilterCompParams(column, useHandler, source, forFloatingFilter) {
		const filterChangedCallback = this.filterChangedCallbackFactory(column);
		const params = this.createBaseFilterParams(column, forFloatingFilter);
		params.filterChangedCallback = filterChangedCallback;
		params.filterModifiedCallback = forFloatingFilter ? () => {} : (additionalEventAttributes) => this.filterModified(column, additionalEventAttributes);
		if (useHandler) {
			const displayParams = params;
			const colId = column.getColId();
			const model = _getFilterModel(this.model, colId);
			displayParams.model = model;
			displayParams.state = this.state.get(colId) ?? { model };
			displayParams.onModelChange = (model2, additionalEventAttributes) => {
				this.updateStoredModel(colId, model2);
				this.refreshHandlerAndUi(column, model2, "ui").then(() => {
					filterChangedCallback({
						...additionalEventAttributes,
						source: "columnFilter"
					});
				});
			};
			displayParams.onStateChange = (state) => {
				this.updateState(column, state);
				this.updateOrRefreshFilterUi(column);
			};
			displayParams.onAction = (action, additionalEventAttributes, event) => {
				this.updateModel(column, action, additionalEventAttributes);
				this.dispatchLocalEvent({
					type: "filterAction",
					column,
					action,
					event
				});
			};
			displayParams.getHandler = () => this.getHandler(column, true);
			displayParams.onUiChange = (additionalEventAttributes) => this.filterUiChanged(column, additionalEventAttributes);
			displayParams.source = source;
		}
		return params;
	}
	createFilterUiForHandler(compDetails, createFilterUi) {
		return createFilterUi ? {
			created: false,
			create: createFilterUi,
			filterParams: compDetails.params,
			compDetails
		} : null;
	}
	createFilterUiLegacy(compDetails, createFilterUi, updateInstanceCallback) {
		const promise = createFilterUi();
		const filterUi = {
			created: true,
			create: createFilterUi,
			filterParams: compDetails.params,
			compDetails,
			promise
		};
		promise.then(updateInstanceCallback);
		return filterUi;
	}
	createFilterWrapper(column) {
		const { compDetails, handler, handlerGenerator, handlerParams, createFilterUi } = this.createFilterInstance(column, column.getColDef(), this.getDefaultFilter(column), (params) => params);
		const colId = column.getColId();
		if (handler) {
			delete this.initialModel[colId];
			handler.init?.({
				...handlerParams,
				source: "init",
				model: _getFilterModel(this.model, colId)
			});
			return {
				column,
				isHandler: true,
				handler,
				handlerGenerator,
				handlerParams,
				filterUi: this.createFilterUiForHandler(compDetails, createFilterUi)
			};
		}
		if (createFilterUi) {
			const filterWrapper = {
				column,
				filterUi: null,
				isHandler: false
			};
			filterWrapper.filterUi = this.createFilterUiLegacy(compDetails, createFilterUi, (filterComp) => {
				filterWrapper.filter = filterComp ?? void 0;
			});
			return filterWrapper;
		}
		return {
			column,
			filterUi: null,
			isHandler: false
		};
	}
	createHandlerFunc(filterDef, defaultFilter) {
		const { gos, frameworkOverrides, registry } = this.beans;
		let doesFilterPass;
		const getFilterHandlerFromDef = (filterDef2) => {
			const filter = filterDef2.filter;
			if (isColumnFilterComp(filter)) {
				const handler = filter.handler;
				if (handler) return handler;
				doesFilterPass = filter.doesFilterPass;
				if (doesFilterPass) return () => ({ doesFilterPass });
				return;
			}
			return typeof filter === "string" ? filter : void 0;
		};
		const providedFilterHandler = gos.get("enableFilterHandlers") ? getFilterHandlerFromDef(filterDef) : void 0;
		const resolveProvidedFilterHandler = (handlerName2) => () => this.createBean(registry.createDynamicBean(handlerName2, true));
		let filterHandler;
		let handlerName;
		if (typeof providedFilterHandler === "string") {
			const userFilterHandler = gos.get("filterHandlers")?.[providedFilterHandler];
			if (userFilterHandler != null) filterHandler = userFilterHandler;
			else if (FILTER_HANDLERS.has(providedFilterHandler)) {
				filterHandler = resolveProvidedFilterHandler(providedFilterHandler);
				handlerName = providedFilterHandler;
			}
		} else filterHandler = providedFilterHandler;
		if (!filterHandler) {
			let filterName;
			const { compName, jsComp, fwComp } = _getFilterCompKeys(frameworkOverrides, filterDef);
			if (compName) filterName = compName;
			else if (jsComp == null && fwComp == null && filterDef.filter === true) filterName = defaultFilter;
			handlerName = this.handlerMap[filterName];
			if (handlerName) filterHandler = resolveProvidedFilterHandler(handlerName);
		}
		if (!filterHandler) return;
		return {
			filterHandler,
			handlerNameOrCallback: doesFilterPass ?? handlerName
		};
	}
	createHandler(column, filterDef, defaultFilter) {
		let handlerFunc = this.createHandlerFunc(filterDef, defaultFilter);
		if (!handlerFunc) {
			const gos = this.gos;
			if (!gos.get("enableFilterHandlers")) return;
			if (_isClientSideRowModel(gos)) _warn(277, { colId: column.getColId() });
			handlerFunc = DUMMY_HANDLER;
		}
		const filterParams = _mergeFilterParamsWithApplicationProvidedParams(this.beans.userCompFactory, filterDef, this.createFilterCompParams(column, true, "init"));
		const { handlerNameOrCallback, filterHandler } = handlerFunc;
		const { handler, handlerParams } = this.createHandlerFromFunc(column, filterHandler, filterParams);
		return {
			handler,
			handlerParams,
			handlerGenerator: handlerNameOrCallback ?? filterHandler
		};
	}
	createHandlerFromFunc(column, filterHandler, filterParams) {
		const colDef = column.getColDef();
		return {
			handler: filterHandler(_addGridCommonParams(this.gos, {
				column,
				colDef
			})),
			handlerParams: this.createHandlerParams(column, filterParams)
		};
	}
	createHandlerParams(column, filterParams) {
		const colDef = column.getColDef();
		const colId = column.getColId();
		const filterChangedCallback = this.filterChangedCallbackFactory(column);
		return _addGridCommonParams(this.gos, {
			colDef,
			column,
			getValue: this.createGetValue(column),
			doesRowPassOtherFilter: (node) => this.beans.filterManager?.doesRowPassOtherFilters(colId, node) ?? true,
			onModelChange: (newModel, additionalEventAttributes) => {
				this.updateStoredModel(colId, newModel);
				this.refreshHandlerAndUi(column, newModel, "handler").then(() => {
					filterChangedCallback({
						...additionalEventAttributes,
						source: "columnFilter"
					});
				});
			},
			filterParams
		});
	}
	onColumnsChanged() {
		const columns = [];
		const { colModel, filterManager, groupFilter } = this.beans;
		this.allColumnFilters.forEach((wrapper$1, colId) => {
			let currentColumn;
			if (wrapper$1.column.isPrimary()) currentColumn = colModel.getColDefCol(colId);
			else currentColumn = colModel.getCol(colId);
			if (currentColumn && currentColumn === wrapper$1.column) return;
			columns.push(wrapper$1.column);
			this.disposeFilterWrapper(wrapper$1, "columnChanged");
			this.disposeColumnListener(colId);
		});
		const allFiltersAreGroupFilters = groupFilter && columns.every((col) => groupFilter.isGroupFilter(col));
		if (columns.length > 0 && !allFiltersAreGroupFilters) filterManager?.onFilterChanged({
			columns,
			source: "api"
		});
	}
	isFilterAllowed(column) {
		if (!column.isFilterAllowed()) return false;
		const groupFilter = this.beans.groupFilter;
		if (groupFilter?.isGroupFilter(column)) return groupFilter.isFilterAllowed(column);
		return true;
	}
	getFloatingFilterCompDetails(column, showParentFilter) {
		const { userCompFactory, frameworkOverrides, selectableFilter } = this.beans;
		const parentFilterInstance = (callback) => {
			const filterComponent = this.getOrCreateFilterUi(column);
			if (filterComponent == null) return;
			filterComponent.then((instance) => {
				callback(_unwrapUserComp(instance));
			});
		};
		const colDef = column.getColDef();
		const filterDef = selectableFilter?.isSelectable(colDef) ? selectableFilter.getFilterDef(column, colDef) : colDef;
		const defaultFloatingFilterType = _getDefaultFloatingFilterType(frameworkOverrides, filterDef, () => this.getDefaultFloatingFilter(column)) ?? "agReadOnlyFloatingFilter";
		const isReactive$1 = this.gos.get("enableFilterHandlers");
		const filterParams = _mergeFilterParamsWithApplicationProvidedParams(userCompFactory, filterDef, this.createFilterCompParams(column, isReactive$1, "init", true));
		const params = _addGridCommonParams(this.gos, {
			column,
			filterParams,
			currentParentModel: () => this.getCurrentFloatingFilterParentModel(column),
			parentFilterInstance,
			showParentFilter
		});
		if (isReactive$1) {
			const displayParams = params;
			const colId = column.getColId();
			const filterChangedCallback = this.filterChangedCallbackFactory(column);
			displayParams.onUiChange = (additionalEventAttributes) => this.floatingFilterUiChanged(column, additionalEventAttributes);
			displayParams.model = _getFilterModel(this.model, colId);
			displayParams.onModelChange = (model, additionalEventAttributes) => {
				this.updateStoredModel(colId, model);
				this.refreshHandlerAndUi(column, model, "floating", true).then(() => {
					filterChangedCallback({
						...additionalEventAttributes,
						source: "columnFilter"
					});
				});
			};
			displayParams.getHandler = () => this.getHandler(column, true);
			displayParams.source = "init";
		}
		return _getFloatingFilterCompDetails(userCompFactory, colDef, params, defaultFloatingFilterType);
	}
	getCurrentFloatingFilterParentModel(column) {
		return this.getModelFromFilterWrapper(this.cachedFilter(column) ?? { column });
	}
	destroyFilterUi(filterWrapper, column, compDetails, createFilterUi) {
		if (filterWrapper.isHandler) {
			const colId = column.getColId();
			delete this.initialModel[colId];
			this.state.delete(colId);
			const filterUi = filterWrapper.filterUi;
			filterWrapper.filterUi = this.createFilterUiForHandler(compDetails, createFilterUi);
			if (filterUi?.created) filterUi.promise.then((filter) => {
				this.destroyBean(filter);
				this.eventSvc.dispatchEvent({
					type: "filterDestroyed",
					source: "paramsUpdated",
					column: filterWrapper.column
				});
			});
		} else this.destroyFilter(column, "paramsUpdated");
	}
	destroyFilter(column, source = "api") {
		const colId = column.getColId();
		const filterWrapper = this.allColumnFilters.get(colId);
		this.disposeColumnListener(colId);
		delete this.initialModel[colId];
		if (filterWrapper) this.disposeFilterWrapper(filterWrapper, source).then((wasActive) => {
			if (wasActive && this.isAlive()) this.beans.filterManager?.onFilterChanged({
				columns: [column],
				source: "api"
			});
		});
	}
	disposeColumnListener(colId) {
		const columnListener = this.allColumnListeners.get(colId);
		if (columnListener) {
			this.allColumnListeners.delete(colId);
			columnListener();
		}
	}
	disposeFilterWrapper(filterWrapper, source) {
		let isActive = false;
		const { column, isHandler, filterUi } = filterWrapper;
		const colId = column.getColId();
		if (isHandler) {
			isActive = this.isHandlerActive(column);
			this.destroyBean(filterWrapper.handler);
			delete this.model[colId];
			this.state.delete(colId);
		}
		const removeFilter = () => {
			this.setColFilterActive(column, false, "filterDestroyed");
			this.allColumnFilters.delete(colId);
			this.eventSvc.dispatchEvent({
				type: "filterDestroyed",
				source,
				column
			});
		};
		if (filterUi) if (filterUi.created) return filterUi.promise.then((filter) => {
			isActive = isHandler ? isActive : !!filter?.isFilterActive();
			this.destroyBean(filter);
			removeFilter();
			return isActive;
		});
		else removeFilter();
		return AgPromise.resolve(isActive);
	}
	filterChangedCallbackFactory(column) {
		return (additionalEventAttributes) => {
			this.callOnFilterChangedOutsideRenderCycle({
				additionalEventAttributes,
				columns: [column],
				column,
				source: additionalEventAttributes?.source ?? "columnFilter"
			});
		};
	}
	filterParamsChanged(colId, source = "api") {
		const filterWrapper = this.allColumnFilters.get(colId);
		if (!filterWrapper) return;
		const beans = this.beans;
		const column = filterWrapper.column;
		const colDef = column.getColDef();
		const isFilterAllowed = column.isFilterAllowed();
		const defaultFilter = this.getDefaultFilter(column);
		const selectableFilter = beans.selectableFilter;
		const filterDef = selectableFilter?.isSelectable(colDef) ? selectableFilter.getFilterDef(column, colDef) : colDef;
		const handlerFunc = isFilterAllowed ? this.createHandlerFunc(filterDef, this.getDefaultFilter(column)) : void 0;
		const isHandler = !!handlerFunc;
		const wasHandler = filterWrapper.isHandler;
		if (wasHandler != isHandler) {
			this.destroyFilter(column, "paramsUpdated");
			return;
		}
		const { compDetails, createFilterUi } = (isFilterAllowed ? this.createFilterComp(column, filterDef, defaultFilter, (params) => params, isHandler, "colDef") : null) ?? {
			compDetails: null,
			createFilterUi: null
		};
		const newFilterParams = compDetails?.params ?? _mergeFilterParamsWithApplicationProvidedParams(beans.userCompFactory, filterDef, this.createFilterCompParams(column, isHandler, "colDef"));
		if (wasHandler) {
			const handlerGenerator = handlerFunc?.handlerNameOrCallback ?? handlerFunc?.filterHandler;
			const existingModel = _getFilterModel(this.model, colId);
			if (filterWrapper.handlerGenerator != handlerGenerator) {
				const oldHandler = filterWrapper.handler;
				const { handler, handlerParams } = this.createHandlerFromFunc(column, handlerFunc.filterHandler, newFilterParams);
				filterWrapper.handler = handler;
				filterWrapper.handlerParams = handlerParams;
				filterWrapper.handlerGenerator = handlerGenerator;
				delete this.model[colId];
				handler.init?.({
					...handlerParams,
					source: "init",
					model: null
				});
				this.destroyBean(oldHandler);
				if (existingModel != null) this.beans.filterManager?.onFilterChanged({
					columns: [column],
					source
				});
			} else {
				const handlerParams = this.createHandlerParams(column, compDetails?.params);
				filterWrapper.handlerParams = handlerParams;
				filterWrapper.handler.refresh?.({
					...handlerParams,
					source: "colDef",
					model: existingModel
				});
			}
		}
		if (this.areFilterCompsDifferent(filterWrapper.filterUi?.compDetails ?? null, compDetails) || !filterWrapper.filterUi || !compDetails) {
			this.destroyFilterUi(filterWrapper, column, compDetails, createFilterUi);
			return;
		}
		filterWrapper.filterUi.filterParams = newFilterParams;
		getFilterUiFromWrapper(filterWrapper, wasHandler)?.then((filter) => {
			if ((filter?.refresh ? filter.refresh(newFilterParams) : true) === false) this.destroyFilterUi(filterWrapper, column, compDetails, createFilterUi);
			else this.dispatchLocalEvent({
				type: "filterParamsChanged",
				column,
				params: newFilterParams
			});
		});
	}
	refreshHandlerAndUi(column, model, source, createIfMissing) {
		const filterWrapper = this.cachedFilter(column);
		if (!filterWrapper) {
			if (createIfMissing) this.getOrCreateFilterWrapper(column, true);
			return AgPromise.resolve();
		}
		if (!filterWrapper.isHandler) return AgPromise.resolve();
		const { filterUi, handler, handlerParams } = filterWrapper;
		return _refreshHandlerAndUi(() => {
			if (filterUi) {
				const { created, filterParams } = filterUi;
				if (created) return filterUi.promise.then((filter) => {
					return filter ? {
						filter,
						filterParams
					} : void 0;
				});
				else filterUi.refreshed = true;
			}
			return AgPromise.resolve(void 0);
		}, handler, handlerParams, model, this.state.get(column.getColId()) ?? { model }, source);
	}
	setColumnFilterWrapper(column, filterWrapper) {
		const colId = column.getColId();
		this.allColumnFilters.set(colId, filterWrapper);
		this.allColumnListeners.set(colId, this.addManagedListeners(column, { colDefChanged: () => this.filterParamsChanged(colId) })[0]);
	}
	areFilterCompsDifferent(oldCompDetails, newCompDetails) {
		if (!newCompDetails || !oldCompDetails) return true;
		const { componentClass: oldComponentClass } = oldCompDetails;
		const { componentClass: newComponentClass } = newCompDetails;
		return !(oldComponentClass === newComponentClass || oldComponentClass?.render && newComponentClass?.render && oldComponentClass.render === newComponentClass.render);
	}
	hasFloatingFilters() {
		return this.beans.colModel.getCols().some((col) => col.getColDef().floatingFilter);
	}
	getFilterInstance(key) {
		const column = this.beans.colModel.getColDefCol(key);
		if (!column) return Promise.resolve(void 0);
		const filterPromise = this.getOrCreateFilterUi(column);
		if (!filterPromise) return Promise.resolve(null);
		return new Promise((resolve) => {
			filterPromise.then((filter) => {
				resolve(_unwrapUserComp(filter));
			});
		});
	}
	processFilterModelUpdateQueue() {
		this.modelUpdates.forEach(({ model, source }) => this.setModel(model, source));
		this.modelUpdates = [];
		this.columnModelUpdates.forEach(({ key, model, resolve }) => {
			this.setModelForColumn(key, model).then(() => resolve());
		});
		this.columnModelUpdates = [];
	}
	getModelForColumn(column, useUnapplied) {
		if (useUnapplied) {
			const { state, model } = this;
			const colId = column.getColId();
			const colState = state.get(colId);
			if (colState) return colState.model ?? null;
			return _getFilterModel(model, colId);
		}
		const filterWrapper = this.cachedFilter(column);
		return filterWrapper ? this.getModelFromFilterWrapper(filterWrapper) : null;
	}
	setModelForColumn(key, model) {
		if (this.beans.dataTypeSvc?.isPendingInference) {
			let resolve = () => {};
			const promise = new Promise((res) => {
				resolve = res;
			});
			this.columnModelUpdates.push({
				key,
				model,
				resolve
			});
			return promise;
		}
		return new Promise((resolve) => {
			this.setModelForColumnLegacy(key, model).then((result) => resolve(result));
		});
	}
	getStateForColumn(colId) {
		return this.state.get(colId) ?? { model: _getFilterModel(this.model, colId) };
	}
	setModelForColumnLegacy(key, model) {
		const column = this.beans.colModel.getColDefCol(key);
		const filterWrapper = column ? this.getOrCreateFilterWrapper(column, true) : null;
		return filterWrapper ? this.setModelOnFilterWrapper(filterWrapper, model) : AgPromise.resolve();
	}
	setColDefPropsForDataType(colDef, dataTypeDefinition, formatValue) {
		const providedFilter = colDef.filter;
		const filter = providedFilter === true ? this.getDefaultFilterFromDataType(() => dataTypeDefinition.baseDataType) : providedFilter;
		if (typeof filter !== "string") return;
		let filterParams;
		let filterValueGetter;
		const beans = this.beans;
		const { filterParams: colDefFilterParams, filterValueGetter: colDefFilterValueGetter } = colDef;
		if (filter === "agMultiColumnFilter") ({filterParams, filterValueGetter} = beans.multiFilter?.getParamsForDataType(colDefFilterParams, colDefFilterValueGetter, dataTypeDefinition, formatValue) ?? {});
		else ({filterParams, filterValueGetter} = _getFilterParamsForDataType(filter, colDefFilterParams, colDefFilterValueGetter, dataTypeDefinition, formatValue, beans, this.getLocaleTextFunc()));
		colDef.filterParams = filterParams;
		if (filterValueGetter) colDef.filterValueGetter = filterValueGetter;
	}
	setColFilterActive(column, active, source, additionalEventAttributes) {
		if (column.filterActive !== active) {
			column.filterActive = active;
			column.dispatchColEvent("filterActiveChanged", source);
		}
		column.dispatchColEvent("filterChanged", source, additionalEventAttributes);
	}
	setModelOnFilterWrapper(filterWrapper, newModel, justCreated) {
		return new AgPromise((resolve) => {
			if (filterWrapper.isHandler) {
				const column = filterWrapper.column;
				const colId = column.getColId();
				const existingModel = this.model[colId];
				this.updateStoredModel(colId, newModel);
				if (justCreated && newModel === existingModel) {
					resolve();
					return;
				}
				this.refreshHandlerAndUi(column, newModel, "api").then(() => resolve());
				return;
			}
			const uiPromise = getFilterUiFromWrapper(filterWrapper);
			if (uiPromise) {
				uiPromise.then((filter) => {
					if (typeof filter?.setModel !== "function") {
						_warn(65);
						resolve();
						return;
					}
					(filter.setModel(newModel) || AgPromise.resolve()).then(() => resolve());
				});
				return;
			}
			resolve();
		});
	}
	updateStoredModel(colId, model) {
		if (_exists(model)) this.model[colId] = model;
		else delete this.model[colId];
		const newState = {
			model,
			state: this.state.get(colId)?.state
		};
		this.state.set(colId, newState);
	}
	filterModified(column, additionalEventAttributes) {
		this.getOrCreateFilterUi(column)?.then((filterInstance) => {
			this.eventSvc.dispatchEvent({
				type: "filterModified",
				column,
				filterInstance,
				...additionalEventAttributes
			});
		});
	}
	filterUiChanged(column, additionalEventAttributes) {
		if (this.gos.get("enableFilterHandlers")) this.eventSvc.dispatchEvent({
			type: "filterUiChanged",
			column,
			...additionalEventAttributes
		});
	}
	floatingFilterUiChanged(column, additionalEventAttributes) {
		if (this.gos.get("enableFilterHandlers")) this.eventSvc.dispatchEvent({
			type: "floatingFilterUiChanged",
			column,
			...additionalEventAttributes
		});
	}
	updateModel(column, action, additionalEventAttributes) {
		const colId = column.getColId();
		const getFilterUi = () => this.cachedFilter(column)?.filterUi;
		_updateFilterModel(action, getFilterUi, () => _getFilterModel(this.model, colId), () => this.state.get(colId), (state) => this.updateState(column, state), (model) => getFilterUi()?.filterParams?.onModelChange(model, additionalEventAttributes));
	}
	updateAllModels(action, additionalEventAttributes) {
		const promises = [];
		this.allColumnFilters.forEach((filter, colId) => {
			const column = this.beans.colModel.getColDefCol(colId);
			if (column) _updateFilterModel(action, () => filter.filterUi, () => _getFilterModel(this.model, colId), () => this.state.get(colId), (state) => this.updateState(column, state), (model) => {
				this.updateStoredModel(colId, model);
				this.dispatchLocalEvent({
					type: "filterAction",
					column,
					action
				});
				promises.push(this.refreshHandlerAndUi(column, model, "ui"));
			});
		});
		if (promises.length) AgPromise.all(promises).then(() => {
			this.callOnFilterChangedOutsideRenderCycle({
				source: "columnFilter",
				additionalEventAttributes,
				columns: []
			});
		});
	}
	updateOrRefreshFilterUi(column) {
		const colId = column.getColId();
		getAndRefreshFilterUi(() => this.cachedFilter(column)?.filterUi, () => _getFilterModel(this.model, colId), () => this.state.get(colId));
	}
	updateState(column, state) {
		this.state.set(column.getColId(), state);
		this.dispatchLocalEvent({
			type: "filterStateChanged",
			column,
			state
		});
	}
	canApplyAll() {
		const { state, model, activeFilterComps } = this;
		for (const comp of activeFilterComps) if (comp.source === "COLUMN_MENU") return false;
		let hasChanges = false;
		for (const colId of state.keys()) {
			const colState = state.get(colId);
			if (colState.valid === false) return false;
			if ((colState.model ?? null) !== _getFilterModel(model, colId)) hasChanges = true;
		}
		return hasChanges;
	}
	hasUnappliedModel(colId) {
		const { model, state } = this;
		return (state.get(colId)?.model ?? null) !== _getFilterModel(model, colId);
	}
	setGlobalButtons(isGlobal) {
		this.isGlobalButtons = isGlobal;
		this.dispatchLocalEvent({
			type: "filterGlobalButtons",
			isGlobal
		});
	}
	shouldKeepStateOnDetach(column, lastContainerType) {
		if (lastContainerType === "newFiltersToolPanel") return true;
		const filterPanelSvc = this.beans.filterPanelSvc;
		if (filterPanelSvc?.isActive) return !!filterPanelSvc.getState(column.getColId());
		return false;
	}
	destroy() {
		super.destroy();
		this.allColumnFilters.forEach((filterWrapper) => this.disposeFilterWrapper(filterWrapper, "gridDestroyed"));
		this.allColumnListeners.clear();
		this.state.clear();
		this.activeFilterComps.clear();
	}
};
function isAnyFilterPresent(beans) {
	return !!beans.filterManager?.isAnyFilterPresent();
}
function onFilterChanged(beans, source = "api") {
	beans.filterManager?.onFilterChanged({ source });
}
var FilterManager = class extends BeanStub {
	constructor() {
		super(...arguments);
		this.beanName = "filterManager";
		this.advFilterModelUpdateQueue = [];
	}
	wireBeans(beans) {
		this.quickFilter = beans.quickFilter;
		this.advancedFilter = beans.advancedFilter;
		this.colFilter = beans.colFilter;
	}
	postConstruct() {
		const refreshFiltersForAggregations = this.refreshFiltersForAggregations.bind(this);
		const updateAdvFilterColumns = this.updateAdvFilterColumns.bind(this);
		this.addManagedEventListeners({
			columnValueChanged: refreshFiltersForAggregations,
			columnPivotChanged: refreshFiltersForAggregations,
			columnPivotModeChanged: refreshFiltersForAggregations,
			newColumnsLoaded: updateAdvFilterColumns,
			columnVisible: updateAdvFilterColumns,
			advancedFilterEnabledChanged: ({ enabled }) => this.onAdvFilterEnabledChanged(enabled),
			dataTypesInferred: this.processFilterModelUpdateQueue.bind(this)
		});
		this.externalFilterPresent = this.isExternalFilterPresentCallback();
		this.addManagedPropertyListeners(["isExternalFilterPresent", "doesExternalFilterPass"], () => {
			this.onFilterChanged({ source: "api" });
		});
		this.updateAggFiltering();
		this.addManagedPropertyListener("groupAggFiltering", () => {
			this.updateAggFiltering();
			this.onFilterChanged();
		});
		if (this.quickFilter) this.addManagedListeners(this.quickFilter, { quickFilterChanged: () => this.onFilterChanged({ source: "quickFilter" }) });
		const { gos } = this;
		this.alwaysPassFilter = gos.get("alwaysPassFilter");
		this.addManagedPropertyListener("alwaysPassFilter", () => {
			this.alwaysPassFilter = gos.get("alwaysPassFilter");
			this.onFilterChanged({ source: "api" });
		});
	}
	isExternalFilterPresentCallback() {
		const isFilterPresent = this.gos.getCallback("isExternalFilterPresent");
		return typeof isFilterPresent === "function" && isFilterPresent({});
	}
	doesExternalFilterPass(node) {
		const doesFilterPass = this.gos.get("doesExternalFilterPass");
		return typeof doesFilterPass === "function" && doesFilterPass(node);
	}
	setFilterState(model, state, source = "api") {
		if (this.isAdvFilterEnabled()) return;
		this.colFilter?.setState(model, state, source);
	}
	setFilterModel(model, source = "api", skipWarning) {
		if (this.isAdvFilterEnabled()) {
			if (!skipWarning) this.warnAdvFilters();
			return;
		}
		this.colFilter?.setModel(model, source);
	}
	getFilterModel() {
		return this.colFilter?.getModel() ?? {};
	}
	getFilterState() {
		return this.colFilter?.getState();
	}
	isColumnFilterPresent() {
		return !!this.colFilter?.isFilterPresent();
	}
	isAggregateFilterPresent() {
		return !!this.colFilter?.isAggFilterPresent();
	}
	isChildFilterPresent() {
		return this.isColumnFilterPresent() || this.isQuickFilterPresent() || this.externalFilterPresent || this.isAdvFilterPresent();
	}
	isAnyFilterPresent() {
		return this.isChildFilterPresent() || this.isAggregateFilterPresent();
	}
	isAdvFilterPresent() {
		return this.isAdvFilterEnabled() && this.advancedFilter.isFilterPresent();
	}
	onAdvFilterEnabledChanged(enabled) {
		if (enabled) {
			if (this.colFilter?.disableFilters()) this.onFilterChanged({ source: "advancedFilter" });
		} else if (this.advancedFilter?.isFilterPresent()) {
			this.advancedFilter.setModel(null);
			this.onFilterChanged({ source: "advancedFilter" });
		}
	}
	isAdvFilterEnabled() {
		return !!this.advancedFilter?.isEnabled();
	}
	isAdvFilterHeaderActive() {
		return this.isAdvFilterEnabled() && this.advancedFilter.isHeaderActive();
	}
	refreshFiltersForAggregations() {
		if (_getGroupAggFiltering(this.gos) && this.isAnyFilterPresent()) this.onFilterChanged();
	}
	onFilterChanged(params = {}) {
		const { source, additionalEventAttributes, columns = [] } = params;
		this.externalFilterPresent = this.isExternalFilterPresentCallback();
		(this.colFilter ? this.colFilter.updateBeforeFilterChanged(params) : AgPromise.resolve()).then(() => {
			const filterChangedEvent = {
				source,
				type: "filterChanged",
				columns
			};
			if (additionalEventAttributes) _mergeDeep(filterChangedEvent, additionalEventAttributes);
			this.eventSvc.dispatchEvent(filterChangedEvent);
			this.colFilter?.updateAfterFilterChanged();
		});
	}
	isSuppressFlashingCellsBecauseFiltering() {
		return !!this.colFilter?.isSuppressFlashingCellsBecauseFiltering();
	}
	isQuickFilterPresent() {
		return !!this.quickFilter?.isFilterPresent();
	}
	updateAggFiltering() {
		this.aggFiltering = !!_getGroupAggFiltering(this.gos);
	}
	isAggregateQuickFilterPresent() {
		return this.isQuickFilterPresent() && this.shouldApplyQuickFilterAfterAgg();
	}
	isNonAggregateQuickFilterPresent() {
		return this.isQuickFilterPresent() && !this.shouldApplyQuickFilterAfterAgg();
	}
	shouldApplyQuickFilterAfterAgg() {
		return (this.aggFiltering || this.beans.colModel.isPivotMode()) && !this.gos.get("applyQuickFilterBeforePivotOrAgg");
	}
	doesRowPassOtherFilters(colIdToSkip, rowNode) {
		return this.doesRowPassFilter({
			rowNode,
			colIdToSkip
		});
	}
	doesRowPassAggregateFilters(params) {
		const { rowNode } = params;
		if (this.alwaysPassFilter?.(rowNode)) return true;
		if (this.isAggregateQuickFilterPresent() && !this.quickFilter.doesRowPass(rowNode)) return false;
		if (this.isAggregateFilterPresent() && !this.colFilter.doFiltersPass(rowNode, params.colIdToSkip, true)) return false;
		return true;
	}
	doesRowPassFilter(params) {
		const { rowNode } = params;
		if (this.alwaysPassFilter?.(rowNode)) return true;
		if (this.isNonAggregateQuickFilterPresent() && !this.quickFilter.doesRowPass(rowNode)) return false;
		if (this.externalFilterPresent && !this.doesExternalFilterPass(rowNode)) return false;
		if (this.isColumnFilterPresent() && !this.colFilter.doFiltersPass(rowNode, params.colIdToSkip)) return false;
		if (this.isAdvFilterPresent() && !this.advancedFilter.doesFilterPass(rowNode)) return false;
		return true;
	}
	isFilterAllowed(column) {
		if (this.isAdvFilterEnabled()) return false;
		return !!this.colFilter?.isFilterAllowed(column);
	}
	getAdvFilterModel() {
		return this.isAdvFilterEnabled() ? this.advancedFilter.getModel() : null;
	}
	setAdvFilterModel(expression, source = "api") {
		if (!this.isAdvFilterEnabled()) return;
		if (this.beans.dataTypeSvc?.isPendingInference) {
			this.advFilterModelUpdateQueue.push(expression);
			return;
		}
		this.advancedFilter.setModel(expression ?? null);
		this.onFilterChanged({ source });
	}
	toggleAdvFilterBuilder(show, source) {
		if (!this.isAdvFilterEnabled()) return;
		this.advancedFilter.getCtrl().toggleFilterBuilder({
			source,
			force: show
		});
	}
	updateAdvFilterColumns() {
		if (!this.isAdvFilterEnabled()) return;
		if (this.advancedFilter.updateValidity()) this.onFilterChanged({ source: "advancedFilter" });
	}
	hasFloatingFilters() {
		if (this.isAdvFilterEnabled()) return false;
		return !!this.colFilter?.hasFloatingFilters();
	}
	getColumnFilterInstance(key) {
		if (this.isAdvFilterEnabled()) {
			this.warnAdvFilters();
			return Promise.resolve(void 0);
		}
		return this.colFilter?.getFilterInstance(key) ?? Promise.resolve(void 0);
	}
	warnAdvFilters() {
		_warn(68);
	}
	setupAdvFilterHeaderComp(eCompToInsertBefore) {
		this.advancedFilter?.getCtrl().setupHeaderComp(eCompToInsertBefore);
	}
	getHeaderRowCount() {
		return this.isAdvFilterHeaderActive() ? 1 : 0;
	}
	getHeaderHeight() {
		return this.isAdvFilterHeaderActive() ? this.advancedFilter.getCtrl().getHeaderHeight() : 0;
	}
	processFilterModelUpdateQueue() {
		this.advFilterModelUpdateQueue.forEach((model) => this.setAdvFilterModel(model));
		this.advFilterModelUpdateQueue = [];
	}
	setColumnFilterModel(key, model) {
		if (this.isAdvFilterEnabled()) {
			this.warnAdvFilters();
			return Promise.resolve();
		}
		return this.colFilter?.setModelForColumn(key, model) ?? Promise.resolve();
	}
};
var FilterMenuFactory = class extends BeanStub {
	constructor() {
		super(...arguments);
		this.beanName = "filterMenuFactory";
	}
	wireBeans(beans) {
		this.popupSvc = beans.popupSvc;
	}
	hideActiveMenu() {
		this.hidePopup?.();
	}
	showMenuAfterMouseEvent(column, mouseEvent, containerType, onClosedCallback) {
		if (column && !column.isColumn) return;
		this.showPopup(column, (eMenu) => {
			this.popupSvc?.positionPopupUnderMouseEvent({
				column,
				type: containerType,
				mouseEvent,
				ePopup: eMenu
			});
		}, containerType, mouseEvent.target, _isLegacyMenuEnabled(this.gos), onClosedCallback);
	}
	showMenuAfterButtonClick(column, eventSource, containerType, onClosedCallback) {
		if (column && !column.isColumn) return;
		let multiplier = -1;
		let alignSide = "left";
		const isLegacyMenuEnabled = _isLegacyMenuEnabled(this.gos);
		if (!isLegacyMenuEnabled && this.gos.get("enableRtl")) {
			multiplier = 1;
			alignSide = "right";
		}
		const nudgeX = isLegacyMenuEnabled ? void 0 : 4 * multiplier;
		const nudgeY = isLegacyMenuEnabled ? void 0 : 4;
		this.showPopup(column, (eMenu) => {
			this.popupSvc?.positionPopupByComponent({
				type: containerType,
				eventSource,
				ePopup: eMenu,
				nudgeX,
				nudgeY,
				alignSide,
				keepWithinBounds: true,
				position: "under",
				column
			});
		}, containerType, eventSource, isLegacyMenuEnabled, onClosedCallback);
	}
	showPopup(column, positionCallback, containerType, eventSource, isLegacyMenuEnabled, onClosedCallback) {
		const comp = column ? this.createBean(new FilterComp(column, "COLUMN_MENU")) : void 0;
		this.activeMenu = comp;
		if (!comp?.hasFilter() || !column) {
			_error(57);
			return;
		}
		const eMenu = _createElement({
			tag: "div",
			cls: `ag-menu${!isLegacyMenuEnabled ? " ag-filter-menu" : ""}`,
			role: "presentation"
		});
		[this.tabListener] = this.addManagedElementListeners(eMenu, { keydown: (e) => this.trapFocusWithin(e, eMenu) });
		eMenu.appendChild(comp?.getGui());
		let hidePopup;
		const afterGuiDetached = () => comp?.afterGuiDetached();
		const anchorToElement = _isColumnMenuAnchoringEnabled(this.gos) ? eventSource ?? this.beans.ctrlsSvc.getGridBodyCtrl().eGridBody : void 0;
		const closedCallback = (e) => {
			_setColMenuVisible(column, false, "contextMenu");
			const isKeyboardEvent = e instanceof KeyboardEvent;
			if (this.tabListener) this.tabListener = this.tabListener();
			if (isKeyboardEvent && eventSource && _isVisible(eventSource)) _findTabbableParent(eventSource)?.focus({ preventScroll: true });
			afterGuiDetached();
			this.destroyBean(this.activeMenu);
			this.dispatchVisibleChangedEvent(false, containerType, column);
			onClosedCallback?.();
		};
		const translate = this.getLocaleTextFunc();
		const ariaLabel = isLegacyMenuEnabled && containerType !== "columnFilter" ? translate("ariaLabelColumnMenu", "Column Menu") : translate("ariaLabelColumnFilter", "Column Filter");
		const addPopupRes = this.popupSvc?.addPopup({
			modal: true,
			eChild: eMenu,
			closeOnEsc: true,
			closedCallback,
			positionCallback: () => positionCallback(eMenu),
			anchorToElement,
			ariaLabel
		});
		if (addPopupRes) this.hidePopup = hidePopup = addPopupRes.hideFunc;
		comp.afterInit().then(() => {
			positionCallback(eMenu);
			comp.afterGuiAttached({
				container: containerType,
				hidePopup
			});
		});
		_setColMenuVisible(column, true, "contextMenu");
		this.dispatchVisibleChangedEvent(true, containerType, column);
	}
	trapFocusWithin(e, menu) {
		if (e.key !== KeyCode.TAB || e.defaultPrevented || _findNextFocusableElement(this.beans, menu, false, e.shiftKey)) return;
		e.preventDefault();
		_focusInto(menu, e.shiftKey);
	}
	dispatchVisibleChangedEvent(visible, containerType, column) {
		this.eventSvc.dispatchEvent({
			type: "columnMenuVisibleChanged",
			visible,
			switchingTab: false,
			key: containerType,
			column: column ?? null,
			columnGroup: null
		});
	}
	isMenuEnabled(column) {
		return column.isFilterAllowed() && (column.getColDef().menuTabs ?? ["filterMenuTab"]).includes("filterMenuTab");
	}
	showMenuAfterContextMenuEvent() {}
	destroy() {
		this.destroyBean(this.activeMenu);
		super.destroy();
	}
};
var FilterValueService = class extends BeanStub {
	constructor() {
		super(...arguments);
		this.beanName = "filterValueSvc";
	}
	getValue(column, rowNode, filterValueGetterOverride) {
		if (!rowNode) return;
		const colDef = column.getColDef();
		const { selectableFilter, valueSvc } = this.beans;
		const filterValueGetter = filterValueGetterOverride ?? selectableFilter?.getFilterValueGetter(column.getColId()) ?? colDef.filterValueGetter;
		if (filterValueGetter) return this.executeFilterValueGetter(filterValueGetter, rowNode.data, column, rowNode, colDef);
		return valueSvc.getValue(column, rowNode);
	}
	executeFilterValueGetter(valueGetter, data, column, node, colDef) {
		const { expressionSvc, valueSvc } = this.beans;
		const params = _addGridCommonParams(this.gos, {
			data,
			node,
			column,
			colDef,
			getValue: valueSvc.getValueCallback.bind(valueSvc, node)
		});
		if (typeof valueGetter === "function") return valueGetter(params);
		return expressionSvc?.evaluate(valueGetter, params);
	}
};
var OptionsFactory = class {
	constructor() {
		this.customFilterOptions = {};
	}
	init(params, defaultOptions) {
		this.filterOptions = params.filterOptions ?? defaultOptions;
		this.mapCustomOptions();
		this.defaultOption = this.getDefaultItem(params.defaultOption);
	}
	refresh(params, defaultOptions) {
		const filterOptions = params.filterOptions ?? defaultOptions;
		if (this.filterOptions !== filterOptions) {
			this.filterOptions = filterOptions;
			this.customFilterOptions = {};
			this.mapCustomOptions();
		}
		this.defaultOption = this.getDefaultItem(params.defaultOption);
	}
	mapCustomOptions() {
		const { filterOptions } = this;
		if (!filterOptions) return;
		filterOptions.forEach((filterOption) => {
			if (typeof filterOption === "string") return;
			const requiredProperties = [
				["displayKey"],
				["displayName"],
				["predicate", "test"]
			];
			const propertyCheck = (keys) => {
				if (!keys.some((key) => filterOption[key] != null)) {
					_warn(72, { keys });
					return false;
				}
				return true;
			};
			if (!requiredProperties.every(propertyCheck)) {
				this.filterOptions = filterOptions.filter((v$1) => v$1 === filterOption) || [];
				return;
			}
			this.customFilterOptions[filterOption.displayKey] = filterOption;
		});
	}
	getDefaultItem(defaultOption) {
		const { filterOptions } = this;
		if (defaultOption) return defaultOption;
		else if (filterOptions.length >= 1) {
			const firstFilterOption = filterOptions[0];
			if (typeof firstFilterOption === "string") return firstFilterOption;
			else if (firstFilterOption.displayKey) return firstFilterOption.displayKey;
			else _warn(73);
		} else _warn(74);
	}
	getCustomOption(name) {
		return this.customFilterOptions[name];
	}
};
function removeItems(items, startPosition, deleteCount) {
	return deleteCount == null ? items.splice(startPosition) : items.splice(startPosition, deleteCount);
}
function isBlank(cellValue) {
	return cellValue == null || typeof cellValue === "string" && cellValue.trim().length === 0;
}
function getDefaultJoinOperator(defaultJoinOperator) {
	return defaultJoinOperator === "AND" || defaultJoinOperator === "OR" ? defaultJoinOperator : "AND";
}
function evaluateCustomFilter(customFilterOption, values, cellValue) {
	if (customFilterOption == null) return;
	const { predicate } = customFilterOption;
	if (predicate != null && !values.some((v$1) => v$1 == null)) return predicate(values, cellValue);
}
function validateAndUpdateConditions(conditions, maxNumConditions) {
	let numConditions = conditions.length;
	if (numConditions > maxNumConditions) {
		conditions.splice(maxNumConditions);
		_warn(78);
		numConditions = maxNumConditions;
	}
	return numConditions;
}
function getNumberOfInputs(type, optionsFactory) {
	const customOpts = optionsFactory.getCustomOption(type);
	if (customOpts) {
		const { numberOfInputs } = customOpts;
		return numberOfInputs != null ? numberOfInputs : 1;
	}
	if (type && [
		"empty",
		"notBlank",
		"blank"
	].indexOf(type) >= 0) return 0;
	else if (type === "inRange") return 2;
	return 1;
}
var SimpleFilter = class extends ProvidedFilter {
	constructor(filterNameKey, mapValuesFromModel, defaultOptions) {
		super(filterNameKey, "simple-filter");
		this.mapValuesFromModel = mapValuesFromModel;
		this.defaultOptions = defaultOptions;
		this.eTypes = [];
		this.eJoinPanels = [];
		this.eJoinAnds = [];
		this.eJoinOrs = [];
		this.eConditionBodies = [];
		this.listener = () => this.onUiChanged();
		this.lastUiCompletePosition = null;
		this.joinOperatorId = 0;
	}
	setParams(params) {
		super.setParams(params);
		const optionsFactory = new OptionsFactory();
		this.optionsFactory = optionsFactory;
		optionsFactory.init(params, this.defaultOptions);
		this.commonUpdateSimpleParams(params);
		this.createOption();
		this.createMissingConditionsAndOperators();
	}
	updateParams(newParams, oldParams) {
		this.optionsFactory.refresh(newParams, this.defaultOptions);
		super.updateParams(newParams, oldParams);
		this.commonUpdateSimpleParams(newParams);
	}
	commonUpdateSimpleParams(params) {
		this.setNumConditions(params);
		this.defaultJoinOperator = getDefaultJoinOperator(params.defaultJoinOperator);
		this.filterPlaceholder = params.filterPlaceholder;
		this.createFilterListOptions();
		const eGui = this.getGui();
		if (this.isReadOnly()) eGui.setAttribute("tabindex", "-1");
		else eGui.removeAttribute("tabindex");
	}
	onFloatingFilterChanged(type, value) {
		this.setTypeFromFloatingFilter(type);
		this.setValueFromFloatingFilter(value);
		this.onUiChanged("immediately", true);
	}
	setTypeFromFloatingFilter(type) {
		this.eTypes.forEach((eType, position) => {
			const value = position === 0 ? type : this.optionsFactory.defaultOption;
			eType.setValue(value, true);
		});
	}
	getModelFromUi() {
		const conditions = this.getUiCompleteConditions();
		if (conditions.length === 0) return null;
		if (this.maxNumConditions > 1 && conditions.length > 1) return {
			filterType: this.filterType,
			operator: this.getJoinOperator(),
			conditions
		};
		return conditions[0];
	}
	getConditionTypes() {
		return this.eTypes.map((eType) => eType.getValue());
	}
	getConditionType(position) {
		return this.eTypes[position].getValue();
	}
	getJoinOperator() {
		const { eJoinOrs: eJoinOperatorsOr, defaultJoinOperator } = this;
		return eJoinOperatorsOr.length === 0 ? defaultJoinOperator : eJoinOperatorsOr[0].getValue() === true ? "OR" : "AND";
	}
	areNonNullModelsEqual(a, b) {
		const aIsSimple = !a.operator;
		const bIsSimple = !b.operator;
		if (!aIsSimple && bIsSimple || aIsSimple && !bIsSimple) return false;
		let res;
		if (aIsSimple) {
			const aSimple = a;
			const bSimple = b;
			res = this.areSimpleModelsEqual(aSimple, bSimple);
		} else {
			const aCombined = a;
			const bCombined = b;
			res = aCombined.operator === bCombined.operator && _areEqual(aCombined.conditions, bCombined.conditions, (aModel, bModel) => this.areSimpleModelsEqual(aModel, bModel));
		}
		return res;
	}
	setModelIntoUi(model, isInitialLoad) {
		if (model == null) {
			this.resetUiToDefaults(isInitialLoad);
			return AgPromise.resolve();
		}
		if (model.operator) {
			const combinedModel = model;
			let conditions = combinedModel.conditions;
			if (conditions == null) {
				conditions = [];
				_warn(77);
			}
			const numConditions = validateAndUpdateConditions(conditions, this.maxNumConditions);
			const numPrevConditions = this.getNumConditions();
			if (numConditions < numPrevConditions) this.removeConditionsAndOperators(numConditions);
			else if (numConditions > numPrevConditions) for (let i = numPrevConditions; i < numConditions; i++) {
				this.createJoinOperatorPanel();
				this.createOption();
			}
			const orChecked = combinedModel.operator === "OR";
			this.eJoinAnds.forEach((eJoinOperatorAnd) => eJoinOperatorAnd.setValue(!orChecked, true));
			this.eJoinOrs.forEach((eJoinOperatorOr) => eJoinOperatorOr.setValue(orChecked, true));
			conditions.forEach((condition, position) => {
				this.eTypes[position].setValue(condition.type, true);
				this.setConditionIntoUi(condition, position);
			});
		} else {
			const simpleModel = model;
			if (this.getNumConditions() > 1) this.removeConditionsAndOperators(1);
			this.eTypes[0].setValue(simpleModel.type, true);
			this.setConditionIntoUi(simpleModel, 0);
		}
		this.lastUiCompletePosition = this.getNumConditions() - 1;
		this.createMissingConditionsAndOperators();
		this.updateUiVisibility();
		if (!isInitialLoad) this.params.onUiChange(this.getUiChangeEventParams());
		return AgPromise.resolve();
	}
	setNumConditions(params) {
		let maxNumConditions = params.maxNumConditions ?? 2;
		if (maxNumConditions < 1) {
			_warn(79);
			maxNumConditions = 1;
		}
		this.maxNumConditions = maxNumConditions;
		let numAlwaysVisibleConditions = params.numAlwaysVisibleConditions ?? 1;
		if (numAlwaysVisibleConditions < 1) {
			_warn(80);
			numAlwaysVisibleConditions = 1;
		}
		if (numAlwaysVisibleConditions > maxNumConditions) {
			_warn(81);
			numAlwaysVisibleConditions = maxNumConditions;
		}
		this.numAlwaysVisibleConditions = numAlwaysVisibleConditions;
	}
	createOption() {
		const eGui = this.getGui();
		const eType = this.createManagedBean(new AgSelect());
		this.eTypes.push(eType);
		eType.addCss("ag-filter-select");
		eGui.appendChild(eType.getGui());
		const eConditionBody = this.createEValue();
		this.eConditionBodies.push(eConditionBody);
		eGui.appendChild(eConditionBody);
		this.putOptionsIntoDropdown(eType);
		this.resetType(eType);
		const position = this.getNumConditions() - 1;
		this.forEachPositionInput(position, (element) => this.resetInput(element));
		this.addChangedListeners(eType, position);
	}
	createJoinOperatorPanel() {
		const eJoinOperatorPanel = _createElement({
			tag: "div",
			cls: "ag-filter-condition"
		});
		this.eJoinPanels.push(eJoinOperatorPanel);
		const eJoinOperatorAnd = this.createJoinOperator(this.eJoinAnds, eJoinOperatorPanel, "and");
		const eJoinOperatorOr = this.createJoinOperator(this.eJoinOrs, eJoinOperatorPanel, "or");
		this.getGui().appendChild(eJoinOperatorPanel);
		const index = this.eJoinPanels.length - 1;
		const uniqueGroupId = this.joinOperatorId++;
		this.resetJoinOperatorAnd(eJoinOperatorAnd, index, uniqueGroupId);
		this.resetJoinOperatorOr(eJoinOperatorOr, index, uniqueGroupId);
		if (!this.isReadOnly()) {
			eJoinOperatorAnd.onValueChange(this.listener);
			eJoinOperatorOr.onValueChange(this.listener);
		}
	}
	createJoinOperator(eJoinOperators, eJoinOperatorPanel, andOr) {
		const eJoinOperator = this.createManagedBean(new AgRadioButton());
		eJoinOperators.push(eJoinOperator);
		const baseClass = "ag-filter-condition-operator";
		eJoinOperator.addCss(baseClass);
		eJoinOperator.addCss(`${baseClass}-${andOr}`);
		eJoinOperatorPanel.appendChild(eJoinOperator.getGui());
		return eJoinOperator;
	}
	createFilterListOptions() {
		this.filterListOptions = this.optionsFactory.filterOptions.map((option) => typeof option === "string" ? this.createBoilerplateListOption(option) : this.createCustomListOption(option));
	}
	putOptionsIntoDropdown(eType) {
		const { filterListOptions } = this;
		filterListOptions.forEach((listOption) => {
			eType.addOption(listOption);
		});
		eType.setDisabled(filterListOptions.length <= 1);
	}
	createBoilerplateListOption(option) {
		return {
			value: option,
			text: this.translate(option)
		};
	}
	createCustomListOption(option) {
		const { displayKey } = option;
		const customOption = this.optionsFactory.getCustomOption(option.displayKey);
		return {
			value: displayKey,
			text: customOption ? this.getLocaleTextFunc()(customOption.displayKey, customOption.displayName) : this.translate(displayKey)
		};
	}
	createBodyTemplate() {
		return null;
	}
	getAgComponents() {
		return [];
	}
	updateUiVisibility() {
		const joinOperator = this.getJoinOperator();
		this.updateNumConditions();
		this.updateConditionStatusesAndValues(this.lastUiCompletePosition, joinOperator);
	}
	updateNumConditions() {
		let lastUiCompletePosition = -1;
		let areAllConditionsUiComplete = true;
		for (let position = 0; position < this.getNumConditions(); position++) if (this.isConditionUiComplete(position)) lastUiCompletePosition = position;
		else areAllConditionsUiComplete = false;
		if (this.shouldAddNewConditionAtEnd(areAllConditionsUiComplete)) {
			this.createJoinOperatorPanel();
			this.createOption();
		} else {
			const activePosition = this.lastUiCompletePosition ?? this.getNumConditions() - 2;
			if (lastUiCompletePosition < activePosition) {
				this.removeConditionsAndOperators(activePosition + 1);
				const removeStartPosition = lastUiCompletePosition + 1;
				const numConditionsToRemove = activePosition - removeStartPosition;
				if (numConditionsToRemove > 0) this.removeConditionsAndOperators(removeStartPosition, numConditionsToRemove);
				this.createMissingConditionsAndOperators();
			}
		}
		this.lastUiCompletePosition = lastUiCompletePosition;
	}
	updateConditionStatusesAndValues(lastUiCompletePosition, joinOperator) {
		this.eTypes.forEach((eType, position) => {
			const disabled = this.isConditionDisabled(position, lastUiCompletePosition);
			eType.setDisabled(disabled || this.filterListOptions.length <= 1);
			if (position === 1) {
				_setDisabled(this.eJoinPanels[0], disabled);
				this.eJoinAnds[0].setDisabled(disabled);
				this.eJoinOrs[0].setDisabled(disabled);
			}
		});
		this.eConditionBodies.forEach((element, index) => {
			_setDisplayed(element, this.isConditionBodyVisible(index));
		});
		const orChecked = (joinOperator ?? this.getJoinOperator()) === "OR";
		this.eJoinAnds.forEach((eJoinOperatorAnd) => {
			eJoinOperatorAnd.setValue(!orChecked, true);
		});
		this.eJoinOrs.forEach((eJoinOperatorOr) => {
			eJoinOperatorOr.setValue(orChecked, true);
		});
		this.forEachInput((element, index, position, numberOfInputs) => {
			this.setElementDisplayed(element, index < numberOfInputs);
			this.setElementDisabled(element, this.isConditionDisabled(position, lastUiCompletePosition));
		});
		this.resetPlaceholder();
	}
	shouldAddNewConditionAtEnd(areAllConditionsUiComplete) {
		return areAllConditionsUiComplete && this.getNumConditions() < this.maxNumConditions && !this.isReadOnly();
	}
	removeConditionsAndOperators(startPosition, deleteCount) {
		if (startPosition >= this.getNumConditions()) return;
		const { eTypes, eConditionBodies, eJoinPanels: eJoinOperatorPanels, eJoinAnds: eJoinOperatorsAnd, eJoinOrs: eJoinOperatorsOr } = this;
		this.removeComponents(eTypes, startPosition, deleteCount);
		this.removeElements(eConditionBodies, startPosition, deleteCount);
		this.removeEValues(startPosition, deleteCount);
		const joinOperatorIndex = Math.max(startPosition - 1, 0);
		this.removeElements(eJoinOperatorPanels, joinOperatorIndex, deleteCount);
		this.removeComponents(eJoinOperatorsAnd, joinOperatorIndex, deleteCount);
		this.removeComponents(eJoinOperatorsOr, joinOperatorIndex, deleteCount);
	}
	removeElements(elements, startPosition, deleteCount) {
		removeItems(elements, startPosition, deleteCount).forEach((element) => _removeFromParent(element));
	}
	removeComponents(components, startPosition, deleteCount) {
		removeItems(components, startPosition, deleteCount).forEach((comp) => {
			_removeFromParent(comp.getGui());
			this.destroyBean(comp);
		});
	}
	afterGuiAttached(params) {
		super.afterGuiAttached(params);
		this.resetPlaceholder();
		if (!params?.suppressFocus) {
			let elementToFocus;
			if (!this.isReadOnly()) {
				const firstInput = this.getInputs(0)[0];
				if (firstInput instanceof AgAbstractInputField && this.isConditionBodyVisible(0)) elementToFocus = firstInput.getInputElement();
				else elementToFocus = this.eTypes[0]?.getFocusableElement();
			}
			(elementToFocus ?? this.getGui()).focus({ preventScroll: true });
		}
	}
	afterGuiDetached() {
		super.afterGuiDetached();
		const params = this.params;
		if (this.beans.colFilter?.shouldKeepStateOnDetach(params.column)) return;
		params.onStateChange({ model: params.model });
		let lastUiCompletePosition = -1;
		let updatedLastUiCompletePosition = -1;
		let conditionsRemoved = false;
		const joinOperator = this.getJoinOperator();
		for (let position = this.getNumConditions() - 1; position >= 0; position--) if (this.isConditionUiComplete(position)) {
			if (lastUiCompletePosition === -1) {
				lastUiCompletePosition = position;
				updatedLastUiCompletePosition = position;
			}
		} else {
			const shouldRemovePositionAtEnd = position >= this.numAlwaysVisibleConditions && !this.isConditionUiComplete(position - 1);
			const positionBeforeLastUiCompletePosition = position < lastUiCompletePosition;
			if (shouldRemovePositionAtEnd || positionBeforeLastUiCompletePosition) {
				this.removeConditionsAndOperators(position, 1);
				conditionsRemoved = true;
				if (positionBeforeLastUiCompletePosition) updatedLastUiCompletePosition--;
			}
		}
		let shouldUpdateConditionStatusesAndValues = false;
		if (this.getNumConditions() < this.numAlwaysVisibleConditions) {
			this.createMissingConditionsAndOperators();
			shouldUpdateConditionStatusesAndValues = true;
		}
		if (this.shouldAddNewConditionAtEnd(updatedLastUiCompletePosition === this.getNumConditions() - 1)) {
			this.createJoinOperatorPanel();
			this.createOption();
			shouldUpdateConditionStatusesAndValues = true;
		}
		if (shouldUpdateConditionStatusesAndValues) this.updateConditionStatusesAndValues(updatedLastUiCompletePosition, joinOperator);
		if (conditionsRemoved) this.updateJoinOperatorsDisabled();
		this.lastUiCompletePosition = updatedLastUiCompletePosition;
	}
	getModelAsString(model) {
		return this.params.getHandler()?.getModelAsString?.(model) ?? "";
	}
	getPlaceholderText(defaultPlaceholder, position) {
		let placeholder = this.translate(defaultPlaceholder);
		if (typeof this.filterPlaceholder === "function") {
			const filterOptionKey = this.eTypes[position].getValue();
			const filterOption = this.translate(filterOptionKey);
			placeholder = this.filterPlaceholder({
				filterOptionKey,
				filterOption,
				placeholder
			});
		} else if (typeof this.filterPlaceholder === "string") placeholder = this.filterPlaceholder;
		return placeholder;
	}
	resetPlaceholder() {
		const globalTranslate = this.getLocaleTextFunc();
		this.forEachInput((element, index, position, numberOfInputs) => {
			if (!(element instanceof AgAbstractInputField)) return;
			const placeholder = index === 0 && numberOfInputs > 1 ? "inRangeStart" : index === 0 ? "filterOoo" : "inRangeEnd";
			const ariaLabel = index === 0 && numberOfInputs > 1 ? globalTranslate("ariaFilterFromValue", "Filter from value") : index === 0 ? globalTranslate("ariaFilterValue", "Filter Value") : globalTranslate("ariaFilterToValue", "Filter to Value");
			element.setInputPlaceholder(this.getPlaceholderText(placeholder, position));
			element.setInputAriaLabel(ariaLabel);
		});
	}
	setElementValue(element, value, fromFloatingFilter) {
		if (element instanceof AgAbstractInputField) element.setValue(value != null ? String(value) : null, true);
	}
	setElementDisplayed(element, displayed) {
		if (element instanceof Component) _setDisplayed(element.getGui(), displayed);
	}
	setElementDisabled(element, disabled) {
		if (element instanceof Component) _setDisabled(element.getGui(), disabled);
	}
	attachElementOnChange(element, listener) {
		if (element instanceof AgAbstractInputField) element.onValueChange(listener);
	}
	forEachInput(cb) {
		this.getConditionTypes().forEach((type, position) => {
			this.forEachPositionTypeInput(position, type, cb);
		});
	}
	forEachPositionInput(position, cb) {
		const type = this.getConditionType(position);
		this.forEachPositionTypeInput(position, type, cb);
	}
	forEachPositionTypeInput(position, type, cb) {
		const numberOfInputs = getNumberOfInputs(type, this.optionsFactory);
		const inputs = this.getInputs(position);
		for (let index = 0; index < inputs.length; index++) {
			const input = inputs[index];
			if (input != null) cb(input, index, position, numberOfInputs);
		}
	}
	isConditionDisabled(position, lastUiCompletePosition) {
		if (this.isReadOnly()) return true;
		if (position === 0) return false;
		return position > lastUiCompletePosition + 1;
	}
	isConditionBodyVisible(position) {
		return getNumberOfInputs(this.getConditionType(position), this.optionsFactory) > 0;
	}
	isConditionUiComplete(position) {
		if (position >= this.getNumConditions()) return false;
		if (this.getConditionType(position) === "empty") return false;
		if (this.getValues(position).some((v$1) => v$1 == null)) return false;
		return true;
	}
	getNumConditions() {
		return this.eTypes.length;
	}
	getUiCompleteConditions() {
		const conditions = [];
		for (let position = 0; position < this.getNumConditions(); position++) if (this.isConditionUiComplete(position)) conditions.push(this.createCondition(position));
		return conditions;
	}
	createMissingConditionsAndOperators() {
		if (this.isReadOnly()) return;
		for (let i = this.getNumConditions(); i < this.numAlwaysVisibleConditions; i++) {
			this.createJoinOperatorPanel();
			this.createOption();
		}
	}
	resetUiToDefaults(silent) {
		this.removeConditionsAndOperators(this.isReadOnly() ? 1 : this.numAlwaysVisibleConditions);
		this.eTypes.forEach((eType) => this.resetType(eType));
		this.eJoinAnds.forEach((eJoinOperatorAnd, index) => this.resetJoinOperatorAnd(eJoinOperatorAnd, index, this.joinOperatorId + index));
		this.eJoinOrs.forEach((eJoinOperatorOr, index) => this.resetJoinOperatorOr(eJoinOperatorOr, index, this.joinOperatorId + index));
		this.joinOperatorId++;
		this.forEachInput((element) => this.resetInput(element));
		this.resetPlaceholder();
		this.createMissingConditionsAndOperators();
		this.lastUiCompletePosition = null;
		this.updateUiVisibility();
		if (!silent) this.params.onUiChange(this.getUiChangeEventParams());
	}
	resetType(eType) {
		const filteringLabel = this.getLocaleTextFunc()("ariaFilteringOperator", "Filtering operator");
		eType.setValue(this.optionsFactory.defaultOption, true).setAriaLabel(filteringLabel).setDisabled(this.isReadOnly() || this.filterListOptions.length <= 1);
	}
	resetJoinOperatorAnd(eJoinOperatorAnd, index, uniqueGroupId) {
		this.resetJoinOperator(eJoinOperatorAnd, index, this.defaultJoinOperator === "AND", this.translate("andCondition"), uniqueGroupId);
	}
	resetJoinOperatorOr(eJoinOperatorOr, index, uniqueGroupId) {
		this.resetJoinOperator(eJoinOperatorOr, index, this.defaultJoinOperator === "OR", this.translate("orCondition"), uniqueGroupId);
	}
	resetJoinOperator(eJoinOperator, index, value, label, uniqueGroupId) {
		this.updateJoinOperatorDisabled(eJoinOperator.setValue(value, true).setName(`ag-simple-filter-and-or-${this.getCompId()}-${uniqueGroupId}`).setLabel(label), index);
	}
	updateJoinOperatorsDisabled() {
		const updater = (eJoinOperator, index) => this.updateJoinOperatorDisabled(eJoinOperator, index);
		this.eJoinAnds.forEach(updater);
		this.eJoinOrs.forEach(updater);
	}
	updateJoinOperatorDisabled(eJoinOperator, index) {
		eJoinOperator.setDisabled(this.isReadOnly() || index > 0);
	}
	resetInput(element) {
		this.setElementValue(element, null);
		this.setElementDisabled(element, this.isReadOnly());
	}
	setConditionIntoUi(model, position) {
		const values = this.mapValuesFromModel(model, this.optionsFactory);
		this.forEachInput((element, index, elPosition) => {
			if (elPosition !== position) return;
			this.setElementValue(element, values[index] != null ? values[index] : null);
		});
	}
	setValueFromFloatingFilter(value) {
		this.forEachInput((element, index, position) => {
			this.setElementValue(element, index === 0 && position === 0 ? value : null, true);
		});
	}
	addChangedListeners(eType, position) {
		if (this.isReadOnly()) return;
		eType.onValueChange(this.listener);
		this.forEachPositionInput(position, (element) => {
			this.attachElementOnChange(element, this.listener);
		});
	}
	hasInvalidInputs() {
		return false;
	}
	isReadOnly() {
		return !!this.params.readOnly;
	}
};
var DateCompWrapper = class {
	constructor(context, userCompFactory, colDef, dateComponentParams, eParent, onReady) {
		this.alive = true;
		this.context = context;
		this.eParent = eParent;
		const compDetails = _getDateCompDetails(userCompFactory, colDef, dateComponentParams);
		if (!compDetails) return;
		compDetails.newAgStackInstance().then((dateComp) => {
			if (!this.alive) {
				context.destroyBean(dateComp);
				return;
			}
			this.dateComp = dateComp;
			if (!dateComp) return;
			eParent.appendChild(dateComp.getGui());
			dateComp?.afterGuiAttached?.();
			const { tempValue, disabled } = this;
			if (tempValue) dateComp.setDate(tempValue);
			if (disabled != null) dateComp.setDisabled?.(disabled);
			onReady?.(this);
		});
	}
	destroy() {
		this.alive = false;
		this.dateComp = this.context.destroyBean(this.dateComp);
	}
	getDate() {
		return this.dateComp ? this.dateComp.getDate() : this.tempValue;
	}
	setDate(value) {
		const dateComp = this.dateComp;
		if (dateComp) dateComp.setDate(value);
		else this.tempValue = value;
	}
	setDisabled(disabled) {
		const dateComp = this.dateComp;
		if (dateComp) dateComp.setDisabled?.(disabled);
		else this.disabled = disabled;
	}
	setDisplayed(displayed) {
		_setDisplayed(this.eParent, displayed);
	}
	setInputPlaceholder(placeholder) {
		this.dateComp?.setInputPlaceholder?.(placeholder);
	}
	setInputAriaLabel(label) {
		this.dateComp?.setInputAriaLabel?.(label);
	}
	afterGuiAttached(params) {
		this.dateComp?.afterGuiAttached?.(params);
	}
	updateParams(params) {
		this.dateComp?.refresh?.(params);
	}
};
var DEFAULT_DATE_FILTER_OPTIONS = [
	"equals",
	"notEqual",
	"lessThan",
	"greaterThan",
	"inRange",
	"blank",
	"notBlank"
];
function mapValuesFromDateFilterModel(filterModel, optionsFactory) {
	const { dateFrom, dateTo, type } = filterModel || {};
	return [dateFrom && _parseDateTimeFromString(dateFrom) || null, dateTo && _parseDateTimeFromString(dateTo) || null].slice(0, getNumberOfInputs(type, optionsFactory));
}
var DEFAULT_MIN_YEAR = 1e3;
var DEFAULT_MAX_YEAR = Infinity;
var DateFilter = class extends SimpleFilter {
	constructor() {
		super("dateFilter", mapValuesFromDateFilterModel, DEFAULT_DATE_FILTER_OPTIONS);
		this.eConditionPanelsFrom = [];
		this.eConditionPanelsTo = [];
		this.dateConditionFromComps = [];
		this.dateConditionToComps = [];
		this.minValidYear = DEFAULT_MIN_YEAR;
		this.maxValidYear = DEFAULT_MAX_YEAR;
		this.minValidDate = null;
		this.maxValidDate = null;
		this.filterType = "date";
	}
	afterGuiAttached(params) {
		super.afterGuiAttached(params);
		this.dateConditionFromComps[0].afterGuiAttached(params);
	}
	commonUpdateSimpleParams(params) {
		super.commonUpdateSimpleParams(params);
		const yearParser = (param, fallback) => {
			const value = params[param];
			if (value != null) if (!isNaN(value)) return value == null ? fallback : Number(value);
			else _warn(82, { param });
			return fallback;
		};
		const minValidYear = yearParser("minValidYear", DEFAULT_MIN_YEAR);
		const maxValidYear = yearParser("maxValidYear", DEFAULT_MAX_YEAR);
		this.minValidYear = minValidYear;
		this.maxValidYear = maxValidYear;
		if (minValidYear > maxValidYear) _warn(83);
		const { minValidDate, maxValidDate } = params;
		const parsedMinValidDate = minValidDate instanceof Date ? minValidDate : _parseDateTimeFromString(minValidDate);
		this.minValidDate = parsedMinValidDate;
		const parsedMaxValidDate = maxValidDate instanceof Date ? maxValidDate : _parseDateTimeFromString(maxValidDate);
		this.maxValidDate = parsedMaxValidDate;
		if (parsedMinValidDate && parsedMaxValidDate && parsedMinValidDate > parsedMaxValidDate) _warn(84);
	}
	createDateCompWrapper(element) {
		const { beans: { userCompFactory, context, gos }, params } = this;
		const dateCompWrapper = new DateCompWrapper(context, userCompFactory, params.colDef, _addGridCommonParams(gos, {
			onDateChanged: () => this.onUiChanged(),
			filterParams: params,
			location: "filter"
		}), element);
		this.addDestroyFunc(() => dateCompWrapper.destroy());
		return dateCompWrapper;
	}
	setElementValue(element, value) {
		element.setDate(value);
	}
	setElementDisplayed(element, displayed) {
		element.setDisplayed(displayed);
	}
	setElementDisabled(element, disabled) {
		element.setDisabled(disabled);
	}
	createEValue() {
		const eCondition = _createElement({
			tag: "div",
			cls: "ag-filter-body"
		});
		this.createFromToElement(eCondition, this.eConditionPanelsFrom, this.dateConditionFromComps, "from");
		this.createFromToElement(eCondition, this.eConditionPanelsTo, this.dateConditionToComps, "to");
		return eCondition;
	}
	createFromToElement(eCondition, eConditionPanels, dateConditionComps, fromTo) {
		const eConditionPanel = _createElement({
			tag: "div",
			cls: `ag-filter-${fromTo} ag-filter-date-${fromTo}`
		});
		eConditionPanels.push(eConditionPanel);
		eCondition.appendChild(eConditionPanel);
		dateConditionComps.push(this.createDateCompWrapper(eConditionPanel));
	}
	removeEValues(startPosition, deleteCount) {
		this.removeDateComps(this.dateConditionFromComps, startPosition, deleteCount);
		this.removeDateComps(this.dateConditionToComps, startPosition, deleteCount);
		removeItems(this.eConditionPanelsFrom, startPosition, deleteCount);
		removeItems(this.eConditionPanelsTo, startPosition, deleteCount);
	}
	removeDateComps(components, startPosition, deleteCount) {
		removeItems(components, startPosition, deleteCount).forEach((comp) => comp.destroy());
	}
	isValidDateValue(value) {
		if (value === null) return false;
		const { minValidDate, maxValidDate, minValidYear, maxValidYear } = this;
		if (minValidDate) {
			if (value < minValidDate) return false;
		} else if (value.getUTCFullYear() < minValidYear) return false;
		if (maxValidDate) {
			if (value > maxValidDate) return false;
		} else if (value.getUTCFullYear() > maxValidYear) return false;
		return true;
	}
	isConditionUiComplete(position) {
		if (!super.isConditionUiComplete(position)) return false;
		let valid = true;
		this.forEachInput((element, index, elPosition, numberOfInputs) => {
			if (elPosition !== position || !valid || index >= numberOfInputs) return;
			valid = valid && this.isValidDateValue(element.getDate());
		});
		return valid;
	}
	areSimpleModelsEqual(aSimple, bSimple) {
		return aSimple.dateFrom === bSimple.dateFrom && aSimple.dateTo === bSimple.dateTo && aSimple.type === bSimple.type;
	}
	createCondition(position) {
		const type = this.getConditionType(position);
		const model = {};
		const values = this.getValues(position);
		if (values.length > 0) model.dateFrom = _serialiseDate(values[0]);
		if (values.length > 1) model.dateTo = _serialiseDate(values[1]);
		return {
			dateFrom: null,
			dateTo: null,
			filterType: this.filterType,
			type,
			...model
		};
	}
	resetPlaceholder() {
		const globalTranslate = this.getLocaleTextFunc();
		const placeholder = this.translate("dateFormatOoo");
		const ariaLabel = globalTranslate("ariaFilterValue", "Filter Value");
		this.forEachInput((element) => {
			element.setInputPlaceholder(placeholder);
			element.setInputAriaLabel(ariaLabel);
		});
	}
	getInputs(position) {
		const { dateConditionFromComps, dateConditionToComps } = this;
		if (position >= dateConditionFromComps.length) return [null, null];
		return [dateConditionFromComps[position], dateConditionToComps[position]];
	}
	getValues(position) {
		const result = [];
		this.forEachPositionInput(position, (element, index, _elPosition, numberOfInputs) => {
			if (index < numberOfInputs) result.push(element.getDate());
		});
		return result;
	}
	translate(key) {
		if (key === "lessThan") return super.translate("before");
		if (key === "greaterThan") return super.translate("after");
		return super.translate(key);
	}
};
var SimpleFilterHandler = class extends BeanStub {
	constructor(mapValuesFromModel, defaultOptions) {
		super();
		this.mapValuesFromModel = mapValuesFromModel;
		this.defaultOptions = defaultOptions;
	}
	init(params) {
		const filterParams = params.filterParams;
		const optionsFactory = new OptionsFactory();
		this.optionsFactory = optionsFactory;
		optionsFactory.init(filterParams, this.defaultOptions);
		this.filterModelFormatter = this.createManagedBean(new this.FilterModelFormatterClass(optionsFactory, filterParams));
		this.updateParams(params);
		this.validateModel(params);
	}
	refresh(params) {
		if (params.source === "colDef") {
			const filterParams = params.filterParams;
			const optionsFactory = this.optionsFactory;
			optionsFactory.refresh(filterParams, this.defaultOptions);
			this.filterModelFormatter.updateParams({
				optionsFactory,
				filterParams
			});
			this.updateParams(params);
		}
		this.validateModel(params);
	}
	updateParams(params) {
		this.params = params;
	}
	doesFilterPass(params) {
		const model = params.model;
		if (model == null) return true;
		const { operator } = model;
		const models = [];
		if (operator) {
			const combinedModel = model;
			models.push(...combinedModel.conditions ?? []);
		} else models.push(model);
		const combineFunction = operator && operator === "OR" ? "some" : "every";
		const cellValue = this.params.getValue(params.node);
		return models[combineFunction]((m) => this.individualConditionPasses(params, m, cellValue));
	}
	getModelAsString(model, source) {
		return this.filterModelFormatter.getModelAsString(model, source) ?? "";
	}
	validateModel(params) {
		const { model, filterParams: { filterOptions, maxNumConditions } } = params;
		if (model == null) return;
		let conditions = isCombinedFilterModel(model) ? model.conditions : [model];
		const newOptionsList = filterOptions?.map((option) => typeof option === "string" ? option : option.displayKey) ?? this.defaultOptions;
		if (!(!conditions || conditions.every((condition) => newOptionsList.find((option) => option === condition.type) !== void 0))) {
			this.params = {
				...params,
				model: null
			};
			params.onModelChange(null);
			return;
		}
		let needsUpdate = false;
		const filterType = this.filterType;
		if (conditions && !conditions.every((condition) => condition.filterType === filterType) || model.filterType !== filterType) {
			conditions = conditions.map((condition) => ({
				...condition,
				filterType
			}));
			needsUpdate = true;
		}
		if (typeof maxNumConditions === "number" && conditions && conditions.length > maxNumConditions) {
			conditions = conditions.slice(0, maxNumConditions);
			needsUpdate = true;
		}
		if (needsUpdate) {
			const updatedModel = conditions.length > 1 ? {
				...model,
				filterType,
				conditions
			} : {
				...conditions[0],
				filterType
			};
			this.params = {
				...params,
				model: updatedModel
			};
			params.onModelChange(updatedModel);
			return;
		}
	}
	individualConditionPasses(params, filterModel, cellValue) {
		const optionsFactory = this.optionsFactory;
		const values = this.mapValuesFromModel(filterModel, optionsFactory);
		const customFilterResult = evaluateCustomFilter(optionsFactory.getCustomOption(filterModel.type), values, cellValue);
		if (customFilterResult != null) return customFilterResult;
		if (cellValue == null) return this.evaluateNullValue(filterModel.type);
		return this.evaluateNonNullValue(values, cellValue, filterModel, params);
	}
};
var ScalarFilterHandler = class extends SimpleFilterHandler {
	evaluateNullValue(filterType) {
		const { includeBlanksInEquals, includeBlanksInNotEqual, includeBlanksInGreaterThan, includeBlanksInLessThan, includeBlanksInRange } = this.params.filterParams;
		switch (filterType) {
			case "equals":
				if (includeBlanksInEquals) return true;
				break;
			case "notEqual":
				if (includeBlanksInNotEqual) return true;
				break;
			case "greaterThan":
			case "greaterThanOrEqual":
				if (includeBlanksInGreaterThan) return true;
				break;
			case "lessThan":
			case "lessThanOrEqual":
				if (includeBlanksInLessThan) return true;
				break;
			case "inRange":
				if (includeBlanksInRange) return true;
				break;
			case "blank": return true;
			case "notBlank": return false;
		}
		return false;
	}
	evaluateNonNullValue(values, cellValue, filterModel) {
		const type = filterModel.type;
		if (!this.isValid(cellValue)) return type === "notEqual" || type === "notBlank";
		const comparator = this.comparator();
		const compareResult = values[0] != null ? comparator(values[0], cellValue) : 0;
		switch (type) {
			case "equals": return compareResult === 0;
			case "notEqual": return compareResult !== 0;
			case "greaterThan": return compareResult > 0;
			case "greaterThanOrEqual": return compareResult >= 0;
			case "lessThan": return compareResult < 0;
			case "lessThanOrEqual": return compareResult <= 0;
			case "inRange": {
				const compareToResult = comparator(values[1], cellValue);
				return this.params.filterParams.inRangeInclusive ? compareResult >= 0 && compareToResult <= 0 : compareResult > 0 && compareToResult < 0;
			}
			case "blank": return isBlank(cellValue);
			case "notBlank": return !isBlank(cellValue);
			default:
				_warn(76, { filterModelType: type });
				return true;
		}
	}
};
var SCALAR_FILTER_TYPE_KEYS = {
	equals: "Equals",
	notEqual: "NotEqual",
	greaterThan: "GreaterThan",
	greaterThanOrEqual: "GreaterThanOrEqual",
	lessThan: "LessThan",
	lessThanOrEqual: "LessThanOrEqual",
	inRange: "InRange"
};
var TEXT_FILTER_TYPE_KEYS = {
	contains: "Contains",
	notContains: "NotContains",
	equals: "TextEquals",
	notEqual: "TextNotEqual",
	startsWith: "StartsWith",
	endsWith: "EndsWith",
	inRange: "InRange"
};
var SimpleFilterModelFormatter = class extends BeanStub {
	constructor(optionsFactory, filterParams, valueFormatter) {
		super();
		this.optionsFactory = optionsFactory;
		this.filterParams = filterParams;
		this.valueFormatter = valueFormatter;
	}
	getModelAsString(model, source) {
		const translate = this.getLocaleTextFunc();
		const forToolPanel = source === "filterToolPanel";
		if (!model) return forToolPanel ? translateForFilter(this, "filterSummaryInactive") : null;
		if (model.operator != null) {
			const combinedModel = model;
			const customOptions = (combinedModel.conditions ?? []).map((condition) => this.getModelAsString(condition, source));
			const joinOperatorTranslateKey = combinedModel.operator === "AND" ? "andCondition" : "orCondition";
			return customOptions.join(` ${translateForFilter(this, joinOperatorTranslateKey)} `);
		} else if (model.type === "blank" || model.type === "notBlank") return forToolPanel ? translateForFilter(this, model.type === "blank" ? "filterSummaryBlank" : "filterSummaryNotBlank") : translate(model.type, model.type);
		else {
			const condition = model;
			const { displayKey, displayName, numberOfInputs } = this.optionsFactory.getCustomOption(condition.type) || {};
			if (displayKey && displayName && numberOfInputs === 0) return translate(displayKey, displayName);
			return this.conditionToString(condition, forToolPanel, condition.type === "inRange" || numberOfInputs === 2, displayKey, displayName);
		}
	}
	updateParams(params) {
		const { optionsFactory, filterParams } = params;
		this.optionsFactory = optionsFactory;
		this.filterParams = filterParams;
	}
	conditionForToolPanel(type, isRange, getFilter, getFilterTo, customDisplayKey, customDisplayName) {
		let typeValue;
		const typeKey = this.getTypeKey(type);
		if (typeKey) typeValue = translateForFilter(this, typeKey);
		if (customDisplayKey && customDisplayName) typeValue = this.getLocaleTextFunc()(customDisplayKey, customDisplayName);
		if (typeValue != null) if (isRange) return `${typeValue} ${translateForFilter(this, "filterSummaryInRangeValues", [getFilter(), getFilterTo()])}`;
		else return `${typeValue} ${getFilter()}`;
		return null;
	}
	getTypeKey(type) {
		const suffix = this.filterTypeKeys[type];
		return suffix ? `filterSummary${suffix}` : null;
	}
	formatValue(value) {
		const valueFormatter = this.valueFormatter;
		return valueFormatter ? valueFormatter(value ?? null) ?? "" : String(value);
	}
};
var DateFilterModelFormatter = class extends SimpleFilterModelFormatter {
	constructor(optionsFactory, filterParams) {
		super(optionsFactory, filterParams, (value) => {
			const { dataTypeSvc, valueSvc } = this.beans;
			const column = filterParams.column;
			const dateFormatFn = dataTypeSvc?.getDateFormatterFunction(column);
			const dateStringStringValue = dateFormatFn?.(value ?? void 0);
			return valueSvc.formatValue(column, null, dateStringStringValue);
		});
		this.filterTypeKeys = SCALAR_FILTER_TYPE_KEYS;
	}
	conditionToString(condition, forToolPanel, isRange, customDisplayKey, customDisplayName) {
		const { type } = condition;
		const dateFrom = _parseDateTimeFromString(condition.dateFrom);
		const dateTo = _parseDateTimeFromString(condition.dateTo);
		const format = this.filterParams.inRangeFloatingFilterDateFormat;
		const formatDate = forToolPanel ? this.formatValue.bind(this) : (value) => _dateToFormattedString(value, format);
		const formattedFrom = () => dateFrom !== null ? formatDate(dateFrom) : "null";
		const formattedTo = () => dateTo !== null ? formatDate(dateTo) : "null";
		if (forToolPanel) {
			const valueForToolPanel = this.conditionForToolPanel(type, isRange, formattedFrom, formattedTo, customDisplayKey, customDisplayName);
			if (valueForToolPanel != null) return valueForToolPanel;
		}
		if (isRange) return `${formattedFrom()}-${formattedTo()}`;
		if (dateFrom != null) return formatDate(dateFrom);
		return `${type}`;
	}
};
function defaultDateComparator(filterDate, cellValue) {
	const cellAsDate = cellValue;
	if (cellAsDate < filterDate) return -1;
	if (cellAsDate > filterDate) return 1;
	return 0;
}
var DateFilterHandler = class extends ScalarFilterHandler {
	constructor() {
		super(mapValuesFromDateFilterModel, DEFAULT_DATE_FILTER_OPTIONS);
		this.filterType = "date";
		this.FilterModelFormatterClass = DateFilterModelFormatter;
	}
	comparator() {
		return this.params.filterParams.comparator ?? defaultDateComparator;
	}
	isValid(value) {
		const isValidDate2 = this.params.filterParams.isValidDate;
		return !isValidDate2 || isValidDate2(value);
	}
};
var SimpleFloatingFilter = class extends Component {
	constructor() {
		super(...arguments);
		this.defaultDebounceMs = 0;
	}
	setLastTypeFromModel(model) {
		if (!model) {
			this.lastType = this.optionsFactory.defaultOption;
			return;
		}
		const isCombined = model.operator;
		let condition;
		if (isCombined) condition = model.conditions[0];
		else condition = model;
		this.lastType = condition.type;
	}
	canWeEditAfterModelFromParentFilter(model) {
		if (!model) return this.isTypeEditable(this.lastType);
		if (model.operator) return false;
		const simpleModel = model;
		return this.isTypeEditable(simpleModel.type);
	}
	init(params) {
		this.params = params;
		const reactive = this.gos.get("enableFilterHandlers");
		this.reactive = reactive;
		this.setParams(params);
		if (reactive) {
			const reactiveParams = params;
			this.onModelUpdated(reactiveParams.model);
		}
	}
	setParams(params) {
		const optionsFactory = new OptionsFactory();
		this.optionsFactory = optionsFactory;
		optionsFactory.init(params.filterParams, this.defaultOptions);
		this.filterModelFormatter = this.createManagedBean(new this.FilterModelFormatterClass(optionsFactory, params.filterParams));
		this.setSimpleParams(params, false);
	}
	setSimpleParams(params, update = true) {
		const defaultOption = this.optionsFactory.defaultOption;
		if (!update) this.lastType = defaultOption;
		this.readOnly = !!params.filterParams.readOnly;
		const editable = this.isTypeEditable(defaultOption);
		this.setEditable(editable);
	}
	refresh(params) {
		this.params = params;
		const reactiveParams = params;
		const reactive = this.reactive;
		if (!reactive || reactiveParams.source === "colDef") this.updateParams(params);
		if (reactive) {
			const { source, model } = reactiveParams;
			if (source === "dataChanged" || source === "ui") return;
			this.onModelUpdated(model);
		}
	}
	updateParams(params) {
		const optionsFactory = this.optionsFactory;
		optionsFactory.refresh(params.filterParams, this.defaultOptions);
		this.setSimpleParams(params);
		this.filterModelFormatter.updateParams({
			optionsFactory,
			filterParams: params.filterParams
		});
	}
	onParentModelChanged(model, event) {
		if (event?.afterFloatingFilter || event?.afterDataChange) return;
		this.onModelUpdated(model);
	}
	hasSingleInput(filterType) {
		const numberOfInputs = this.optionsFactory.getCustomOption(filterType)?.numberOfInputs;
		return numberOfInputs == null || numberOfInputs == 1;
	}
	isTypeEditable(type) {
		return !!type && !this.readOnly && this.hasSingleInput(type) && [
			"inRange",
			"empty",
			"blank",
			"notBlank"
		].indexOf(type) < 0;
	}
	getAriaLabel(params) {
		return `${this.beans.colNames.getDisplayNameForColumn(params.column, "header", true)} ${this.getLocaleTextFunc()("ariaFilterInput", "Filter Input")}`;
	}
};
var DateFloatingFilterElement = {
	tag: "div",
	cls: "ag-floating-filter-input",
	role: "presentation",
	children: [{
		tag: "ag-input-text-field",
		ref: "eReadOnlyText"
	}, {
		tag: "div",
		ref: "eDateWrapper",
		cls: "ag-date-floating-filter-wrapper"
	}]
};
var DateFloatingFilter = class extends SimpleFloatingFilter {
	constructor() {
		super(DateFloatingFilterElement, [AgInputTextFieldSelector]);
		this.eReadOnlyText = null;
		this.eDateWrapper = null;
		this.FilterModelFormatterClass = DateFilterModelFormatter;
		this.filterType = "date";
		this.defaultOptions = DEFAULT_DATE_FILTER_OPTIONS;
	}
	setParams(params) {
		super.setParams(params);
		this.createDateComponent();
		const translate = this.getLocaleTextFunc();
		this.eReadOnlyText.setDisabled(true).setInputAriaLabel(translate("ariaDateFilterInput", "Date Filter Input"));
	}
	updateParams(params) {
		super.updateParams(params);
		this.dateComp.updateParams(this.getDateComponentParams());
		this.updateCompOnModelChange(params.currentParentModel());
	}
	updateCompOnModelChange(model) {
		const allowEditing = !this.readOnly && this.canWeEditAfterModelFromParentFilter(model);
		this.setEditable(allowEditing);
		if (allowEditing) {
			const dateModel = model ? _parseDateTimeFromString(model.dateFrom) : null;
			this.dateComp.setDate(dateModel);
			this.eReadOnlyText.setValue("");
		} else {
			this.eReadOnlyText.setValue(this.filterModelFormatter.getModelAsString(model));
			this.dateComp.setDate(null);
		}
	}
	setEditable(editable) {
		_setDisplayed(this.eDateWrapper, editable);
		_setDisplayed(this.eReadOnlyText.getGui(), !editable);
	}
	onModelUpdated(model) {
		super.setLastTypeFromModel(model);
		this.updateCompOnModelChange(model);
	}
	onDateChanged() {
		const filterValueDate = this.dateComp.getDate();
		if (this.reactive) {
			const reactiveParams = this.params;
			reactiveParams.onUiChange();
			const model = reactiveParams.model;
			const filterValueText = _serialiseDate(filterValueDate);
			const newModel = filterValueText == null ? null : {
				...model ?? {
					filterType: this.filterType,
					type: this.lastType ?? this.optionsFactory.defaultOption
				},
				dateFrom: filterValueText
			};
			reactiveParams.onModelChange(newModel, { afterFloatingFilter: true });
		} else this.params.parentFilterInstance((filterInstance) => {
			filterInstance?.onFloatingFilterChanged(this.lastType || null, filterValueDate);
		});
	}
	getDateComponentParams() {
		const { filterParams } = this.params;
		const debounceMs = getDebounceMs(filterParams, this.defaultDebounceMs);
		return _addGridCommonParams(this.gos, {
			onDateChanged: _debounce(this, this.onDateChanged.bind(this), debounceMs),
			filterParams,
			location: "floatingFilter"
		});
	}
	createDateComponent() {
		const { beans: { context, userCompFactory }, eDateWrapper, params } = this;
		this.dateComp = new DateCompWrapper(context, userCompFactory, params.column.getColDef(), this.getDateComponentParams(), eDateWrapper, (dateComp) => {
			dateComp.setInputAriaLabel(this.getAriaLabel(params));
		});
		this.addDestroyFunc(() => this.dateComp.destroy());
	}
};
var DefaultDateElement = {
	tag: "div",
	cls: "ag-filter-filter",
	children: [{
		tag: "ag-input-text-field",
		ref: "eDateInput",
		cls: "ag-date-filter"
	}]
};
var DefaultDateComponent = class extends Component {
	constructor() {
		super(DefaultDateElement, [AgInputTextFieldSelector]);
		this.eDateInput = null;
		this.isApply = false;
		this.applyOnFocusOut = false;
	}
	init(params) {
		this.params = params;
		this.setParams(params);
		const inputElement = this.eDateInput.getInputElement();
		this.addManagedListeners(inputElement, {
			mouseDown: () => {
				if (this.eDateInput.isDisabled() || this.usingSafariDatePicker) return;
				inputElement.focus({ preventScroll: true });
			},
			input: this.handleInput.bind(this, false),
			change: this.handleInput.bind(this, true),
			focusout: this.handleFocusOut.bind(this)
		});
	}
	handleInput(isChange) {
		if (this.eDateInput.isDisabled()) return;
		if (this.isApply) {
			this.applyOnFocusOut = !isChange;
			if (isChange) this.params.onDateChanged();
			return;
		}
		if (!isChange) this.params.onDateChanged();
	}
	handleFocusOut() {
		if (this.applyOnFocusOut) {
			this.applyOnFocusOut = false;
			this.params.onDateChanged();
		}
	}
	setParams(params) {
		const inputElement = this.eDateInput.getInputElement();
		const shouldUseBrowserDatePicker = this.shouldUseBrowserDatePicker(params);
		this.usingSafariDatePicker = shouldUseBrowserDatePicker && _isBrowserSafari();
		const { minValidYear, maxValidYear, minValidDate, maxValidDate, buttons, includeTime, colDef } = params.filterParams || {};
		const dataTypeSvc = this.beans.dataTypeSvc;
		const shouldUseDateTimeLocal = includeTime ?? dataTypeSvc?.getDateIncludesTimeFlag?.(colDef.cellDataType) ?? false;
		if (shouldUseBrowserDatePicker) if (shouldUseDateTimeLocal) {
			inputElement.type = "datetime-local";
			inputElement.step = "1";
		} else inputElement.type = "date";
		else inputElement.type = "text";
		if (minValidDate && minValidYear) _warn(85);
		if (maxValidDate && maxValidYear) _warn(86);
		if (minValidDate && maxValidDate) {
			const [parsedMinValidDate, parsedMaxValidDate] = [minValidDate, maxValidDate].map((v$1) => v$1 instanceof Date ? v$1 : _parseDateTimeFromString(v$1));
			if (parsedMinValidDate && parsedMaxValidDate && parsedMinValidDate.getTime() > parsedMaxValidDate.getTime()) _warn(87);
		}
		if (minValidDate) if (minValidDate instanceof Date) inputElement.min = _dateToFormattedString(minValidDate);
		else inputElement.min = minValidDate;
		else if (minValidYear) inputElement.min = `${minValidYear}-01-01`;
		if (maxValidDate) if (maxValidDate instanceof Date) inputElement.max = _dateToFormattedString(maxValidDate);
		else inputElement.max = maxValidDate;
		else if (maxValidYear) inputElement.max = `${maxValidYear}-12-31`;
		this.isApply = params.location === "floatingFilter" && !!buttons?.includes("apply");
	}
	refresh(params) {
		this.params = params;
		this.setParams(params);
	}
	getDate() {
		return _parseDateTimeFromString(this.eDateInput.getValue());
	}
	setDate(date) {
		const colType = this.params.filterParams.colDef.cellDataType;
		const includeTime = this.beans.dataTypeSvc?.getDateIncludesTimeFlag(colType) ?? false;
		this.eDateInput.setValue(_serialiseDate(date, includeTime));
	}
	setInputPlaceholder(placeholder) {
		this.eDateInput.setInputPlaceholder(placeholder);
	}
	setInputAriaLabel(ariaLabel) {
		this.eDateInput.setAriaLabel(ariaLabel);
	}
	setDisabled(disabled) {
		this.eDateInput.setDisabled(disabled);
	}
	afterGuiAttached(params) {
		if (!params || !params.suppressFocus) this.eDateInput.getInputElement().focus({ preventScroll: true });
	}
	shouldUseBrowserDatePicker(params) {
		return params?.filterParams?.browserDatePicker ?? true;
	}
};
var DEFAULT_NUMBER_FILTER_OPTIONS = [
	"equals",
	"notEqual",
	"greaterThan",
	"greaterThanOrEqual",
	"lessThan",
	"lessThanOrEqual",
	"inRange",
	"blank",
	"notBlank"
];
function getAllowedCharPattern(filterParams) {
	const { allowedCharPattern } = filterParams ?? {};
	return allowedCharPattern ?? null;
}
function processNumberFilterValue(value) {
	if (value == null) return null;
	return isNaN(value) ? null : value;
}
function mapValuesFromNumberFilterModel(filterModel, optionsFactory) {
	const { filter, filterTo, type } = filterModel || {};
	return [processNumberFilterValue(filter), processNumberFilterValue(filterTo)].slice(0, getNumberOfInputs(type, optionsFactory));
}
var NumberFilter = class extends SimpleFilter {
	constructor() {
		super("numberFilter", mapValuesFromNumberFilterModel, DEFAULT_NUMBER_FILTER_OPTIONS);
		this.eValuesFrom = [];
		this.eValuesTo = [];
		this.filterType = "number";
		this.defaultDebounceMs = 500;
	}
	setElementValue(element, value, fromFloatingFilter) {
		const { numberFormatter } = this.params;
		const valueToSet = !fromFloatingFilter && numberFormatter ? numberFormatter(value ?? null) : value;
		super.setElementValue(element, valueToSet);
	}
	createEValue() {
		const allowedCharPattern = getAllowedCharPattern(this.params);
		const eCondition = _createElement({
			tag: "div",
			cls: "ag-filter-body",
			role: "presentation"
		});
		this.createFromToElement(eCondition, this.eValuesFrom, "from", allowedCharPattern);
		this.createFromToElement(eCondition, this.eValuesTo, "to", allowedCharPattern);
		return eCondition;
	}
	createFromToElement(eCondition, eValues, fromTo, allowedCharPattern) {
		const eValue = this.createManagedBean(allowedCharPattern ? new AgInputTextField({ allowedCharPattern }) : new AgInputNumberField());
		eValue.addCss(`ag-filter-${fromTo}`);
		eValue.addCss("ag-filter-filter");
		eValues.push(eValue);
		eCondition.appendChild(eValue.getGui());
	}
	removeEValues(startPosition, deleteCount) {
		const removeComps = (eGui) => this.removeComponents(eGui, startPosition, deleteCount);
		removeComps(this.eValuesFrom);
		removeComps(this.eValuesTo);
	}
	getValues(position) {
		const result = [];
		this.forEachPositionInput(position, (element, index, _elPosition, numberOfInputs) => {
			if (index < numberOfInputs) result.push(processNumberFilterValue(this.stringToFloat(element.getValue())));
		});
		return result;
	}
	areSimpleModelsEqual(aSimple, bSimple) {
		return aSimple.filter === bSimple.filter && aSimple.filterTo === bSimple.filterTo && aSimple.type === bSimple.type;
	}
	stringToFloat(value) {
		if (typeof value === "number") return value;
		let filterText = _makeNull(value);
		if (filterText != null && filterText.trim() === "") filterText = null;
		const numberParser = this.params.numberParser;
		if (numberParser) return numberParser(filterText);
		return filterText == null || filterText.trim() === "-" ? null : parseFloat(filterText);
	}
	createCondition(position) {
		const type = this.getConditionType(position);
		const model = {
			filterType: this.filterType,
			type
		};
		const values = this.getValues(position);
		if (values.length > 0) model.filter = values[0];
		if (values.length > 1) model.filterTo = values[1];
		return model;
	}
	getInputs(position) {
		const { eValuesFrom, eValuesTo } = this;
		if (position >= eValuesFrom.length) return [null, null];
		return [eValuesFrom[position], eValuesTo[position]];
	}
	hasInvalidInputs() {
		let invalidInputs = false;
		this.forEachInput((element) => {
			if (!element.getInputElement().validity.valid) {
				invalidInputs = true;
				return;
			}
		});
		return invalidInputs;
	}
};
var NumberFilterModelFormatter = class extends SimpleFilterModelFormatter {
	constructor(optionsFactory, filterParams) {
		super(optionsFactory, filterParams, filterParams.numberFormatter);
		this.filterTypeKeys = SCALAR_FILTER_TYPE_KEYS;
	}
	conditionToString(condition, forToolPanel, isRange, customDisplayKey, customDisplayName) {
		const { filter, filterTo, type } = condition;
		const formatValue = this.formatValue.bind(this);
		if (forToolPanel) {
			const valueForToolPanel = this.conditionForToolPanel(type, isRange, () => formatValue(filter), () => formatValue(filterTo), customDisplayKey, customDisplayName);
			if (valueForToolPanel != null) return valueForToolPanel;
		}
		if (isRange) return `${formatValue(filter)}-${formatValue(filterTo)}`;
		if (filter != null) return formatValue(filter);
		return `${type}`;
	}
};
var NumberFilterHandler = class extends ScalarFilterHandler {
	constructor() {
		super(mapValuesFromNumberFilterModel, DEFAULT_NUMBER_FILTER_OPTIONS);
		this.filterType = "number";
		this.FilterModelFormatterClass = NumberFilterModelFormatter;
	}
	comparator() {
		return (left, right) => {
			if (left === right) return 0;
			return left < right ? 1 : -1;
		};
	}
	isValid(value) {
		return !isNaN(value);
	}
};
var FloatingFilterTextInputService = class extends BeanStub {
	constructor(params) {
		super();
		this.params = params;
		this.eInput = null;
		this.onValueChanged = () => {};
	}
	setupGui(parentElement) {
		this.eInput = this.createManagedBean(new AgInputTextField(this.params?.config));
		const eInput = this.eInput.getGui();
		parentElement.appendChild(eInput);
		const listener = (e) => this.onValueChanged(e);
		this.addManagedListeners(eInput, {
			input: listener,
			keydown: listener
		});
	}
	setEditable(editable) {
		this.eInput.setDisabled(!editable);
	}
	getValue() {
		return this.eInput.getValue();
	}
	setValue(value, silent) {
		this.eInput.setValue(value, silent);
	}
	setValueChangedListener(listener) {
		this.onValueChanged = listener;
	}
	setParams({ ariaLabel, autoComplete }) {
		const { eInput } = this;
		eInput.setInputAriaLabel(ariaLabel);
		if (autoComplete !== void 0) eInput.setAutoComplete(autoComplete);
	}
};
function trimInputForFilter(value) {
	const trimmedInput = value?.trim();
	return trimmedInput === "" ? value : trimmedInput;
}
function mapValuesFromTextFilterModel(filterModel, optionsFactory) {
	const { filter, filterTo, type } = filterModel || {};
	return [filter || null, filterTo || null].slice(0, getNumberOfInputs(type, optionsFactory));
}
var TextInputFloatingFilterElement = {
	tag: "div",
	ref: "eFloatingFilterInputContainer",
	cls: "ag-floating-filter-input",
	role: "presentation"
};
var TextInputFloatingFilter = class extends SimpleFloatingFilter {
	constructor() {
		super(...arguments);
		this.eFloatingFilterInputContainer = null;
		this.defaultDebounceMs = 500;
	}
	postConstruct() {
		this.setTemplate(TextInputFloatingFilterElement);
	}
	onModelUpdated(model) {
		this.setLastTypeFromModel(model);
		this.setEditable(this.canWeEditAfterModelFromParentFilter(model));
		this.inputSvc.setValue(this.filterModelFormatter.getModelAsString(model));
	}
	setParams(params) {
		this.setupFloatingFilterInputService(params);
		super.setParams(params);
		this.setTextInputParams(params);
	}
	setupFloatingFilterInputService(params) {
		this.inputSvc = this.createFloatingFilterInputService(params);
		this.inputSvc.setupGui(this.eFloatingFilterInputContainer);
	}
	setTextInputParams(params) {
		const autoComplete = params.browserAutoComplete ?? false;
		const { inputSvc, defaultDebounceMs, readOnly } = this;
		inputSvc.setParams({
			ariaLabel: this.getAriaLabel(params),
			autoComplete
		});
		this.applyActive = _isUseApplyButton(params.filterParams);
		if (!readOnly) {
			const debounceMs = getDebounceMs(params.filterParams, defaultDebounceMs);
			const toDebounce = _debounce(this, this.syncUpWithParentFilter.bind(this), debounceMs);
			inputSvc.setValueChangedListener(toDebounce);
		}
	}
	updateParams(params) {
		super.updateParams(params);
		this.setTextInputParams(params);
	}
	recreateFloatingFilterInputService(params) {
		const { inputSvc } = this;
		const value = inputSvc.getValue();
		_clearElement(this.eFloatingFilterInputContainer);
		this.destroyBean(inputSvc);
		this.setupFloatingFilterInputService(params);
		inputSvc.setValue(value, true);
	}
	syncUpWithParentFilter(e) {
		const isEnterKey = e.key === KeyCode.ENTER;
		const reactive = this.reactive;
		if (reactive) this.params.onUiChange();
		if (this.applyActive && !isEnterKey) return;
		const { inputSvc, params, lastType } = this;
		let value = inputSvc.getValue();
		if (params.filterParams.trimInput) {
			value = trimInputForFilter(value);
			inputSvc.setValue(value, true);
		}
		if (reactive) {
			const reactiveParams = params;
			const model = reactiveParams.model;
			const parsedValue = this.convertValue(value);
			const newModel = parsedValue == null ? null : {
				...model ?? {
					filterType: this.filterType,
					type: lastType ?? this.optionsFactory.defaultOption
				},
				filter: parsedValue
			};
			reactiveParams.onModelChange(newModel, { afterFloatingFilter: true });
		} else params.parentFilterInstance((filterInstance) => {
			filterInstance?.onFloatingFilterChanged(lastType || null, value || null);
		});
	}
	convertValue(value) {
		return value || null;
	}
	setEditable(editable) {
		this.inputSvc.setEditable(editable);
	}
};
var FloatingFilterNumberInputService = class extends BeanStub {
	constructor() {
		super(...arguments);
		this.onValueChanged = () => {};
		this.numberInputActive = true;
	}
	setupGui(parentElement) {
		this.eNumberInput = this.createManagedBean(new AgInputNumberField());
		this.eTextInput = this.createManagedBean(new AgInputTextField());
		this.eTextInput.setDisabled(true);
		const eNumberInput = this.eNumberInput.getGui();
		const eTextInput = this.eTextInput.getGui();
		parentElement.appendChild(eNumberInput);
		parentElement.appendChild(eTextInput);
		this.setupListeners(eNumberInput, (e) => this.onValueChanged(e));
		this.setupListeners(eTextInput, (e) => this.onValueChanged(e));
	}
	setEditable(editable) {
		this.numberInputActive = editable;
		this.eNumberInput.setDisplayed(this.numberInputActive);
		this.eTextInput.setDisplayed(!this.numberInputActive);
	}
	setAutoComplete(autoComplete) {
		this.eNumberInput.setAutoComplete(autoComplete);
		this.eTextInput.setAutoComplete(autoComplete);
	}
	getValue() {
		return this.getActiveInputElement().getValue();
	}
	setValue(value, silent) {
		this.getActiveInputElement().setValue(value, silent);
	}
	getActiveInputElement() {
		return this.numberInputActive ? this.eNumberInput : this.eTextInput;
	}
	setValueChangedListener(listener) {
		this.onValueChanged = listener;
	}
	setupListeners(element, listener) {
		this.addManagedListeners(element, {
			input: listener,
			keydown: listener
		});
	}
	setParams(params) {
		this.setAriaLabel(params.ariaLabel);
		if (params.autoComplete !== void 0) this.setAutoComplete(params.autoComplete);
	}
	setAriaLabel(ariaLabel) {
		this.eNumberInput.setInputAriaLabel(ariaLabel);
		this.eTextInput.setInputAriaLabel(ariaLabel);
	}
};
var NumberFloatingFilter = class extends TextInputFloatingFilter {
	constructor() {
		super(...arguments);
		this.FilterModelFormatterClass = NumberFilterModelFormatter;
		this.filterType = "number";
		this.defaultOptions = DEFAULT_NUMBER_FILTER_OPTIONS;
	}
	updateParams(params) {
		if (getAllowedCharPattern(params.filterParams) !== this.allowedCharPattern) this.recreateFloatingFilterInputService(params);
		super.updateParams(params);
	}
	createFloatingFilterInputService(params) {
		this.allowedCharPattern = getAllowedCharPattern(params.filterParams);
		if (this.allowedCharPattern) return this.createManagedBean(new FloatingFilterTextInputService({ config: { allowedCharPattern: this.allowedCharPattern } }));
		return this.createManagedBean(new FloatingFilterNumberInputService());
	}
	convertValue(value) {
		return value ? Number(value) : null;
	}
};
var DEFAULT_TEXT_FILTER_OPTIONS = [
	"contains",
	"notContains",
	"equals",
	"notEqual",
	"startsWith",
	"endsWith",
	"blank",
	"notBlank"
];
var TextFilter = class extends SimpleFilter {
	constructor() {
		super("textFilter", mapValuesFromTextFilterModel, DEFAULT_TEXT_FILTER_OPTIONS);
		this.filterType = "text";
		this.eValuesFrom = [];
		this.eValuesTo = [];
		this.defaultDebounceMs = 500;
	}
	createCondition(position) {
		const type = this.getConditionType(position);
		const model = {
			filterType: this.filterType,
			type
		};
		const values = this.getValuesWithSideEffects(position, true);
		if (values.length > 0) model.filter = values[0];
		if (values.length > 1) model.filterTo = values[1];
		return model;
	}
	areSimpleModelsEqual(aSimple, bSimple) {
		return aSimple.filter === bSimple.filter && aSimple.filterTo === bSimple.filterTo && aSimple.type === bSimple.type;
	}
	getInputs(position) {
		const { eValuesFrom, eValuesTo } = this;
		if (position >= eValuesFrom.length) return [null, null];
		return [eValuesFrom[position], eValuesTo[position]];
	}
	getValues(position) {
		return this.getValuesWithSideEffects(position, false);
	}
	getValuesWithSideEffects(position, applySideEffects) {
		const result = [];
		this.forEachPositionInput(position, (element, index, _elPosition, numberOfInputs) => {
			if (index < numberOfInputs) {
				let value = _makeNull(element.getValue());
				if (applySideEffects && this.params.trimInput) {
					value = trimInputForFilter(value) ?? null;
					element.setValue(value, true);
				}
				result.push(value);
			}
		});
		return result;
	}
	createEValue() {
		const eCondition = _createElement({
			tag: "div",
			cls: "ag-filter-body",
			role: "presentation"
		});
		const { eValuesFrom, eValuesTo } = this;
		this.createFromToElement(eCondition, eValuesFrom, "from");
		this.createFromToElement(eCondition, eValuesTo, "to");
		return eCondition;
	}
	createFromToElement(eCondition, eValues, fromTo) {
		const eValue = this.createManagedBean(new AgInputTextField());
		eValue.addCss(`ag-filter-${fromTo}`);
		eValue.addCss("ag-filter-filter");
		eValues.push(eValue);
		eCondition.appendChild(eValue.getGui());
	}
	removeEValues(startPosition, deleteCount) {
		const removeComps = (eGui) => this.removeComponents(eGui, startPosition, deleteCount);
		const { eValuesFrom, eValuesTo } = this;
		removeComps(eValuesFrom);
		removeComps(eValuesTo);
	}
};
var TextFilterModelFormatter = class extends SimpleFilterModelFormatter {
	constructor() {
		super(...arguments);
		this.filterTypeKeys = TEXT_FILTER_TYPE_KEYS;
	}
	conditionToString(condition, forToolPanel, isRange, customDisplayKey, customDisplayName) {
		const { filter, filterTo, type } = condition;
		if (forToolPanel) {
			const getValueFunc = (value) => () => translateForFilter(this, "filterSummaryTextQuote", [value]);
			const valueForToolPanel = this.conditionForToolPanel(type, isRange, getValueFunc(filter), getValueFunc(filterTo), customDisplayKey, customDisplayName);
			if (valueForToolPanel != null) return valueForToolPanel;
		}
		if (isRange) return `${filter}-${filterTo}`;
		if (filter != null) return `${filter}`;
		return `${type}`;
	}
};
var defaultMatcher = ({ filterOption, value, filterText }) => {
	if (filterText == null) return false;
	switch (filterOption) {
		case "contains": return value.indexOf(filterText) >= 0;
		case "notContains": return value.indexOf(filterText) < 0;
		case "equals": return value === filterText;
		case "notEqual": return value != filterText;
		case "startsWith": return value.indexOf(filterText) === 0;
		case "endsWith": {
			const index = value.lastIndexOf(filterText);
			return index >= 0 && index === value.length - filterText.length;
		}
		default: return false;
	}
};
var defaultFormatter = (from) => from;
var defaultLowercaseFormatter = (from) => from == null ? null : from.toString().toLowerCase();
var TextFilterHandler = class extends SimpleFilterHandler {
	constructor() {
		super(mapValuesFromTextFilterModel, DEFAULT_TEXT_FILTER_OPTIONS);
		this.filterType = "text";
		this.FilterModelFormatterClass = TextFilterModelFormatter;
	}
	updateParams(params) {
		super.updateParams(params);
		const filterParams = params.filterParams;
		this.matcher = filterParams.textMatcher ?? defaultMatcher;
		this.formatter = filterParams.textFormatter ?? (filterParams.caseSensitive ? defaultFormatter : defaultLowercaseFormatter);
	}
	evaluateNullValue(filterType) {
		return filterType ? [
			"notEqual",
			"notContains",
			"blank"
		].indexOf(filterType) >= 0 : false;
	}
	evaluateNonNullValue(values, cellValue, filterModel, params) {
		const formattedValues = values.map((v$1) => this.formatter(v$1)) || [];
		const cellValueFormatted = this.formatter(cellValue);
		const { api, colDef, column, context, filterParams: { textFormatter } } = this.params;
		if (filterModel.type === "blank") return isBlank(cellValue);
		else if (filterModel.type === "notBlank") return !isBlank(cellValue);
		const matcherParams = {
			api,
			colDef,
			column,
			context,
			node: params.node,
			data: params.data,
			filterOption: filterModel.type,
			value: cellValueFormatted,
			textFormatter
		};
		return formattedValues.some((v$1) => this.matcher({
			...matcherParams,
			filterText: v$1
		}));
	}
};
var TextFloatingFilter = class extends TextInputFloatingFilter {
	constructor() {
		super(...arguments);
		this.FilterModelFormatterClass = TextFilterModelFormatter;
		this.filterType = "text";
		this.defaultOptions = DEFAULT_TEXT_FILTER_OPTIONS;
	}
	createFloatingFilterInputService() {
		return this.createManagedBean(new FloatingFilterTextInputService());
	}
};
var ColumnFilterModule = {
	moduleName: "ColumnFilter",
	version: VERSION,
	beans: [ColumnFilterService, FilterMenuFactory],
	dynamicBeans: { headerFilterCellCtrl: HeaderFilterCellCtrl },
	icons: {
		filter: "filter",
		filterActive: "filter"
	},
	apiFunctions: {
		isColumnFilterPresent,
		getColumnFilterInstance,
		destroyFilter,
		setFilterModel,
		getFilterModel,
		getColumnFilterModel,
		setColumnFilterModel,
		showColumnFilter,
		hideColumnFilter,
		getColumnFilterHandler,
		doFilterAction
	},
	dependsOn: [
		{
			moduleName: "FilterCore",
			version: VERSION,
			beans: [FilterManager],
			apiFunctions: {
				isAnyFilterPresent,
				onFilterChanged
			},
			css: [columnFiltersCSS],
			dependsOn: [{
				moduleName: "ClientSideRowModelFilter",
				version: VERSION,
				rowModels: ["clientSide"],
				beans: [FilterStage]
			}]
		},
		PopupModule,
		{
			moduleName: "FilterValue",
			version: VERSION,
			beans: [FilterValueService]
		},
		SharedMenuModule
	]
};
var TextFilterModule = {
	moduleName: "TextFilter",
	version: VERSION,
	dependsOn: [ColumnFilterModule],
	userComponents: {
		agTextColumnFilter: {
			classImp: TextFilter,
			params: { useForm: true }
		},
		agTextColumnFloatingFilter: TextFloatingFilter
	},
	dynamicBeans: { agTextColumnFilterHandler: TextFilterHandler }
};
var NumberFilterModule = {
	moduleName: "NumberFilter",
	version: VERSION,
	dependsOn: [ColumnFilterModule],
	userComponents: {
		agNumberColumnFilter: {
			classImp: NumberFilter,
			params: { useForm: true }
		},
		agNumberColumnFloatingFilter: NumberFloatingFilter
	},
	dynamicBeans: { agNumberColumnFilterHandler: NumberFilterHandler }
};
var DateFilterModule = {
	moduleName: "DateFilter",
	version: VERSION,
	dependsOn: [ColumnFilterModule],
	userComponents: {
		agDateColumnFilter: {
			classImp: DateFilter,
			params: { useForm: true }
		},
		agDateInput: DefaultDateComponent,
		agDateColumnFloatingFilter: DateFloatingFilter
	},
	dynamicBeans: { agDateColumnFilterHandler: DateFilterHandler }
};
var tooltipCSS = `.ag-tooltip{background-color:var(--ag-tooltip-background-color);border:var(--ag-tooltip-border);border-radius:var(--ag-border-radius);color:var(--ag-tooltip-text-color);padding:var(--ag-widget-container-vertical-padding) var(--ag-widget-container-horizontal-padding);position:absolute;white-space:normal;z-index:99999;&:where(.ag-cell-editor-tooltip){background-color:var(--ag-tooltip-error-background-color);border:var(--ag-tooltip-error-border);color:var(--ag-tooltip-error-text-color);font-weight:500}}.ag-tooltip-custom{position:absolute;z-index:99999}.ag-tooltip-custom:where(:not(.ag-tooltip-interactive)),.ag-tooltip:where(:not(.ag-tooltip-interactive)){pointer-events:none}.ag-tooltip-animate{transition:opacity 1s;&:where(.ag-tooltip-hiding){opacity:0}}`;
var getEditErrorsForPosition = (beans, cellCtrl, translate) => {
	const { editModelSvc } = beans;
	const cellValidationErrors = editModelSvc?.getCellValidationModel()?.getCellValidation(cellCtrl)?.errorMessages;
	const rowValidationErrors = editModelSvc?.getRowValidationModel().getRowValidation(cellCtrl)?.errorMessages;
	const errors = cellValidationErrors || rowValidationErrors;
	return errors && errors.length ? errors.join(translate("tooltipValidationErrorSeparator", ". ")) : void 0;
};
var TooltipService = class extends BeanStub {
	constructor() {
		super(...arguments);
		this.beanName = "tooltipSvc";
	}
	setupHeaderTooltip(existingTooltipFeature, ctrl, value, shouldDisplayTooltip) {
		if (existingTooltipFeature) ctrl.destroyBean(existingTooltipFeature);
		const isTooltipWhenTruncated = _isShowTooltipWhenTruncated(this.gos);
		const { column, eGui } = ctrl;
		const colDef = column.getColDef();
		if (!shouldDisplayTooltip && isTooltipWhenTruncated && !colDef.headerComponent) shouldDisplayTooltip = _isElementOverflowingCallback(() => eGui.querySelector(".ag-header-cell-text"));
		const tooltipCtrl = {
			getColumn: () => column,
			getColDef: () => column.getColDef(),
			getGui: () => eGui,
			getLocation: () => "header",
			getTooltipValue: () => {
				if (value != null) return value;
				return column.getColDef().headerTooltip;
			},
			shouldDisplayTooltip
		};
		let tooltipFeature = this.createTooltipFeature(tooltipCtrl);
		if (tooltipFeature) {
			tooltipFeature = ctrl.createBean(tooltipFeature);
			ctrl.setRefreshFunction("tooltip", () => tooltipFeature.refreshTooltip());
		}
		return tooltipFeature;
	}
	setupHeaderGroupTooltip(existingTooltipFeature, ctrl, value, shouldDisplayTooltip) {
		if (existingTooltipFeature) ctrl.destroyBean(existingTooltipFeature);
		const isTooltipWhenTruncated = _isShowTooltipWhenTruncated(this.gos);
		const { column, eGui } = ctrl;
		const colGroupDef = column.getColGroupDef();
		if (!shouldDisplayTooltip && isTooltipWhenTruncated && !colGroupDef?.headerGroupComponent) shouldDisplayTooltip = _isElementOverflowingCallback(() => eGui.querySelector(".ag-header-group-text"));
		const tooltipCtrl = {
			getColumn: () => column,
			getGui: () => eGui,
			getLocation: () => "headerGroup",
			getTooltipValue: () => value ?? (colGroupDef && colGroupDef.headerTooltip),
			shouldDisplayTooltip
		};
		if (colGroupDef) tooltipCtrl.getColDef = () => colGroupDef;
		const tooltipFeature = this.createTooltipFeature(tooltipCtrl);
		return tooltipFeature ? ctrl.createBean(tooltipFeature) : tooltipFeature;
	}
	enableCellTooltipFeature(ctrl, value, shouldDisplayTooltip) {
		const { beans } = this;
		const { gos, editSvc } = beans;
		const { column, rowNode } = ctrl;
		let location = "cell";
		const getTooltipValue = () => {
			const errorMessages = !!!editSvc?.isEditing(ctrl) && getEditErrorsForPosition(beans, ctrl, this.getLocaleTextFunc());
			if (errorMessages) {
				location = "cellEditor";
				return errorMessages;
			}
			location = "cell";
			const colDef = column.getColDef();
			const data = rowNode.data;
			if (colDef.tooltipField && _exists(data)) return _getValueUsingField(data, colDef.tooltipField, column.isTooltipFieldContainsDots());
			const valueGetter = colDef.tooltipValueGetter;
			if (valueGetter) return valueGetter(_addGridCommonParams(gos, {
				location: "cell",
				colDef: column.getColDef(),
				column,
				rowIndex: ctrl.cellPosition.rowIndex,
				node: rowNode,
				data: rowNode.data,
				value: ctrl.value,
				valueFormatted: ctrl.valueFormatted
			}));
			return null;
		};
		const isTooltipWhenTruncated = _isShowTooltipWhenTruncated(gos);
		if (!shouldDisplayTooltip) if (isTooltipWhenTruncated && !ctrl.isCellRenderer()) shouldDisplayTooltip = () => {
			const isEditing2 = !!editSvc?.isEditing(ctrl);
			if (!isEditing2 && getEditErrorsForPosition(beans, ctrl, this.getLocaleTextFunc())) return true;
			if (!column.isTooltipEnabled()) return false;
			const isElementOverflowing = _isElementOverflowingCallback(() => {
				const eCell = ctrl.eGui;
				return eCell.children.length === 0 ? eCell : eCell.querySelector(".ag-cell-value");
			});
			return !isEditing2 && isElementOverflowing();
		};
		else shouldDisplayTooltip = () => !editSvc?.isEditing(ctrl);
		const tooltipCtrl = {
			getColumn: () => column,
			getColDef: () => column.getColDef(),
			getRowIndex: () => ctrl.cellPosition.rowIndex,
			getRowNode: () => rowNode,
			getGui: () => ctrl.eGui,
			getLocation: () => location,
			getTooltipValue: value != null ? () => value : getTooltipValue,
			getValueFormatted: () => ctrl.valueFormatted,
			shouldDisplayTooltip
		};
		return this.createTooltipFeature(tooltipCtrl, beans);
	}
	setupFullWidthRowTooltip(existingTooltipFeature, ctrl, value, shouldDisplayTooltip) {
		const tooltipParams = {
			getGui: () => ctrl.getFullWidthElement(),
			getTooltipValue: () => value,
			getLocation: () => "fullWidthRow",
			shouldDisplayTooltip
		};
		const beans = this.beans;
		const context = beans.context;
		if (existingTooltipFeature) ctrl.destroyBean(existingTooltipFeature, context);
		const tooltipFeature = this.createTooltipFeature(tooltipParams, beans);
		if (!tooltipFeature) return;
		return ctrl.createBean(tooltipFeature, context);
	}
	setupCellEditorTooltip(cellCtrl, editor) {
		const { beans } = this;
		const { context } = beans;
		const el = editor.getValidationElement?.(true) || !editor.isPopup?.() && cellCtrl.eGui;
		if (!el) return;
		const tooltipFeature = this.createTooltipFeature({
			getGui: () => el,
			getTooltipValue: () => getEditErrorsForPosition(beans, cellCtrl, this.getLocaleTextFunc()),
			getLocation: () => "cellEditor",
			shouldDisplayTooltip: () => {
				const { editModelSvc } = beans;
				const rowValidationMap = editModelSvc?.getRowValidationModel()?.getRowValidationMap();
				const cellValidationMap = editModelSvc?.getCellValidationModel()?.getCellValidationMap();
				const hasRowValidationErrors = !!rowValidationMap && rowValidationMap.size > 0;
				const hasCellValidationErrors = !!cellValidationMap && cellValidationMap.size > 0;
				return hasRowValidationErrors || hasCellValidationErrors;
			}
		}, beans);
		if (!tooltipFeature) return;
		return cellCtrl.createBean(tooltipFeature, context);
	}
	initCol(column) {
		const { colDef } = column;
		column.tooltipEnabled = _exists(colDef.tooltipField) || _exists(colDef.tooltipValueGetter) || _exists(colDef.tooltipComponent);
	}
	createTooltipFeature(tooltipCtrl, beans) {
		return this.beans.registry.createDynamicBean("tooltipFeature", false, tooltipCtrl, beans);
	}
};
var TooltipModule = {
	moduleName: "Tooltip",
	version: VERSION,
	beans: [TooltipService],
	dynamicBeans: { tooltipFeature: TooltipFeature },
	userComponents: { agTooltipComponent: TooltipComponent2 },
	dependsOn: [PopupModule],
	css: [tooltipCSS]
};
var UndoRedoAction = class {
	constructor(cellValueChanges) {
		this.cellValueChanges = cellValueChanges;
	}
};
var RangeUndoRedoAction = class extends UndoRedoAction {
	constructor(cellValueChanges, initialRange, finalRange, ranges) {
		super(cellValueChanges);
		this.initialRange = initialRange;
		this.finalRange = finalRange;
		this.ranges = ranges;
	}
};
var DEFAULT_STACK_SIZE = 10;
var UndoRedoStack = class {
	constructor(maxStackSize) {
		this.actionStack = [];
		this.maxStackSize = maxStackSize ? maxStackSize : DEFAULT_STACK_SIZE;
		this.actionStack = new Array(this.maxStackSize);
	}
	pop() {
		return this.actionStack.pop();
	}
	push(item) {
		if (!(item.cellValueChanges && item.cellValueChanges.length > 0)) return;
		if (this.actionStack.length === this.maxStackSize) this.actionStack.shift();
		this.actionStack.push(item);
	}
	clear() {
		this.actionStack = [];
	}
	getCurrentStackSize() {
		return this.actionStack.length;
	}
};
var UndoRedoService = class extends BeanStub {
	constructor() {
		super(...arguments);
		this.beanName = "undoRedo";
		this.cellValueChanges = [];
		this.activeCellEdit = null;
		this.activeRowEdit = null;
		this.isPasting = false;
		this.isRangeInAction = false;
		this.batchEditing = false;
		this.bulkEditing = false;
		this.onCellValueChanged = (event) => {
			const eventCell = {
				column: event.column,
				rowIndex: event.rowIndex,
				rowPinned: event.rowPinned
			};
			const isCellEditing = this.activeCellEdit !== null && _areCellsEqual(this.activeCellEdit, eventCell);
			const isRowEditing = this.activeRowEdit !== null && _isSameRow(this.activeRowEdit, eventCell);
			if (!(isCellEditing || isRowEditing || this.isPasting || this.isRangeInAction)) return;
			const { rowPinned, rowIndex, column, oldValue, value } = event;
			const cellValueChange = {
				rowPinned,
				rowIndex,
				columnId: column.getColId(),
				newValue: value,
				oldValue
			};
			this.cellValueChanges.push(cellValueChange);
		};
		this.clearStacks = () => {
			this.undoStack.clear();
			this.redoStack.clear();
		};
	}
	postConstruct() {
		const { gos, ctrlsSvc } = this.beans;
		if (!gos.get("undoRedoCellEditing")) return;
		const undoRedoLimit = gos.get("undoRedoCellEditingLimit");
		if (undoRedoLimit <= 0) return;
		this.undoStack = new UndoRedoStack(undoRedoLimit);
		this.redoStack = new UndoRedoStack(undoRedoLimit);
		this.addListeners();
		const listener = this.clearStacks.bind(this);
		this.addManagedEventListeners({
			cellValueChanged: this.onCellValueChanged.bind(this),
			modelUpdated: (e) => {
				if (!e.keepUndoRedoStack) this.clearStacks();
			},
			columnPivotModeChanged: listener,
			newColumnsLoaded: listener,
			columnGroupOpened: listener,
			columnRowGroupChanged: listener,
			columnMoved: listener,
			columnPinned: listener,
			columnVisible: listener,
			rowDragEnd: listener
		});
		ctrlsSvc.whenReady(this, (p) => {
			this.gridBodyCtrl = p.gridBodyCtrl;
		});
	}
	getCurrentUndoStackSize() {
		return this.undoStack?.getCurrentStackSize() ?? 0;
	}
	getCurrentRedoStackSize() {
		return this.redoStack?.getCurrentStackSize() ?? 0;
	}
	undo(source) {
		const { eventSvc, undoStack, redoStack } = this;
		eventSvc.dispatchEvent({
			type: "undoStarted",
			source
		});
		const operationPerformed = this.undoRedo(undoStack, redoStack, "initialRange", "oldValue", "undo");
		eventSvc.dispatchEvent({
			type: "undoEnded",
			source,
			operationPerformed
		});
	}
	redo(source) {
		const { eventSvc, undoStack, redoStack } = this;
		eventSvc.dispatchEvent({
			type: "redoStarted",
			source
		});
		const operationPerformed = this.undoRedo(redoStack, undoStack, "finalRange", "newValue", "redo");
		eventSvc.dispatchEvent({
			type: "redoEnded",
			source,
			operationPerformed
		});
	}
	undoRedo(undoRedoStack, opposingUndoRedoStack, rangeProperty, cellValueChangeProperty, source) {
		if (!undoRedoStack) return false;
		const undoRedoAction = undoRedoStack.pop();
		if (!undoRedoAction || !undoRedoAction.cellValueChanges) return false;
		this.processAction(undoRedoAction, (cellValueChange) => cellValueChange[cellValueChangeProperty], source);
		if (undoRedoAction instanceof RangeUndoRedoAction) this.processRange(undoRedoAction.ranges || [undoRedoAction[rangeProperty]]);
		else this.processCell(undoRedoAction.cellValueChanges);
		opposingUndoRedoStack.push(undoRedoAction);
		return true;
	}
	processAction(action, valueExtractor, source) {
		action.cellValueChanges.forEach((cellValueChange) => {
			const { rowIndex, rowPinned, columnId } = cellValueChange;
			const rowPosition = {
				rowIndex,
				rowPinned
			};
			const currentRow = _getRowNode(this.beans, rowPosition);
			if (!currentRow.displayed) return;
			currentRow.setDataValue(columnId, valueExtractor(cellValueChange), source);
		});
	}
	processRange(ranges) {
		let lastFocusedCell;
		const rangeSvc = this.beans.rangeSvc;
		rangeSvc.removeAllCellRanges(true);
		ranges.forEach((range, idx) => {
			if (!range) return;
			const startRow = range.startRow;
			const endRow = range.endRow;
			if (idx === ranges.length - 1) {
				lastFocusedCell = {
					rowPinned: startRow.rowPinned,
					rowIndex: startRow.rowIndex,
					columnId: range.startColumn.getColId()
				};
				this.setLastFocusedCell(lastFocusedCell);
			}
			const cellRangeParams = {
				rowStartIndex: startRow.rowIndex,
				rowStartPinned: startRow.rowPinned,
				rowEndIndex: endRow.rowIndex,
				rowEndPinned: endRow.rowPinned,
				columnStart: range.startColumn,
				columns: range.columns
			};
			rangeSvc.addCellRange(cellRangeParams);
		});
	}
	processCell(cellValueChanges) {
		const cellValueChange = cellValueChanges[0];
		const { rowIndex, rowPinned } = cellValueChange;
		const rowPosition = {
			rowIndex,
			rowPinned
		};
		const row = _getRowNode(this.beans, rowPosition);
		const lastFocusedCell = {
			rowPinned: cellValueChange.rowPinned,
			rowIndex: row.rowIndex,
			columnId: cellValueChange.columnId
		};
		this.setLastFocusedCell(lastFocusedCell);
	}
	setLastFocusedCell(lastFocusedCell) {
		const { rowIndex, columnId, rowPinned } = lastFocusedCell;
		const { colModel, focusSvc, rangeSvc } = this.beans;
		const column = colModel.getCol(columnId);
		if (!column) return;
		const { scrollFeature } = this.gridBodyCtrl;
		scrollFeature.ensureIndexVisible(rowIndex);
		scrollFeature.ensureColumnVisible(column);
		const cellPosition = {
			rowIndex,
			column,
			rowPinned
		};
		focusSvc.setFocusedCell({
			...cellPosition,
			forceBrowserFocus: true
		});
		rangeSvc?.setRangeToCell(cellPosition);
	}
	addListeners() {
		this.addManagedEventListeners({
			rowEditingStarted: (e) => {
				this.activeRowEdit = {
					rowIndex: e.rowIndex,
					rowPinned: e.rowPinned
				};
			},
			rowEditingStopped: () => {
				const action = new UndoRedoAction(this.cellValueChanges);
				this.pushActionsToUndoStack(action);
				this.activeRowEdit = null;
			},
			cellEditingStarted: (e) => {
				this.activeCellEdit = {
					column: e.column,
					rowIndex: e.rowIndex,
					rowPinned: e.rowPinned
				};
			},
			cellEditingStopped: (e) => {
				this.activeCellEdit = null;
				if (e.valueChanged && !this.activeRowEdit && !this.isPasting && !this.isRangeInAction) {
					const action = new UndoRedoAction(this.cellValueChanges);
					this.pushActionsToUndoStack(action);
				}
			},
			pasteStart: () => {
				this.isPasting = true;
			},
			pasteEnd: () => {
				const action = new UndoRedoAction(this.cellValueChanges);
				this.pushActionsToUndoStack(action);
				this.isPasting = false;
			},
			fillStart: () => {
				this.isRangeInAction = true;
			},
			fillEnd: (event) => {
				const action = new RangeUndoRedoAction(this.cellValueChanges, event.initialRange, event.finalRange);
				this.pushActionsToUndoStack(action);
				this.isRangeInAction = false;
			},
			keyShortcutChangedCellStart: () => {
				this.isRangeInAction = true;
			},
			keyShortcutChangedCellEnd: () => {
				let action;
				const { rangeSvc, gos } = this.beans;
				if (rangeSvc && _isCellSelectionEnabled(gos)) action = new RangeUndoRedoAction(this.cellValueChanges, void 0, void 0, [...rangeSvc.getCellRanges()]);
				else action = new UndoRedoAction(this.cellValueChanges);
				this.pushActionsToUndoStack(action);
				this.isRangeInAction = false;
			},
			batchEditingStarted: () => this.startBigChange("batchEditing"),
			batchEditingStopped: ({ changes }) => this.stopBigChange("batchEditing", changes),
			bulkEditingStarted: () => this.startBigChange("bulkEditing"),
			bulkEditingStopped: ({ changes }) => this.stopBigChange("bulkEditing", changes)
		});
	}
	startBigChange(key) {
		this[key] = true;
	}
	stopBigChange(key, changes) {
		if (!this[key]) return;
		this[key] = false;
		if (changes?.length === 0) return;
		const action = new UndoRedoAction(changes ?? []);
		this.pushActionsToUndoStack(action);
		this.cellValueChanges = [];
	}
	pushActionsToUndoStack(action) {
		this.undoStack.push(action);
		this.cellValueChanges = [];
		this.redoStack.clear();
	}
};
var cellEditingCSS = `.ag-cell-inline-editing{border:var(--ag-cell-editing-border)!important;border-radius:var(--ag-border-radius);box-shadow:var(--ag-cell-editing-shadow);padding:0;z-index:1;.ag-cell-edit-wrapper,.ag-cell-editor,.ag-cell-wrapper,:where(.ag-cell-editor) .ag-input-field-input,:where(.ag-cell-editor) .ag-wrapper{height:100%;line-height:normal;min-height:100%;width:100%}&.ag-cell-editing-error{border-color:var(--ag-invalid-color)!important}}:where(.ag-popup-editor) .ag-large-text{background-color:var(--ag-background-color);border-radius:var(--ag-border-radius);box-shadow:var(--ag-dropdown-shadow);padding:0}.ag-large-text-input{height:auto;padding:var(--ag-cell-horizontal-padding)}:where(.ag-rtl .ag-large-text-input) textarea{resize:none}:where(.ag-ltr) .ag-checkbox-edit{padding-left:var(--ag-cell-horizontal-padding)}:where(.ag-rtl) .ag-checkbox-edit{padding-right:var(--ag-cell-horizontal-padding)}:where(.ag-row.ag-row-editing-invalid .ag-cell-inline-editing){opacity:.8}`;
var CheckboxCellEditorElement = {
	tag: "div",
	cls: "ag-cell-wrapper ag-cell-edit-wrapper ag-checkbox-edit",
	children: [{
		tag: "ag-checkbox",
		ref: "eEditor",
		role: "presentation"
	}]
};
var CheckboxCellEditor = class extends AgAbstractCellEditor {
	constructor() {
		super(CheckboxCellEditorElement, [AgCheckboxSelector]);
		this.eEditor = null;
	}
	initialiseEditor(params) {
		const isSelected = params.value ?? void 0;
		const eEditor = this.eEditor;
		eEditor.setValue(isSelected);
		eEditor.getInputElement().setAttribute("tabindex", "-1");
		this.setAriaLabel(isSelected);
		this.addManagedListeners(eEditor, { fieldValueChanged: (event) => this.setAriaLabel(event.selected) });
	}
	getValue() {
		return this.eEditor.getValue();
	}
	focusIn() {
		this.eEditor.getFocusableElement().focus();
	}
	afterGuiAttached() {
		if (this.params.cellStartedEdit) this.focusIn();
	}
	isPopup() {
		return false;
	}
	setAriaLabel(isSelected) {
		const translate = this.getLocaleTextFunc();
		const stateName = _getAriaCheckboxStateName(translate, isSelected);
		const ariaLabel = translate("ariaToggleCellValue", "Press SPACE to toggle cell value");
		this.eEditor.setInputAriaLabel(`${ariaLabel} (${stateName})`);
	}
	getValidationElement(tooltip) {
		return tooltip ? this.params.eGridCell : this.eEditor.getInputElement();
	}
	getValidationErrors() {
		const { params } = this;
		const { getValidationErrors } = params;
		const value = this.getValue();
		if (!getValidationErrors) return null;
		return getValidationErrors({
			value,
			internalErrors: null,
			cellEditorParams: params
		});
	}
};
var SimpleCellEditor = class extends AgAbstractCellEditor {
	constructor(cellEditorInput) {
		super();
		this.cellEditorInput = cellEditorInput;
		this.eEditor = null;
	}
	initialiseEditor(params) {
		const { cellEditorInput } = this;
		this.setTemplate({
			tag: "div",
			cls: "ag-cell-edit-wrapper",
			children: [cellEditorInput.getTemplate()]
		}, cellEditorInput.getAgComponents());
		const { eEditor } = this;
		const { cellStartedEdit, eventKey, suppressPreventDefault } = params;
		eEditor.getInputElement().setAttribute("title", "");
		cellEditorInput.init(eEditor, params);
		let startValue;
		let shouldSetStartValue = true;
		if (cellStartedEdit) {
			this.focusAfterAttached = true;
			if (eventKey === KeyCode.BACKSPACE || eventKey === KeyCode.DELETE) startValue = "";
			else if (eventKey && eventKey.length === 1) if (suppressPreventDefault) shouldSetStartValue = false;
			else startValue = eventKey;
			else {
				startValue = cellEditorInput.getStartValue();
				if (eventKey !== KeyCode.F2) this.highlightAllOnFocus = true;
			}
		} else {
			this.focusAfterAttached = false;
			startValue = cellEditorInput.getStartValue();
		}
		if (shouldSetStartValue && startValue != null) eEditor.setStartValue(startValue);
		this.addGuiEventListener("keydown", (event) => {
			const { key } = event;
			if (key === KeyCode.PAGE_UP || key === KeyCode.PAGE_DOWN) event.preventDefault();
		});
	}
	afterGuiAttached() {
		const translate = this.getLocaleTextFunc();
		const eInput = this.eEditor;
		eInput.setInputAriaLabel(translate("ariaInputEditor", "Input Editor"));
		if (!this.focusAfterAttached) return;
		if (!_isBrowserSafari()) eInput.getFocusableElement().focus();
		const inputEl = eInput.getInputElement();
		if (this.highlightAllOnFocus) inputEl.select();
		else this.cellEditorInput.setCaret?.();
	}
	focusIn() {
		const { eEditor } = this;
		const focusEl = eEditor.getFocusableElement();
		const inputEl = eEditor.getInputElement();
		focusEl.focus();
		inputEl.select();
	}
	getValue() {
		return this.cellEditorInput.getValue();
	}
	isPopup() {
		return false;
	}
	getValidationElement() {
		return this.eEditor.getInputElement();
	}
	getValidationErrors() {
		return this.cellEditorInput.getValidationErrors();
	}
};
var DateCellElement = {
	tag: "ag-input-date-field",
	ref: "eEditor",
	cls: "ag-cell-editor"
};
var DateCellEditorInput = class {
	constructor(getDataTypeService, getLocaleTextFunc) {
		this.getDataTypeService = getDataTypeService;
		this.getLocaleTextFunc = getLocaleTextFunc;
	}
	getTemplate() {
		return DateCellElement;
	}
	getAgComponents() {
		return [AgInputDateFieldSelector];
	}
	init(eEditor, params) {
		this.eEditor = eEditor;
		this.params = params;
		const { min, max, step, colDef } = params;
		if (min != null) eEditor.setMin(min);
		if (max != null) eEditor.setMax(max);
		if (step != null) eEditor.setStep(step);
		this.includeTime = params.includeTime ?? this.getDataTypeService()?.getDateIncludesTimeFlag?.(colDef.cellDataType);
		if (this.includeTime != null) eEditor.setIncludeTime(this.includeTime);
	}
	getValidationErrors() {
		const value = this.eEditor.getInputElement().valueAsDate;
		const { params } = this;
		const { min, max, getValidationErrors } = params;
		let internalErrors = [];
		const translate = this.getLocaleTextFunc();
		if (value instanceof Date && !isNaN(value.getTime())) {
			if (min) {
				const minValue = min instanceof Date ? min : new Date(min);
				if (value < minValue) {
					const minDateString = minValue.toLocaleDateString();
					internalErrors.push(translate("minDateValidation", `Date must be after ${minDateString}`, [minDateString]));
				}
			}
			if (max) {
				const maxValue = max instanceof Date ? max : new Date(max);
				if (value > maxValue) {
					const maxDateString = maxValue.toLocaleDateString();
					internalErrors.push(translate("maxDateValidation", `Date must be before ${maxDateString}`, [maxDateString]));
				}
			}
		}
		if (!internalErrors.length) internalErrors = null;
		if (getValidationErrors) return getValidationErrors({
			value,
			cellEditorParams: params,
			internalErrors
		});
		return internalErrors;
	}
	getValue() {
		const { eEditor, params } = this;
		const value = eEditor.getDate();
		if (!_exists(value) && !_exists(params.value)) return params.value;
		return value ?? null;
	}
	getStartValue() {
		const { value } = this.params;
		if (!(value instanceof Date)) return;
		return _serialiseDate(value, this.includeTime ?? false);
	}
};
var DateCellEditor = class extends SimpleCellEditor {
	constructor() {
		super(new DateCellEditorInput(() => this.beans.dataTypeSvc, () => this.getLocaleTextFunc()));
	}
};
var DateStringCellElement = {
	tag: "ag-input-date-field",
	ref: "eEditor",
	cls: "ag-cell-editor"
};
var DateStringCellEditorInput = class {
	constructor(getDataTypeService, getLocaleTextFunc) {
		this.getDataTypeService = getDataTypeService;
		this.getLocaleTextFunc = getLocaleTextFunc;
	}
	getTemplate() {
		return DateStringCellElement;
	}
	getAgComponents() {
		return [AgInputDateFieldSelector];
	}
	init(eEditor, params) {
		this.eEditor = eEditor;
		this.params = params;
		const { min, max, step, colDef } = params;
		if (min != null) eEditor.setMin(min);
		if (max != null) eEditor.setMax(max);
		if (step != null) eEditor.setStep(step);
		this.includeTime = params.includeTime ?? this.getDataTypeService()?.getDateIncludesTimeFlag?.(colDef.cellDataType);
		if (this.includeTime != null) eEditor.setIncludeTime(this.includeTime);
	}
	getValidationErrors() {
		const { eEditor, params } = this;
		const raw = eEditor.getInputElement().value;
		const value = this.formatDate(this.parseDate(raw ?? void 0));
		const { min, max, getValidationErrors } = params;
		let internalErrors = [];
		if (value) {
			const date = new Date(value);
			const translate = this.getLocaleTextFunc();
			if (min) {
				const minDate = new Date(min);
				if (date < minDate) {
					const minDateString = minDate.toLocaleDateString();
					internalErrors.push(translate("minDateValidation", `Date must be after ${minDateString}`, [minDateString]));
				}
			}
			if (max) {
				const maxDate = new Date(max);
				if (date > maxDate) {
					const maxDateString = maxDate.toLocaleDateString();
					internalErrors.push(translate("maxDateValidation", `Date must be before ${maxDateString}`, [maxDateString]));
				}
			}
		}
		if (!internalErrors.length) internalErrors = null;
		if (getValidationErrors) return getValidationErrors({
			value: this.getValue(),
			cellEditorParams: params,
			internalErrors
		});
		return internalErrors;
	}
	getValue() {
		const { params, eEditor } = this;
		const value = this.formatDate(eEditor.getDate());
		if (!_exists(value) && !_exists(params.value)) return params.value;
		return params.parseValue(value ?? "");
	}
	getStartValue() {
		return _serialiseDate(this.parseDate(this.params.value ?? void 0) ?? null, this.includeTime ?? false);
	}
	parseDate(value) {
		const dataTypeSvc = this.getDataTypeService();
		return dataTypeSvc ? dataTypeSvc.getDateParserFunction(this.params.column)(value) : _parseDateTimeFromString(value) ?? void 0;
	}
	formatDate(value) {
		const dataTypeSvc = this.getDataTypeService();
		return dataTypeSvc ? dataTypeSvc.getDateFormatterFunction(this.params.column)(value) : _serialiseDate(value ?? null, this.includeTime ?? false) ?? void 0;
	}
};
var DateStringCellEditor = class extends SimpleCellEditor {
	constructor() {
		super(new DateStringCellEditorInput(() => this.beans.dataTypeSvc, () => this.getLocaleTextFunc()));
	}
};
var LargeTextCellElement = {
	tag: "div",
	cls: "ag-large-text",
	children: [{
		tag: "ag-input-text-area",
		ref: "eEditor",
		cls: "ag-large-text-input"
	}]
};
var LargeTextCellEditor = class extends AgAbstractCellEditor {
	constructor() {
		super(LargeTextCellElement, [AgInputTextAreaSelector]);
		this.eEditor = null;
	}
	initialiseEditor(params) {
		const { eEditor } = this;
		const { cellStartedEdit, eventKey, value, maxLength, cols, rows } = params;
		this.focusAfterAttached = cellStartedEdit;
		eEditor.getInputElement().setAttribute("title", "");
		eEditor.setMaxLength(maxLength || 200).setCols(cols || 60).setRows(rows || 10);
		let startValue;
		if (cellStartedEdit) {
			this.focusAfterAttached = true;
			if (eventKey === KeyCode.BACKSPACE || eventKey === KeyCode.DELETE) startValue = "";
			else if (eventKey && eventKey.length === 1) startValue = eventKey;
			else {
				startValue = value.toString();
				if (eventKey !== KeyCode.F2) this.highlightAllOnFocus = true;
			}
		} else {
			this.focusAfterAttached = false;
			startValue = value.toString();
		}
		if (startValue != null) eEditor.setValue(startValue, true);
		this.addGuiEventListener("keydown", this.onKeyDown.bind(this));
		this.activateTabIndex();
	}
	onKeyDown(event) {
		const key = event.key;
		if (key === KeyCode.LEFT || key === KeyCode.UP || key === KeyCode.RIGHT || key === KeyCode.DOWN || event.shiftKey && key === KeyCode.ENTER) event.stopPropagation();
	}
	afterGuiAttached() {
		const { eEditor, focusAfterAttached, highlightAllOnFocus } = this;
		const translate = this.getLocaleTextFunc();
		eEditor.setInputAriaLabel(translate("ariaInputEditor", "Input Editor"));
		if (focusAfterAttached) {
			eEditor.getFocusableElement().focus();
			if (highlightAllOnFocus) eEditor.getInputElement().select();
		}
	}
	getValue() {
		const { eEditor, params } = this;
		const { value } = params;
		const editorValue = eEditor.getValue();
		if (!_exists(editorValue) && !_exists(value)) return value;
		return params.parseValue(editorValue);
	}
	getValidationElement() {
		return this.eEditor.getInputElement();
	}
	getValidationErrors() {
		const { params } = this;
		const { maxLength, getValidationErrors } = params;
		const translate = this.getLocaleTextFunc();
		const value = this.getValue();
		let internalErrors = [];
		if (typeof value === "string" && maxLength != null && value.length > maxLength) internalErrors.push(translate("maxLengthValidation", `Must be ${maxLength} characters or fewer.`, [String(maxLength)]));
		if (!internalErrors.length) internalErrors = null;
		if (getValidationErrors) return getValidationErrors({
			value,
			internalErrors,
			cellEditorParams: params
		});
		return internalErrors;
	}
};
var NumberCellElement = {
	tag: "ag-input-number-field",
	ref: "eEditor",
	cls: "ag-cell-editor"
};
var NumberCellEditorInput = class {
	constructor(getLocaleTextFunc) {
		this.getLocaleTextFunc = getLocaleTextFunc;
	}
	getTemplate() {
		return NumberCellElement;
	}
	getAgComponents() {
		return [AgInputNumberFieldSelector];
	}
	init(eEditor, params) {
		this.eEditor = eEditor;
		this.params = params;
		const { max, min, precision, step } = params;
		if (max != null) eEditor.setMax(max);
		if (min != null) eEditor.setMin(min);
		if (precision != null) eEditor.setPrecision(precision);
		if (step != null) eEditor.setStep(step);
		const editorEl = eEditor.getInputElement();
		if (params.preventStepping) eEditor.addManagedElementListeners(editorEl, { keydown: this.preventStepping });
		else if (params.showStepperButtons) editorEl.classList.add("ag-number-field-input-stepper");
	}
	getValidationErrors() {
		const { params } = this;
		const { min, max, getValidationErrors } = params;
		const value = this.eEditor.getInputElement().valueAsNumber;
		const translate = this.getLocaleTextFunc();
		let internalErrors = [];
		if (typeof value === "number") {
			if (min != null && value < min) internalErrors.push(translate("minValueValidation", `Must be greater than or equal to ${min}.`, [String(min)]));
			if (max != null && value > max) internalErrors.push(translate("maxValueValidation", `Must be less than or equal to ${max}.`, [String(max)]));
		}
		if (!internalErrors.length) internalErrors = null;
		if (getValidationErrors) return getValidationErrors({
			value,
			cellEditorParams: params,
			internalErrors
		});
		return internalErrors;
	}
	preventStepping(e) {
		if (e.key === KeyCode.UP || e.key === KeyCode.DOWN) e.preventDefault();
	}
	getValue() {
		const { eEditor, params } = this;
		const value = eEditor.getValue();
		if (!_exists(value) && !_exists(params.value)) return params.value;
		let parsedValue = params.parseValue(value);
		if (parsedValue == null) return parsedValue;
		if (typeof parsedValue === "string") {
			if (parsedValue === "") return null;
			parsedValue = Number(parsedValue);
		}
		return isNaN(parsedValue) ? null : parsedValue;
	}
	getStartValue() {
		return this.params.value;
	}
	setCaret() {
		if (_isBrowserSafari()) this.eEditor.getInputElement().focus({ preventScroll: true });
	}
};
var NumberCellEditor = class extends SimpleCellEditor {
	constructor() {
		super(new NumberCellEditorInput(() => this.getLocaleTextFunc()));
	}
};
var TextCellEditorElement = {
	tag: "ag-input-text-field",
	ref: "eEditor",
	cls: "ag-cell-editor"
};
var TextCellEditorInput = class {
	constructor(getLocaleTextFunc) {
		this.getLocaleTextFunc = getLocaleTextFunc;
	}
	getTemplate() {
		return TextCellEditorElement;
	}
	getAgComponents() {
		return [AgInputTextFieldSelector];
	}
	init(eEditor, params) {
		this.eEditor = eEditor;
		this.params = params;
		const maxLength = params.maxLength;
		if (maxLength != null) eEditor.setMaxLength(maxLength);
	}
	getValidationErrors() {
		const { params } = this;
		const { maxLength, getValidationErrors } = params;
		const value = this.getValue();
		const translate = this.getLocaleTextFunc();
		let internalErrors = [];
		if (maxLength != null && typeof value === "string" && value.length > maxLength) internalErrors.push(translate("maxLengthValidation", `Must be ${maxLength} characters or fewer.`, [String(maxLength)]));
		if (!internalErrors.length) internalErrors = null;
		if (getValidationErrors) return getValidationErrors({
			value,
			cellEditorParams: params,
			internalErrors
		});
		return internalErrors;
	}
	getValue() {
		const { eEditor, params } = this;
		const value = eEditor.getValue();
		if (!_exists(value) && !_exists(params.value)) return params.value;
		return params.parseValue(value);
	}
	getStartValue() {
		const params = this.params;
		return params.useFormatter || params.column.getColDef().refData ? params.formatValue(params.value) : params.value;
	}
	setCaret() {
		const eInput = this.eEditor;
		const value = eInput.getValue();
		const len = _exists(value) && value.length || 0;
		if (len) eInput.getInputElement().setSelectionRange(len, len);
	}
};
var TextCellEditor = class extends SimpleCellEditor {
	constructor() {
		super(new TextCellEditorInput(() => this.getLocaleTextFunc()));
	}
};
function getVerticalPixelRange(beans) {
	return beans.ctrlsSvc.getScrollFeature().getVScrollPosition();
}
function getHorizontalPixelRange(beans) {
	return beans.ctrlsSvc.getScrollFeature().getHScrollPosition();
}
function ensureColumnVisible(beans, key, position = "auto") {
	beans.frameworkOverrides.wrapIncoming(() => beans.ctrlsSvc.getScrollFeature().ensureColumnVisible(key, position), "ensureVisible");
}
function ensureIndexVisible(beans, index, position) {
	beans.frameworkOverrides.wrapIncoming(() => beans.ctrlsSvc.getScrollFeature().ensureIndexVisible(index, position), "ensureVisible");
}
function ensureNodeVisible(beans, nodeSelector, position = null) {
	beans.frameworkOverrides.wrapIncoming(() => beans.ctrlsSvc.getScrollFeature().ensureNodeVisible(nodeSelector, position), "ensureVisible");
}
function undoCellEditing(beans) {
	beans.undoRedo?.undo("api");
}
function redoCellEditing(beans) {
	beans.undoRedo?.redo("api");
}
function getEditingCells(beans) {
	const edits = beans.editModelSvc?.getEditMap();
	const positions = [];
	edits?.forEach((editRow, rowNode) => {
		const { rowIndex, rowPinned } = rowNode;
		editRow.forEach((editValue, column) => {
			const { editorValue, pendingValue, sourceValue: oldValue, state } = editValue;
			const diff = _sourceAndPendingDiffer(editValue);
			let newValue = editorValue ?? pendingValue;
			if (newValue === UNEDITED) newValue = void 0;
			const edit = {
				newValue,
				oldValue,
				state,
				column,
				colId: column.getColId(),
				colKey: column.getColId(),
				rowIndex,
				rowPinned
			};
			if (state === "editing" || state === "changed" && diff) positions.push(edit);
		});
	});
	return positions;
}
function stopEditing(beans, cancel = false) {
	const { editSvc } = beans;
	if (editSvc?.isBatchEditing()) {
		if (cancel) beans.editModelSvc?.getEditPositions().forEach((cellPosition) => {
			if (cellPosition.state === "editing") editSvc.revertSingleCellEdit(cellPosition);
		});
		else _syncFromEditors(beans, true);
		_destroyEditors(beans);
	} else editSvc?.stopEditing(void 0, {
		cancel,
		source: "api"
	});
}
function isEditing(beans, cellPosition) {
	const cellCtrl = _getCellCtrl(beans, cellPosition);
	return beans.editSvc?.isEditing(cellCtrl) ?? false;
}
function startEditingCell(beans, params) {
	const { key, colKey, rowIndex, rowPinned } = params;
	const { editSvc, colModel } = beans;
	const column = colModel.getCol(colKey);
	if (!column) {
		_warn(12, { colKey });
		return;
	}
	const rowNode = _getRowNode(beans, {
		rowIndex,
		rowPinned: rowPinned || null,
		column
	});
	if (!rowNode) {
		_warn(290, {
			rowIndex,
			rowPinned
		});
		return;
	}
	if (!column.isCellEditable(rowNode)) return;
	if (rowPinned == null) ensureIndexVisible(beans, rowIndex);
	ensureColumnVisible(beans, colKey);
	editSvc?.startEditing({
		rowNode,
		column
	}, {
		event: key ? new KeyboardEvent("keydown", { key }) : void 0,
		source: "api"
	});
}
function validateEdit(beans) {
	return beans.editSvc?.validateEdit() || null;
}
function getCurrentUndoSize(beans) {
	return beans.undoRedo?.getCurrentUndoStackSize() ?? 0;
}
function getCurrentRedoSize(beans) {
	return beans.undoRedo?.getCurrentRedoStackSize() ?? 0;
}
var PopupEditorElement = {
	tag: "div",
	cls: "ag-popup-editor",
	attrs: { tabindex: "-1" }
};
var PopupEditorWrapper = class extends PopupComponent {
	constructor(params) {
		super(PopupEditorElement);
		this.params = params;
	}
	postConstruct() {
		_setDomData(this.gos, this.getGui(), "popupEditorWrapper", true);
		this.addKeyDownListener();
	}
	addKeyDownListener() {
		const eGui = this.getGui();
		const params = this.params;
		const listener = (event) => {
			if (!_isUserSuppressingKeyboardEvent(this.gos, event, params.node, params.column, true)) params.onKeyDown(event);
		};
		this.addManagedElementListeners(eGui, { keydown: listener });
	}
};
var editHighlightFn = (edit, includeEditing = false) => {
	if (edit !== void 0) return _sourceAndPendingDiffer(edit) || includeEditing && edit.state === "editing";
};
function _hasEdits(beans, position, includeEditing = false) {
	return editHighlightFn(beans.editModelSvc?.getEdit(position), includeEditing);
}
function _hasLeafEdits(beans, position) {
	const { editModelSvc } = beans;
	const { column, rowNode } = position;
	if (beans.gos.get("groupTotalRow") && !rowNode?.footer) return false;
	for (const node of rowNode?.allLeafChildren ?? []) if (editHighlightFn(editModelSvc?.getEdit({
		rowNode: node,
		column
	})) || editHighlightFn(editModelSvc?.getEdit({
		rowNode: node.pinnedSibling,
		column
	}))) return true;
}
function _hasPinnedEdits(beans, { rowNode, column }) {
	rowNode = rowNode.pinnedSibling;
	if (!rowNode) return;
	return editHighlightFn(beans.editModelSvc?.getEdit({
		rowNode,
		column
	}));
}
var CellEditStyleFeature = class extends BeanStub {
	constructor(cellCtrl, beans) {
		super();
		this.cellCtrl = cellCtrl;
		this.beans = beans;
		this.editSvc = beans.editSvc;
		this.editModelSvc = beans.editModelSvc;
	}
	setComp(comp) {
		this.cellComp = comp;
		this.applyCellStyles();
	}
	applyCellStyles() {
		const { cellCtrl, editSvc, beans } = this;
		if (editSvc?.isBatchEditing() && editSvc.isEditing()) {
			const state = _hasEdits(beans, cellCtrl) || _hasLeafEdits(beans, cellCtrl) || _hasPinnedEdits(beans, cellCtrl);
			this.applyBatchingStyle(state);
		} else this.applyBatchingStyle(false);
		const hasErrors = !!this.editModelSvc?.getCellValidationModel().hasCellValidation(this.cellCtrl);
		this.cellComp.toggleCss("ag-cell-editing-error", hasErrors);
	}
	applyBatchingStyle(newState) {
		this.cellComp.toggleCss("ag-cell-editing", newState ?? false);
		this.cellComp.toggleCss("ag-cell-batch-edit", (newState && this.editSvc?.isBatchEditing()) ?? false);
	}
};
var RowEditStyleFeature = class extends BeanStub {
	constructor(rowCtrl, beans) {
		super();
		this.rowCtrl = rowCtrl;
		this.beans = beans;
		this.gos = beans.gos;
		this.editSvc = beans.editSvc;
		this.editModelSvc = beans.editModelSvc;
	}
	applyRowStyles() {
		const { rowCtrl, editModelSvc, beans } = this;
		let rowNode = rowCtrl.rowNode;
		let edits = editModelSvc?.getEditRow(rowNode);
		const hasErrors = this.editModelSvc?.getRowValidationModel().hasRowValidation({ rowNode });
		if (!edits && rowNode.pinnedSibling) {
			rowNode = rowNode.pinnedSibling;
			edits = editModelSvc?.getEditRow(rowNode);
		}
		if (edits) {
			const editing = Array.from(edits.keys()).some((column) => {
				const position = {
					rowNode,
					column
				};
				return _hasEdits(beans, position, true) || _hasLeafEdits(beans, position) || _hasPinnedEdits(beans, position);
			});
			this.applyStyle(hasErrors, editing);
			return;
		}
		this.applyStyle(hasErrors);
	}
	applyStyle(hasErrors = false, editing = false) {
		const batchEdit = this.editSvc?.isBatchEditing() ?? false;
		const fullRow = this.gos.get("editType") === "fullRow";
		this.rowCtrl?.forEachGui(void 0, ({ rowComp }) => {
			rowComp.toggleCss("ag-row-editing", fullRow && editing);
			rowComp.toggleCss("ag-row-batch-edit", fullRow && editing && batchEdit);
			rowComp.toggleCss("ag-row-inline-editing", editing);
			rowComp.toggleCss("ag-row-not-inline-editing", !editing);
			rowComp.toggleCss("ag-row-editing-invalid", fullRow && editing && hasErrors);
		});
	}
};
var purgeRows = ({ rowModel, pinnedRowModel, editModelSvc }, rowNodes) => {
	const found = /* @__PURE__ */ new Set();
	rowModel.forEachNode((node) => rowNodes.has(node) && found.add(node));
	pinnedRowModel?.forEachPinnedRow("top", (node) => rowNodes.has(node) && found.add(node));
	pinnedRowModel?.forEachPinnedRow("bottom", (node) => rowNodes.has(node) && found.add(node));
	rowNodes.forEach((rowNode) => {
		if (!found.has(rowNode)) editModelSvc.removeEdits({ rowNode });
	});
	return found;
};
var purgeCells = ({ editModelSvc }, rowNodes, columns) => {
	rowNodes.forEach((rowNode) => editModelSvc?.getEditRow(rowNode)?.forEach((_, column) => !columns.has(column) && editModelSvc.removeEdits({
		rowNode,
		column
	})));
};
var _refreshEditCells = (beans) => () => {
	const columns = new Set(beans.colModel.getCols());
	const updates = beans.editModelSvc.getEditMap(true);
	purgeCells(beans, purgeRows(beans, new Set(updates.keys())), columns);
};
var KEEP_EDITOR_SOURCES = /* @__PURE__ */ new Set(["undo", "redo"]);
var STOP_EDIT_SOURCE_TRANSFORM = {
	paste: "ui",
	rangeSvc: "ui",
	fillHandle: "api",
	cellClear: "api"
};
var STOP_EDIT_SOURCE_TRANSFORM_KEYS = new Set(Object.keys(STOP_EDIT_SOURCE_TRANSFORM));
var SET_DATA_SOURCE_AS_API = /* @__PURE__ */ new Set([
	"paste",
	"rangeSvc",
	"renderer",
	"cellClear",
	"redo",
	"undo"
]);
var CANCEL_PARAMS = {
	cancel: true,
	source: "api"
};
var COMMIT_PARAMS = {
	cancel: false,
	source: "api"
};
var CHECK_SIBLING = { checkSiblings: true };
var FORCE_REFRESH = {
	force: true,
	suppressFlash: true
};
var EditService = class extends BeanStub {
	constructor() {
		super(...arguments);
		this.beanName = "editSvc";
		this.batch = false;
	}
	postConstruct() {
		const { beans } = this;
		this.model = beans.editModelSvc;
		this.valueSvc = beans.valueSvc;
		this.rangeSvc = beans.rangeSvc;
		this.addManagedPropertyListener("editType", ({ currentValue }) => {
			this.stopEditing(void 0, CANCEL_PARAMS);
			this.createStrategy(currentValue);
		});
		const handler = _refreshEditCells(beans);
		const stopInvalidEdits = () => {
			const hasCellValidation = this.model.getCellValidationModel().getCellValidationMap().size > 0;
			const hasRowValidation = this.model.getRowValidationModel().getRowValidationMap().size > 0;
			if (hasCellValidation || hasRowValidation) this.stopEditing(void 0, CANCEL_PARAMS);
			else if (this.isEditing()) if (this.isBatchEditing()) _destroyEditors(beans, this.model.getEditPositions());
			else this.stopEditing(void 0, COMMIT_PARAMS);
			return false;
		};
		this.addManagedEventListeners({
			columnPinned: handler,
			columnVisible: handler,
			columnRowGroupChanged: handler,
			rowGroupOpened: handler,
			pinnedRowsChanged: handler,
			displayedRowsChanged: handler,
			sortChanged: stopInvalidEdits,
			filterChanged: stopInvalidEdits,
			cellFocused: this.onCellFocused.bind(this)
		});
	}
	isBatchEditing() {
		return this.batch;
	}
	setBatchEditing(enabled) {
		if (enabled) {
			this.batch = true;
			this.stopEditing(void 0, CANCEL_PARAMS);
		} else {
			this.stopEditing(void 0, CANCEL_PARAMS);
			this.batch = false;
		}
	}
	createStrategy(editType) {
		const { beans, gos, strategy } = this;
		const name = editType ?? gos.get("editType") ?? "singleCell";
		if (strategy) {
			if (strategy.beanName === name) return strategy;
			this.destroyStrategy();
		}
		return this.strategy = this.createOptionalManagedBean(beans.registry.createDynamicBean(name, true));
	}
	destroyStrategy() {
		if (!this.strategy) return;
		this.strategy.destroy();
		this.strategy = this.destroyBean(this.strategy);
	}
	shouldStartEditing(position, event, cellStartedEdit, source = "ui") {
		this.strategy ?? (this.strategy = this.createStrategy());
		return this.strategy?.shouldStart(position, event, cellStartedEdit, source) ?? null;
	}
	shouldStopEditing(position, event, source = "ui") {
		return this.strategy?.shouldStop(position, event, source) ?? null;
	}
	shouldCancelEditing(position, event, source = "ui") {
		return this.strategy?.shouldCancel(position, event, source) ?? null;
	}
	validateEdit() {
		return _validateEdit(this.beans);
	}
	isEditing(position, params) {
		return this.model.hasEdits(position, params ?? CHECK_SIBLING);
	}
	isRowEditing(rowNode, params) {
		return (rowNode && this.model.hasRowEdits(rowNode, params)) ?? false;
	}
	startEditing(position, params) {
		const { startedEdit = true, event = null, source = "ui", ignoreEventKey = false } = params;
		this.strategy ?? (this.strategy = this.createStrategy());
		if (!this.isCellEditable(position, "api")) return;
		const cellCtrl = _getCellCtrl(this.beans, position);
		if (cellCtrl && !cellCtrl.comp) {
			cellCtrl.onCompAttachedFuncs.push(() => this.startEditing(position, params));
			return;
		}
		const res = this.shouldStartEditing?.(position, event, startedEdit, source);
		if (res === false && source !== "api") {
			this.isEditing(position) && this.stopEditing();
			return;
		}
		if (!this.batch && this.shouldStopEditing(position, void 0, source)) this.stopEditing(void 0, { source });
		if (res && this.isBatchEditing()) this.dispatchBatchEvent("batchEditingStarted", /* @__PURE__ */ new Map());
		this.strategy.start(position, event, source, ignoreEventKey);
	}
	stopEditing(position, params) {
		const { event, cancel, source = "ui", suppressNavigateAfterEdit } = params || {};
		const { beans, model } = this;
		if (STOP_EDIT_SOURCE_TRANSFORM_KEYS.has(source)) {
			if (this.isBatchEditing()) {
				this.bulkRefresh(position);
				return false;
			}
			return this.stopEditing(position, {
				...params,
				source: STOP_EDIT_SOURCE_TRANSFORM[source]
			});
		}
		if (!(this.isEditing(position) || this.isBatchEditing() && model.hasEdits(position, CHECK_SIBLING)) || !this.strategy) return false;
		const cellCtrl = _getCellCtrl(beans, position);
		if (cellCtrl) cellCtrl.onEditorAttachedFuncs = [];
		let edits = model.getEditMap(true);
		let res = false;
		const willStop = !cancel && !!this.shouldStopEditing(position, event, source);
		const willCancel = cancel && !!this.shouldCancelEditing(position, event, source);
		if (willStop || willCancel) {
			_syncFromEditors(beans, true);
			const freshEdits = model.getEditMap();
			this.processEdits(freshEdits, cancel);
			this.strategy?.stop(cancel, event);
			this.bulkRefresh(void 0, edits);
			edits = freshEdits;
			res || (res = willStop);
		} else if (event instanceof KeyboardEvent && this.batch && this.strategy?.midBatchInputsAllowed(position) && this.isEditing(position, { withOpenEditor: true })) {
			const key = event.key;
			const isEnter = key === KeyCode.ENTER;
			const isEscape = key === KeyCode.ESCAPE;
			const isTab = key === KeyCode.TAB;
			if (isEnter || isTab || isEscape) {
				if (isEnter || isTab) _syncFromEditors(beans, true);
				else if (isEscape) this.revertSingleCellEdit(cellCtrl);
				if (this.isBatchEditing()) this.strategy?.cleanupEditors();
				else _destroyEditors(beans, model.getEditPositions(), { event });
				event.preventDefault();
				this.bulkRefresh(position, edits, { suppressFlash: true });
				edits = model.getEditMap();
			}
		} else {
			_syncFromEditors(beans, true);
			edits = model.getEditMap();
		}
		if (res && position) this.model.removeEdits(position);
		if (!suppressNavigateAfterEdit && cellCtrl) this.navigateAfterEdit(event instanceof KeyboardEvent && event.shiftKey, cellCtrl.cellPosition);
		_purgeUnchangedEdits(beans);
		if (!this.model.hasEdits()) {
			this.model.getCellValidationModel().clearCellValidationMap();
			this.model.getRowValidationModel().clearRowValidationMap();
		}
		this.bulkRefresh();
		if (willCancel) this.beans.rowRenderer.refreshRows({ rowNodes: Array.from(edits.keys()) });
		if (this.isBatchEditing()) {
			this.beans.rowRenderer.refreshRows({
				suppressFlash: true,
				force: true
			});
			if (res && willStop) this.dispatchBatchEvent("batchEditingStopped", edits);
		}
		return res;
	}
	navigateAfterEdit(shiftKey, cellPosition) {
		if (this.gos.get("enterNavigatesVerticallyAfterEdit")) {
			const key = shiftKey ? KeyCode.UP : KeyCode.DOWN;
			this.beans.navigation?.navigateToNextCell(null, key, cellPosition, false);
		}
	}
	processEdits(edits, cancel = false) {
		const rowNodes = Array.from(edits.keys());
		const { beans } = this;
		const hasValidationErrors = this.model.getCellValidationModel().getCellValidationMap().size > 0 || this.model.getRowValidationModel().getRowValidationMap().size > 0;
		const editsToDelete = [];
		for (const rowNode of rowNodes) {
			const editRow = edits.get(rowNode);
			for (const column of editRow.keys()) {
				const editValue = editRow.get(column);
				const position = {
					rowNode,
					column
				};
				const cellCtrl = _getCellCtrl(beans, position);
				const valueChanged = _sourceAndPendingDiffer(editValue);
				const isCancelAfterEnd = cellCtrl?.comp?.getCellEditor()?.isCancelAfterEnd?.();
				if (!cancel && !isCancelAfterEnd && valueChanged && !hasValidationErrors) {
					if (!this.setNodeDataValue(rowNode, column, editValue.pendingValue)) editsToDelete.push(position);
				}
				cellCtrl?.refreshCell(FORCE_REFRESH);
			}
		}
		editsToDelete.forEach((position) => {
			this.model.clearEditValue(position);
		});
	}
	setNodeDataValue(rowNode, column, newValue, refreshCell) {
		const { beans } = this;
		const cellCtrl = _getCellCtrl(beans, {
			rowNode,
			column
		});
		if (cellCtrl) cellCtrl.suppressRefreshCell = true;
		const success = rowNode.setDataValue(column, newValue, "commit");
		if (cellCtrl) cellCtrl.suppressRefreshCell = false;
		if (refreshCell) cellCtrl?.refreshCell(FORCE_REFRESH);
		return success;
	}
	setEditMap(edits, params) {
		this.strategy ?? (this.strategy = this.createStrategy());
		this.strategy?.setEditMap(edits, params);
		this.bulkRefresh();
		this.beans.rowRenderer.refreshCells(FORCE_REFRESH);
	}
	dispatchEditValuesChanged({ rowNode, column }, edit = {}) {
		if (!rowNode || !column || !edit) return;
		const { pendingValue, sourceValue } = edit;
		const { rowIndex, rowPinned, data } = rowNode;
		this.beans.eventSvc.dispatchEvent({
			type: "cellEditValuesChanged",
			node: rowNode,
			rowIndex,
			rowPinned,
			column,
			source: "api",
			data,
			newValue: pendingValue,
			oldValue: sourceValue,
			value: pendingValue,
			colDef: column.getColDef()
		});
	}
	bulkRefresh(position = {}, editMap, params = {}) {
		const { beans, gos } = this;
		const { editModelSvc, rowModel } = beans;
		if (_isClientSideRowModel(gos, rowModel)) {
			if (position.rowNode && position.column) this.refCell(position, this.model.getEdit(position), params);
			else if (editMap) editModelSvc?.getEditMap(false)?.forEach((editRow, rowNode) => {
				for (const column of editRow.keys()) this.refCell({
					rowNode,
					column
				}, editRow.get(column), params);
			});
		}
	}
	refCell({ rowNode, column }, edit, params = {}) {
		const { beans, gos } = this;
		const updatedNodes = /* @__PURE__ */ new Set([rowNode]);
		const refreshNodes = /* @__PURE__ */ new Set();
		const pinnedSibling = rowNode.pinnedSibling;
		if (pinnedSibling) updatedNodes.add(pinnedSibling);
		const sibling = rowNode.sibling;
		if (sibling) refreshNodes.add(sibling);
		let parent = rowNode.parent;
		while (parent) {
			if (parent.sibling?.footer && gos.get("groupTotalRow")) refreshNodes.add(parent.sibling);
			else if (!parent.parent && parent.sibling && gos.get("grandTotalRow")) refreshNodes.add(parent.sibling);
			else refreshNodes.add(parent);
			parent = parent.parent;
		}
		updatedNodes.forEach((node) => this.dispatchEditValuesChanged({
			rowNode: node,
			column
		}, edit));
		updatedNodes.forEach((node) => _getCellCtrl(beans, {
			rowNode: node,
			column
		})?.refreshCell(params));
		refreshNodes.forEach((node) => _getCellCtrl(beans, {
			rowNode: node,
			column
		})?.refreshCell(params));
	}
	stopAllEditing(cancel = false, source = "ui") {
		if (this.isEditing()) this.stopEditing(void 0, {
			cancel,
			source
		});
	}
	isCellEditable(position, source = "ui") {
		const { rowNode } = position;
		if (rowNode.group) {
			if (this.gos.get("treeData")) {
				if (!rowNode.data && !this.gos.get("enableGroupEdit")) return false;
			} else if (!this.gos.get("enableGroupEdit")) return false;
		}
		this.strategy ?? (this.strategy = this.createStrategy());
		return this.strategy?.isCellEditable(position, source) ?? false;
	}
	cellEditingInvalidCommitBlocks() {
		return this.gos.get("invalidEditValueMode") === "block";
	}
	checkNavWithValidation(position, event, focus = true) {
		if (this.hasValidationErrors(position)) {
			const cellCtrl = _getCellCtrl(this.beans, position);
			if (this.cellEditingInvalidCommitBlocks()) {
				event?.preventDefault?.();
				if (focus) {
					!cellCtrl?.hasBrowserFocus() && cellCtrl?.focusCell();
					cellCtrl?.comp?.getCellEditor()?.focusIn?.();
				}
				return "block-stop";
			}
			cellCtrl && this.revertSingleCellEdit(cellCtrl);
			return "revert-continue";
		}
		return "continue";
	}
	revertSingleCellEdit(cellPosition, focus = false) {
		const cellCtrl = _getCellCtrl(this.beans, cellPosition);
		if (!cellCtrl?.comp?.getCellEditor()) return;
		_destroyEditors(this.beans, [cellPosition], { silent: true });
		this.model.clearEditValue(cellPosition);
		_setupEditor(this.beans, cellPosition, { silent: true });
		_populateModelValidationErrors(this.beans);
		cellCtrl?.refreshCell(FORCE_REFRESH);
		cellCtrl.rowCtrl.rowEditStyleFeature?.applyRowStyles();
		if (!focus) return;
		cellCtrl?.focusCell();
		cellCtrl?.comp?.getCellEditor()?.focusIn?.();
	}
	hasValidationErrors(position) {
		_populateModelValidationErrors(this.beans);
		const cellCtrl = _getCellCtrl(this.beans, position);
		if (cellCtrl) {
			cellCtrl.refreshCell(FORCE_REFRESH);
			cellCtrl.rowCtrl.rowEditStyleFeature?.applyRowStyles();
		}
		let invalid = false;
		if (position?.rowNode) {
			invalid || (invalid = this.model.getRowValidationModel().hasRowValidation({ rowNode: position.rowNode }));
			if (position.column) invalid || (invalid = this.model.getCellValidationModel().hasCellValidation({
				rowNode: position.rowNode,
				column: position.column
			}));
		} else {
			invalid || (invalid = this.model.getCellValidationModel().getCellValidationMap().size > 0);
			invalid || (invalid = this.model.getRowValidationModel().getRowValidationMap().size > 0);
		}
		return invalid;
	}
	moveToNextCell(prev, backwards, event, source = "ui") {
		let res;
		const editing = this.isEditing();
		const preventNavigation = editing && this.checkNavWithValidation(void 0, event) === "block-stop";
		if (prev instanceof CellCtrl && editing) res = this.strategy?.moveToNextEditingCell(prev, backwards, event, source, preventNavigation);
		if (res === null) return res;
		res = res || !!this.beans.focusSvc.focusedHeader;
		if (res === false && !preventNavigation) this.stopEditing();
		return res;
	}
	getCellDataValue({ rowNode, column }, preferEditor = true) {
		if (!rowNode || !column) return;
		let edit = this.model.getEdit({
			rowNode,
			column
		});
		const pinnedSibling = rowNode.pinnedSibling;
		if (pinnedSibling) {
			const siblingEdit = this.model.getEdit({
				rowNode: pinnedSibling,
				column
			});
			if (siblingEdit) edit = siblingEdit;
		}
		const newValue = preferEditor ? edit?.editorValue ?? edit?.pendingValue : edit?.pendingValue;
		return newValue === UNEDITED || !edit ? this.valueSvc.getValue(column, rowNode, true, "api") : newValue;
	}
	getRowDataValue(rowNode, params) {
		return this.model.getEditRowDataValue(rowNode, params);
	}
	addStopEditingWhenGridLosesFocus(viewports) {
		_addStopEditingWhenGridLosesFocus(this, this.beans, viewports);
	}
	createPopupEditorWrapper(params) {
		return new PopupEditorWrapper(params);
	}
	setDataValue(position, newValue, eventSource) {
		if ((!this.isEditing() || eventSource === "commit") && !SET_DATA_SOURCE_AS_API.has(eventSource)) return;
		const { beans } = this;
		this.strategy ?? (this.strategy = this.createStrategy());
		const source = this.isBatchEditing() ? "ui" : "api";
		if (!eventSource || KEEP_EDITOR_SOURCES.has(eventSource)) {
			_syncFromEditor(beans, position, true, newValue, eventSource);
			return this.setNodeDataValue(position.rowNode, position.column, newValue, true);
		}
		const existing = this.model.getEdit(position);
		if (existing) {
			if (existing.pendingValue === newValue) return false;
			if (existing.sourceValue !== newValue) {
				_syncFromEditor(beans, position, true, newValue, eventSource);
				this.stopEditing(position, {
					source,
					suppressNavigateAfterEdit: true
				});
				return true;
			}
			if (existing.sourceValue === newValue) {
				beans.editModelSvc?.removeEdits(position);
				this.dispatchEditValuesChanged(position, {
					...existing,
					pendingValue: newValue
				});
				return true;
			}
		}
		_syncFromEditor(beans, position, true, newValue, eventSource);
		this.stopEditing(position, {
			source,
			suppressNavigateAfterEdit: true
		});
		return true;
	}
	handleColDefChanged(cellCtrl) {
		_refreshEditorOnColDefChanged(this.beans, cellCtrl);
	}
	destroy() {
		this.model.clear();
		this.destroyStrategy();
		super.destroy();
	}
	prepDetailsDuringBatch(position, params) {
		if (!this.batch) return;
		if (!this.model.hasRowEdits(position.rowNode, CHECK_SIBLING)) return;
		const { rowNode, column } = position;
		const { compDetails, valueToDisplay } = params;
		if (compDetails) {
			const { params: params2 } = compDetails;
			params2.data = this.model.getEditRowDataValue(rowNode, CHECK_SIBLING);
			return { compDetails };
		}
		const editRow = this.model.getEditRow(position.rowNode, CHECK_SIBLING);
		if (valueToDisplay !== void 0 && editRow?.has(column)) return { valueToDisplay: this.valueSvc.getValue(column, rowNode) };
	}
	cleanupEditors() {
		this.strategy?.cleanupEditors();
	}
	dispatchCellEvent(position, event, type, payload) {
		this.strategy?.dispatchCellEvent(position, event, type, payload);
	}
	dispatchRowEvent(position, type) {
		this.strategy?.dispatchRowEvent(position, type);
	}
	dispatchBatchEvent(type, edits) {
		this.eventSvc.dispatchEvent(this.createBatchEditEvent(type, edits));
	}
	createBatchEditEvent(type, edits) {
		return _addGridCommonParams(this.gos, {
			type,
			...type === "batchEditingStopped" ? { changes: this.toEventChangeList(edits) } : {}
		});
	}
	toEventChangeList(edits) {
		return this.model.getEditPositions(edits).map((edit) => ({
			rowIndex: edit.rowNode.rowIndex,
			rowPinned: edit.rowNode.rowPinned,
			columnId: edit.column.getColId(),
			newValue: edit.pendingValue,
			oldValue: edit.sourceValue
		}));
	}
	applyBulkEdit({ rowNode, column }, ranges) {
		if (!ranges || ranges.length === 0) return;
		const { beans, rangeSvc, valueSvc } = this;
		_syncFromEditors(beans, true);
		const edits = this.model.getEditMap(true);
		const editValue = edits.get(rowNode)?.get(column)?.pendingValue;
		if (!this.batch) this.eventSvc.dispatchEvent({ type: "bulkEditingStarted" });
		ranges.forEach((range) => {
			rangeSvc?.forEachRowInRange(range, (position) => {
				const rowNode2 = _getRowNode(beans, position);
				if (rowNode2 === void 0) return;
				const editRow = edits.get(rowNode2) ?? /* @__PURE__ */ new Map();
				for (const column2 of range.columns) {
					if (!column2) continue;
					if (this.isCellEditable({
						rowNode: rowNode2,
						column: column2
					}, "api")) {
						const sourceValue = valueSvc.getValue(column2, rowNode2, true, "api");
						let pendingValue = valueSvc.parseValue(column2, rowNode2 ?? null, editValue, sourceValue);
						if (Number.isNaN(pendingValue)) pendingValue = null;
						editRow.set(column2, {
							editorValue: void 0,
							pendingValue,
							sourceValue,
							state: "changed"
						});
					}
				}
				if (editRow.size > 0) edits.set(rowNode2, editRow);
			});
			this.setEditMap(edits);
			if (this.batch) {
				this.cleanupEditors();
				_purgeUnchangedEdits(beans);
				this.bulkRefresh();
				return;
			}
			this.stopEditing(void 0, { source: "api" });
			this.eventSvc.dispatchEvent({
				type: "bulkEditingStopped",
				changes: this.toEventChangeList(edits)
			});
		});
		this.bulkRefresh();
		const cellCtrl = _getCellCtrl(beans, {
			rowNode,
			column
		});
		if (cellCtrl) cellCtrl.focusCell(true);
	}
	createCellStyleFeature(cellCtrl, beans) {
		return new CellEditStyleFeature(cellCtrl, beans);
	}
	createRowStyleFeature(rowCtrl, beans) {
		return new RowEditStyleFeature(rowCtrl, beans);
	}
	setEditingCells(cells, params) {
		const { beans } = this;
		const { colModel, valueSvc } = beans;
		const edits = /* @__PURE__ */ new Map();
		cells.forEach(({ colId, column, colKey, rowIndex, rowPinned, newValue: pendingValue, state }) => {
			const col = colId ? colModel.getCol(colId) : colKey ? colModel.getCol(colKey) : column;
			if (!col) return;
			const rowNode = _getRowNode(beans, {
				rowIndex,
				rowPinned
			});
			if (!rowNode) return;
			const sourceValue = valueSvc.getValue(col, rowNode, true, "api");
			if (!_sourceAndPendingDiffer({
				pendingValue,
				sourceValue
			}) && state !== "editing") return;
			let editRow = edits.get(rowNode);
			if (!editRow) {
				editRow = /* @__PURE__ */ new Map();
				edits.set(rowNode, editRow);
			}
			if (pendingValue === void 0) pendingValue = UNEDITED;
			editRow.set(col, {
				editorValue: void 0,
				pendingValue,
				sourceValue,
				state: state ?? "changed"
			});
		});
		this.setEditMap(edits, params);
	}
	onCellFocused(event) {
		const cellCtrl = _getCellCtrl(this.beans, event);
		if (!cellCtrl || !this.isEditing(cellCtrl, CHECK_SIBLING)) return;
		const edit = this.model.getEdit(cellCtrl);
		if (!edit || !_sourceAndPendingDiffer(edit)) return;
		const label = this.getLocaleTextFunc()("ariaPendingChange", "Pending Change");
		this.beans.ariaAnnounce?.announceValue(label, "pendingChange");
	}
	allowedFocusTargetOnValidation(cellPosition) {
		return _getCellCtrl(this.beans, cellPosition);
	}
};
var BaseEditStrategy = class extends BeanStub {
	postConstruct() {
		this.model = this.beans.editModelSvc;
		this.editSvc = this.beans.editSvc;
		this.addManagedEventListeners({
			cellFocused: this.onCellFocusChanged?.bind(this),
			cellFocusCleared: this.onCellFocusChanged?.bind(this)
		});
	}
	clearEdits(position) {
		this.model.clearEditValue(position);
	}
	onCellFocusChanged(event) {
		let cellCtrl;
		const previous = event["previousParams"];
		const { editSvc, beans } = this;
		const sourceEvent = event.type === "cellFocused" ? event.sourceEvent : null;
		if (previous) cellCtrl = _getCellCtrl(beans, previous);
		const { gos, editModelSvc } = beans;
		const isFocusCleared = event.type === "cellFocusCleared";
		if (editSvc.isEditing(void 0, { withOpenEditor: true })) {
			const { column, rowIndex, rowPinned } = event;
			const cellPositionFromEvent = {
				column,
				rowNode: _getRowNode(beans, {
					rowIndex,
					rowPinned
				})
			};
			const isBlock = gos.get("invalidEditValueMode") === "block";
			if (isBlock) return;
			const shouldRevert = !isBlock;
			const hasError = !!editModelSvc?.getCellValidationModel().hasCellValidation(cellPositionFromEvent);
			const shouldCancel = shouldRevert && hasError;
			if (!(previous || isFocusCleared ? editSvc.stopEditing(void 0, {
				cancel: shouldCancel,
				source: isFocusCleared && shouldRevert ? "api" : void 0,
				event: sourceEvent
			}) : true)) if (editSvc.isBatchEditing()) editSvc.cleanupEditors();
			else editSvc.stopEditing(void 0, { source: "api" });
		}
		cellCtrl?.refreshCell({
			suppressFlash: true,
			force: true
		});
	}
	isCellEditable({ rowNode, column }, _source = "ui") {
		return column.isColumnFunc(rowNode, column.getColDef().editable);
	}
	stop(cancel, event) {
		const editingCells = this.model.getEditPositions();
		const results = {
			all: [],
			pass: [],
			fail: []
		};
		editingCells.forEach((cell) => {
			results.all.push(cell);
			if ((this.model.getCellValidationModel().getCellValidation(cell)?.errorMessages?.length ?? 0) > 0) {
				results.fail.push(cell);
				return;
			}
			results.pass.push(cell);
		});
		if (cancel) {
			editingCells.forEach((cell) => {
				_destroyEditor(this.beans, cell);
				this.model.stop(cell);
			});
			return true;
		}
		const actions$1 = this.processValidationResults(results);
		if (actions$1.destroy.length > 0) actions$1.destroy.forEach((cell) => {
			_destroyEditor(this.beans, cell, { event });
			this.model.stop(cell);
		});
		if (actions$1.keep.length > 0) actions$1.keep.forEach((cell) => {
			const cellCtrl = _getCellCtrl(this.beans, cell);
			if (!this.editSvc?.cellEditingInvalidCommitBlocks()) cellCtrl && this.editSvc.revertSingleCellEdit(cellCtrl);
		});
		return true;
	}
	cleanupEditors({ rowNode } = {}, includeEditing) {
		_syncFromEditors(this.beans, false);
		const positions = this.model.getEditPositions();
		const discard = [];
		if (rowNode) positions.forEach((pos) => {
			if (!(!rowNode || pos.rowNode === rowNode)) discard.push(pos);
		});
		else positions.forEach((pos) => {
			discard.push(pos);
		});
		_destroyEditors(this.beans, discard);
		_purgeUnchangedEdits(this.beans, includeEditing);
	}
	setFocusOutOnEditor(cellCtrl) {
		cellCtrl.comp?.getCellEditor()?.focusOut?.();
	}
	setFocusInOnEditor(cellCtrl) {
		const comp = cellCtrl.comp;
		const editor = comp?.getCellEditor();
		if (editor?.focusIn) editor.focusIn();
		else {
			const isFullRow = this.beans.gos.get("editType") === "fullRow";
			cellCtrl.focusCell(isFullRow);
			cellCtrl.onEditorAttachedFuncs.push(() => comp?.getCellEditor()?.focusIn?.());
		}
	}
	setupEditors(cells = this.model.getEditPositions(), position, cellStartedEdit, event, ignoreEventKey = false) {
		const key = event instanceof KeyboardEvent && !ignoreEventKey && event.key || void 0;
		_setupEditors(this.beans, cells, position, key, event, cellStartedEdit);
	}
	dispatchCellEvent(position, event, type, payload) {
		const cellCtrl = _getCellCtrl(this.beans, position);
		if (cellCtrl) this.eventSvc.dispatchEvent({
			...cellCtrl.createEvent(event ?? null, type),
			...payload
		});
	}
	dispatchRowEvent(position, type) {
		const rowCtrl = _getRowCtrl(this.beans, position);
		if (rowCtrl) this.eventSvc.dispatchEvent(rowCtrl.createRowEvent(type));
	}
	shouldStart({ column }, event, cellStartedEdit, source = "ui") {
		if (event instanceof KeyboardEvent && (event.key === KeyCode.TAB || event.key === KeyCode.ENTER || event.key === KeyCode.F2 || event.key === KeyCode.BACKSPACE && cellStartedEdit)) return true;
		if (event?.shiftKey && this.beans.rangeSvc?.getCellRanges().length != 0) return false;
		const colDef = column?.getColDef();
		const clickCount = this.deriveClickCount(colDef);
		const type = event?.type;
		if (type === "click" && event?.detail === 1 && clickCount === 1) return true;
		if (type === "dblclick" && event?.detail === 2 && clickCount === 2) return true;
		if (source === "api") return cellStartedEdit ?? false;
		return false;
	}
	shouldStop(_position, event, source = "ui") {
		const batch = this.editSvc.isBatchEditing();
		if (batch && source === "api") return true;
		if (batch && source === "ui") return false;
		if (source === "api") return true;
		if (event instanceof KeyboardEvent && !batch) return event.key === KeyCode.ENTER;
		return null;
	}
	shouldCancel(_position, event, source = "ui") {
		const batch = this.editSvc.isBatchEditing();
		if (event instanceof KeyboardEvent && !batch) {
			if (event.key === KeyCode.ESCAPE) return true;
		}
		if (batch && source === "api") return true;
		if (source === "api") return true;
		return false;
	}
	setEditMap(edits, params) {
		if (!params?.update) this.editSvc.stopEditing(void 0, {
			cancel: true,
			source: "api"
		});
		const cells = [];
		edits.forEach((editRow, rowNode) => {
			editRow.forEach((cellData, column) => {
				if (cellData.state === "editing") cells.push({
					...cellData,
					rowNode,
					column
				});
			});
		});
		if (params?.update) edits = new Map([...this.model.getEditMap(), ...edits]);
		this.model?.setEditMap(edits);
		if (cells.length > 0) {
			const cell = cells.at(-1);
			const key = cell.pendingValue === UNEDITED ? void 0 : cell.pendingValue;
			this.start(cell, new KeyboardEvent("keydown", { key }), "api");
			const cellCtrl = _getCellCtrl(this.beans, cell);
			if (cellCtrl) this.setFocusInOnEditor(cellCtrl);
		}
	}
	deriveClickCount(colDef) {
		const { gos } = this.beans;
		if (gos.get("suppressClickEdit") === true) return 0;
		if (gos.get("singleClickEdit") === true) return 1;
		if (colDef?.singleClickEdit) return 1;
		return 2;
	}
	destroy() {
		this.cleanupEditors();
		super.destroy();
	}
};
var FullRowEditStrategy = class extends BaseEditStrategy {
	constructor() {
		super(...arguments);
		this.beanName = "fullRow";
		this.startedRows = [];
	}
	isCellEditable(position, source = "ui") {
		const editable = super.isCellEditable(position, source);
		if (editable === true || source === "ui") return editable;
		return this.beans.colModel.getCols().some((col) => super.isCellEditable({
			rowNode: position.rowNode,
			column: col
		}, source));
	}
	shouldStop(position, event, _source = "ui") {
		const { rowNode } = position || {};
		if (!_getRowCtrl(this.beans, { rowNode: this.rowNode })) return true;
		const res = super.shouldStop({ rowNode: this.rowNode }, event, _source);
		if (res !== null) return res;
		if (!this.rowNode) return false;
		return rowNode !== this.rowNode;
	}
	midBatchInputsAllowed({ rowNode }) {
		if (!rowNode) return false;
		return this.model.hasEdits({ rowNode });
	}
	clearEdits(position) {
		this.model.clearEditValue(position);
	}
	start(position, event, _source = "ui", ignoreEventKey) {
		const { rowNode } = position;
		if (this.rowNode !== rowNode) super.cleanupEditors(position);
		this.dispatchRowEvent({ rowNode }, "rowEditingStarted");
		this.startedRows.push(rowNode);
		const columns = this.beans.visibleCols.allCols;
		const cells = [];
		columns.forEach((column) => {
			if (!column.isCellEditable(rowNode)) return;
			const position2 = {
				rowNode,
				column
			};
			cells.push(position2);
			if (!this.model.hasEdits(position2)) this.model.start(position2);
		});
		this.rowNode = rowNode;
		this.setupEditors(cells, position, true, event, ignoreEventKey);
	}
	processValidationResults(results) {
		if (results.fail.length > 0 && this.editSvc.cellEditingInvalidCommitBlocks()) return {
			destroy: [],
			keep: results.all
		};
		return {
			destroy: results.all,
			keep: []
		};
	}
	stop(cancel, event) {
		const { rowNode } = this;
		if (rowNode && !this.model.hasRowEdits(rowNode)) return false;
		const changedRows = [];
		if (!cancel) this.model.getEditMap().forEach((rowEdits, rowNode2) => {
			if (!rowEdits || rowEdits.size === 0) return;
			for (const edit of rowEdits.values()) if (_sourceAndPendingDiffer(edit)) {
				changedRows.push(rowNode2);
				break;
			}
		});
		_populateModelValidationErrors(this.beans);
		if (!cancel && this.editSvc?.checkNavWithValidation({ rowNode }) === "block-stop") return false;
		super.stop(cancel, event);
		changedRows.forEach((rowNode2) => this.dispatchRowEvent({ rowNode: rowNode2 }, "rowValueChanged"));
		this.cleanupEditors({ rowNode }, true);
		this.rowNode = void 0;
		return true;
	}
	onCellFocusChanged(event) {
		const { rowIndex } = event;
		const prev = event["previousParams"];
		if (prev?.rowIndex === rowIndex || event.sourceEvent instanceof KeyboardEvent) return;
		const prevCell = _getCellCtrl(this.beans, prev);
		if (this.gos.get("invalidEditValueMode") === "block" && prevCell && (this.model.getCellValidationModel().getCellValidation(prevCell) || this.model.getRowValidationModel().getRowValidation(prevCell))) return;
		super.onCellFocusChanged(event);
	}
	cleanupEditors(position = {}, includeEditing) {
		super.cleanupEditors(position, includeEditing);
		this.startedRows.forEach((rowNode) => this.dispatchRowEvent({ rowNode }, "rowEditingStopped"));
		this.startedRows.length = 0;
	}
	moveToNextEditingCell(prevCell, backwards, event, source = "ui", preventNavigation = false) {
		const prevPos = prevCell.cellPosition;
		let nextCell;
		this.model.suspend(true);
		try {
			nextCell = this.beans.navigation?.findNextCellToFocusOn(prevPos, {
				backwards,
				startEditing: true,
				skipToNextEditableCell: false
			});
		} finally {
			this.model.suspend(false);
		}
		if (nextCell === false) return null;
		if (nextCell == null) return false;
		const nextPos = nextCell.cellPosition;
		const prevEditable = prevCell.isCellEditable();
		const nextEditable = nextCell.isCellEditable();
		const rowsMatch = nextPos && prevPos.rowIndex === nextPos.rowIndex && prevPos.rowPinned === nextPos.rowPinned;
		if (prevEditable) this.setFocusOutOnEditor(prevCell);
		this.restoreEditors();
		const suppressStartEditOnTab = this.gos.get("suppressStartEditOnTab");
		if (nextEditable && !preventNavigation) if (suppressStartEditOnTab) nextCell.focusCell(true, event);
		else {
			if (!nextCell.comp?.getCellEditor()) _setupEditor(this.beans, nextCell, {
				event,
				cellStartedEdit: true
			});
			this.setFocusInOnEditor(nextCell);
			nextCell.focusCell(false, event);
		}
		else {
			if (nextEditable && preventNavigation) this.setFocusInOnEditor(nextCell);
			nextCell.focusCell(true, event);
		}
		if (!rowsMatch && !preventNavigation) {
			this.cleanupEditors(nextCell, true);
			if (suppressStartEditOnTab) nextCell.focusCell(true, event);
			else this.editSvc.startEditing(nextCell, {
				startedEdit: true,
				event,
				source,
				ignoreEventKey: true
			});
		}
		prevCell.rowCtrl?.refreshRow({
			suppressFlash: true,
			force: true
		});
		return true;
	}
	restoreEditors() {
		this.model.getEditMap().forEach((rowEdits, rowNode) => rowEdits.forEach(({ state }, column) => {
			if (state !== "editing") return;
			const cellCtrl = _getCellCtrl(this.beans, {
				rowNode,
				column
			});
			if (cellCtrl && !cellCtrl.comp?.getCellEditor()) _setupEditor(this.beans, cellCtrl, { silent: true });
		}));
	}
	destroy() {
		super.destroy();
		this.rowNode = void 0;
		this.startedRows.length = 0;
	}
};
var SingleCellEditStrategy = class extends BaseEditStrategy {
	constructor() {
		super(...arguments);
		this.beanName = "singleCell";
	}
	shouldStop(position, event, source = "ui") {
		const res = super.shouldStop(position, event, source);
		if (res !== null) return res;
		const { rowNode, column } = position || {};
		if ((!this.rowNode || !this.column) && rowNode && column) return null;
		return this.rowNode !== rowNode || this.column !== column;
	}
	midBatchInputsAllowed(position) {
		return this.model.hasEdits(position);
	}
	start(position, event, _source = "ui", ignoreEventKey) {
		if (this.rowNode !== position.rowNode || this.column !== position.column) super.cleanupEditors();
		this.rowNode = position.rowNode;
		this.column = position.column;
		this.model.start(position);
		this.setupEditors([position], position, true, event, ignoreEventKey);
	}
	dispatchRowEvent(_position, _type) {}
	processValidationResults(results) {
		if (results.fail.length > 0 && this.editSvc.cellEditingInvalidCommitBlocks()) return {
			destroy: [],
			keep: results.all
		};
		return {
			destroy: results.all,
			keep: []
		};
	}
	stop(cancel, event) {
		super.stop(cancel, event);
		this.rowNode = void 0;
		this.column = void 0;
		return true;
	}
	onCellFocusChanged(event) {
		const { colModel, editSvc } = this.beans;
		const { rowIndex, column, rowPinned } = event;
		const rowNode = _getRowNode(this.beans, {
			rowIndex,
			rowPinned
		});
		const curColId = _getColId(column);
		const curCol = colModel.getCol(curColId);
		const previous = event["previousParams"];
		if (previous) {
			const prevColId = _getColId(previous.column);
			if (previous?.rowIndex === rowIndex && prevColId === curColId && previous?.rowPinned === rowPinned) return;
		}
		if (editSvc?.isEditing({
			rowNode,
			column: curCol
		}, { withOpenEditor: true }) && event.type === "cellFocused") return;
		super.onCellFocusChanged(event);
	}
	moveToNextEditingCell(prevCell, backwards, event, source = "ui", preventNavigation = false) {
		const prevPos = prevCell.cellPosition;
		let nextCell;
		const shouldSuspend = this.beans.gos.get("editType") === "fullRow";
		if (shouldSuspend) this.model.suspend(true);
		if (!preventNavigation) {
			prevCell.eGui.focus();
			this.editSvc?.stopEditing(prevCell, {
				source: this.editSvc?.isBatchEditing() ? "ui" : "api",
				event
			});
		}
		try {
			nextCell = this.beans.navigation?.findNextCellToFocusOn(prevPos, {
				backwards,
				startEditing: true
			});
		} finally {
			if (shouldSuspend) this.model.suspend(false);
		}
		if (nextCell === false) return null;
		if (nextCell == null) return false;
		const nextPos = nextCell.cellPosition;
		const prevEditable = prevCell.isCellEditable();
		const nextEditable = nextCell.isCellEditable();
		const rowsMatch = nextPos && prevPos.rowIndex === nextPos.rowIndex && prevPos.rowPinned === nextPos.rowPinned;
		if (prevEditable && !preventNavigation) this.setFocusOutOnEditor(prevCell);
		const suppressStartEditOnTab = this.gos.get("suppressStartEditOnTab");
		if (!rowsMatch && !preventNavigation) {
			super.cleanupEditors(nextCell, true);
			if (suppressStartEditOnTab) nextCell.focusCell(true, event);
			else this.editSvc.startEditing(nextCell, {
				startedEdit: true,
				event,
				source,
				ignoreEventKey: true
			});
		}
		if (nextEditable && !preventNavigation) {
			nextCell.focusCell(false, event);
			if (suppressStartEditOnTab) nextCell.focusCell(true, event);
			else if (!nextCell.comp?.getCellEditor()) {
				_setupEditor(this.beans, nextCell, {
					event,
					cellStartedEdit: true
				});
				this.setFocusInOnEditor(nextCell);
			}
		} else {
			if (nextEditable && preventNavigation) this.setFocusInOnEditor(nextCell);
			nextCell.focusCell(true, event);
		}
		prevCell.rowCtrl?.refreshRow({
			suppressFlash: true,
			force: true
		});
		return true;
	}
	destroy() {
		super.destroy();
		this.rowNode = void 0;
		this.column = void 0;
	}
};
var EditCoreModule = {
	moduleName: "EditCore",
	version: VERSION,
	beans: [EditModelService, EditService],
	apiFunctions: {
		getEditingCells,
		getCellEditorInstances,
		startEditingCell,
		stopEditing,
		isEditing,
		validateEdit
	},
	dynamicBeans: {
		singleCell: SingleCellEditStrategy,
		fullRow: FullRowEditStrategy
	},
	dependsOn: [PopupModule, TooltipModule],
	css: [cellEditingCSS]
};
var UndoRedoEditModule = {
	moduleName: "UndoRedoEdit",
	version: VERSION,
	beans: [UndoRedoService],
	apiFunctions: {
		undoCellEditing,
		redoCellEditing,
		getCurrentUndoSize,
		getCurrentRedoSize
	},
	dependsOn: [EditCoreModule]
};
var TextEditorModule = {
	moduleName: "TextEditor",
	version: VERSION,
	userComponents: {
		agCellEditor: TextCellEditor,
		agTextCellEditor: TextCellEditor
	},
	dependsOn: [EditCoreModule]
};
var NumberEditorModule = {
	moduleName: "NumberEditor",
	version: VERSION,
	userComponents: { agNumberCellEditor: { classImp: NumberCellEditor } },
	dependsOn: [EditCoreModule]
};
var DateEditorModule = {
	moduleName: "DateEditor",
	version: VERSION,
	userComponents: {
		agDateCellEditor: DateCellEditor,
		agDateStringCellEditor: DateStringCellEditor
	},
	dependsOn: [EditCoreModule]
};
var CheckboxEditorModule = {
	moduleName: "CheckboxEditor",
	version: VERSION,
	userComponents: { agCheckboxCellEditor: CheckboxCellEditor },
	dependsOn: [EditCoreModule]
};
var LargeTextEditorModule = {
	moduleName: "LargeTextEditor",
	version: VERSION,
	userComponents: { agLargeTextCellEditor: LargeTextCellEditor },
	dependsOn: [EditCoreModule]
};
var SelectionColService = class extends BeanStub {
	constructor() {
		super(...arguments);
		this.beanName = "selectionColSvc";
	}
	postConstruct() {
		this.addManagedPropertyListener("rowSelection", (event) => {
			this.onSelectionOptionsChanged(event.currentValue, event.previousValue, _convertColumnEventSourceType(event.source));
		});
		this.addManagedPropertyListener("selectionColumnDef", this.updateColumns.bind(this));
	}
	addColumns(cols) {
		const selectionCols = this.columns;
		if (selectionCols == null) return;
		cols.list = selectionCols.list.concat(cols.list);
		cols.tree = selectionCols.tree.concat(cols.tree);
		_updateColsMap(cols);
	}
	createColumns(cols, updateOrders) {
		const destroyCollection = () => {
			_destroyColumnTree(this.beans, this.columns?.tree);
			this.columns = null;
		};
		const newTreeDepth = cols.treeDepth;
		const treeDepthSame = (this.columns?.treeDepth ?? -1) == newTreeDepth;
		const list = this.generateSelectionCols();
		if (_areColIdsEqual(list, this.columns?.list ?? []) && treeDepthSame) return;
		destroyCollection();
		const { colGroupSvc } = this.beans;
		const treeDepth = colGroupSvc?.findDepth(cols.tree) ?? 0;
		this.columns = {
			list,
			tree: colGroupSvc?.balanceTreeForAutoCols(list, treeDepth) ?? [],
			treeDepth,
			map: {}
		};
		const putSelectionColsFirstInList = (cols2) => {
			if (!cols2) return null;
			const colsFiltered = cols2.filter((col) => !isColumnSelectionCol(col));
			return [...list, ...colsFiltered];
		};
		updateOrders(putSelectionColsFirstInList);
	}
	updateColumns(event) {
		const source = _convertColumnEventSourceType(event.source);
		this.columns?.list.forEach((col) => {
			const newColDef = this.createSelectionColDef(event.currentValue);
			col.setColDef(newColDef, null, source);
			_applyColumnState(this.beans, { state: [{
				...newColDef,
				colId: col.getColId()
			}] }, source);
		});
	}
	getColumn(key) {
		return this.columns?.list.find((col) => _columnsMatch(col, key)) ?? null;
	}
	getColumns() {
		return this.columns?.list ?? null;
	}
	isSelectionColumnEnabled() {
		const { gos, beans } = this;
		const rowSelection = gos.get("rowSelection");
		if (typeof rowSelection !== "object" || !_isRowSelection(gos)) return false;
		const hasAutoCols = (beans.autoColSvc?.getColumns()?.length ?? 0) > 0;
		if (rowSelection.checkboxLocation === "autoGroupColumn" && hasAutoCols) return false;
		const checkboxes = !!_getCheckboxes(rowSelection);
		const headerCheckbox = _getHeaderCheckbox(rowSelection);
		return checkboxes || headerCheckbox;
	}
	createSelectionColDef(def) {
		const { gos } = this.beans;
		const selectionColumnDef = def ?? gos.get("selectionColumnDef");
		const enableRTL = gos.get("enableRtl");
		const { rowSpan: _, spanRows: __,...filteredSelColDef } = selectionColumnDef ?? {};
		return {
			width: 50,
			resizable: false,
			suppressHeaderMenuButton: true,
			sortable: false,
			suppressMovable: true,
			lockPosition: enableRTL ? "right" : "left",
			comparator(valueA, valueB, nodeA, nodeB) {
				const aSelected = nodeA.isSelected();
				return aSelected === nodeB.isSelected() ? 0 : aSelected ? 1 : -1;
			},
			editable: false,
			suppressFillHandle: true,
			pinned: null,
			...filteredSelColDef,
			colId: SELECTION_COLUMN_ID,
			chartDataType: "excluded"
		};
	}
	generateSelectionCols() {
		if (!this.isSelectionColumnEnabled()) return [];
		const colDef = this.createSelectionColDef();
		const colId = colDef.colId;
		this.gos.validateColDef(colDef, colId, true);
		const col = new AgColumn(colDef, null, colId, false);
		this.createBean(col);
		return [col];
	}
	onSelectionOptionsChanged(current, prev, source) {
		const checkboxHasChanged = (prev && typeof prev !== "string" ? _getCheckboxes(prev) : void 0) !== (current && typeof current !== "string" ? _getCheckboxes(current) : void 0);
		const headerCheckboxHasChanged = (prev && typeof prev !== "string" ? _getHeaderCheckbox(prev) : void 0) !== (current && typeof current !== "string" ? _getHeaderCheckbox(current) : void 0);
		const locationChanged = _getCheckboxLocation(current) !== _getCheckboxLocation(prev);
		if (checkboxHasChanged || headerCheckboxHasChanged || locationChanged) this.beans.colModel.refreshAll(source);
	}
	destroy() {
		_destroyColumnTree(this.beans, this.columns?.tree);
		super.destroy();
	}
	refreshVisibility(leftCols, centerCols, rightCols) {
		if (!this.columns?.list.length) return;
		const numVisibleCols = leftCols.length + centerCols.length + rightCols.length;
		if (numVisibleCols === 0) return;
		const column = this.columns.list[0];
		if (!column.isVisible()) return;
		const hideSelectionCol = () => {
			let cols;
			switch (column.pinned) {
				case "left":
				case true:
					cols = leftCols;
					break;
				case "right":
					cols = rightCols;
					break;
				default: cols = centerCols;
			}
			cols && _removeFromArray(cols, column);
		};
		if ((this.beans.rowNumbersSvc?.getColumn("ag-Grid-RowNumbersColumn") ? 2 : 1) === numVisibleCols) hideSelectionCol();
	}
};
function setNodesSelected(beans, params) {
	if (!params.nodes.every((node) => {
		if (node.rowPinned && !_isManualPinnedRow(node)) {
			_warn(59);
			return false;
		}
		if (node.id === void 0) {
			_warn(60);
			return false;
		}
		return true;
	})) return;
	const { nodes, source, newValue } = params;
	beans.selectionSvc?.setNodesSelected({
		nodes,
		source: source ?? "api",
		newValue
	});
}
function selectAll(beans, selectAll2, source = "apiSelectAll") {
	beans.selectionSvc?.selectAllRowNodes({
		source,
		selectAll: selectAll2
	});
}
function deselectAll(beans, selectAll2, source = "apiSelectAll") {
	beans.selectionSvc?.deselectAllRowNodes({
		source,
		selectAll: selectAll2
	});
}
function selectAllFiltered(beans, source = "apiSelectAllFiltered") {
	beans.selectionSvc?.selectAllRowNodes({
		source,
		selectAll: "filtered"
	});
}
function deselectAllFiltered(beans, source = "apiSelectAllFiltered") {
	beans.selectionSvc?.deselectAllRowNodes({
		source,
		selectAll: "filtered"
	});
}
function selectAllOnCurrentPage(beans, source = "apiSelectAllCurrentPage") {
	beans.selectionSvc?.selectAllRowNodes({
		source,
		selectAll: "currentPage"
	});
}
function deselectAllOnCurrentPage(beans, source = "apiSelectAllCurrentPage") {
	beans.selectionSvc?.deselectAllRowNodes({
		source,
		selectAll: "currentPage"
	});
}
function getSelectedNodes(beans) {
	return beans.selectionSvc?.getSelectedNodes() ?? [];
}
function getSelectedRows(beans) {
	return beans.selectionSvc?.getSelectedRows() ?? [];
}
var SelectionService = class extends BaseSelectionService {
	constructor() {
		super(...arguments);
		this.beanName = "selectionSvc";
		this.selectedNodes = /* @__PURE__ */ new Map();
		this.detailSelection = /* @__PURE__ */ new Map();
		this.masterSelectsDetail = false;
	}
	postConstruct() {
		super.postConstruct();
		const { gos } = this;
		this.mode = _getRowSelectionMode(gos);
		this.groupSelectsDescendants = _getGroupSelectsDescendants(gos);
		this.groupSelectsFiltered = _getGroupSelection(gos) === "filteredDescendants";
		this.masterSelectsDetail = _getMasterSelects(gos) === "detail";
		this.addManagedPropertyListeners([
			"groupSelectsChildren",
			"groupSelectsFiltered",
			"rowSelection"
		], () => {
			const groupSelectsDescendants = _getGroupSelectsDescendants(gos);
			const selectionMode = _getRowSelectionMode(gos);
			const groupSelectsFiltered = _getGroupSelection(gos) === "filteredDescendants";
			this.masterSelectsDetail = _getMasterSelects(gos) === "detail";
			if (groupSelectsDescendants !== this.groupSelectsDescendants || groupSelectsFiltered !== this.groupSelectsFiltered || selectionMode !== this.mode) {
				this.deselectAllRowNodes({ source: "api" });
				this.groupSelectsDescendants = groupSelectsDescendants;
				this.groupSelectsFiltered = groupSelectsFiltered;
				this.mode = selectionMode;
			}
		});
		this.addManagedEventListeners({ rowSelected: this.onRowSelected.bind(this) });
	}
	destroy() {
		super.destroy();
		this.resetNodes();
	}
	handleSelectionEvent(event, rowNode, source) {
		if (this.isRowSelectionBlocked(rowNode)) return 0;
		const selection = this.inferNodeSelections(rowNode, event.shiftKey, event.metaKey || event.ctrlKey, source);
		if (selection == null) return 0;
		this.selectionCtx.selectAll = false;
		if ("select" in selection) {
			if (selection.reset) this.resetNodes();
			else this.selectRange(selection.deselect, false, source);
			return this.selectRange(selection.select, true, source);
		} else return this.setNodesSelected({
			nodes: [selection.node],
			newValue: selection.newValue,
			clearSelection: selection.clearSelection,
			keepDescendants: selection.keepDescendants,
			event,
			source
		});
	}
	setNodesSelected({ newValue, clearSelection, suppressFinishActions, nodes, event, source, keepDescendants = false }) {
		if (!_isRowSelection(this.gos) && newValue) {
			_warn(132);
			return 0;
		}
		if (nodes.length === 0) return 0;
		if (nodes.length > 1 && !this.isMultiSelect()) {
			_warn(130);
			return 0;
		}
		let updatedCount = 0;
		for (let i = 0; i < nodes.length; i++) {
			const rowNode = nodes[i];
			const node = _normaliseSiblingRef(rowNode);
			const skipThisNode = this.groupSelectsFiltered && node.group;
			if (node.rowPinned && !_isManualPinnedRow(node)) {
				_warn(59);
				continue;
			}
			if (node.id === void 0) {
				_warn(60);
				continue;
			}
			if (!skipThisNode) {
				if (this.selectRowNode(node, newValue, event, source)) {
					this.detailSelection.delete(node.id);
					updatedCount++;
				}
			}
			if (this.groupSelectsDescendants && node.childrenAfterGroup?.length) updatedCount += this.selectChildren(node, newValue, source);
		}
		if (!suppressFinishActions) {
			if (nodes.length === 1 && source === "api") this.selectionCtx.setRoot(_normaliseSiblingRef(nodes[0]));
			if (newValue && (clearSelection || !this.isMultiSelect())) updatedCount += this.clearOtherNodes(_normaliseSiblingRef(nodes[0]), keepDescendants, source);
			if (updatedCount > 0) {
				this.updateGroupsFromChildrenSelections(source);
				this.dispatchSelectionChanged(source);
			}
		}
		return updatedCount;
	}
	selectRange(nodesToSelect, value, source) {
		let updatedCount = 0;
		nodesToSelect.forEach((node) => {
			const rowNode = _normaliseSiblingRef(node);
			if (rowNode.group && this.groupSelectsDescendants) return;
			if (this.selectRowNode(rowNode, value, void 0, source)) updatedCount++;
		});
		if (updatedCount > 0) {
			this.updateGroupsFromChildrenSelections(source);
			this.dispatchSelectionChanged(source);
		}
		return updatedCount;
	}
	selectChildren(node, newValue, source) {
		const children = this.groupSelectsFiltered ? node.childrenAfterAggFilter : node.childrenAfterGroup;
		if (!children) return 0;
		return this.setNodesSelected({
			newValue,
			clearSelection: false,
			suppressFinishActions: true,
			source,
			nodes: children
		});
	}
	getSelectedNodes() {
		return Array.from(this.selectedNodes.values());
	}
	getSelectedRows() {
		const selectedRows = [];
		this.selectedNodes.forEach((rowNode) => rowNode.data && selectedRows.push(rowNode.data));
		return selectedRows;
	}
	getSelectionCount() {
		return this.selectedNodes.size;
	}
	filterFromSelection(predicate) {
		const newSelectedNodes = /* @__PURE__ */ new Map();
		this.selectedNodes.forEach((rowNode, key) => {
			if (predicate(rowNode)) newSelectedNodes.set(key, rowNode);
		});
		this.selectedNodes = newSelectedNodes;
	}
	updateGroupsFromChildrenSelections(source, changedPath) {
		if (!this.groupSelectsDescendants) return false;
		const { gos, rowModel } = this.beans;
		if (!_isClientSideRowModel(gos, rowModel)) return false;
		const rootNode = rowModel.rootNode;
		if (!rootNode) return false;
		if (!changedPath) {
			changedPath = new ChangedPath(true, rootNode);
			changedPath.active = false;
		}
		let selectionChanged = false;
		changedPath.forEachChangedNodeDepthFirst((rowNode) => {
			if (rowNode !== rootNode) {
				const selected = this.calculateSelectedFromChildren(rowNode);
				selectionChanged = this.selectRowNode(rowNode, selected === null ? false : selected, void 0, source) || selectionChanged;
			}
		});
		return selectionChanged;
	}
	clearOtherNodes(rowNodeToKeepSelected, keepDescendants, source) {
		const groupsToRefresh = /* @__PURE__ */ new Map();
		let updatedCount = 0;
		this.selectedNodes.forEach((otherRowNode) => {
			const isNodeToKeep = otherRowNode.id == rowNodeToKeepSelected.id;
			if ((keepDescendants ? !isDescendantOf(rowNodeToKeepSelected, otherRowNode) : true) && !isNodeToKeep) {
				const rowNode = this.selectedNodes.get(otherRowNode.id);
				updatedCount += this.setNodesSelected({
					nodes: [rowNode],
					newValue: false,
					clearSelection: false,
					suppressFinishActions: true,
					source
				});
				if (this.groupSelectsDescendants && otherRowNode.parent) groupsToRefresh.set(otherRowNode.parent.id, otherRowNode.parent);
			}
		});
		groupsToRefresh.forEach((group) => {
			const selected = this.calculateSelectedFromChildren(group);
			this.selectRowNode(group, selected === null ? false : selected, void 0, source);
		});
		return updatedCount;
	}
	onRowSelected(event) {
		const rowNode = event.node;
		if (this.groupSelectsDescendants && rowNode.group) return;
		if (rowNode.isSelected()) this.selectedNodes.set(rowNode.id, rowNode);
		else this.selectedNodes.delete(rowNode.id);
	}
	syncInRowNode(rowNode, oldNode) {
		this.syncInOldRowNode(rowNode, oldNode);
		this.syncInNewRowNode(rowNode);
	}
	createDaemonNode(rowNode) {
		if (!rowNode.id) return;
		const oldNode = new RowNode(this.beans);
		oldNode.id = rowNode.id;
		oldNode.data = rowNode.data;
		oldNode.__daemon = true;
		oldNode.__selected = rowNode.__selected;
		oldNode.level = rowNode.level;
		return oldNode;
	}
	syncInOldRowNode(rowNode, oldNode) {
		if (oldNode && rowNode.id !== oldNode.id) {
			if (this.selectedNodes.get(oldNode.id) == rowNode) this.selectedNodes.set(oldNode.id, oldNode);
		}
	}
	syncInNewRowNode(rowNode) {
		if (this.selectedNodes.has(rowNode.id)) {
			rowNode.__selected = true;
			this.selectedNodes.set(rowNode.id, rowNode);
		} else rowNode.__selected = false;
	}
	reset(source) {
		const selectionCount = this.getSelectionCount();
		this.resetNodes();
		if (selectionCount) this.dispatchSelectionChanged(source);
	}
	resetNodes() {
		this.selectedNodes.forEach((node) => {
			this.selectRowNode(node, false);
		});
		this.selectedNodes.clear();
	}
	getBestCostNodeSelection() {
		const { gos, rowModel } = this.beans;
		if (!_isClientSideRowModel(gos, rowModel)) return;
		const topLevelNodes = rowModel.getTopLevelNodes();
		if (topLevelNodes === null) return;
		const result = [];
		function traverse(nodes) {
			for (let i = 0, l = nodes.length; i < l; i++) {
				const node = nodes[i];
				if (node.isSelected()) result.push(node);
				else if (node.group && node.childrenAfterGroup) traverse(node.childrenAfterGroup);
			}
		}
		traverse(topLevelNodes);
		return result;
	}
	isEmpty() {
		return this.getSelectionCount() === 0;
	}
	deselectAllRowNodes({ source, selectAll: selectAll2 }) {
		const rowModelClientSide = _isClientSideRowModel(this.gos);
		let updatedNodes = false;
		const callback = (rowNode) => {
			const updated = this.selectRowNode(_normaliseSiblingRef(rowNode), false, void 0, source);
			updatedNodes || (updatedNodes = updated);
		};
		if (selectAll2 === "currentPage" || selectAll2 === "filtered") {
			if (!rowModelClientSide) {
				_error(102);
				return;
			}
			this.getNodesToSelect(selectAll2).forEach(callback);
		} else {
			this.selectedNodes.forEach(callback);
			this.reset(source);
		}
		this.selectionCtx.selectAll = false;
		if (rowModelClientSide && this.groupSelectsDescendants) {
			const updated = this.updateGroupsFromChildrenSelections(source);
			updatedNodes || (updatedNodes = updated);
		}
		if (updatedNodes) this.dispatchSelectionChanged(source);
	}
	getSelectedCounts(selectAll2) {
		let selectedCount = 0;
		let notSelectedCount = 0;
		this.getNodesToSelect(selectAll2).forEach((node) => {
			if (this.groupSelectsDescendants && node.group) return;
			if (node.isSelected()) selectedCount++;
			else if (node.selectable) notSelectedCount++;
		});
		return {
			selectedCount,
			notSelectedCount
		};
	}
	getSelectAllState(selectAll2) {
		const { selectedCount, notSelectedCount } = this.getSelectedCounts(selectAll2);
		return _calculateSelectAllState(selectedCount, notSelectedCount) ?? null;
	}
	hasNodesToSelect(selectAll2) {
		return this.getNodesToSelect(selectAll2).filter((node) => node.selectable).length > 0;
	}
	getNodesToSelect(selectAll2) {
		if (!this.canSelectAll()) return [];
		const nodes = [];
		const addToResult = (node) => nodes.push(node);
		if (selectAll2 === "currentPage") {
			this.forEachNodeOnPage((node) => {
				if (!node.group) {
					addToResult(node);
					return;
				}
				if (!node.expanded && !node.footer) {
					const recursivelyAddChildren = (child) => {
						addToResult(child);
						child.childrenAfterFilter?.forEach(recursivelyAddChildren);
					};
					recursivelyAddChildren(node);
					return;
				}
				if (!this.groupSelectsDescendants) addToResult(node);
			});
			return nodes;
		}
		const clientSideRowModel = this.beans.rowModel;
		if (selectAll2 === "filtered") {
			clientSideRowModel.forEachNodeAfterFilter(addToResult);
			return nodes;
		}
		clientSideRowModel.forEachNode(addToResult);
		return nodes;
	}
	forEachNodeOnPage(callback) {
		const { pageBounds, rowModel } = this.beans;
		const firstRow = pageBounds.getFirstRow();
		const lastRow = pageBounds.getLastRow();
		for (let i = firstRow; i <= lastRow; i++) {
			const node = rowModel.getRow(i);
			if (node) callback(node);
		}
	}
	selectAllRowNodes(params) {
		const { gos, selectionCtx } = this;
		if (!_isRowSelection(gos)) {
			_warn(132);
			return;
		}
		if (_isUsingNewRowSelectionAPI(gos) && !_isMultiRowSelection(gos)) {
			_warn(130);
			return;
		}
		if (!this.canSelectAll()) return;
		const { source, selectAll: selectAll2 } = params;
		let updatedNodes = false;
		this.getNodesToSelect(selectAll2).forEach((rowNode) => {
			const updated = this.selectRowNode(_normaliseSiblingRef(rowNode), true, void 0, source);
			updatedNodes || (updatedNodes = updated);
		});
		selectionCtx.selectAll = true;
		if (_isClientSideRowModel(gos) && this.groupSelectsDescendants) {
			const updated = this.updateGroupsFromChildrenSelections(source);
			updatedNodes || (updatedNodes = updated);
		}
		if (updatedNodes) this.dispatchSelectionChanged(source);
	}
	getSelectionState() {
		return this.isEmpty() ? null : Array.from(this.selectedNodes.keys());
	}
	setSelectionState(state, source, clearSelection) {
		if (!state) state = [];
		if (!Array.isArray(state)) {
			_error(103);
			return;
		}
		const rowIds = new Set(state);
		const nodes = [];
		this.beans.rowModel.forEachNode((node) => {
			if (rowIds.has(node.id)) nodes.push(node);
		});
		if (clearSelection) this.resetNodes();
		this.setNodesSelected({
			newValue: true,
			nodes,
			source
		});
	}
	canSelectAll() {
		const { gos } = this.beans;
		if (!_isClientSideRowModel(gos)) return false;
		return true;
	}
	updateSelectable(changedPath) {
		const { gos, rowModel } = this.beans;
		if (!_isRowSelection(gos)) return;
		const source = "selectableChanged";
		const skipLeafNodes = changedPath !== void 0;
		const isCSRMGroupSelectsDescendants = _isClientSideRowModel(gos) && this.groupSelectsDescendants;
		const nodesToDeselect = [];
		const nodeCallback = (node) => {
			if (skipLeafNodes && !node.group) return;
			if (isCSRMGroupSelectsDescendants && node.group) {
				const hasSelectableChild = node.childrenAfterGroup?.some((rowNode) => rowNode.selectable) ?? false;
				this.setRowSelectable(node, hasSelectableChild, true);
				return;
			}
			if (!this.updateRowSelectable(node, true) && node.isSelected()) nodesToDeselect.push(node);
		};
		if (isCSRMGroupSelectsDescendants) {
			if (changedPath === void 0) {
				const rootNode = rowModel.rootNode;
				changedPath = rootNode ? new ChangedPath(false, rootNode) : void 0;
			}
			changedPath?.forEachChangedNodeDepthFirst(nodeCallback, !skipLeafNodes, !skipLeafNodes);
		} else rowModel.forEachNode(nodeCallback);
		if (nodesToDeselect.length) this.setNodesSelected({
			nodes: nodesToDeselect,
			newValue: false,
			source
		});
		if (!skipLeafNodes && isCSRMGroupSelectsDescendants) this.updateGroupsFromChildrenSelections?.(source);
	}
	updateSelectableAfterGrouping(changedPath) {
		this.updateSelectable(changedPath);
		if (this.groupSelectsDescendants) {
			if (this.updateGroupsFromChildrenSelections?.("rowGroupChanged", changedPath)) this.dispatchSelectionChanged("rowGroupChanged");
		}
	}
	refreshMasterNodeState(node, e) {
		if (!this.masterSelectsDetail) return;
		const detailApi = node.detailNode?.detailGridInfo?.api;
		if (!detailApi) return;
		const isSelectAll = _isAllSelected(detailApi);
		if (node.isSelected() !== isSelectAll) {
			if (this.selectRowNode(node, isSelectAll, e, "masterDetail")) this.dispatchSelectionChanged("masterDetail");
		}
		if (!isSelectAll) {
			const detailSelected = this.detailSelection.get(node.id) ?? /* @__PURE__ */ new Set();
			for (const n of detailApi.getSelectedNodes()) detailSelected.add(n.id);
			this.detailSelection.set(node.id, detailSelected);
		}
	}
	setDetailSelectionState(masterNode, detailGridOptions, detailApi) {
		if (!this.masterSelectsDetail) return;
		if (!_isMultiRowSelection(detailGridOptions)) {
			_warn(269);
			return;
		}
		switch (masterNode.isSelected()) {
			case true:
				detailApi.selectAll();
				break;
			case false:
				detailApi.deselectAll();
				break;
			case void 0: {
				const selectedIds = this.detailSelection.get(masterNode.id);
				if (selectedIds) {
					const nodes = [];
					for (const id of selectedIds) {
						const n = detailApi.getRowNode(id);
						if (n) nodes.push(n);
					}
					detailApi.setNodesSelected({
						nodes,
						newValue: true,
						source: "masterDetail"
					});
				}
				break;
			}
			default: break;
		}
	}
	dispatchSelectionChanged(source) {
		this.eventSvc.dispatchEvent({
			type: "selectionChanged",
			source,
			selectedNodes: this.getSelectedNodes(),
			serverSideState: null
		});
	}
};
function _normaliseSiblingRef(node) {
	return _isManualPinnedRow(node) ? node.pinnedSibling : node.footer ? node.sibling : node;
}
function _isAllSelected(api) {
	let selectedCount = 0;
	let notSelectedCount = 0;
	api.forEachNode((node) => {
		if (node.isSelected()) selectedCount++;
		else if (node.selectable) notSelectedCount++;
	});
	return _calculateSelectAllState(selectedCount, notSelectedCount);
}
function _calculateSelectAllState(selected, notSelected) {
	if (selected === 0 && notSelected === 0) return false;
	if (selected > 0 && notSelected > 0) return;
	return selected > 0;
}
function isDescendantOf(root, child) {
	let parent = child.parent;
	while (parent) {
		if (parent === root) return true;
		parent = parent.parent;
	}
	return false;
}
var RowSelectionModule = {
	moduleName: "RowSelection",
	version: VERSION,
	rowModels: [
		"clientSide",
		"infinite",
		"viewport"
	],
	beans: [SelectionService],
	dependsOn: [{
		moduleName: "SharedRowSelection",
		version: VERSION,
		beans: [SelectionColService],
		apiFunctions: {
			setNodesSelected,
			selectAll,
			deselectAll,
			selectAllFiltered,
			deselectAllFiltered,
			selectAllOnCurrentPage,
			deselectAllOnCurrentPage,
			getSelectedNodes,
			getSelectedRows
		}
	}]
};
function expandAll(beans) {
	beans.expansionSvc?.expandAll(true);
}
function collapseAll(beans) {
	beans.expansionSvc?.expandAll(false);
}
function onRowHeightChanged(beans) {
	const clientSideRowModel = _getClientSideRowModel(beans);
	const serverSideRowModel = _getServerSideRowModel(beans);
	if (clientSideRowModel) clientSideRowModel.onRowHeightChanged();
	else if (serverSideRowModel) serverSideRowModel.onRowHeightChanged();
}
var CsrmSsrmSharedApiModule = {
	moduleName: "CsrmSsrmSharedApi",
	version: VERSION,
	apiFunctions: {
		expandAll,
		collapseAll,
		onRowHeightChanged
	}
};
var ClientSideNodeManager = class extends AbstractClientSideNodeManager {
	constructor() {
		super(...arguments);
		this.beanName = "csrmNodeSvc";
	}
};
var ChangedRowNodes = class {
	constructor() {
		this.removals = /* @__PURE__ */ new Set();
		this.updates = /* @__PURE__ */ new Set();
		this.adds = /* @__PURE__ */ new Set();
	}
	remove(node) {
		if (!this.adds.delete(node)) {
			this.updates.delete(node);
			this.removals.add(node);
		}
	}
	update(node) {
		if (!this.adds.has(node)) this.updates.add(node);
	}
	add(node) {
		this.adds.add(node);
	}
};
function updateChildIndexes(rowNode) {
	if (_missing(rowNode.childrenAfterSort)) return;
	const listToSort = rowNode.childrenAfterSort;
	for (let i = 0; i < listToSort.length; i++) {
		const child = listToSort[i];
		const firstChild = i === 0;
		const lastChild = i === rowNode.childrenAfterSort.length - 1;
		child.setFirstChild(firstChild);
		if (child.lastChild !== lastChild) {
			child.lastChild = lastChild;
			child.dispatchRowEvent("lastChildChanged");
		}
		if (child.childIndex !== i) {
			child.childIndex = i;
			child.dispatchRowEvent("childIndexChanged");
		}
	}
}
function updateRowNodeAfterSort(rowNode) {
	if (rowNode.sibling) rowNode.sibling.childrenAfterSort = rowNode.childrenAfterSort;
	updateChildIndexes(rowNode);
}
var SortStage = class extends BeanStub {
	constructor() {
		super(...arguments);
		this.beanName = "sortStage";
		this.refreshProps = /* @__PURE__ */ new Set([
			"postSortRows",
			"groupDisplayType",
			"accentedSort"
		]);
		this.step = "sort";
	}
	execute(params) {
		const beans = this.beans;
		const sortOptions = beans.sortSvc.getSortOptions();
		const sortActive = _exists(sortOptions) && sortOptions.length > 0;
		const deltaSort = sortActive && !!params.changedRowNodes && this.gos.get("deltaSort");
		const sortContainsGroupColumns = sortOptions.some(({ column }) => {
			if (_isColumnsSortingCoupledToGroup(beans.gos)) return column.isPrimary() && column.isRowGroupActive();
			return !!column.getColDef().showRowGroup;
		});
		this.sort(beans, sortOptions, sortActive, deltaSort, params.changedRowNodes, params.changedPath, sortContainsGroupColumns);
	}
	sort(beans, sortOptions, sortActive, useDeltaSort, changedRowNodes, changedPath, sortContainsGroupColumns) {
		const { gos, colModel, rowGroupColsSvc, rowNodeSorter, rowRenderer, showRowGroupCols } = beans;
		const groupMaintainOrder = gos.get("groupMaintainOrder");
		const groupColumnsPresent = colModel.getCols().some((c) => c.isRowGroupActive());
		const isPivotMode = colModel.isPivotMode();
		const postSortFunc = gos.getCallback("postSortRows");
		let hasAnyFirstChildChanged = false;
		const callback = (rowNode) => {
			const skipSortingPivotLeafs = isPivotMode && rowNode.leafGroup;
			const skipSortingGroups = groupMaintainOrder && groupColumnsPresent && !rowNode.leafGroup && !sortContainsGroupColumns;
			let newChildrenAfterSort;
			if (skipSortingGroups) {
				const wasSortExplicitlyRemoved = (rowGroupColsSvc?.columns?.[rowNode.level + 1])?.getSort() === null;
				const childrenToBeSorted = rowNode.childrenAfterAggFilter.slice(0);
				if (rowNode.childrenAfterSort && !wasSortExplicitlyRemoved) {
					const indexedOrders = {};
					rowNode.childrenAfterSort.forEach((node, idx) => {
						indexedOrders[node.id] = idx;
					});
					childrenToBeSorted.sort((row1, row2) => (indexedOrders[row1.id] ?? 0) - (indexedOrders[row2.id] ?? 0));
				}
				newChildrenAfterSort = childrenToBeSorted;
			} else if (!sortActive || skipSortingPivotLeafs) newChildrenAfterSort = rowNode.childrenAfterAggFilter.slice(0);
			else if (useDeltaSort && changedRowNodes) newChildrenAfterSort = doDeltaSort(rowNodeSorter, rowNode, changedRowNodes, changedPath, sortOptions);
			else newChildrenAfterSort = rowNodeSorter.doFullSort(rowNode.childrenAfterAggFilter, sortOptions);
			hasAnyFirstChildChanged || (hasAnyFirstChildChanged = rowNode.childrenAfterSort?.[0] !== newChildrenAfterSort[0]);
			rowNode.childrenAfterSort = newChildrenAfterSort;
			updateRowNodeAfterSort(rowNode);
			if (postSortFunc) postSortFunc({ nodes: rowNode.childrenAfterSort });
		};
		changedPath?.forEachChangedNodeDepthFirst(callback);
		if (hasAnyFirstChildChanged && this.gos.get("groupHideOpenParents")) {
			const columns = showRowGroupCols?.getShowRowGroupCols();
			if (columns?.length) rowRenderer.refreshCells({
				columns,
				force: true
			});
		}
	}
};
function doDeltaSort(rowNodeSorter, rowNode, changedRowNodes, changedPath, sortOptions) {
	const unsortedRows = rowNode.childrenAfterAggFilter;
	const oldSortedRows = rowNode.childrenAfterSort;
	if (!oldSortedRows) return rowNodeSorter.doFullSort(unsortedRows, sortOptions);
	const untouchedRows = /* @__PURE__ */ new Set();
	const touchedRows = [];
	const { updates, adds } = changedRowNodes;
	for (let i = 0, len = unsortedRows.length; i < len; ++i) {
		const row = unsortedRows[i];
		if (updates.has(row) || adds.has(row) || changedPath && !changedPath.canSkip(row)) touchedRows.push({
			currentPos: touchedRows.length,
			rowNode: row
		});
		else untouchedRows.add(row.id);
	}
	const sortedUntouchedRows = oldSortedRows.filter((child) => untouchedRows.has(child.id)).map((rowNode2, currentPos) => ({
		currentPos,
		rowNode: rowNode2
	}));
	touchedRows.sort((a, b) => rowNodeSorter.compareRowNodes(sortOptions, a, b));
	return mergeSortedArrays(rowNodeSorter, sortOptions, touchedRows, sortedUntouchedRows);
}
function mergeSortedArrays(rowNodeSorter, sortOptions, arr1, arr2) {
	const res = [];
	let i = 0;
	let j = 0;
	const arr1Length = arr1.length;
	const arr2Length = arr2.length;
	while (i < arr1Length && j < arr2Length) {
		const a = arr1[i];
		const b = arr2[j];
		const compareResult = rowNodeSorter.compareRowNodes(sortOptions, a, b);
		let chosen;
		if (compareResult < 0) {
			chosen = a;
			++i;
		} else {
			chosen = b;
			++j;
		}
		res.push(chosen.rowNode);
	}
	while (i < arr1Length) res.push(arr1[i++].rowNode);
	while (j < arr2Length) res.push(arr2[j++].rowNode);
	return res;
}
var ClientSideRowModel = class extends BeanStub {
	constructor() {
		super(...arguments);
		this.beanName = "rowModel";
		this.rootNode = null;
		this.rowsToDisplay = [];
		this.rowDataUpdatedPending = false;
		this.started = false;
		this.isRefreshingModel = false;
		this.rowNodesCountReady = false;
		this.rowCountReady = false;
		this.onRowHeightChanged_debounced = _debounce(this, this.onRowHeightChanged.bind(this), 100);
	}
	wireBeans(beans) {
		this.colModel = beans.colModel;
		this.valueCache = beans.valueCache;
		this.filterStage = beans.filterStage;
		this.sortStage = beans.sortStage;
		this.flattenStage = beans.flattenStage;
		this.groupStage = beans.groupStage;
		this.aggStage = beans.aggStage;
		this.pivotStage = beans.pivotStage;
		this.filterAggStage = beans.filterAggStage;
	}
	postConstruct() {
		this.orderedStages = [
			this.groupStage,
			this.filterStage,
			this.pivotStage,
			this.aggStage,
			this.sortStage,
			this.filterAggStage,
			this.flattenStage
		].filter((stage) => !!stage);
		const refreshEverythingFunc = this.refreshModel.bind(this, { step: "group" });
		const refreshEverythingAfterColsChangedFunc = this.refreshModel.bind(this, {
			step: "group",
			afterColumnsChanged: true,
			keepRenderedRows: true,
			animate: !this.gos.get("suppressAnimationFrame")
		});
		this.addManagedEventListeners({
			newColumnsLoaded: refreshEverythingAfterColsChangedFunc,
			columnRowGroupChanged: refreshEverythingFunc,
			columnValueChanged: this.onValueChanged.bind(this),
			columnPivotChanged: this.refreshModel.bind(this, { step: "pivot" }),
			filterChanged: this.onFilterChanged.bind(this),
			sortChanged: this.onSortChanged.bind(this),
			columnPivotModeChanged: refreshEverythingFunc,
			gridStylesChanged: this.onGridStylesChanges.bind(this),
			gridReady: this.onGridReady.bind(this)
		});
		this.addPropertyListeners();
		this.rootNode = new RowNode(this.beans);
		const nodeManager = this.getNewNodeManager();
		this.nodeManager = nodeManager;
		nodeManager.activate(this.rootNode);
	}
	getNewNodeManager() {
		const { gos, beans } = this;
		return _getGroupingApproach(gos) === "treeNested" && beans.csrmChildrenTreeNodeSvc || beans.csrmNodeSvc;
	}
	addPropertyListeners() {
		const allProps = [
			"treeData",
			"treeDataChildrenField",
			...this.orderedStages.flatMap(({ refreshProps }) => [...refreshProps])
		];
		this.addManagedPropertyListeners(allProps, (params) => {
			const properties = params.changeSet?.properties;
			if (properties) this.onPropChange(properties);
		});
		this.addManagedPropertyListener("rowData", () => this.onPropChange(["rowData"]));
		this.addManagedPropertyListener("rowHeight", () => this.resetRowHeights());
	}
	start() {
		this.started = true;
		if (this.rowNodesCountReady) this.refreshModel({
			step: "group",
			rowDataUpdated: true,
			newData: true
		});
		else this.setInitialData();
	}
	setInitialData() {
		if (this.gos.get("rowData")) this.onPropChange(["rowData"]);
	}
	ensureRowHeightsValid(startPixel, endPixel, startLimitIndex, endLimitIndex) {
		let atLeastOneChange;
		let res = false;
		do {
			atLeastOneChange = false;
			const rowAtStartPixel = this.getRowIndexAtPixel(startPixel);
			const rowAtEndPixel = this.getRowIndexAtPixel(endPixel);
			const firstRow = Math.max(rowAtStartPixel, startLimitIndex);
			const lastRow = Math.min(rowAtEndPixel, endLimitIndex);
			for (let rowIndex = firstRow; rowIndex <= lastRow; rowIndex++) {
				const rowNode = this.getRow(rowIndex);
				if (rowNode.rowHeightEstimated) {
					const rowHeight = _getRowHeightForNode(this.beans, rowNode);
					rowNode.setRowHeight(rowHeight.height);
					atLeastOneChange = true;
					res = true;
				}
			}
			if (atLeastOneChange) this.setRowTopAndRowIndex();
		} while (atLeastOneChange);
		return res;
	}
	onPropChange(properties) {
		if (!this.rootNode) return;
		const gos = this.gos;
		const changedProps = new Set(properties);
		const params = {
			step: "nothing",
			changedProps
		};
		const rowDataChanged = changedProps.has("rowData");
		const oldNodeManager = this.nodeManager;
		const nodeManager = this.getNewNodeManager();
		const reset = oldNodeManager !== nodeManager || rowDataChanged && changedProps.has("treeData") && gos.get("treeData") || changedProps.has("treeDataChildrenField") && gos.get("treeData");
		let newRowData;
		if (reset || rowDataChanged) {
			newRowData = gos.get("rowData");
			if (newRowData != null && !Array.isArray(newRowData)) {
				newRowData = null;
				_warn(1);
			}
		}
		if (reset) {
			if (!rowDataChanged) newRowData = oldNodeManager?.extractRowData() ?? newRowData;
			if (oldNodeManager !== nodeManager) {
				oldNodeManager?.deactivate();
				this.nodeManager = nodeManager;
			}
			nodeManager.activate(this.rootNode);
		}
		if (newRowData) if (!reset && !this.isEmpty() && newRowData.length > 0 && gos.exists("getRowId") && !gos.get("resetRowDataOnUpdate")) {
			params.keepRenderedRows = true;
			params.animate = !this.gos.get("suppressAnimationFrame");
			params.changedRowNodes = new ChangedRowNodes();
			nodeManager.setImmutableRowData(params, newRowData);
		} else {
			params.rowDataUpdated = true;
			params.newData = true;
			const { selectionSvc, pinnedRowModel } = this.beans;
			selectionSvc?.reset("rowDataChanged");
			if (pinnedRowModel?.isManual()) pinnedRowModel.reset();
			this.rowNodesCountReady = true;
			nodeManager.setNewRowData(newRowData);
		}
		if (params.rowDataUpdated) params.step = "group";
		else if (params.step === "nothing") {
			for (const { refreshProps, step } of this.orderedStages) if (properties.some((prop) => refreshProps.has(prop))) {
				params.step = step;
				break;
			}
		}
		if (params.step !== "nothing") this.refreshModel(params);
	}
	setRowTopAndRowIndex() {
		const { beans, rowsToDisplay } = this;
		const defaultRowHeight = beans.environment.getDefaultRowHeight();
		let nextRowTop = 0;
		const displayedRowsMapped = /* @__PURE__ */ new Set();
		const allowEstimate = _isDomLayout(this.gos, "normal");
		for (let i = 0, len = rowsToDisplay.length; i < len; ++i) {
			const rowNode = rowsToDisplay[i];
			if (rowNode.id != null) displayedRowsMapped.add(rowNode.id);
			if (rowNode.rowHeight == null) {
				const rowHeight = _getRowHeightForNode(beans, rowNode, allowEstimate, defaultRowHeight);
				rowNode.setRowHeight(rowHeight.height, rowHeight.estimated);
			}
			rowNode.setRowTop(nextRowTop);
			rowNode.setRowIndex(i);
			nextRowTop += rowNode.rowHeight;
		}
		return displayedRowsMapped;
	}
	clearRowTopAndRowIndex(changedPath, displayedRowsMapped) {
		const changedPathActive = changedPath.active;
		const clearIfNotDisplayed = (rowNode) => {
			if (rowNode && rowNode.id != null && !displayedRowsMapped.has(rowNode.id)) rowNode.clearRowTopAndRowIndex();
		};
		const recurse = (rowNode) => {
			if (rowNode === null) return;
			clearIfNotDisplayed(rowNode);
			clearIfNotDisplayed(rowNode.detailNode);
			clearIfNotDisplayed(rowNode.sibling);
			if (rowNode.hasChildren()) {
				if (rowNode.childrenAfterGroup) {
					const isRootNode = rowNode.level == -1;
					if (!(changedPathActive && !isRootNode && !rowNode.expanded)) rowNode.childrenAfterGroup.forEach(recurse);
				}
			}
		};
		recurse(this.rootNode);
	}
	isLastRowIndexKnown() {
		return true;
	}
	getRowCount() {
		if (this.rowsToDisplay) return this.rowsToDisplay.length;
		return 0;
	}
	getTopLevelRowCount() {
		const rootNode = this.rootNode;
		if (!rootNode) return 0;
		if (this.rowsToDisplay.length === 0) return 0;
		if (this.rowsToDisplay && this.rowsToDisplay[0] === rootNode) return 1;
		const filteredChildren = rootNode.childrenAfterSort;
		const totalFooterInc = rootNode.sibling && rootNode.sibling.displayed ? 1 : 0;
		return (filteredChildren ? filteredChildren.length : 0) + totalFooterInc;
	}
	getTopLevelRowDisplayedIndex(topLevelIndex) {
		const { rootNode, rowsToDisplay } = this;
		if (!rootNode || !rowsToDisplay.length || rowsToDisplay[0] === rootNode) return topLevelIndex;
		const { childrenAfterSort } = rootNode;
		const getDefaultIndex = (adjustedIndex) => {
			let rowNode = childrenAfterSort[adjustedIndex];
			if (this.gos.get("groupHideOpenParents")) while (rowNode.expanded && rowNode.childrenAfterSort && rowNode.childrenAfterSort.length > 0) rowNode = rowNode.childrenAfterSort[0];
			return rowNode.rowIndex;
		};
		const { footerSvc } = this.beans;
		if (footerSvc) return footerSvc.getTopDisplayIndex(rowsToDisplay, topLevelIndex, childrenAfterSort, getDefaultIndex);
		else return getDefaultIndex(topLevelIndex);
	}
	getTopLevelIndexFromDisplayedIndex(displayedIndex) {
		const { rootNode, rowsToDisplay } = this;
		if (!rootNode || !rowsToDisplay.length || rowsToDisplay[0] === rootNode) return displayedIndex;
		let node = this.getRow(displayedIndex);
		if (node.footer) node = node.sibling;
		while (node.parent && node.parent !== rootNode) node = node.parent;
		const topLevelIndex = rootNode.childrenAfterSort?.findIndex((childNode) => childNode === node);
		return topLevelIndex === -1 ? displayedIndex : topLevelIndex ?? displayedIndex;
	}
	getRowBounds(index) {
		const rowNode = this.rowsToDisplay[index];
		if (rowNode) return {
			rowTop: rowNode.rowTop,
			rowHeight: rowNode.rowHeight
		};
		return null;
	}
	onRowGroupOpened() {
		const animate = _isAnimateRows(this.gos);
		this.refreshModel({
			step: "map",
			keepRenderedRows: true,
			animate
		});
	}
	onFilterChanged(event) {
		if (event.afterDataChange) return;
		const animate = _isAnimateRows(this.gos);
		const step = event.columns.length === 0 || event.columns.some((col) => col.isPrimary()) ? "filter" : "filter_aggregates";
		this.refreshModel({
			step,
			keepRenderedRows: true,
			animate
		});
	}
	onSortChanged() {
		const animate = _isAnimateRows(this.gos);
		this.refreshModel({
			step: "sort",
			keepRenderedRows: true,
			animate
		});
	}
	getType() {
		return "clientSide";
	}
	onValueChanged() {
		this.refreshModel({ step: this.colModel.isPivotActive() ? "pivot" : "aggregate" });
	}
	createChangePath(enabled) {
		const changedPath = new ChangedPath(false, this.rootNode);
		if (!enabled) changedPath.active = false;
		return changedPath;
	}
	isSuppressModelUpdateAfterUpdateTransaction(params) {
		if (!this.gos.get("suppressModelUpdateAfterUpdateTransaction")) return false;
		const { changedRowNodes, newData, rowDataUpdated } = params;
		if (!changedRowNodes || newData || !rowDataUpdated) return false;
		if (changedRowNodes.removals.size || changedRowNodes.adds.size) return false;
		return true;
	}
	refreshModel(params) {
		if (!this.rootNode) return;
		const beans = this.beans;
		let rowDataUpdated = !!params.rowDataUpdated;
		const changedPath = params.changedPath ?? (params.changedPath = this.createChangePath(!params.newData && rowDataUpdated));
		if (this.started && rowDataUpdated) this.eventSvc.dispatchEvent({ type: "rowDataUpdated" });
		this.rowDataUpdatedPending || (this.rowDataUpdatedPending = rowDataUpdated);
		if (!this.started || this.isRefreshingModel || this.colModel.changeEventsDispatching || this.isSuppressModelUpdateAfterUpdateTransaction(params)) return;
		if (this.rowDataUpdatedPending) {
			this.rowDataUpdatedPending = false;
			params.rowDataUpdated = rowDataUpdated = true;
		}
		this.isRefreshingModel = true;
		beans.masterDetailSvc?.refreshModel(params);
		if (rowDataUpdated && params.step !== "group") beans.colFilter?.refreshModel();
		switch (params.step) {
			case "group":
				if (this.doRowGrouping(params) || rowDataUpdated) beans.colFilter?.refreshModel();
				if (!this.rowCountReady && this.rowNodesCountReady) {
					this.rowCountReady = true;
					this.eventSvc.dispatchEventOnce({ type: "rowCountReady" });
				}
			case "filter": this.doFilter(changedPath);
			case "pivot": this.doPivot(changedPath);
			case "aggregate": this.doAggregate(changedPath);
			case "filter_aggregates": this.doFilterAggregates(changedPath);
			case "sort": this.doSort(params.changedRowNodes, changedPath);
			case "map": this.doRowsToDisplay();
		}
		const displayedNodesMapped = this.setRowTopAndRowIndex();
		this.clearRowTopAndRowIndex(changedPath, displayedNodesMapped);
		this.isRefreshingModel = false;
		this.eventSvc.dispatchEvent({
			type: "modelUpdated",
			animate: params.animate,
			keepRenderedRows: params.keepRenderedRows,
			newData: params.newData,
			newPage: false,
			keepUndoRedoStack: params.keepUndoRedoStack
		});
	}
	isEmpty() {
		return !this.rootNode?.allLeafChildren?.length || !this.colModel?.ready;
	}
	isRowsToRender() {
		return this.rowsToDisplay.length > 0;
	}
	getNodesInRangeForSelection(firstInRange, lastInRange) {
		let started = false;
		let finished = false;
		const result = [];
		const groupsSelectChildren = _getGroupSelectsDescendants(this.gos);
		this.forEachNodeAfterFilterAndSort((rowNode) => {
			if (finished) return;
			if (started) {
				if (rowNode === lastInRange || rowNode === firstInRange) {
					finished = true;
					if (rowNode.group && groupsSelectChildren) {
						result.push(...rowNode.allLeafChildren);
						return;
					}
				}
			}
			if (!started) {
				if (rowNode !== lastInRange && rowNode !== firstInRange) return;
				started = true;
			}
			if (!rowNode.group || !groupsSelectChildren) {
				result.push(rowNode);
				return;
			}
		});
		return result;
	}
	getTopLevelNodes() {
		return this.rootNode?.childrenAfterGroup ?? null;
	}
	getRow(index) {
		return this.rowsToDisplay[index];
	}
	isRowPresent(rowNode) {
		return this.rowsToDisplay.indexOf(rowNode) >= 0;
	}
	getRowIndexAtPixel(pixelToMatch) {
		const rowsToDisplay = this.rowsToDisplay;
		if (this.isEmpty() || rowsToDisplay.length === 0) return -1;
		let bottomPointer = 0;
		let topPointer = rowsToDisplay.length - 1;
		if (pixelToMatch <= 0) return 0;
		if (_last(rowsToDisplay).rowTop <= pixelToMatch) return rowsToDisplay.length - 1;
		let oldBottomPointer = -1;
		let oldTopPointer = -1;
		while (true) {
			const midPointer = Math.floor((bottomPointer + topPointer) / 2);
			const currentRowNode = rowsToDisplay[midPointer];
			if (this.isRowInPixel(currentRowNode, pixelToMatch)) return midPointer;
			if (currentRowNode.rowTop < pixelToMatch) bottomPointer = midPointer + 1;
			else if (currentRowNode.rowTop > pixelToMatch) topPointer = midPointer - 1;
			if (oldBottomPointer === bottomPointer && oldTopPointer === topPointer) return midPointer;
			oldBottomPointer = bottomPointer;
			oldTopPointer = topPointer;
		}
	}
	isRowInPixel(rowNode, pixelToMatch) {
		const topPixel = rowNode.rowTop;
		const bottomPixel = rowNode.rowTop + rowNode.rowHeight;
		return topPixel <= pixelToMatch && bottomPixel > pixelToMatch;
	}
	forEachLeafNode(callback) {
		this.rootNode?.allLeafChildren?.forEach((rowNode, index) => callback(rowNode, index));
	}
	forEachNode(callback, includeFooterNodes = false) {
		this.depthFirstSearchRowNodes(callback, includeFooterNodes);
	}
	forEachDisplayedNode(callback) {
		this.rowsToDisplay.forEach(callback);
	}
	forEachNodeAfterFilter(callback, includeFooterNodes = false) {
		this.depthFirstSearchRowNodes(callback, includeFooterNodes, (node) => node.childrenAfterAggFilter);
	}
	forEachNodeAfterFilterAndSort(callback, includeFooterNodes = false) {
		this.depthFirstSearchRowNodes(callback, includeFooterNodes, (node) => node.childrenAfterSort);
	}
	forEachPivotNode(callback, includeFooterNodes = false, afterSort = false) {
		const { colModel, rowGroupColsSvc } = this.beans;
		if (!colModel.isPivotMode()) return;
		if (!rowGroupColsSvc?.columns.length) {
			callback(this.rootNode, 0);
			return;
		}
		const childrenField = afterSort ? "childrenAfterSort" : "childrenAfterGroup";
		this.depthFirstSearchRowNodes(callback, includeFooterNodes, (node) => !node.leafGroup ? node[childrenField] : null);
	}
	depthFirstSearchRowNodes(callback, includeFooterNodes = false, getChildren = (node2) => node2.childrenAfterGroup, node = this.rootNode, startIndex = 0) {
		let index = startIndex;
		if (!node) return index;
		const isRootNode = node === this.rootNode;
		if (!isRootNode) callback(node, index++);
		const { footerSvc } = this.beans;
		if (node.hasChildren() && !node.footer) {
			const children = getChildren(node);
			if (children) {
				index = footerSvc?.addTotalRows(index, node, callback, includeFooterNodes, isRootNode, "top") ?? index;
				for (const node2 of children) index = this.depthFirstSearchRowNodes(callback, includeFooterNodes, getChildren, node2, index);
				return footerSvc?.addTotalRows(index, node, callback, includeFooterNodes, isRootNode, "bottom") ?? index;
			}
		}
		return index;
	}
	doAggregate(changedPath) {
		const rootNode = this.rootNode;
		if (rootNode) this.aggStage?.execute({
			rowNode: rootNode,
			changedPath
		});
	}
	doFilterAggregates(changedPath) {
		const rootNode = this.rootNode;
		if (this.filterAggStage) this.filterAggStage.execute({
			rowNode: rootNode,
			changedPath
		});
		else rootNode.childrenAfterAggFilter = rootNode.childrenAfterFilter;
	}
	doSort(changedRowNodes, changedPath) {
		if (this.sortStage) this.sortStage.execute({
			rowNode: this.rootNode,
			changedRowNodes,
			changedPath
		});
		else changedPath.forEachChangedNodeDepthFirst((rowNode) => {
			rowNode.childrenAfterSort = rowNode.childrenAfterAggFilter.slice(0);
			updateRowNodeAfterSort(rowNode);
		});
	}
	doRowGrouping(params) {
		const rootNode = this.rootNode;
		const groupStageExecuted = this.groupStage?.execute({
			rowNode: rootNode,
			changedRowNodes: params.changedRowNodes,
			changedPath: params.changedPath,
			rowNodesOrderChanged: !!params.rowNodesOrderChanged,
			afterColumnsChanged: !!params.afterColumnsChanged
		});
		if (groupStageExecuted !== void 0) return groupStageExecuted;
		const sibling = rootNode.sibling;
		rootNode.childrenAfterGroup = rootNode.allLeafChildren;
		if (sibling) sibling.childrenAfterGroup = rootNode.childrenAfterGroup;
		rootNode.updateHasChildren();
		return false;
	}
	doFilter(changedPath) {
		if (this.filterStage) this.filterStage.execute({
			rowNode: this.rootNode,
			changedPath
		});
		else changedPath.forEachChangedNodeDepthFirst((rowNode) => {
			rowNode.childrenAfterFilter = rowNode.childrenAfterGroup;
			updateRowNodeAfterFilter(rowNode);
		}, true);
	}
	doPivot(changedPath) {
		this.pivotStage?.execute({
			rowNode: this.rootNode,
			changedPath
		});
	}
	getRowNode(id) {
		const found = this.nodeManager.getRowNode(id);
		if (typeof found === "object") return found;
		return typeof id == "string" && id.indexOf("row-group-") === 0 ? this.groupStage?.getNode(id) : void 0;
	}
	batchUpdateRowData(rowDataTransaction, callback) {
		if (this.applyAsyncTransactionsTimeout == null) {
			this.rowDataTransactionBatch = [];
			const waitMillis = this.gos.get("asyncTransactionWaitMillis");
			this.applyAsyncTransactionsTimeout = window.setTimeout(() => {
				if (this.isAlive()) this.executeBatchUpdateRowData();
			}, waitMillis);
		}
		this.rowDataTransactionBatch.push({
			rowDataTransaction,
			callback
		});
	}
	flushAsyncTransactions() {
		if (this.applyAsyncTransactionsTimeout != null) {
			clearTimeout(this.applyAsyncTransactionsTimeout);
			this.executeBatchUpdateRowData();
		}
	}
	executeBatchUpdateRowData() {
		this.valueCache?.onDataChanged();
		const callbackFuncsBound = [];
		const rowNodeTrans = [];
		const changedRowNodes = new ChangedRowNodes();
		let orderChanged = false;
		this.rowDataTransactionBatch?.forEach((tranItem) => {
			this.rowNodesCountReady = true;
			const { rowNodeTransaction, rowsInserted } = this.nodeManager.updateRowData(tranItem.rowDataTransaction, changedRowNodes);
			if (rowsInserted) orderChanged = true;
			rowNodeTrans.push(rowNodeTransaction);
			if (tranItem.callback) callbackFuncsBound.push(tranItem.callback.bind(null, rowNodeTransaction));
		});
		this.commitTransactions(orderChanged, changedRowNodes);
		if (callbackFuncsBound.length > 0) window.setTimeout(() => {
			callbackFuncsBound.forEach((func) => func());
		}, 0);
		if (rowNodeTrans.length > 0) this.eventSvc.dispatchEvent({
			type: "asyncTransactionsFlushed",
			results: rowNodeTrans
		});
		this.rowDataTransactionBatch = null;
		this.applyAsyncTransactionsTimeout = void 0;
	}
	updateRowData(rowDataTran) {
		this.valueCache?.onDataChanged();
		this.rowNodesCountReady = true;
		const changedRowNodes = new ChangedRowNodes();
		const { rowNodeTransaction, rowsInserted } = this.nodeManager.updateRowData(rowDataTran, changedRowNodes);
		this.commitTransactions(rowsInserted, changedRowNodes);
		return rowNodeTransaction;
	}
	commitTransactions(rowNodesOrderChanged, changedRowNodes) {
		this.refreshModel({
			step: "group",
			rowDataUpdated: true,
			rowNodesOrderChanged,
			keepRenderedRows: true,
			animate: !this.gos.get("suppressAnimationFrame"),
			changedRowNodes,
			changedPath: this.createChangePath(true)
		});
	}
	doRowsToDisplay() {
		const { flattenStage, rootNode } = this;
		let rowsToDisplay;
		if (flattenStage) rowsToDisplay = flattenStage.execute({ rowNode: rootNode });
		else {
			rowsToDisplay = rootNode?.childrenAfterSort ?? [];
			for (const row of rowsToDisplay) row.setUiLevel(0);
		}
		this.rowsToDisplay = rowsToDisplay;
	}
	onRowHeightChanged() {
		this.refreshModel({
			step: "map",
			keepRenderedRows: true,
			keepUndoRedoStack: true
		});
	}
	resetRowHeights() {
		const rootNode = this.rootNode;
		if (!rootNode) return;
		const atLeastOne = this.resetRowHeightsForAllRowNodes();
		rootNode.setRowHeight(rootNode.rowHeight, true);
		if (rootNode.sibling) rootNode.sibling.setRowHeight(rootNode.sibling.rowHeight, true);
		if (atLeastOne) this.onRowHeightChanged();
	}
	resetRowHeightsForAllRowNodes() {
		let atLeastOne = false;
		this.forEachNode((rowNode) => {
			rowNode.setRowHeight(rowNode.rowHeight, true);
			const detailNode = rowNode.detailNode;
			if (detailNode) detailNode.setRowHeight(detailNode.rowHeight, true);
			if (rowNode.sibling) rowNode.sibling.setRowHeight(rowNode.sibling.rowHeight, true);
			atLeastOne = true;
		});
		return atLeastOne;
	}
	onGridStylesChanges(e) {
		if (e.rowHeightChanged) {
			if (this.beans.rowAutoHeight?.active) return;
			this.resetRowHeights();
		}
	}
	onGridReady() {
		if (!this.started) this.setInitialData();
	}
	isRowDataLoaded() {
		return this.rowCountReady;
	}
	destroy() {
		super.destroy();
		this.started = false;
		this.rootNode = null;
		this.nodeManager = null;
		this.rowDataTransactionBatch = null;
		this.orderedStages = _EmptyArray;
		this.rowsToDisplay = _EmptyArray;
	}
	onRowHeightChangedDebounced() {
		this.onRowHeightChanged_debounced();
	}
};
function onGroupExpandedOrCollapsed(beans) {
	beans.expansionSvc?.onGroupExpandedOrCollapsed();
}
function refreshClientSideRowModel(beans, step) {
	const clientSideRowModel = _getClientSideRowModel(beans);
	if (clientSideRowModel) {
		if (!step || step === "everything") step = "group";
		clientSideRowModel.refreshModel({
			step,
			keepRenderedRows: true,
			animate: !beans.gos.get("suppressAnimationFrame")
		});
	}
}
function isRowDataEmpty(beans) {
	return _getClientSideRowModel(beans)?.isEmpty() ?? true;
}
function forEachLeafNode(beans, callback) {
	_getClientSideRowModel(beans)?.forEachLeafNode(callback);
}
function forEachNodeAfterFilter(beans, callback) {
	_getClientSideRowModel(beans)?.forEachNodeAfterFilter(callback);
}
function forEachNodeAfterFilterAndSort(beans, callback) {
	_getClientSideRowModel(beans)?.forEachNodeAfterFilterAndSort(callback);
}
function resetRowHeights(beans) {
	if (beans.rowAutoHeight?.active) {
		_warn(3);
		return;
	}
	_getClientSideRowModel(beans)?.resetRowHeights();
}
function applyTransaction(beans, rowDataTransaction) {
	return beans.frameworkOverrides.wrapIncoming(() => _getClientSideRowModel(beans)?.updateRowData(rowDataTransaction));
}
function applyTransactionAsync(beans, rowDataTransaction, callback) {
	beans.frameworkOverrides.wrapIncoming(() => _getClientSideRowModel(beans)?.batchUpdateRowData(rowDataTransaction, callback));
}
function flushAsyncTransactions(beans) {
	beans.frameworkOverrides.wrapIncoming(() => _getClientSideRowModel(beans)?.flushAsyncTransactions());
}
function getBestCostNodeSelection(beans) {
	return beans.selectionSvc?.getBestCostNodeSelection();
}
var ClientSideRowModelModule = {
	moduleName: "ClientSideRowModel",
	version: VERSION,
	rowModels: ["clientSide"],
	beans: [
		ClientSideNodeManager,
		ClientSideRowModel,
		SortStage
	],
	dependsOn: [SortModule]
};
var ClientSideRowModelApiModule = {
	moduleName: "ClientSideRowModelApi",
	version: VERSION,
	apiFunctions: {
		onGroupExpandedOrCollapsed,
		refreshClientSideRowModel,
		isRowDataEmpty,
		forEachLeafNode,
		forEachNodeAfterFilter,
		forEachNodeAfterFilterAndSort,
		resetRowHeights,
		applyTransaction,
		applyTransactionAsync,
		flushAsyncTransactions,
		getBestCostNodeSelection
	},
	dependsOn: [CsrmSsrmSharedApiModule]
};
function redrawRows(beans, params = {}) {
	const rowNodes = params ? params.rowNodes : void 0;
	beans.frameworkOverrides.wrapIncoming(() => beans.rowRenderer.redrawRows(rowNodes));
}
function setRowNodeExpanded(beans, rowNode, expanded, expandParents, forceSync) {
	if (rowNode) {
		if (expandParents && rowNode.parent && rowNode.parent.level !== -1) setRowNodeExpanded(beans, rowNode.parent, expanded, expandParents, forceSync);
		rowNode.setExpanded(expanded, void 0, forceSync);
	}
}
function getRowNode(beans, id) {
	return beans.rowModel.getRowNode(id);
}
function addRenderedRowListener(beans, eventName, rowIndex, callback) {
	beans.rowRenderer.addRenderedRowListener(eventName, rowIndex, callback);
}
function getRenderedNodes(beans) {
	return beans.rowRenderer.getRenderedNodes();
}
function forEachNode(beans, callback, includeFooterNodes) {
	beans.rowModel.forEachNode(callback, includeFooterNodes);
}
function getFirstDisplayedRowIndex(beans) {
	return beans.rowRenderer.firstRenderedRow;
}
function getLastDisplayedRowIndex(beans) {
	return beans.rowRenderer.lastRenderedRow;
}
function getDisplayedRowAtIndex(beans, index) {
	return beans.rowModel.getRow(index);
}
function getDisplayedRowCount(beans) {
	return beans.rowModel.getRowCount();
}
var RowApiModule = {
	moduleName: "RowApi",
	version: VERSION,
	apiFunctions: {
		redrawRows,
		setRowNodeExpanded,
		getRowNode,
		addRenderedRowListener,
		getRenderedNodes,
		forEachNode,
		getFirstDisplayedRowIndex,
		getLastDisplayedRowIndex,
		getDisplayedRowAtIndex,
		getDisplayedRowCount
	}
};
var ScrollApiModule = {
	moduleName: "ScrollApi",
	version: VERSION,
	apiFunctions: {
		getVerticalPixelRange,
		getHorizontalPixelRange,
		ensureColumnVisible,
		ensureIndexVisible,
		ensureNodeVisible
	}
};
function setGridAriaProperty(beans, property, value) {
	if (!property) return;
	const eGrid = beans.ctrlsSvc.getGridBodyCtrl().eGridBody;
	const ariaProperty = `aria-${property}`;
	if (value === null) eGrid.removeAttribute(ariaProperty);
	else eGrid.setAttribute(ariaProperty, value);
}
function refreshCells(beans, params = {}) {
	beans.frameworkOverrides.wrapIncoming(() => beans.rowRenderer.refreshCells(params));
}
function refreshHeader(beans) {
	beans.frameworkOverrides.wrapIncoming(() => beans.ctrlsSvc.getHeaderRowContainerCtrls().forEach((c) => c.refresh()));
}
function isAnimationFrameQueueEmpty(beans) {
	return beans.animationFrameSvc?.isQueueEmpty() ?? true;
}
function flushAllAnimationFrames(beans) {
	beans.animationFrameSvc?.flushAllFrames();
}
function getSizesForCurrentTheme(beans) {
	return {
		rowHeight: _getRowHeightAsNumber(beans),
		headerHeight: getHeaderHeight(beans)
	};
}
function getCellRendererInstances(beans, params = {}) {
	const cellRenderers = [];
	beans.rowRenderer.getCellCtrls(params.rowNodes, params.columns).forEach((cellCtrl) => {
		const cellRenderer = cellCtrl.getCellRenderer();
		if (cellRenderer != null) cellRenderers.push(_unwrapUserComp(cellRenderer));
	});
	if (params.columns?.length) return cellRenderers;
	const fullWidthRenderers = [];
	const rowIdMap = mapRowNodes(params.rowNodes);
	beans.rowRenderer.getAllRowCtrls().forEach((rowCtrl) => {
		if (rowIdMap && !isRowInMap(rowCtrl.rowNode, rowIdMap)) return;
		if (!rowCtrl.isFullWidth()) return;
		const renderers = rowCtrl.getFullWidthCellRenderers();
		for (let i = 0; i < renderers.length; i++) {
			const renderer = renderers[i];
			if (renderer != null) fullWidthRenderers.push(_unwrapUserComp(renderer));
		}
	});
	return [...fullWidthRenderers, ...cellRenderers];
}
var RenderApiModule = {
	moduleName: "RenderApi",
	version: VERSION,
	apiFunctions: {
		setGridAriaProperty,
		refreshCells,
		refreshHeader,
		isAnimationFrameQueueEmpty,
		flushAllAnimationFrames,
		getSizesForCurrentTheme,
		getCellRendererInstances
	}
};
function sizeColumnsToFit(beans, paramsOrGridWidth) {
	if (typeof paramsOrGridWidth === "number") beans.colAutosize?.sizeColumnsToFit(paramsOrGridWidth, "api");
	else beans.colAutosize?.sizeColumnsToFitGridBody(paramsOrGridWidth);
}
function autoSizeColumns({ colAutosize, visibleCols }, keysOrParams, skipHeader) {
	if (Array.isArray(keysOrParams)) colAutosize?.autoSizeCols({
		colKeys: keysOrParams,
		skipHeader,
		source: "api"
	});
	else colAutosize?.autoSizeCols({
		colKeys: keysOrParams.colIds ?? visibleCols.allCols,
		skipHeader: keysOrParams.skipHeader,
		defaultMaxWidth: keysOrParams.defaultMaxWidth,
		defaultMinWidth: keysOrParams.defaultMinWidth,
		columnLimits: keysOrParams.columnLimits,
		source: "api"
	});
}
function autoSizeAllColumns(beans, paramsOrSkipHeader) {
	if (paramsOrSkipHeader && typeof paramsOrSkipHeader === "object") autoSizeColumns(beans, paramsOrSkipHeader);
	else beans.colAutosize?.autoSizeAllColumns({
		source: "api",
		skipHeader: paramsOrSkipHeader
	});
}
var ColumnAutosizeService = class extends BeanStub {
	constructor() {
		super(...arguments);
		this.beanName = "colAutosize";
		this.timesDelayed = 0;
		this.shouldQueueResizeOperations = false;
		this.resizeOperationQueue = [];
	}
	postConstruct() {
		this.addManagedEventListeners({ firstDataRendered: () => this.onFirstDataRendered() });
	}
	autoSizeCols(params) {
		if (this.shouldQueueResizeOperations) {
			this.pushResizeOperation(() => this.autoSizeCols(params));
			return;
		}
		const { colKeys, skipHeader, skipHeaderGroups, stopAtGroup, defaultMaxWidth, defaultMinWidth, columnLimits = [], source = "api" } = params;
		const { animationFrameSvc, renderStatus, colModel, autoWidthCalc, visibleCols } = this.beans;
		animationFrameSvc?.flushAllFrames();
		if (this.timesDelayed < 5 && renderStatus && !renderStatus.areHeaderCellsRendered()) {
			this.timesDelayed++;
			setTimeout(() => {
				if (this.isAlive()) this.autoSizeCols(params);
			});
			return;
		}
		this.timesDelayed = 0;
		const columnsAutoSized = [];
		let changesThisTimeAround = -1;
		const columnLimitsIndex = Object.fromEntries(columnLimits.map(({ colId, maxWidth, minWidth }) => [colId, {
			maxWidth,
			minWidth
		}]));
		const shouldSkipHeader = skipHeader != null ? skipHeader : this.gos.get("skipHeaderOnAutoSize");
		const shouldSkipHeaderGroups = skipHeaderGroups != null ? skipHeaderGroups : shouldSkipHeader;
		while (changesThisTimeAround !== 0) {
			changesThisTimeAround = 0;
			const updatedColumns = [];
			colKeys.forEach((key) => {
				if (!key || isSpecialCol(key)) return;
				const column = colModel.getCol(key);
				if (!column) return;
				if (columnsAutoSized.indexOf(column) >= 0) return;
				const preferredWidth = autoWidthCalc.getPreferredWidthForColumn(column, shouldSkipHeader);
				if (preferredWidth > 0) {
					const columnLimit = columnLimitsIndex[column.colId] ?? {};
					columnLimit.minWidth ?? (columnLimit.minWidth = defaultMinWidth);
					columnLimit.maxWidth ?? (columnLimit.maxWidth = defaultMaxWidth);
					const newWidth = normaliseColumnWidth(column, preferredWidth, columnLimit);
					column.setActualWidth(newWidth, source);
					columnsAutoSized.push(column);
					changesThisTimeAround++;
				}
				updatedColumns.push(column);
			});
			if (!updatedColumns.length) continue;
			visibleCols.refresh(source);
		}
		if (!shouldSkipHeaderGroups) this.autoSizeColumnGroupsByColumns(colKeys, source, stopAtGroup);
		dispatchColumnResizedEvent(this.eventSvc, columnsAutoSized, true, "autosizeColumns");
	}
	autoSizeColumn(key, source, skipHeader) {
		if (key) this.autoSizeCols({
			colKeys: [key],
			skipHeader,
			skipHeaderGroups: true,
			source
		});
	}
	autoSizeColumnGroupsByColumns(keys, source, stopAtGroup) {
		const { colModel, ctrlsSvc } = this.beans;
		const columnGroups = /* @__PURE__ */ new Set();
		colModel.getColsForKeys(keys).forEach((col) => {
			let parent = col.getParent();
			while (parent && parent != stopAtGroup) {
				if (!parent.isPadding()) columnGroups.add(parent);
				parent = parent.getParent();
			}
		});
		let headerGroupCtrl;
		const resizedColumns = [];
		for (const columnGroup of columnGroups) {
			for (const headerContainerCtrl of ctrlsSvc.getHeaderRowContainerCtrls()) {
				headerGroupCtrl = headerContainerCtrl.getHeaderCtrlForColumn(columnGroup);
				if (headerGroupCtrl) break;
			}
			if (headerGroupCtrl) headerGroupCtrl.resizeLeafColumnsToFit(source);
		}
		return resizedColumns;
	}
	autoSizeAllColumns(params) {
		if (this.shouldQueueResizeOperations) {
			this.pushResizeOperation(() => this.autoSizeAllColumns(params));
			return;
		}
		const allDisplayedColumns = this.beans.visibleCols.allCols;
		this.autoSizeCols({
			colKeys: allDisplayedColumns,
			...params
		});
	}
	addColumnAutosize(element, column) {
		const skipHeaderOnAutoSize = this.gos.get("skipHeaderOnAutoSize");
		const autoSizeColListener = () => {
			this.autoSizeColumn(column, "uiColumnResized", skipHeaderOnAutoSize);
		};
		element.addEventListener("dblclick", autoSizeColListener);
		const touchListener = new TouchListener(element);
		touchListener.addEventListener("doubleTap", autoSizeColListener);
		return () => {
			element.removeEventListener("dblclick", autoSizeColListener);
			touchListener.removeEventListener("doubleTap", autoSizeColListener);
			touchListener.destroy();
		};
	}
	addColumnGroupResize(element, columnGroup, callback) {
		const skipHeaderOnAutoSize = this.gos.get("skipHeaderOnAutoSize");
		const listener = () => {
			const keys = [];
			columnGroup.getDisplayedLeafColumns().forEach((column) => {
				if (!column.getColDef().suppressAutoSize) keys.push(column.getColId());
			});
			if (keys.length > 0) this.autoSizeCols({
				colKeys: keys,
				skipHeader: skipHeaderOnAutoSize,
				stopAtGroup: columnGroup,
				source: "uiColumnResized"
			});
			callback();
		};
		element.addEventListener("dblclick", listener);
		return () => element.removeEventListener("dblclick", listener);
	}
	sizeColumnsToFitGridBody(params, nextTimeout) {
		if (!this.isAlive()) return;
		const { ctrlsSvc, scrollVisibleSvc } = this.beans;
		const gridBodyCtrl = ctrlsSvc.getGridBodyCtrl();
		const scrollWidthToRemove = gridBodyCtrl.isVerticalScrollShowing() ? scrollVisibleSvc.getScrollbarWidth() : 0;
		const availableWidth = _getInnerWidth(gridBodyCtrl.eGridBody) - scrollWidthToRemove;
		if (availableWidth > 0) {
			this.sizeColumnsToFit(availableWidth, "sizeColumnsToFit", false, params);
			return;
		}
		if (nextTimeout === void 0) window.setTimeout(() => {
			this.sizeColumnsToFitGridBody(params, 100);
		}, 0);
		else if (nextTimeout === 100) window.setTimeout(() => {
			this.sizeColumnsToFitGridBody(params, 500);
		}, 100);
		else if (nextTimeout === 500) window.setTimeout(() => {
			this.sizeColumnsToFitGridBody(params, -1);
		}, 500);
		else _warn(29);
	}
	sizeColumnsToFit(gridWidth, source = "sizeColumnsToFit", silent, params) {
		if (this.shouldQueueResizeOperations) {
			this.pushResizeOperation(() => this.sizeColumnsToFit(gridWidth, source, silent, params));
			return;
		}
		const limitsMap = {};
		if (params) params?.columnLimits?.forEach(({ key,...dimensions }) => {
			limitsMap[typeof key === "string" ? key : key.getColId()] = dimensions;
		});
		const allDisplayedColumns = this.beans.visibleCols.allCols;
		if (gridWidth <= 0 || !allDisplayedColumns.length) return;
		if (gridWidth === getWidthOfColsInList(allDisplayedColumns)) {
			if (allDisplayedColumns.every((column) => {
				if (column.colDef.suppressSizeToFit) return true;
				const widthOverride = limitsMap?.[column.getId()];
				const minWidth = widthOverride?.minWidth ?? params?.defaultMinWidth;
				const maxWidth = widthOverride?.maxWidth ?? params?.defaultMaxWidth;
				const colWidth = column.getActualWidth();
				return (minWidth == null || colWidth >= minWidth) && (maxWidth == null || colWidth <= maxWidth);
			})) return;
		}
		const colsToSpread = [];
		const colsToNotSpread = [];
		allDisplayedColumns.forEach((column) => {
			if (column.getColDef().suppressSizeToFit === true) colsToNotSpread.push(column);
			else colsToSpread.push(column);
		});
		const colsToDispatchEventFor = colsToSpread.slice(0);
		let finishedResizing = false;
		const moveToNotSpread = (column) => {
			_removeFromArray(colsToSpread, column);
			colsToNotSpread.push(column);
		};
		colsToSpread.forEach((column) => {
			column.resetActualWidth(source);
			const widthOverride = limitsMap?.[column.getId()];
			const minOverride = widthOverride?.minWidth ?? params?.defaultMinWidth;
			const maxOverride = widthOverride?.maxWidth ?? params?.defaultMaxWidth;
			const colWidth = column.getActualWidth();
			if (typeof minOverride === "number" && colWidth < minOverride) column.setActualWidth(minOverride, source, true);
			else if (typeof maxOverride === "number" && colWidth > maxOverride) column.setActualWidth(maxOverride, source, true);
		});
		while (!finishedResizing) {
			finishedResizing = true;
			const availablePixels = gridWidth - getWidthOfColsInList(colsToNotSpread);
			if (availablePixels <= 0) colsToSpread.forEach((column) => {
				const widthOverride = limitsMap?.[column.getId()]?.minWidth ?? params?.defaultMinWidth;
				if (typeof widthOverride === "number") {
					column.setActualWidth(widthOverride, source, true);
					return;
				}
				column.setActualWidth(column.minWidth, source);
			});
			else {
				const scale = availablePixels / getWidthOfColsInList(colsToSpread);
				let pixelsForLastCol = availablePixels;
				for (let i = colsToSpread.length - 1; i >= 0; i--) {
					const column = colsToSpread[i];
					const widthOverride = limitsMap?.[column.getId()];
					const minOverride = widthOverride?.minWidth ?? params?.defaultMinWidth;
					const maxOverride = widthOverride?.maxWidth ?? params?.defaultMaxWidth;
					const colMinWidth = column.getMinWidth();
					const colMaxWidth = column.getMaxWidth();
					const minWidth = typeof minOverride === "number" && minOverride > colMinWidth ? minOverride : colMinWidth;
					const maxWidth = typeof maxOverride === "number" && maxOverride < colMaxWidth ? maxOverride : colMaxWidth;
					let newWidth = Math.round(column.getActualWidth() * scale);
					if (newWidth < minWidth) {
						newWidth = minWidth;
						moveToNotSpread(column);
						finishedResizing = false;
					} else if (newWidth > maxWidth) {
						newWidth = maxWidth;
						moveToNotSpread(column);
						finishedResizing = false;
					} else if (i === 0) newWidth = pixelsForLastCol;
					column.setActualWidth(newWidth, source, true);
					pixelsForLastCol -= newWidth;
				}
			}
		}
		colsToDispatchEventFor.forEach((col) => {
			col.fireColumnWidthChangedEvent(source);
		});
		const visibleCols = this.beans.visibleCols;
		visibleCols.setLeftValues(source);
		visibleCols.updateBodyWidths();
		if (silent) return;
		dispatchColumnResizedEvent(this.eventSvc, colsToDispatchEventFor, true, source);
	}
	applyAutosizeStrategy() {
		const autoSizeStrategy = this.gos.get("autoSizeStrategy");
		if (!autoSizeStrategy) return;
		const { type } = autoSizeStrategy;
		setTimeout(() => {
			if (type === "fitGridWidth") {
				const { columnLimits: propColumnLimits, defaultMinWidth, defaultMaxWidth } = autoSizeStrategy;
				const columnLimits = propColumnLimits?.map(({ colId: key, minWidth, maxWidth }) => ({
					key,
					minWidth,
					maxWidth
				}));
				this.sizeColumnsToFitGridBody({
					defaultMinWidth,
					defaultMaxWidth,
					columnLimits
				});
			} else if (type === "fitProvidedWidth") this.sizeColumnsToFit(autoSizeStrategy.width, "sizeColumnsToFit");
		});
	}
	onFirstDataRendered() {
		const autoSizeStrategy = this.gos.get("autoSizeStrategy");
		if (autoSizeStrategy?.type !== "fitCellContents") return;
		const { colIds: columns, skipHeader, defaultMaxWidth, defaultMinWidth, columnLimits } = autoSizeStrategy;
		setTimeout(() => {
			const params = {
				skipHeader,
				source: "autosizeColumns",
				defaultMaxWidth,
				defaultMinWidth,
				columnLimits
			};
			if (columns) this.autoSizeCols({
				colKeys: columns,
				...params
			});
			else this.autoSizeAllColumns(params);
		});
	}
	processResizeOperations() {
		this.shouldQueueResizeOperations = false;
		this.resizeOperationQueue.forEach((resizeOperation) => resizeOperation());
		this.resizeOperationQueue = [];
	}
	pushResizeOperation(func) {
		this.resizeOperationQueue.push(func);
	}
	destroy() {
		this.resizeOperationQueue.length = 0;
		super.destroy();
	}
};
function normaliseColumnWidth(column, newWidth, limits = {}) {
	const minWidth = limits.minWidth ?? column.getMinWidth();
	if (newWidth < minWidth) newWidth = minWidth;
	const maxWidth = limits.maxWidth ?? column.getMaxWidth();
	if (newWidth > maxWidth) newWidth = maxWidth;
	return newWidth;
}
var ColumnAutoSizeModule = {
	moduleName: "ColumnAutoSize",
	version: VERSION,
	beans: [ColumnAutosizeService],
	apiFunctions: {
		sizeColumnsToFit,
		autoSizeColumns,
		autoSizeAllColumns
	},
	dependsOn: [AutoWidthModule]
};
var manualPinnedRowCSS = `.ag-row-pinned-source{background-color:var(--ag-pinned-source-row-background-color);color:var(--ag-pinned-source-row-text-color);font-weight:var(--ag-pinned-source-row-font-weight)}.ag-row-pinned-manual{background-color:var(--ag-pinned-row-background-color);color:var(--ag-pinned-row-text-color);font-weight:var(--ag-pinned-row-font-weight)}`;
function getPinnedTopRowCount(beans) {
	return beans.pinnedRowModel?.getPinnedTopRowCount() ?? 0;
}
function getPinnedBottomRowCount(beans) {
	return beans.pinnedRowModel?.getPinnedBottomRowCount() ?? 0;
}
function getPinnedTopRow(beans, index) {
	return beans.pinnedRowModel?.getPinnedTopRow(index);
}
function getPinnedBottomRow(beans, index) {
	return beans.pinnedRowModel?.getPinnedBottomRow(index);
}
function forEachPinnedRow(beans, floating, callback) {
	return beans.pinnedRowModel?.forEachPinnedRow(floating, callback);
}
var PinnedRowModule = {
	moduleName: "PinnedRow",
	version: VERSION,
	beans: [PinnedRowModel],
	css: [manualPinnedRowCSS],
	apiFunctions: {
		getPinnedTopRowCount,
		getPinnedBottomRowCount,
		getPinnedTopRow,
		getPinnedBottomRow,
		forEachPinnedRow
	},
	icons: {
		rowPin: "pin",
		rowPinTop: "pinned-top",
		rowPinBottom: "pinned-bottom",
		rowUnpin: "un-pin"
	}
};
var CellCustomStyleFeature = class extends BeanStub {
	constructor(cellCtrl, beans) {
		super();
		this.cellCtrl = cellCtrl;
		this.staticClasses = [];
		this.beans = beans;
		this.column = cellCtrl.column;
	}
	setComp(comp) {
		this.cellComp = comp;
		this.applyUserStyles();
		this.applyCellClassRules();
		this.applyClassesFromColDef();
	}
	applyCellClassRules() {
		const { column, cellComp } = this;
		const colDef = column.colDef;
		const cellClassRules = colDef.cellClassRules;
		const cellClassParams = this.getCellClassParams(column, colDef);
		processClassRules(this.beans.expressionSvc, cellClassRules === this.cellClassRules ? void 0 : this.cellClassRules, cellClassRules, cellClassParams, (className) => cellComp.toggleCss(className, true), (className) => cellComp.toggleCss(className, false));
		this.cellClassRules = cellClassRules;
	}
	applyUserStyles() {
		const column = this.column;
		const colDef = column.colDef;
		const cellStyle = colDef.cellStyle;
		if (!cellStyle) return;
		let styles;
		if (typeof cellStyle === "function") styles = cellStyle(this.getCellClassParams(column, colDef));
		else styles = cellStyle;
		if (styles) this.cellComp.setUserStyles(styles);
	}
	applyClassesFromColDef() {
		const { column, cellComp } = this;
		const colDef = column.colDef;
		const cellClassParams = this.getCellClassParams(column, colDef);
		this.staticClasses.forEach((className) => cellComp.toggleCss(className, false));
		const newStaticClasses = this.beans.cellStyles.getStaticCellClasses(colDef, cellClassParams);
		this.staticClasses = newStaticClasses;
		newStaticClasses.forEach((className) => cellComp.toggleCss(className, true));
	}
	getCellClassParams(column, colDef) {
		const { value, rowNode } = this.cellCtrl;
		return _addGridCommonParams(this.beans.gos, {
			value,
			data: rowNode.data,
			node: rowNode,
			colDef,
			column,
			rowIndex: rowNode.rowIndex
		});
	}
};
var CellStyleService = class extends BeanStub {
	constructor() {
		super(...arguments);
		this.beanName = "cellStyles";
	}
	processAllCellClasses(colDef, params, onApplicableClass, onNotApplicableClass) {
		processClassRules(this.beans.expressionSvc, void 0, colDef.cellClassRules, params, onApplicableClass, onNotApplicableClass);
		this.processStaticCellClasses(colDef, params, onApplicableClass);
	}
	getStaticCellClasses(colDef, params) {
		const { cellClass } = colDef;
		if (!cellClass) return [];
		let classOrClasses;
		if (typeof cellClass === "function") classOrClasses = cellClass(params);
		else classOrClasses = cellClass;
		if (typeof classOrClasses === "string") classOrClasses = [classOrClasses];
		return classOrClasses || [];
	}
	createCellCustomStyleFeature(ctrl, beans) {
		return new CellCustomStyleFeature(ctrl, beans);
	}
	processStaticCellClasses(colDef, params, onApplicableClass) {
		this.getStaticCellClasses(colDef, params).forEach((cssClassItem) => {
			onApplicableClass(cssClassItem);
		});
	}
};
var CellStyleModule = {
	moduleName: "CellStyle",
	version: VERSION,
	beans: [CellStyleService]
};
var ApiEventService = class extends BeanStub {
	constructor() {
		super(...arguments);
		this.beanName = "apiEventSvc";
		this.syncListeners = /* @__PURE__ */ new Map();
		this.asyncListeners = /* @__PURE__ */ new Map();
		this.syncGlobalListeners = /* @__PURE__ */ new Set();
		this.globalListenerPairs = /* @__PURE__ */ new Map();
	}
	postConstruct() {
		this.wrapSvc = this.beans.frameworkOverrides.createGlobalEventListenerWrapper?.();
	}
	addEventListener(eventType, userListener) {
		const listener = this.wrapSvc?.wrap(eventType, userListener) ?? userListener;
		const async = !ALWAYS_SYNC_GLOBAL_EVENTS.has(eventType);
		const listeners = async ? this.asyncListeners : this.syncListeners;
		if (!listeners.has(eventType)) listeners.set(eventType, /* @__PURE__ */ new Set());
		listeners.get(eventType).add(listener);
		this.eventSvc.addEventListener(eventType, listener, async);
	}
	removeEventListener(eventType, userListener) {
		const listener = this.wrapSvc?.unwrap(eventType, userListener) ?? userListener;
		const hasAsync = !!this.asyncListeners.get(eventType)?.delete(listener);
		if (!hasAsync) this.syncListeners.get(eventType)?.delete(listener);
		this.eventSvc.removeEventListener(eventType, listener, hasAsync);
	}
	addGlobalListener(userListener) {
		const listener = this.wrapSvc?.wrapGlobal(userListener) ?? userListener;
		const syncListener = (eventType, event) => {
			if (ALWAYS_SYNC_GLOBAL_EVENTS.has(eventType)) listener(eventType, event);
		};
		const asyncListener = (eventType, event) => {
			if (!ALWAYS_SYNC_GLOBAL_EVENTS.has(eventType)) listener(eventType, event);
		};
		this.globalListenerPairs.set(userListener, {
			syncListener,
			asyncListener
		});
		const eventSvc = this.eventSvc;
		eventSvc.addGlobalListener(syncListener, false);
		eventSvc.addGlobalListener(asyncListener, true);
	}
	removeGlobalListener(userListener) {
		const { eventSvc, wrapSvc, globalListenerPairs } = this;
		const listener = wrapSvc?.unwrapGlobal(userListener) ?? userListener;
		if (globalListenerPairs.has(listener)) {
			const { syncListener, asyncListener } = globalListenerPairs.get(listener);
			eventSvc.removeGlobalListener(syncListener, false);
			eventSvc.removeGlobalListener(asyncListener, true);
			globalListenerPairs.delete(userListener);
		} else {
			this.syncGlobalListeners.delete(listener);
			eventSvc.removeGlobalListener(listener, false);
		}
	}
	destroyEventListeners(map, async) {
		map.forEach((listeners, eventType) => {
			listeners.forEach((listener) => this.eventSvc.removeEventListener(eventType, listener, async));
			listeners.clear();
		});
		map.clear();
	}
	destroyGlobalListeners(set, async) {
		set.forEach((listener) => this.eventSvc.removeGlobalListener(listener, async));
		set.clear();
	}
	destroy() {
		super.destroy();
		this.destroyEventListeners(this.syncListeners, false);
		this.destroyEventListeners(this.asyncListeners, true);
		this.destroyGlobalListeners(this.syncGlobalListeners, false);
		const { globalListenerPairs, eventSvc } = this;
		globalListenerPairs.forEach(({ syncListener, asyncListener }) => {
			eventSvc.removeGlobalListener(syncListener, false);
			eventSvc.removeGlobalListener(asyncListener, true);
		});
		globalListenerPairs.clear();
	}
};
function addEventListener(beans, eventType, listener) {
	beans.apiEventSvc?.addEventListener(eventType, listener);
}
function removeEventListener(beans, eventType, listener) {
	beans.apiEventSvc?.removeEventListener(eventType, listener);
}
function addGlobalListener(beans, listener) {
	beans.apiEventSvc?.addGlobalListener(listener);
}
function removeGlobalListener(beans, listener) {
	beans.apiEventSvc?.removeGlobalListener(listener);
}
var EventApiModule = {
	moduleName: "EventApi",
	version: VERSION,
	apiFunctions: {
		addEventListener,
		addGlobalListener,
		removeEventListener,
		removeGlobalListener
	},
	beans: [ApiEventService]
};
var W = Object.defineProperty;
var N = (r, d, e) => d in r ? W(r, d, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: e
}) : r[d] = e;
var C = (r, d, e) => N(r, typeof d != "symbol" ? d + "" : d, e);
var v = class v {
	static getComponentDefinition(d, e) {
		let n;
		return typeof d == "string" ? n = this.searchForComponentInstance(e, d) : n = { extends: defineComponent({ ...d }) }, n || _error(114, { component: d }), n.extends ? (n.extends.setup && (n.setup = n.extends.setup), n.extends.props = this.addParamsToProps(n.extends.props)) : n.props = this.addParamsToProps(n.props), n;
	}
	static addParamsToProps(d) {
		return !d || Array.isArray(d) && d.indexOf("params") === -1 ? d = ["params", ...d || []] : typeof d == "object" && !d.params && (d.params = { type: Object }), d;
	}
	static createAndMountComponent(d, e, n, s) {
		const t = v.getComponentDefinition(d, n);
		if (!t) return;
		const { vNode: l, destroy: o, el: i } = this.mount(t, { params: Object.freeze(e) }, n, s || {});
		return {
			componentInstance: l.component.proxy,
			element: i,
			destroy: o
		};
	}
	static mount(d, e, n, s) {
		let t = createVNode(d, e);
		t.appContext = {
			...n.appContext,
			provides: s
		};
		let l = document.createDocumentFragment();
		return render(t, l), {
			vNode: t,
			destroy: () => {
				l && render(null, l), l = null, t = null;
			},
			el: l
		};
	}
	static searchForComponentInstance(d, e, n = 10, s = !1) {
		let t = null, l = 0, o = d.parent;
		for (; !t && o && o.components && ++l < n;) o.components && o.components[e] && (t = o.components[e]), o = o.parent;
		for (l = 0, o = d.parent; !t && o && o.$options && ++l < n;) {
			const i = o;
			i.$options && i.$options.components && i.$options.components[e] ? t = i.$options.components[e] : i[e] && (t = i[e]), o = o.parent;
		}
		for (l = 0, o = d.parent; !t && o && ++l < n;) {
			if (o.exposed) {
				const i = o;
				i.exposed && i.exposed[e] ? t = i.exposed[e] : i[e] && (t = i[e]);
			}
			o = o.parent;
		}
		if (!t) {
			const i = d.appContext.components;
			i && i[e] && (t = i[e]);
		}
		return !t && !s ? (_error(114, { component: e }), null) : t;
	}
};
var fe = class extends BaseComponentWrapper {
	constructor(e, n) {
		super();
		C(this, "parent");
		C(this, "provides");
		this.parent = e, this.provides = n;
	}
	createWrapper(e) {
		const n = this;
		class s extends ce {
			init(o) {
				super.init(o);
			}
			hasMethod(o) {
				var p, c;
				const i = t.getFrameworkComponentInstance();
				return i[o] ? !0 : ((p = i.$.exposed) == null ? void 0 : p[o]) != null || ((c = i.exposed) == null ? void 0 : c[o]) != null || i.$.setupState[o] != null;
			}
			callMethod(o, i) {
				var B, h;
				const p = this.getFrameworkComponentInstance(), c = t.getFrameworkComponentInstance();
				if (c[o]) return c[o].apply(p, i);
				{
					const m = ((B = p.$.exposed) == null ? void 0 : B[o]) || ((h = p.exposed) == null ? void 0 : h[o]) || p.$.setupState[o];
					return m == null ? void 0 : m.apply(p, i);
				}
			}
			addMethod(o, i) {
				t[o] = i;
			}
			processMethod(o, i) {
				return o === "refresh" && (this.getFrameworkComponentInstance().params = i[0]), this.hasMethod(o) ? this.callMethod(o, i) : o === "refresh";
			}
			createComponent(o) {
				return n.createComponent(e, o);
			}
		}
		const t = new s();
		return t;
	}
	createComponent(e, n) {
		return v.createAndMountComponent(e, n, this.parent, this.provides);
	}
	createMethodProxy(e, n, s) {
		return function() {
			return e.hasMethod(n) ? e.callMethod(n, arguments) : (s && _warn(233, { methodName: n }), null);
		};
	}
	destroy() {
		this.parent = null;
	}
};
var ce = class {
	constructor() {
		C(this, "componentInstance");
		C(this, "element");
		C(this, "unmount");
	}
	getGui() {
		return this.element;
	}
	destroy() {
		this.getFrameworkComponentInstance() && typeof this.getFrameworkComponentInstance().destroy == "function" && this.getFrameworkComponentInstance().destroy(), this.unmount();
	}
	getFrameworkComponentInstance() {
		return this.componentInstance;
	}
	init(d) {
		const { componentInstance: e, element: n, destroy: s } = this.createComponent(d);
		this.componentInstance = e, this.unmount = s, this.element = n.firstElementChild ?? n;
	}
};
var ge = class extends VanillaFrameworkOverrides {
	constructor(e) {
		super("vue");
		C(this, "parent");
		this.parent = e;
	}
	frameworkComponent(e, n) {
		let s = v.searchForComponentInstance(this.parent, e, 10, !0) ? e : null;
		if (!s && n && n[e]) {
			const t = n[e];
			s = v.searchForComponentInstance(this.parent, t, 10, !0) ? t : null;
		}
		return s;
	}
	isFrameworkComponent(e) {
		return typeof e == "object";
	}
};
function ye() {
	return {
		gridOptions: {},
		modules: [],
		statusBar: void 0,
		sideBar: void 0,
		suppressContextMenu: void 0,
		preventDefaultOnContextMenu: void 0,
		allowContextMenuWithControlKey: void 0,
		columnMenu: void 0,
		suppressMenuHide: void 0,
		enableBrowserTooltips: void 0,
		tooltipTrigger: void 0,
		tooltipShowDelay: void 0,
		tooltipHideDelay: void 0,
		tooltipMouseTrack: void 0,
		tooltipShowMode: void 0,
		tooltipInteraction: void 0,
		popupParent: void 0,
		copyHeadersToClipboard: void 0,
		copyGroupHeadersToClipboard: void 0,
		clipboardDelimiter: void 0,
		suppressCopyRowsToClipboard: void 0,
		suppressCopySingleCellRanges: void 0,
		suppressLastEmptyLineOnPaste: void 0,
		suppressClipboardPaste: void 0,
		suppressClipboardApi: void 0,
		suppressCutToClipboard: void 0,
		columnDefs: void 0,
		defaultColDef: void 0,
		defaultColGroupDef: void 0,
		columnTypes: void 0,
		dataTypeDefinitions: void 0,
		maintainColumnOrder: void 0,
		enableStrictPivotColumnOrder: void 0,
		suppressFieldDotNotation: void 0,
		headerHeight: void 0,
		groupHeaderHeight: void 0,
		floatingFiltersHeight: void 0,
		pivotHeaderHeight: void 0,
		pivotGroupHeaderHeight: void 0,
		hidePaddedHeaderRows: void 0,
		allowDragFromColumnsToolPanel: void 0,
		suppressMovableColumns: void 0,
		suppressColumnMoveAnimation: void 0,
		suppressMoveWhenColumnDragging: void 0,
		suppressDragLeaveHidesColumns: void 0,
		suppressGroupChangesColumnVisibility: void 0,
		suppressMakeColumnVisibleAfterUnGroup: void 0,
		suppressRowGroupHidesColumns: void 0,
		colResizeDefault: void 0,
		suppressAutoSize: void 0,
		autoSizePadding: void 0,
		skipHeaderOnAutoSize: void 0,
		autoSizeStrategy: void 0,
		components: void 0,
		editType: void 0,
		suppressStartEditOnTab: void 0,
		getFullRowEditValidationErrors: void 0,
		invalidEditValueMode: void 0,
		singleClickEdit: void 0,
		suppressClickEdit: void 0,
		readOnlyEdit: void 0,
		stopEditingWhenCellsLoseFocus: void 0,
		enterNavigatesVertically: void 0,
		enterNavigatesVerticallyAfterEdit: void 0,
		enableCellEditingOnBackspace: void 0,
		undoRedoCellEditing: void 0,
		undoRedoCellEditingLimit: void 0,
		defaultCsvExportParams: void 0,
		suppressCsvExport: void 0,
		defaultExcelExportParams: void 0,
		suppressExcelExport: void 0,
		excelStyles: void 0,
		findSearchValue: void 0,
		findOptions: void 0,
		quickFilterText: void 0,
		cacheQuickFilter: void 0,
		includeHiddenColumnsInQuickFilter: void 0,
		quickFilterParser: void 0,
		quickFilterMatcher: void 0,
		applyQuickFilterBeforePivotOrAgg: void 0,
		excludeChildrenWhenTreeDataFiltering: void 0,
		enableAdvancedFilter: void 0,
		alwaysPassFilter: void 0,
		includeHiddenColumnsInAdvancedFilter: void 0,
		advancedFilterParent: void 0,
		advancedFilterBuilderParams: void 0,
		advancedFilterParams: void 0,
		suppressAdvancedFilterEval: void 0,
		suppressSetFilterByDefault: void 0,
		enableFilterHandlers: void 0,
		filterHandlers: void 0,
		enableCharts: void 0,
		chartThemes: void 0,
		customChartThemes: void 0,
		chartThemeOverrides: void 0,
		chartToolPanelsDef: void 0,
		chartMenuItems: void 0,
		loadingCellRenderer: void 0,
		loadingCellRendererParams: void 0,
		loadingCellRendererSelector: void 0,
		localeText: void 0,
		masterDetail: void 0,
		keepDetailRows: void 0,
		keepDetailRowsCount: void 0,
		detailCellRenderer: void 0,
		detailCellRendererParams: void 0,
		detailRowHeight: void 0,
		detailRowAutoHeight: void 0,
		context: void 0,
		alignedGrids: void 0,
		tabIndex: void 0,
		rowBuffer: void 0,
		valueCache: void 0,
		valueCacheNeverExpires: void 0,
		enableCellExpressions: void 0,
		suppressTouch: void 0,
		suppressFocusAfterRefresh: void 0,
		suppressBrowserResizeObserver: void 0,
		suppressPropertyNamesCheck: void 0,
		suppressChangeDetection: void 0,
		debug: void 0,
		loading: void 0,
		overlayLoadingTemplate: void 0,
		loadingOverlayComponent: void 0,
		loadingOverlayComponentParams: void 0,
		suppressLoadingOverlay: void 0,
		overlayNoRowsTemplate: void 0,
		noRowsOverlayComponent: void 0,
		noRowsOverlayComponentParams: void 0,
		suppressNoRowsOverlay: void 0,
		pagination: void 0,
		paginationPageSize: void 0,
		paginationPageSizeSelector: void 0,
		paginationAutoPageSize: void 0,
		paginateChildRows: void 0,
		suppressPaginationPanel: void 0,
		pivotMode: void 0,
		pivotPanelShow: void 0,
		pivotMaxGeneratedColumns: void 0,
		pivotDefaultExpanded: void 0,
		pivotColumnGroupTotals: void 0,
		pivotRowTotals: void 0,
		pivotSuppressAutoColumn: void 0,
		suppressExpandablePivotGroups: void 0,
		functionsReadOnly: void 0,
		aggFuncs: void 0,
		suppressAggFuncInHeader: void 0,
		alwaysAggregateAtRootLevel: void 0,
		aggregateOnlyChangedColumns: void 0,
		suppressAggFilteredOnly: void 0,
		removePivotHeaderRowWhenSingleValueColumn: void 0,
		animateRows: void 0,
		cellFlashDuration: void 0,
		cellFadeDuration: void 0,
		allowShowChangeAfterFilter: void 0,
		domLayout: void 0,
		ensureDomOrder: void 0,
		enableCellSpan: void 0,
		enableRtl: void 0,
		suppressColumnVirtualisation: void 0,
		suppressMaxRenderedRowRestriction: void 0,
		suppressRowVirtualisation: void 0,
		rowDragManaged: void 0,
		rowDragInsertDelay: void 0,
		suppressRowDrag: void 0,
		suppressMoveWhenRowDragging: void 0,
		rowDragEntireRow: void 0,
		rowDragMultiRow: void 0,
		rowDragText: void 0,
		dragAndDropImageComponent: void 0,
		dragAndDropImageComponentParams: void 0,
		fullWidthCellRenderer: void 0,
		fullWidthCellRendererParams: void 0,
		embedFullWidthRows: void 0,
		groupDisplayType: void 0,
		groupDefaultExpanded: void 0,
		autoGroupColumnDef: void 0,
		groupMaintainOrder: void 0,
		groupSelectsChildren: void 0,
		groupLockGroupColumns: void 0,
		groupAggFiltering: void 0,
		groupTotalRow: void 0,
		grandTotalRow: void 0,
		suppressStickyTotalRow: void 0,
		groupSuppressBlankHeader: void 0,
		groupSelectsFiltered: void 0,
		showOpenedGroup: void 0,
		groupHideParentOfSingleChild: void 0,
		groupRemoveSingleChildren: void 0,
		groupRemoveLowestSingleChildren: void 0,
		groupHideOpenParents: void 0,
		groupAllowUnbalanced: void 0,
		rowGroupPanelShow: void 0,
		groupRowRenderer: void 0,
		groupRowRendererParams: void 0,
		treeData: void 0,
		treeDataChildrenField: void 0,
		treeDataParentIdField: void 0,
		rowGroupPanelSuppressSort: void 0,
		suppressGroupRowsSticky: void 0,
		pinnedTopRowData: void 0,
		pinnedBottomRowData: void 0,
		enableRowPinning: void 0,
		isRowPinnable: void 0,
		isRowPinned: void 0,
		rowModelType: void 0,
		rowData: void 0,
		asyncTransactionWaitMillis: void 0,
		suppressModelUpdateAfterUpdateTransaction: void 0,
		datasource: void 0,
		cacheOverflowSize: void 0,
		infiniteInitialRowCount: void 0,
		serverSideInitialRowCount: void 0,
		suppressServerSideFullWidthLoadingRow: void 0,
		cacheBlockSize: void 0,
		maxBlocksInCache: void 0,
		maxConcurrentDatasourceRequests: void 0,
		blockLoadDebounceMillis: void 0,
		purgeClosedRowNodes: void 0,
		serverSideDatasource: void 0,
		serverSideSortAllLevels: void 0,
		serverSideEnableClientSideSort: void 0,
		serverSideOnlyRefreshFilteredGroups: void 0,
		serverSidePivotResultFieldSeparator: void 0,
		viewportDatasource: void 0,
		viewportRowModelPageSize: void 0,
		viewportRowModelBufferSize: void 0,
		alwaysShowHorizontalScroll: void 0,
		alwaysShowVerticalScroll: void 0,
		debounceVerticalScrollbar: void 0,
		suppressHorizontalScroll: void 0,
		suppressScrollOnNewData: void 0,
		suppressScrollWhenPopupsAreOpen: void 0,
		suppressAnimationFrame: void 0,
		suppressMiddleClickScrolls: void 0,
		suppressPreventDefaultOnMouseWheel: void 0,
		scrollbarWidth: void 0,
		rowSelection: void 0,
		cellSelection: void 0,
		rowMultiSelectWithClick: void 0,
		suppressRowDeselection: void 0,
		suppressRowClickSelection: void 0,
		suppressCellFocus: void 0,
		suppressHeaderFocus: void 0,
		selectionColumnDef: void 0,
		rowNumbers: void 0,
		suppressMultiRangeSelection: void 0,
		enableCellTextSelection: void 0,
		enableRangeSelection: void 0,
		enableRangeHandle: void 0,
		enableFillHandle: void 0,
		fillHandleDirection: void 0,
		suppressClearOnFillReduction: void 0,
		sortingOrder: void 0,
		accentedSort: void 0,
		unSortIcon: void 0,
		suppressMultiSort: void 0,
		alwaysMultiSort: void 0,
		multiSortKey: void 0,
		suppressMaintainUnsortedOrder: void 0,
		icons: void 0,
		rowHeight: void 0,
		rowStyle: void 0,
		rowClass: void 0,
		rowClassRules: void 0,
		suppressRowHoverHighlight: void 0,
		suppressRowTransform: void 0,
		columnHoverHighlight: void 0,
		gridId: void 0,
		deltaSort: void 0,
		treeDataDisplayType: void 0,
		enableGroupEdit: void 0,
		initialState: void 0,
		theme: void 0,
		loadThemeGoogleFonts: void 0,
		themeCssLayer: void 0,
		styleNonce: void 0,
		themeStyleContainer: void 0,
		getContextMenuItems: void 0,
		getMainMenuItems: void 0,
		postProcessPopup: void 0,
		processUnpinnedColumns: void 0,
		processCellForClipboard: void 0,
		processHeaderForClipboard: void 0,
		processGroupHeaderForClipboard: void 0,
		processCellFromClipboard: void 0,
		sendToClipboard: void 0,
		processDataFromClipboard: void 0,
		isExternalFilterPresent: void 0,
		doesExternalFilterPass: void 0,
		getChartToolbarItems: void 0,
		createChartContainer: void 0,
		focusGridInnerElement: void 0,
		navigateToNextHeader: void 0,
		tabToNextHeader: void 0,
		navigateToNextCell: void 0,
		tabToNextCell: void 0,
		getLocaleText: void 0,
		getDocument: void 0,
		paginationNumberFormatter: void 0,
		getGroupRowAgg: void 0,
		isGroupOpenByDefault: void 0,
		initialGroupOrderComparator: void 0,
		processPivotResultColDef: void 0,
		processPivotResultColGroupDef: void 0,
		getDataPath: void 0,
		getChildCount: void 0,
		getServerSideGroupLevelParams: void 0,
		isServerSideGroupOpenByDefault: void 0,
		isApplyServerSideTransaction: void 0,
		isServerSideGroup: void 0,
		getServerSideGroupKey: void 0,
		getBusinessKeyForNode: void 0,
		getRowId: void 0,
		resetRowDataOnUpdate: void 0,
		processRowPostCreate: void 0,
		isRowSelectable: void 0,
		isRowMaster: void 0,
		fillOperation: void 0,
		postSortRows: void 0,
		getRowStyle: void 0,
		getRowClass: void 0,
		getRowHeight: void 0,
		isFullWidthRow: void 0,
		isRowValidDropPosition: void 0,
		"onColumn-everything-changed": void 0,
		"onNew-columns-loaded": void 0,
		"onColumn-pivot-mode-changed": void 0,
		"onPivot-max-columns-exceeded": void 0,
		"onColumn-row-group-changed": void 0,
		"onExpand-or-collapse-all": void 0,
		"onColumn-pivot-changed": void 0,
		"onGrid-columns-changed": void 0,
		"onColumn-value-changed": void 0,
		"onColumn-moved": void 0,
		"onColumn-visible": void 0,
		"onColumn-pinned": void 0,
		"onColumn-group-opened": void 0,
		"onColumn-resized": void 0,
		"onDisplayed-columns-changed": void 0,
		"onVirtual-columns-changed": void 0,
		"onColumn-header-mouse-over": void 0,
		"onColumn-header-mouse-leave": void 0,
		"onColumn-header-clicked": void 0,
		"onColumn-header-context-menu": void 0,
		"onAsync-transactions-flushed": void 0,
		"onRow-group-opened": void 0,
		"onRow-data-updated": void 0,
		"onPinned-row-data-changed": void 0,
		"onPinned-rows-changed": void 0,
		"onRange-selection-changed": void 0,
		"onCell-selection-changed": void 0,
		"onChart-created": void 0,
		"onChart-range-selection-changed": void 0,
		"onChart-options-changed": void 0,
		"onChart-destroyed": void 0,
		"onTool-panel-visible-changed": void 0,
		"onTool-panel-size-changed": void 0,
		"onModel-updated": void 0,
		"onCut-start": void 0,
		"onCut-end": void 0,
		"onPaste-start": void 0,
		"onPaste-end": void 0,
		"onFill-start": void 0,
		"onFill-end": void 0,
		"onCell-selection-delete-start": void 0,
		"onCell-selection-delete-end": void 0,
		"onRange-delete-start": void 0,
		"onRange-delete-end": void 0,
		"onUndo-started": void 0,
		"onUndo-ended": void 0,
		"onRedo-started": void 0,
		"onRedo-ended": void 0,
		"onCell-clicked": void 0,
		"onCell-double-clicked": void 0,
		"onCell-mouse-down": void 0,
		"onCell-context-menu": void 0,
		"onCell-value-changed": void 0,
		"onCell-edit-request": void 0,
		"onRow-value-changed": void 0,
		"onHeader-focused": void 0,
		"onCell-focused": void 0,
		"onRow-selected": void 0,
		"onSelection-changed": void 0,
		"onTooltip-show": void 0,
		"onTooltip-hide": void 0,
		"onCell-key-down": void 0,
		"onCell-mouse-over": void 0,
		"onCell-mouse-out": void 0,
		"onFilter-changed": void 0,
		"onFilter-modified": void 0,
		"onFilter-ui-changed": void 0,
		"onFilter-opened": void 0,
		"onFloating-filter-ui-changed": void 0,
		"onAdvanced-filter-builder-visible-changed": void 0,
		"onSort-changed": void 0,
		"onVirtual-row-removed": void 0,
		"onRow-clicked": void 0,
		"onRow-double-clicked": void 0,
		"onGrid-ready": void 0,
		"onGrid-pre-destroyed": void 0,
		"onGrid-size-changed": void 0,
		"onViewport-changed": void 0,
		"onFirst-data-rendered": void 0,
		"onDrag-started": void 0,
		"onDrag-stopped": void 0,
		"onDrag-cancelled": void 0,
		"onRow-editing-started": void 0,
		"onRow-editing-stopped": void 0,
		"onCell-editing-started": void 0,
		"onCell-editing-stopped": void 0,
		"onBody-scroll": void 0,
		"onBody-scroll-end": void 0,
		"onPagination-changed": void 0,
		"onComponent-state-changed": void 0,
		"onStore-refreshed": void 0,
		"onState-updated": void 0,
		"onColumn-menu-visible-changed": void 0,
		"onContext-menu-visible-changed": void 0,
		"onRow-drag-enter": void 0,
		"onRow-drag-move": void 0,
		"onRow-drag-leave": void 0,
		"onRow-drag-end": void 0,
		"onRow-drag-cancel": void 0,
		"onFind-changed": void 0,
		"onRow-resize-started": void 0,
		"onRow-resize-ended": void 0,
		"onColumns-reset": void 0,
		"onBulk-editing-started": void 0,
		"onBulk-editing-stopped": void 0,
		"onBatch-editing-started": void 0,
		"onBatch-editing-stopped": void 0
	};
}
var Ce = (r, d) => {
	let e;
	return () => {
		const n = function() {
			r();
		};
		window.clearTimeout(e), e = window.setTimeout(n, d);
	};
};
function me(r) {
	return r && r.constructor && r.constructor.toString().substring(0, 5) === "class";
}
function R(r) {
	const d = (e) => me(e) ? toRaw(e) : Array.isArray(e) ? e.map((n) => d(n)) : isRef(e) || isReactive(e) || isProxy(e) ? d(toRaw(e)) : e;
	return d(r);
}
var he = { ref: "root" }, Be = /* @__PURE__ */ defineComponent({
	__name: "AgGridVue",
	props: /* @__PURE__ */ mergeModels(/* @__PURE__ */ mergeDefaults({
		gridOptions: {},
		modules: {},
		statusBar: {},
		sideBar: { type: [
			Object,
			String,
			Array,
			Boolean,
			null
		] },
		suppressContextMenu: { type: Boolean },
		preventDefaultOnContextMenu: { type: Boolean },
		allowContextMenuWithControlKey: { type: Boolean },
		columnMenu: {},
		suppressMenuHide: { type: Boolean },
		enableBrowserTooltips: { type: Boolean },
		tooltipTrigger: {},
		tooltipShowDelay: {},
		tooltipHideDelay: {},
		tooltipMouseTrack: { type: Boolean },
		tooltipShowMode: {},
		tooltipInteraction: { type: Boolean },
		popupParent: {},
		copyHeadersToClipboard: { type: Boolean },
		copyGroupHeadersToClipboard: { type: Boolean },
		clipboardDelimiter: {},
		suppressCopyRowsToClipboard: { type: Boolean },
		suppressCopySingleCellRanges: { type: Boolean },
		suppressLastEmptyLineOnPaste: { type: Boolean },
		suppressClipboardPaste: { type: Boolean },
		suppressClipboardApi: { type: Boolean },
		suppressCutToClipboard: { type: Boolean },
		columnDefs: {},
		defaultColDef: {},
		defaultColGroupDef: {},
		columnTypes: {},
		dataTypeDefinitions: {},
		maintainColumnOrder: { type: Boolean },
		enableStrictPivotColumnOrder: { type: Boolean },
		suppressFieldDotNotation: { type: Boolean },
		headerHeight: {},
		groupHeaderHeight: {},
		floatingFiltersHeight: {},
		pivotHeaderHeight: {},
		pivotGroupHeaderHeight: {},
		hidePaddedHeaderRows: { type: Boolean },
		allowDragFromColumnsToolPanel: { type: Boolean },
		suppressMovableColumns: { type: Boolean },
		suppressColumnMoveAnimation: { type: Boolean },
		suppressMoveWhenColumnDragging: { type: Boolean },
		suppressDragLeaveHidesColumns: { type: Boolean },
		suppressGroupChangesColumnVisibility: { type: [Boolean, String] },
		suppressMakeColumnVisibleAfterUnGroup: { type: Boolean },
		suppressRowGroupHidesColumns: { type: Boolean },
		colResizeDefault: {},
		suppressAutoSize: { type: Boolean },
		autoSizePadding: {},
		skipHeaderOnAutoSize: { type: Boolean },
		autoSizeStrategy: {},
		components: {},
		editType: {},
		suppressStartEditOnTab: { type: Boolean },
		getFullRowEditValidationErrors: { type: Function },
		invalidEditValueMode: {},
		singleClickEdit: { type: Boolean },
		suppressClickEdit: { type: Boolean },
		readOnlyEdit: { type: Boolean },
		stopEditingWhenCellsLoseFocus: { type: Boolean },
		enterNavigatesVertically: { type: Boolean },
		enterNavigatesVerticallyAfterEdit: { type: Boolean },
		enableCellEditingOnBackspace: { type: Boolean },
		undoRedoCellEditing: { type: Boolean },
		undoRedoCellEditingLimit: {},
		defaultCsvExportParams: {},
		suppressCsvExport: { type: Boolean },
		defaultExcelExportParams: {},
		suppressExcelExport: { type: Boolean },
		excelStyles: {},
		findSearchValue: {},
		findOptions: {},
		quickFilterText: {},
		cacheQuickFilter: { type: Boolean },
		includeHiddenColumnsInQuickFilter: { type: Boolean },
		quickFilterParser: { type: Function },
		quickFilterMatcher: { type: Function },
		applyQuickFilterBeforePivotOrAgg: { type: Boolean },
		excludeChildrenWhenTreeDataFiltering: { type: Boolean },
		enableAdvancedFilter: { type: Boolean },
		alwaysPassFilter: { type: Function },
		includeHiddenColumnsInAdvancedFilter: { type: Boolean },
		advancedFilterParent: {},
		advancedFilterBuilderParams: {},
		advancedFilterParams: {},
		suppressAdvancedFilterEval: { type: Boolean },
		suppressSetFilterByDefault: { type: Boolean },
		enableFilterHandlers: { type: Boolean },
		filterHandlers: {},
		enableCharts: { type: Boolean },
		chartThemes: {},
		customChartThemes: {},
		chartThemeOverrides: {},
		chartToolPanelsDef: {},
		chartMenuItems: { type: [Array, Function] },
		loadingCellRenderer: {},
		loadingCellRendererParams: {},
		loadingCellRendererSelector: { type: Function },
		localeText: {},
		masterDetail: { type: Boolean },
		keepDetailRows: { type: Boolean },
		keepDetailRowsCount: {},
		detailCellRenderer: {},
		detailCellRendererParams: {},
		detailRowHeight: {},
		detailRowAutoHeight: { type: Boolean },
		context: {},
		alignedGrids: { type: [Array, Function] },
		tabIndex: {},
		rowBuffer: {},
		valueCache: { type: Boolean },
		valueCacheNeverExpires: { type: Boolean },
		enableCellExpressions: { type: Boolean },
		suppressTouch: { type: Boolean },
		suppressFocusAfterRefresh: { type: Boolean },
		suppressBrowserResizeObserver: { type: Boolean },
		suppressPropertyNamesCheck: { type: Boolean },
		suppressChangeDetection: { type: Boolean },
		debug: { type: Boolean },
		loading: { type: Boolean },
		overlayLoadingTemplate: {},
		loadingOverlayComponent: {},
		loadingOverlayComponentParams: {},
		suppressLoadingOverlay: { type: Boolean },
		overlayNoRowsTemplate: {},
		noRowsOverlayComponent: {},
		noRowsOverlayComponentParams: {},
		suppressNoRowsOverlay: { type: Boolean },
		pagination: { type: Boolean },
		paginationPageSize: {},
		paginationPageSizeSelector: { type: [Array, Boolean] },
		paginationAutoPageSize: { type: Boolean },
		paginateChildRows: { type: Boolean },
		suppressPaginationPanel: { type: Boolean },
		pivotMode: { type: Boolean },
		pivotPanelShow: {},
		pivotMaxGeneratedColumns: {},
		pivotDefaultExpanded: {},
		pivotColumnGroupTotals: {},
		pivotRowTotals: {},
		pivotSuppressAutoColumn: { type: Boolean },
		suppressExpandablePivotGroups: { type: Boolean },
		functionsReadOnly: { type: Boolean },
		aggFuncs: {},
		suppressAggFuncInHeader: { type: Boolean },
		alwaysAggregateAtRootLevel: { type: Boolean },
		aggregateOnlyChangedColumns: { type: Boolean },
		suppressAggFilteredOnly: { type: Boolean },
		removePivotHeaderRowWhenSingleValueColumn: { type: Boolean },
		animateRows: { type: Boolean },
		cellFlashDuration: {},
		cellFadeDuration: {},
		allowShowChangeAfterFilter: { type: Boolean },
		domLayout: {},
		ensureDomOrder: { type: Boolean },
		enableCellSpan: { type: Boolean },
		enableRtl: { type: Boolean },
		suppressColumnVirtualisation: { type: Boolean },
		suppressMaxRenderedRowRestriction: { type: Boolean },
		suppressRowVirtualisation: { type: Boolean },
		rowDragManaged: { type: Boolean },
		rowDragInsertDelay: {},
		suppressRowDrag: { type: Boolean },
		suppressMoveWhenRowDragging: { type: Boolean },
		rowDragEntireRow: { type: Boolean },
		rowDragMultiRow: { type: Boolean },
		rowDragText: { type: Function },
		dragAndDropImageComponent: {},
		dragAndDropImageComponentParams: {},
		fullWidthCellRenderer: {},
		fullWidthCellRendererParams: {},
		embedFullWidthRows: { type: Boolean },
		groupDisplayType: {},
		groupDefaultExpanded: {},
		autoGroupColumnDef: {},
		groupMaintainOrder: { type: Boolean },
		groupSelectsChildren: { type: Boolean },
		groupLockGroupColumns: {},
		groupAggFiltering: { type: [Boolean, Function] },
		groupTotalRow: { type: [String, Function] },
		grandTotalRow: {},
		suppressStickyTotalRow: { type: [Boolean, String] },
		groupSuppressBlankHeader: { type: Boolean },
		groupSelectsFiltered: { type: Boolean },
		showOpenedGroup: { type: Boolean },
		groupHideParentOfSingleChild: { type: [Boolean, String] },
		groupRemoveSingleChildren: { type: Boolean },
		groupRemoveLowestSingleChildren: { type: Boolean },
		groupHideOpenParents: { type: Boolean },
		groupAllowUnbalanced: { type: Boolean },
		rowGroupPanelShow: {},
		groupRowRenderer: {},
		groupRowRendererParams: {},
		treeData: { type: Boolean },
		treeDataChildrenField: {},
		treeDataParentIdField: {},
		rowGroupPanelSuppressSort: { type: Boolean },
		suppressGroupRowsSticky: { type: Boolean },
		pinnedTopRowData: {},
		pinnedBottomRowData: {},
		enableRowPinning: { type: [Boolean, String] },
		isRowPinnable: { type: Function },
		isRowPinned: { type: Function },
		rowModelType: {},
		rowData: {},
		asyncTransactionWaitMillis: {},
		suppressModelUpdateAfterUpdateTransaction: { type: Boolean },
		datasource: {},
		cacheOverflowSize: {},
		infiniteInitialRowCount: {},
		serverSideInitialRowCount: {},
		suppressServerSideFullWidthLoadingRow: { type: Boolean },
		cacheBlockSize: {},
		maxBlocksInCache: {},
		maxConcurrentDatasourceRequests: {},
		blockLoadDebounceMillis: {},
		purgeClosedRowNodes: { type: Boolean },
		serverSideDatasource: {},
		serverSideSortAllLevels: { type: Boolean },
		serverSideEnableClientSideSort: { type: Boolean },
		serverSideOnlyRefreshFilteredGroups: { type: Boolean },
		serverSidePivotResultFieldSeparator: {},
		viewportDatasource: {},
		viewportRowModelPageSize: {},
		viewportRowModelBufferSize: {},
		alwaysShowHorizontalScroll: { type: Boolean },
		alwaysShowVerticalScroll: { type: Boolean },
		debounceVerticalScrollbar: { type: Boolean },
		suppressHorizontalScroll: { type: Boolean },
		suppressScrollOnNewData: { type: Boolean },
		suppressScrollWhenPopupsAreOpen: { type: Boolean },
		suppressAnimationFrame: { type: Boolean },
		suppressMiddleClickScrolls: { type: Boolean },
		suppressPreventDefaultOnMouseWheel: { type: Boolean },
		scrollbarWidth: {},
		rowSelection: {},
		cellSelection: { type: [Boolean, Object] },
		rowMultiSelectWithClick: { type: Boolean },
		suppressRowDeselection: { type: Boolean },
		suppressRowClickSelection: { type: Boolean },
		suppressCellFocus: { type: Boolean },
		suppressHeaderFocus: { type: Boolean },
		selectionColumnDef: {},
		rowNumbers: { type: [Boolean, Object] },
		suppressMultiRangeSelection: { type: Boolean },
		enableCellTextSelection: { type: Boolean },
		enableRangeSelection: { type: Boolean },
		enableRangeHandle: { type: Boolean },
		enableFillHandle: { type: Boolean },
		fillHandleDirection: {},
		suppressClearOnFillReduction: { type: Boolean },
		sortingOrder: {},
		accentedSort: { type: Boolean },
		unSortIcon: { type: Boolean },
		suppressMultiSort: { type: Boolean },
		alwaysMultiSort: { type: Boolean },
		multiSortKey: {},
		suppressMaintainUnsortedOrder: { type: Boolean },
		icons: {},
		rowHeight: {},
		rowStyle: {},
		rowClass: {},
		rowClassRules: {},
		suppressRowHoverHighlight: { type: Boolean },
		suppressRowTransform: { type: Boolean },
		columnHoverHighlight: { type: Boolean },
		gridId: {},
		deltaSort: { type: Boolean },
		treeDataDisplayType: {},
		enableGroupEdit: { type: Boolean },
		initialState: {},
		theme: {},
		loadThemeGoogleFonts: { type: Boolean },
		themeCssLayer: {},
		styleNonce: {},
		themeStyleContainer: {},
		getContextMenuItems: { type: Function },
		getMainMenuItems: { type: Function },
		postProcessPopup: { type: Function },
		processUnpinnedColumns: { type: Function },
		processCellForClipboard: { type: Function },
		processHeaderForClipboard: { type: Function },
		processGroupHeaderForClipboard: { type: Function },
		processCellFromClipboard: { type: Function },
		sendToClipboard: { type: Function },
		processDataFromClipboard: { type: Function },
		isExternalFilterPresent: { type: Function },
		doesExternalFilterPass: { type: Function },
		getChartToolbarItems: { type: Function },
		createChartContainer: { type: Function },
		focusGridInnerElement: { type: Function },
		navigateToNextHeader: { type: Function },
		tabToNextHeader: { type: Function },
		navigateToNextCell: { type: Function },
		tabToNextCell: { type: Function },
		getLocaleText: { type: Function },
		getDocument: { type: Function },
		paginationNumberFormatter: { type: Function },
		getGroupRowAgg: { type: Function },
		isGroupOpenByDefault: { type: Function },
		initialGroupOrderComparator: { type: Function },
		processPivotResultColDef: { type: Function },
		processPivotResultColGroupDef: { type: Function },
		getDataPath: { type: Function },
		getChildCount: { type: Function },
		getServerSideGroupLevelParams: { type: Function },
		isServerSideGroupOpenByDefault: { type: Function },
		isApplyServerSideTransaction: { type: Function },
		isServerSideGroup: { type: Function },
		getServerSideGroupKey: { type: Function },
		getBusinessKeyForNode: { type: Function },
		getRowId: { type: Function },
		resetRowDataOnUpdate: { type: Boolean },
		processRowPostCreate: { type: Function },
		isRowSelectable: { type: Function },
		isRowMaster: { type: Function },
		fillOperation: { type: Function },
		postSortRows: { type: Function },
		getRowStyle: { type: Function },
		getRowClass: { type: Function },
		getRowHeight: { type: Function },
		isFullWidthRow: { type: Function },
		isRowValidDropPosition: {},
		"onTool-panel-visible-changed": {},
		"onTool-panel-size-changed": {},
		"onColumn-menu-visible-changed": {},
		"onContext-menu-visible-changed": {},
		"onCut-start": {},
		"onCut-end": {},
		"onPaste-start": {},
		"onPaste-end": {},
		"onColumn-visible": {},
		"onColumn-pinned": {},
		"onColumn-resized": {},
		"onColumn-moved": {},
		"onColumn-value-changed": {},
		"onColumn-pivot-mode-changed": {},
		"onColumn-pivot-changed": {},
		"onColumn-group-opened": {},
		"onNew-columns-loaded": {},
		"onGrid-columns-changed": {},
		"onDisplayed-columns-changed": {},
		"onVirtual-columns-changed": {},
		"onColumn-everything-changed": {},
		"onColumns-reset": {},
		"onColumn-header-mouse-over": {},
		"onColumn-header-mouse-leave": {},
		"onColumn-header-clicked": {},
		"onColumn-header-context-menu": {},
		"onComponent-state-changed": {},
		"onCell-value-changed": {},
		"onCell-edit-request": {},
		"onRow-value-changed": {},
		"onCell-editing-started": {},
		"onCell-editing-stopped": {},
		"onRow-editing-started": {},
		"onRow-editing-stopped": {},
		"onBulk-editing-started": {},
		"onBulk-editing-stopped": {},
		"onBatch-editing-started": {},
		"onBatch-editing-stopped": {},
		"onUndo-started": {},
		"onUndo-ended": {},
		"onRedo-started": {},
		"onRedo-ended": {},
		"onCell-selection-delete-start": {},
		"onCell-selection-delete-end": {},
		"onRange-delete-start": {},
		"onRange-delete-end": {},
		"onFill-start": {},
		"onFill-end": {},
		"onFilter-opened": {},
		"onFilter-changed": {},
		"onFilter-modified": {},
		"onFilter-ui-changed": {},
		"onFloating-filter-ui-changed": {},
		"onAdvanced-filter-builder-visible-changed": {},
		"onFind-changed": {},
		"onChart-created": {},
		"onChart-range-selection-changed": {},
		"onChart-options-changed": {},
		"onChart-destroyed": {},
		"onCell-key-down": {},
		"onGrid-ready": {},
		"onGrid-pre-destroyed": {},
		"onFirst-data-rendered": {},
		"onGrid-size-changed": {},
		"onModel-updated": {},
		"onVirtual-row-removed": {},
		"onViewport-changed": {},
		"onBody-scroll": {},
		"onBody-scroll-end": {},
		"onDrag-started": {},
		"onDrag-stopped": {},
		"onDrag-cancelled": {},
		"onState-updated": {},
		"onPagination-changed": {},
		"onRow-drag-enter": {},
		"onRow-drag-move": {},
		"onRow-drag-leave": {},
		"onRow-drag-end": {},
		"onRow-drag-cancel": {},
		"onRow-resize-started": {},
		"onRow-resize-ended": {},
		"onColumn-row-group-changed": {},
		"onRow-group-opened": {},
		"onExpand-or-collapse-all": {},
		"onPivot-max-columns-exceeded": {},
		"onPinned-row-data-changed": {},
		"onPinned-rows-changed": {},
		"onRow-data-updated": {},
		"onAsync-transactions-flushed": {},
		"onStore-refreshed": {},
		"onHeader-focused": {},
		"onCell-clicked": {},
		"onCell-double-clicked": {},
		"onCell-focused": {},
		"onCell-mouse-over": {},
		"onCell-mouse-out": {},
		"onCell-mouse-down": {},
		"onRow-clicked": {},
		"onRow-double-clicked": {},
		"onRow-selected": {},
		"onSelection-changed": {},
		"onCell-context-menu": {},
		"onRange-selection-changed": {},
		"onCell-selection-changed": {},
		"onTooltip-show": {},
		"onTooltip-hide": {},
		"onSort-changed": {}
	}, ye()), {
		modelValue: {},
		modelModifiers: {}
	}),
	emits: /* @__PURE__ */ mergeModels(["update:modelValue"], ["update:modelValue"]),
	setup(r, { expose: d, emit: e }) {
		const n = r, s = useTemplateRef("root"), t = ref(void 0), l = ref(!1), o = ref(!1), i = ref(!1), p = ref({}), c = ref(null), B = toRefs(n);
		_GET_ALL_GRID_OPTIONS().filter((a) => a != "gridOptions").forEach((a) => {
			watch(() => B[a], (u, f) => {
				(a === "rowData" && !w.value || a !== "rowData") && P(a, u), w.value = !1;
			}, { deep: !0 });
		});
		const h = /* @__PURE__ */ new Set([
			"rowDataUpdated",
			"cellValueChanged",
			"rowValueChanged"
		]), m = useModel(r, "modelValue"), F = ref(!1), w = ref(!1), E = e;
		watch(m, (a, u) => {
			l.value && (w.value || (F.value = !0, P("rowData", R(a), R(u))), w.value = !1);
		}, { deep: !0 });
		const G = Ce(() => {
			w.value = !0, E("update:modelValue", L());
		}, 10), D = getCurrentInstance(), I = (a) => {
			var u, f;
			i.value && h.has(a) && (f = (u = D == null ? void 0 : D.vnode) == null ? void 0 : u.props) != null && f["onUpdate:modelValue"] && G();
		}, V = () => m.value || n.rowData || n.gridOptions.rowData, L = () => {
			const a = [];
			return t?.value.forEachLeafNode((u) => {
				a.push(u.data);
			}), a;
		}, b = (a) => (u) => {
			if (o.value) return;
			u === "gridReady" && (i.value = !0);
			const f = ALWAYS_SYNC_GLOBAL_EVENTS.has(u);
			f && !a || !f && a || h.has(u) && (F.value || I(u), F.value = !1);
		}, P = (a, u, f) => {
			if (l.value) {
				let y = u.value || u;
				a === "rowData" && y != null && (y = R(y)), p.value[a] = y, c.value ??= window.setTimeout(() => {
					c.value = null, _processOnChange(p.value, t.value), p.value = {};
				}, 0);
			}
		}, z = () => Object.create(getCurrentInstance().provides);
		return onMounted(() => {
			_registerModule(RowApiModule, void 0, !0);
			const a = new fe(getCurrentInstance(), z()), u = {
				globalListener: b(),
				globalSyncListener: b(!0),
				frameworkOverrides: new ge(getCurrentInstance()),
				providedBeanInstances: { frameworkCompWrapper: a },
				modules: n.modules
			}, f = markRaw(_combineAttributesAndGridOptions(R(n.gridOptions), n, [..._GET_ALL_GRID_OPTIONS(), ...Object.values(_PUBLIC_EVENT_HANDLERS_MAP)])), y = V();
			y !== void 0 && (f.rowData = R(y)), t.value = createGrid(s.value, f, u), l.value = !0;
		}), onUnmounted(() => {
			var a;
			l.value && ((a = t == null ? void 0 : t.value) == null || a.destroy(), o.value = !0);
		}), d({ api: t }), (a, u) => (openBlock(), createElementBlock("div", he, null, 512));
	}
});
const n8nTheme = themeQuartz.withPart(iconSetAlpine).withParams({
	columnBorder: true,
	rowBorder: true,
	rowVerticalPaddingScale: .8,
	sidePanelBorder: true,
	wrapperBorder: true,
	headerColumnBorder: { color: "var(--color--foreground)" },
	headerColumnBorderHeight: "100%",
	checkboxUncheckedBackgroundColor: "var(--color--background--light-1)",
	checkboxCheckedBackgroundColor: "var(--color--primary)"
});
var modulesRegistered = false;
const registerAgGridModulesOnce = () => {
	if (modulesRegistered) return;
	ModuleRegistry.registerModules([
		ValidationModule,
		ClientSideRowModelModule,
		TextEditorModule,
		LargeTextEditorModule,
		ColumnAutoSizeModule,
		CheckboxEditorModule,
		NumberEditorModule,
		RowSelectionModule,
		RenderApiModule,
		DateEditorModule,
		ClientSideRowModelApiModule,
		UndoRedoEditModule,
		CellStyleModule,
		PinnedRowModule,
		ScrollApiModule,
		ColumnApiModule,
		TextFilterModule,
		NumberFilterModule,
		DateFilterModule,
		EventApiModule
	]);
	modulesRegistered = true;
};
const useDataTablePagination = (options = {}) => {
	const currentPage = ref(options.initialPage ?? 1);
	const pageSize = ref(options.initialPageSize ?? 20);
	const totalItems = ref(0);
	const pageSizeOptions = options.pageSizeOptions ?? [
		10,
		20,
		50
	];
	const setTotalItems = (count) => {
		totalItems.value = count;
	};
	const setCurrentPage = async (page) => {
		currentPage.value = page;
		if (options.onChange) await options.onChange(currentPage.value, pageSize.value);
	};
	const setPageSize = async (size) => {
		pageSize.value = size;
		currentPage.value = 1;
		if (options.onChange) await options.onChange(currentPage.value, pageSize.value);
	};
	const ensureItemOnPage = async (itemIndex) => {
		const itemPage = Math.max(1, Math.ceil(itemIndex / pageSize.value));
		if (currentPage.value !== itemPage) {
			currentPage.value = itemPage;
			if (options.onChange) await options.onChange(currentPage.value, pageSize.value);
		}
	};
	return {
		currentPage,
		pageSize,
		pageSizeOptions,
		totalItems,
		setTotalItems,
		setCurrentPage,
		setPageSize,
		ensureItemOnPage
	};
};
const useAgGrid = ({ gridContainerRef, defaultSortColumn, pinnedBottomRowId, defaultColDef }) => {
	const gridApi = ref(null);
	const isTextEditorOpen = ref(false);
	const currentSortBy = ref(defaultSortColumn);
	const currentSortOrder = ref("asc");
	const initializedGridApi = computed(() => {
		if (!gridApi.value) throw new Error("Grid API is not initialized");
		return gridApi.value;
	});
	const onClipboardPaste = (data) => {
		if (!gridApi.value) return;
		const focusedCell = initializedGridApi.value.getFocusedCell();
		const isEditing$1 = initializedGridApi.value.getEditingCells().length > 0;
		if (!focusedCell || isEditing$1) return;
		const row = initializedGridApi.value.getDisplayedRowAtIndex(focusedCell.rowIndex);
		if (!row) return;
		const colDef = focusedCell.column.getColDef();
		if (colDef.cellDataType === "text") row.setDataValue(focusedCell.column.getColId(), data);
		else if (colDef.cellDataType === "number") {
			if (!Number.isNaN(Number(data))) row.setDataValue(focusedCell.column.getColId(), Number(data));
		} else if (colDef.cellDataType === "date") {
			if (!Number.isNaN(Date.parse(data))) row.setDataValue(focusedCell.column.getColId(), new Date(data));
		} else if (colDef.cellDataType === "boolean") {
			if (data.toLowerCase() === "true") row.setDataValue(focusedCell.column.getColId(), true);
			else if (data.toLowerCase() === "false") row.setDataValue(focusedCell.column.getColId(), false);
		}
	};
	const { copy: copyToClipboard } = useClipboard({ onPaste: onClipboardPaste });
	const lastFocusedCell = ref(null);
	const onGridReady = (params) => {
		gridApi.value = params.api;
		if (gridContainerRef.value) params.api.setGridOption("popupParent", gridContainerRef.value);
		if (defaultColDef) params.api.setGridOption("defaultColDef", defaultColDef);
	};
	const setGridData = ({ colDefs, rowData }) => {
		if (colDefs) initializedGridApi.value.setGridOption("columnDefs", colDefs);
		if (rowData) initializedGridApi.value.setGridOption("rowData", rowData);
		if (pinnedBottomRowId !== void 0) initializedGridApi.value.setGridOption("pinnedBottomRowData", [{ id: pinnedBottomRowId }]);
	};
	const focusFirstEditableCell = (rowId, excludeColumnId) => {
		const rowNode = initializedGridApi.value.getRowNode(String(rowId));
		if (rowNode?.rowIndex === null || rowNode?.rowIndex === void 0) return;
		const rowIndex = rowNode.rowIndex;
		const firstEditable = initializedGridApi.value.getAllDisplayedColumns().find((col) => {
			const def = col.getColDef();
			if (!def) return false;
			if (excludeColumnId && def.colId === excludeColumnId) return false;
			return !!def.editable;
		});
		if (!firstEditable) return;
		const columnId = firstEditable.getColId();
		requestAnimationFrame(() => {
			initializedGridApi.value.ensureIndexVisible(rowIndex);
			requestAnimationFrame(() => {
				initializedGridApi.value.setFocusedCell(rowIndex, columnId);
				initializedGridApi.value.startEditingCell({
					rowIndex,
					colKey: columnId
				});
			});
		});
	};
	const onCellEditingStarted = (params) => {
		if (params.column.getColDef().cellDataType === "text") isTextEditorOpen.value = true;
		else isTextEditorOpen.value = false;
	};
	const onCellEditingStopped = (params) => {
		if (params.column.getColDef().cellDataType === "text") isTextEditorOpen.value = false;
	};
	const handleCopyFocusedCell = async (params) => {
		const focused = params.api.getFocusedCell();
		if (!focused) return;
		const row = params.api.getDisplayedRowAtIndex(focused.rowIndex);
		const colDef = focused.column.getColDef();
		if (row?.data && colDef.field) {
			const rawValue = row.data[colDef.field];
			await copyToClipboard(rawValue === null || rawValue === void 0 ? "" : String(rawValue));
		}
	};
	const onCellClicked = (params) => {
		const clickedCellColumn = params.column.getColId();
		const clickedCellRow = params.rowIndex;
		if (clickedCellRow === null || params.api.isEditing({
			rowIndex: clickedCellRow,
			column: params.column,
			rowPinned: null
		})) return;
		if (lastFocusedCell.value && lastFocusedCell.value.rowIndex === clickedCellRow && lastFocusedCell.value.colId === clickedCellColumn && params.column.getColDef()?.editable) params.api.startEditingCell({
			rowIndex: clickedCellRow,
			colKey: clickedCellColumn
		});
		lastFocusedCell.value = {
			rowIndex: clickedCellRow,
			colId: clickedCellColumn
		};
	};
	const resetLastFocusedCell = () => {
		lastFocusedCell.value = null;
	};
	const onSortChanged$1 = (event, colDefs) => {
		const sortedColumn = event.columns?.filter((col) => col.getSort() !== null).pop() ?? null;
		if (sortedColumn) {
			const colId = sortedColumn.getColId();
			currentSortBy.value = colDefs.find((col) => col.colId === colId)?.field ?? colId;
			currentSortOrder.value = sortedColumn.getSort() ?? "asc";
		} else {
			currentSortBy.value = defaultSortColumn;
			currentSortOrder.value = "asc";
		}
	};
	onClickOutside(gridContainerRef, () => {
		resetLastFocusedCell();
		initializedGridApi.value.clearFocusedCell();
	});
	return {
		gridApi: initializedGridApi,
		onGridReady,
		setGridData,
		focusFirstEditableCell,
		onCellEditingStarted,
		onCellEditingStopped,
		handleCopyFocusedCell,
		onCellClicked,
		resetLastFocusedCell,
		currentSortBy,
		currentSortOrder,
		onSortChanged: onSortChanged$1,
		isTextEditorOpen
	};
};
const DATA_TABLE_COLUMN_TYPES = [
	"string",
	"number",
	"boolean",
	"date"
];
const AG_GRID_CELL_TYPES = [
	"text",
	"number",
	"boolean",
	"date",
	"dateString",
	"object"
];
const isDataTableValue = (value) => {
	return value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean" || value instanceof Date;
};
const isAGGridCellType = (value) => {
	return typeof value === "string" && AG_GRID_CELL_TYPES.includes(value);
};
const useDataTableTypes = () => {
	const getIconForType = (type) => DATA_TYPE_ICON_MAP[type];
	const mapToAGCellType = (colType) => {
		if (colType === "string") return "text";
		return colType;
	};
	const mapToDataTableColumnType = (colType) => {
		if (!isAGGridCellType(colType)) return "string";
		if (colType === "text") return "string";
		return colType;
	};
	return {
		getIconForType,
		mapToAGCellType,
		mapToDataTableColumnType
	};
};
var _hoisted_1$3 = { class: "data-table-column-header-icon-wrapper" };
var _hoisted_2$2 = {
	key: 2,
	class: "ag-header-cell-text",
	"data-test-id": "data-table-column-header-text"
};
var _hoisted_3$1 = {
	key: 3,
	class: "sort-indicator"
};
var ItemAction = /* @__PURE__ */ function(ItemAction$1) {
	ItemAction$1["Rename"] = "rename";
	ItemAction$1["Delete"] = "delete";
	return ItemAction$1;
}(ItemAction || {});
var CHAR_WIDTH_PX = 7;
var PADDING_PX = 16;
var MIN_WIDTH_PX = 50;
var MAX_WIDTH_PX = 250;
var ColumnHeader_default = /* @__PURE__ */ defineComponent({
	__name: "ColumnHeader",
	props: { params: {} },
	setup(__props) {
		const props = __props;
		const { getIconForType, mapToDataTableColumnType } = useDataTableTypes();
		const i18n = useI18n();
		const renameInput = useTemplateRef("renameInput");
		const isHovered = ref(false);
		const isDropdownOpen = ref(false);
		const isFilterOpen = ref(false);
		const hasActiveFilter = ref(false);
		const currentSort = ref(null);
		const shouldShowTypeIcon = computed(() => props.params.showTypeIcon !== false);
		const isFilterable = computed(() => props.params.column.getColDef().filter !== false);
		const onNameSubmit = (newName) => {
			const trimmed = newName.trim();
			if (!trimmed || trimmed === props.params.displayName) {
				renameInput.value?.forceCancel();
				return;
			}
			props.params.onRename?.(props.params.column.getColId(), trimmed);
		};
		const onNameToggle = (e) => {
			e?.stopPropagation();
			if (renameInput.value?.forceFocus && !isSystemColumn.value) renameInput.value.forceFocus();
		};
		const onItemClick = (action) => {
			const actionEnum = action;
			if (actionEnum === ItemAction.Delete) props.params.onDelete?.(props.params.column.getColId());
			else if (actionEnum === ItemAction.Rename) onNameToggle();
		};
		const onMouseEnter = () => {
			isHovered.value = true;
		};
		const onMouseLeave = () => {
			isHovered.value = false;
		};
		const onDropdownVisibleChange = (visible) => {
			isDropdownOpen.value = visible;
		};
		const checkFilterStatus = () => {
			if (!isFilterable.value) {
				hasActiveFilter.value = false;
				return;
			}
			const columnId = props.params.column.getColId();
			const filterModel = props.params.api.getFilterModel();
			hasActiveFilter.value = filterModel && Boolean(filterModel[columnId]);
		};
		const checkSortStatus = () => {
			currentSort.value = props.params.column.getSort() ?? null;
		};
		const isMenuButtonVisible = computed(() => {
			return props.params.allowMenuActions && (isHovered.value || isDropdownOpen.value || isFilterOpen.value || hasActiveFilter.value);
		});
		const isFilterButtonVisible = computed(() => {
			if (!isFilterable.value) return false;
			return isHovered.value || isDropdownOpen.value || isFilterOpen.value || hasActiveFilter.value;
		});
		const typeIcon = computed(() => {
			if (!shouldShowTypeIcon.value) return null;
			const cellDataType = props.params.column.getColDef().cellDataType;
			if (!isAGGridCellType(cellDataType)) return null;
			return getIconForType(mapToDataTableColumnType(cellDataType));
		});
		const isSystemColumn = computed(() => {
			const columnId = props.params.column.getColId();
			return DATA_TABLE_SYSTEM_COLUMNS.includes(columnId);
		});
		const columnWidth = computed(() => {
			const calculatedWidth = (props.params.displayName || "").length * CHAR_WIDTH_PX + PADDING_PX;
			return Math.min(Math.max(calculatedWidth, MIN_WIDTH_PX), MAX_WIDTH_PX);
		});
		const columnActionItems = computed(() => {
			const items = [];
			items.push({
				id: ItemAction.Rename,
				label: i18n.baseText("dataTable.renameColumn.label"),
				icon: "pen",
				customClass: "data-table-column-header-action-item"
			});
			items.push({
				id: ItemAction.Delete,
				label: i18n.baseText("dataTable.deleteColumn.confirm.title"),
				icon: "trash-2",
				customClass: "data-table-column-header-action-item"
			});
			return items;
		});
		const isSortable = computed(() => {
			return props.params.column.getColDef().sortable;
		});
		const showSortIndicator = computed(() => {
			return isSortable.value && Boolean(currentSort.value);
		});
		const onHeaderClick = () => {
			if (isSortable.value) {
				const currentSortDirection = currentSort.value;
				let nextSort = null;
				if (!currentSortDirection) nextSort = "asc";
				else if (currentSortDirection === "asc") nextSort = "desc";
				props.params.setSort(nextSort, false);
			}
		};
		const onShowFilter = (e) => {
			e.stopPropagation();
			isFilterOpen.value = true;
			props.params.showFilter(e.currentTarget);
		};
		const onFilterClosed = () => {
			isFilterOpen.value = false;
		};
		onMounted(() => {
			checkFilterStatus();
			checkSortStatus();
			props.params.api.addEventListener("filterChanged", checkFilterStatus);
			props.params.api.addEventListener("sortChanged", checkSortStatus);
			props.params.api.addEventListener("filterClosed", onFilterClosed);
		});
		onUnmounted(() => {
			props.params.api.removeEventListener("filterChanged", checkFilterStatus);
			props.params.api.removeEventListener("sortChanged", checkSortStatus);
			props.params.api.removeEventListener("filterClosed", onFilterClosed);
		});
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", {
				class: normalizeClass([
					"ag-header-cell-label",
					"data-table-column-header-wrapper",
					{ sortable: isSortable.value }
				]),
				"data-test-id": "data-table-column-header",
				onMouseenter: onMouseEnter,
				onMouseleave: onMouseLeave,
				onClick: onHeaderClick
			}, [
				createBaseVNode("div", _hoisted_1$3, [
					typeIcon.value ? (openBlock(), createBlock(unref(N8nIcon_default), {
						key: 0,
						icon: typeIcon.value
					}, null, 8, ["icon"])) : createCommentVNode("", true),
					!isSystemColumn.value ? (openBlock(), createBlock(unref(N8nInlineTextEdit_default), {
						key: 1,
						ref_key: "renameInput",
						ref: renameInput,
						"model-value": props.params.displayName,
						"max-width": columnWidth.value,
						"read-only": false,
						disabled: false,
						class: "ag-header-cell-text",
						"data-test-id": "data-table-column-header-text",
						"onUpdate:modelValue": onNameSubmit,
						onClick: onNameToggle,
						onKeydown: _cache[0] || (_cache[0] = withModifiers(() => {}, ["stop"]))
					}, null, 8, ["model-value", "max-width"])) : (openBlock(), createElementBlock("span", _hoisted_2$2, toDisplayString(props.params.displayName), 1)),
					showSortIndicator.value ? (openBlock(), createElementBlock("div", _hoisted_3$1, [currentSort.value === "asc" ? (openBlock(), createBlock(unref(N8nIcon_default), {
						key: 0,
						icon: "arrow-up",
						class: "sort-icon-active"
					})) : currentSort.value === "desc" ? (openBlock(), createBlock(unref(N8nIcon_default), {
						key: 1,
						icon: "arrow-down",
						class: "sort-icon-active"
					})) : createCommentVNode("", true)])) : createCommentVNode("", true)
				]),
				withDirectives(createVNode(unref(N8nIconButton_default), {
					"data-test-id": "data-table-column-header-filter-button",
					icon: "funnel",
					type: "tertiary",
					text: "",
					class: normalizeClass({ "filter-highlighted": hasActiveFilter.value }),
					onClick: onShowFilter
				}, null, 8, ["class"]), [[vShow, isFilterButtonVisible.value]]),
				withDirectives(createVNode(unref(N8nActionDropdown_default), {
					"data-test-id": "data-table-column-header-actions",
					items: columnActionItems.value,
					placement: "bottom-start",
					"activator-icon": "ellipsis",
					onSelect: onItemClick,
					onVisibleChange: onDropdownVisibleChange,
					onClick: _cache[1] || (_cache[1] = withModifiers(() => {}, ["stop"]))
				}, null, 8, ["items"]), [[vShow, isMenuButtonVisible.value]])
			], 34);
		};
	}
});
const parseLooseDateInput = (text) => {
	const trimmed = text.trim();
	const m = LOOSE_DATE_REGEX.exec(trimmed);
	if (!m) return null;
	const y = Number(m[1]);
	const mo = Number(m[2]);
	const d = Number(m[3]);
	const hh = m[4] !== void 0 ? Number(m[4]) : 0;
	const mm = m[5] !== void 0 ? Number(m[5]) : 0;
	const ss = m[6] !== void 0 ? Number(m[6]) : 0;
	const dt = new Date(y, mo - 1, d, hh, mm, ss, 0);
	if (dt.getFullYear() !== y || dt.getMonth() !== mo - 1 || dt.getDate() !== d || dt.getHours() !== hh || dt.getMinutes() !== mm || dt.getSeconds() !== ss) return null;
	return dt;
};
const areValuesEqual = (oldValue, newValue, type) => {
	if (type && type === "date") {
		if (oldValue instanceof Date && newValue instanceof Date) return oldValue.getTime() === newValue.getTime();
	}
	return oldValue === newValue;
};
const useDatePickerCommon = (callbacks = {}) => {
	const pickerRef = useTemplateRef("pickerRef");
	const wrapperRef = useTemplateRef("wrapperRef");
	const dateValue = ref(null);
	const initialValue = ref(null);
	const getInnerInput = () => {
		if (!(wrapperRef.value instanceof HTMLElement)) return null;
		return wrapperRef.value.querySelector("input") ?? null;
	};
	const commitIfParsedFromInput = (target) => {
		const parsed = parseLooseDateInput((target instanceof HTMLInputElement ? target : null)?.value ?? "");
		if (parsed) {
			dateValue.value = parsed;
			callbacks.onCommit?.();
			return true;
		}
		return false;
	};
	const onKeydown = (e) => {
		if (e.key === "Escape") {
			e.stopPropagation();
			dateValue.value = initialValue.value;
			callbacks.onCancel?.();
			return;
		}
		if (e.key === "Enter") {
			if (commitIfParsedFromInput(e.target)) {
				e.preventDefault();
				e.stopPropagation();
			}
		}
	};
	const onClear = () => {
		dateValue.value = null;
		callbacks.onCommit?.();
	};
	const onDateChange = () => {
		callbacks.onChange?.();
	};
	const focusPicker = async () => {
		await nextTick();
		if (isFocusableEl(pickerRef.value)) pickerRef.value.focus();
	};
	const getDate = () => {
		const parsed = parseLooseDateInput(getInnerInput()?.value ?? "");
		if (parsed) return parsed;
		return dateValue.value;
	};
	const setDate = (date) => {
		dateValue.value = date;
		initialValue.value = date;
	};
	const initializeValue = (value) => {
		if (value === null || value === void 0) dateValue.value = null;
		else if (value instanceof Date) dateValue.value = value;
		initialValue.value = dateValue.value;
	};
	return {
		pickerRef,
		wrapperRef,
		dateValue,
		initialValue,
		getInnerInput,
		commitIfParsedFromInput,
		onKeydown,
		onClear,
		onDateChange,
		focusPicker,
		getDate,
		setDate,
		initializeValue
	};
};
var ElDatePickerCellEditor_default = /* @__PURE__ */ defineComponent({
	__name: "ElDatePickerCellEditor",
	props: { params: {} },
	setup(__props, { expose: __expose }) {
		const props = __props;
		const inputWidth = ref(props.params.column.getActualWidth() - 4);
		const { pickerRef, wrapperRef, dateValue, onKeydown, onClear, onDateChange, focusPicker, getDate, initializeValue } = useDatePickerCommon({
			onCommit: () => props.params.stopEditing(),
			onCancel: () => props.params.stopEditing(),
			onChange: () => props.params.stopEditing()
		});
		const dateValueComputed = computed({
			get: () => dateValue.value ?? void 0,
			set: (val) => {
				dateValue.value = val ?? null;
			}
		});
		onMounted(async () => {
			initializeValue(props.params.value);
			await focusPicker();
		});
		__expose({
			getValue: getDate,
			isPopup: () => true
		});
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", {
				ref_key: "wrapperRef",
				ref: wrapperRef,
				class: "data-table-datepicker-wrapper"
			}, [createVNode(unref(ElDatePicker), {
				id: "data-table-datepicker",
				ref_key: "pickerRef",
				ref: pickerRef,
				modelValue: dateValueComputed.value,
				"onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => dateValueComputed.value = $event),
				type: "datetime",
				style: normalizeStyle({ width: `${inputWidth.value}px` }),
				clearable: true,
				editable: true,
				teleported: false,
				"popper-class": "ag-custom-component-popup data-table-datepicker-popper",
				placeholder: "YYYY-MM-DD (HH:mm:ss)",
				size: "small",
				onChange: unref(onDateChange),
				onClear: unref(onClear),
				onKeydown: unref(onKeydown)
			}, null, 8, [
				"modelValue",
				"style",
				"onChange",
				"onClear",
				"onKeydown"
			])], 512);
		};
	}
});
var ElDatePickerFilter_default = /* @__PURE__ */ defineComponent({
	__name: "ElDatePickerFilter",
	props: { params: {} },
	setup(__props, { expose: __expose }) {
		const props = __props;
		const { pickerRef, wrapperRef, dateValue, onKeydown, onClear, onDateChange, focusPicker, getDate, setDate } = useDatePickerCommon({
			onCommit: () => props.params.onDateChanged(),
			onCancel: () => {
				dateValue.value = null;
				props.params.onDateChanged();
			},
			onChange: () => props.params.onDateChanged()
		});
		const dateValueComputed = computed({
			get: () => dateValue.value ?? void 0,
			set: (val) => {
				dateValue.value = val ?? null;
			}
		});
		onMounted(async () => {
			await focusPicker();
		});
		__expose({
			getDate,
			setDate
		});
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", {
				ref_key: "wrapperRef",
				ref: wrapperRef,
				class: "data-table-date-filter-wrapper"
			}, [createVNode(unref(ElDatePicker), {
				ref_key: "pickerRef",
				ref: pickerRef,
				modelValue: dateValueComputed.value,
				"onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => dateValueComputed.value = $event),
				type: "datetime",
				clearable: true,
				editable: true,
				teleported: true,
				placement: "bottom",
				"popper-class": "ag-custom-component-popup data-table-date-filter-popper",
				placeholder: "YYYY-MM-DD (HH:mm:ss)",
				size: "small",
				onChange: unref(onDateChange),
				onClear: unref(onClear),
				onKeydown: unref(onKeydown)
			}, null, 8, [
				"modelValue",
				"onChange",
				"onClear",
				"onKeydown"
			])], 512);
		};
	}
});
var import_orderBy = /* @__PURE__ */ __toESM(require_orderBy());
var _hoisted_1$2 = { class: "add-column-header-component-wrapper" };
var _hoisted_2$1 = {
	class: "add-ds-column-header-popover-content",
	"data-test-id": "add-column-popover-content"
};
var _hoisted_3 = { class: "popover-body" };
var _hoisted_4 = {
	key: 0,
	class: "error-message"
};
var _hoisted_5 = { class: "add-column-option-content" };
var AddColumnButton_default = /* @__PURE__ */ defineComponent({
	__name: "AddColumnButton",
	props: {
		params: {},
		popoverId: {},
		useTextTrigger: { type: Boolean }
	},
	setup(__props) {
		const props = __props;
		const i18n = useI18n();
		const { getIconForType } = useDataTableTypes();
		const { debounce } = useDebounce();
		const nameInputRef = ref(null);
		const columnName = ref("");
		const columnType = ref("string");
		const columnTypes = [...DATA_TABLE_COLUMN_TYPES];
		const error = ref(null);
		const popoverOpen = ref(false);
		const isSelectOpen = ref(false);
		const popoverId = computed(() => props.popoverId ?? "add-column-popover");
		const columnTypeOptions = computed(() => {
			return columnTypes.map((type) => ({
				label: type === "date" ? "datetime" : type,
				value: type
			}));
		});
		const onAddButtonClicked = async () => {
			validateName();
			if (!columnName.value || !columnType.value || error.value) return;
			const response = await props.params.onAddColumn({
				name: columnName.value,
				type: columnType.value
			});
			if (!response.success) {
				let errorMessage = i18n.baseText("dataTable.addColumn.error");
				let errorDescription = response.errorMessage;
				if (response.httpStatus === 409) {
					errorMessage = i18n.baseText("dataTable.column.alreadyExistsError", { interpolate: { name: columnName.value } });
					errorDescription = response.errorMessage?.includes("system") ? i18n.baseText("dataTable.addColumn.systemColumnDescription") : response.errorMessage?.includes("testing") ? i18n.baseText("dataTable.addColumn.testingColumnDescription") : i18n.baseText("dataTable.addColumn.alreadyExistsDescription");
				}
				error.value = {
					message: errorMessage,
					description: errorDescription
				};
				return;
			}
			columnName.value = "";
			columnType.value = "string";
			popoverOpen.value = false;
		};
		const handlePopoverOpenChange = async (open) => {
			if (!open && isSelectOpen.value) return;
			popoverOpen.value = open;
			if (open) await nextTick(() => {
				nameInputRef.value?.focus();
			});
		};
		const validateName = () => {
			if (error.value) error.value = null;
			if (columnName.value && !COLUMN_NAME_REGEX.test(columnName.value)) error.value = {
				message: i18n.baseText("dataTable.addColumn.invalidName.error"),
				description: i18n.baseText("dataTable.addColumn.invalidName.description")
			};
		};
		const onInput = debounce(validateName, { debounceTime: 100 });
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(N8nTooltip_default), {
				disabled: popoverOpen.value,
				content: unref(i18n).baseText("dataTable.addColumn.label")
			}, {
				default: withCtx(() => [createBaseVNode("div", _hoisted_1$2, [createVNode(unref(N8nPopoverReka_default), {
					id: popoverId.value,
					open: popoverOpen.value,
					"popper-options": { strategy: "fixed" },
					"show-arrow": false,
					"onUpdate:open": handlePopoverOpenChange
				}, {
					trigger: withCtx(() => [props.useTextTrigger ? (openBlock(), createBlock(unref(N8nButton_default), {
						key: 0,
						"data-test-id": "data-table-add-column-trigger-button",
						type: "tertiary"
					}, {
						default: withCtx(() => [createTextVNode(toDisplayString(unref(i18n).baseText("dataTable.addColumn.label")), 1)]),
						_: 1
					})) : (openBlock(), createBlock(unref(N8nIconButton_default), {
						key: 1,
						"data-test-id": "data-table-add-column-trigger-button",
						text: "",
						icon: "plus",
						type: "tertiary"
					}))]),
					content: withCtx(() => [createBaseVNode("div", _hoisted_2$1, [createBaseVNode("div", _hoisted_3, [
						createVNode(unref(N8nInputLabel_default), {
							label: unref(i18n).baseText("dataTable.addColumn.nameInput.label"),
							required: true,
							class: normalizeClass(error.value ? "" : "mb-s")
						}, {
							default: withCtx(() => [createVNode(unref(N8nInput_default), {
								ref_key: "nameInputRef",
								ref: nameInputRef,
								modelValue: columnName.value,
								"onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => columnName.value = $event),
								placeholder: unref(i18n).baseText("dataTable.addColumn.nameInput.placeholder"),
								maxlength: unref(128),
								"data-test-id": "add-column-name-input",
								onKeyup: withKeys(onAddButtonClicked, ["enter"]),
								onInput: unref(onInput)
							}, null, 8, [
								"modelValue",
								"placeholder",
								"maxlength",
								"onInput"
							]), error.value ? (openBlock(), createElementBlock("div", _hoisted_4, [error.value.message ? (openBlock(), createBlock(unref(N8nText_default), {
								key: 0,
								size: "small",
								color: "danger",
								tag: "span"
							}, {
								default: withCtx(() => [createTextVNode(toDisplayString(error.value.message), 1)]),
								_: 1
							})) : createCommentVNode("", true), createVNode(unref(N8nTooltip_default), {
								content: error.value.description,
								placement: "top",
								disabled: !error.value.description
							}, {
								default: withCtx(() => [createVNode(unref(N8nIcon_default), {
									icon: "circle-help",
									size: "small",
									class: "error-tooltip",
									color: "text-base",
									"data-test-id": "add-column-error-help-icon"
								})]),
								_: 1
							}, 8, ["content", "disabled"])])) : createCommentVNode("", true)]),
							_: 1
						}, 8, ["label", "class"]),
						createVNode(unref(N8nInputLabel_default), {
							label: unref(i18n).baseText("dataTable.addColumn.typeInput.label"),
							required: true,
							class: "type-label"
						}, {
							default: withCtx(() => [createVNode(unref(N8nSelect_default), {
								modelValue: columnType.value,
								"onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => columnType.value = $event),
								"append-to": `#${popoverId.value}`,
								onVisibleChange: _cache[2] || (_cache[2] = ($event) => isSelectOpen.value = $event)
							}, {
								default: withCtx(() => [(openBlock(true), createElementBlock(Fragment, null, renderList(columnTypeOptions.value, (option) => {
									return openBlock(), createBlock(unref(N8nOption_default), {
										key: option.value,
										label: option.label,
										value: option.value
									}, {
										default: withCtx(() => [createBaseVNode("div", _hoisted_5, [createVNode(unref(N8nIcon_default), { icon: unref(getIconForType)(option.value) }, null, 8, ["icon"]), createVNode(unref(N8nText_default), null, {
											default: withCtx(() => [createTextVNode(toDisplayString(option.label), 1)]),
											_: 2
										}, 1024)])]),
										_: 2
									}, 1032, ["label", "value"]);
								}), 128))]),
								_: 1
							}, 8, ["modelValue", "append-to"])]),
							_: 1
						}, 8, ["label"]),
						createVNode(unref(N8nButton_default), {
							"data-test-id": "data-table-add-column-submit-button",
							type: "primary",
							class: "mt-m",
							size: "large",
							disabled: !columnName.value || !columnType.value || !!error.value,
							onClick: onAddButtonClicked
						}, {
							default: withCtx(() => [createTextVNode(toDisplayString(unref(i18n).baseText("dataTable.addColumn.label")), 1)]),
							_: 1
						}, 8, ["disabled"])
					])])]),
					_: 1
				}, 8, ["id", "open"])])]),
				_: 1
			}, 8, ["disabled", "content"]);
		};
	}
});
var AddRowButton_default = /* @__PURE__ */ defineComponent({
	__name: "AddRowButton",
	props: { params: {} },
	setup(__props) {
		const i18n = useI18n();
		const props = __props;
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(N8nTooltip_default), { content: unref(i18n).baseText("dataTable.addRow.label") }, {
				default: withCtx(() => [createVNode(unref(N8nIconButton_default), {
					text: "",
					type: "tertiary",
					icon: "plus",
					onClick: props.params.onClick
				}, null, 8, ["onClick"])]),
				_: 1
			}, 8, ["content"]);
		};
	}
});
var _hoisted_1$1 = { class: "n8n-empty-value" };
var NullEmptyCellRenderer_default = /* @__PURE__ */ defineComponent({
	__name: "NullEmptyCellRenderer",
	props: { params: {} },
	setup(__props) {
		const props = __props;
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("span", _hoisted_1$1, toDisplayString(props.params.value), 1);
		};
	}
});
const getCellClass = (params) => {
	if (params.data?.id === "__n8n_add_row__") return "add-row-cell";
	if (params.column.getUserProvidedColDef()?.cellDataType === "boolean") return "boolean-cell";
	return "";
};
const createValueGetter = (col) => (params) => {
	if (params.data?.[col.name] === null || params.data?.[col.name] === void 0) return null;
	if (col.type === "date") {
		const value = params.data?.[col.name];
		if (typeof value === "string") return new Date(value);
	}
	return params.data?.[col.name];
};
const createCellRendererSelector = (col) => (params) => {
	if (params.data?.id === "__n8n_add_row__" || col.id === "add-column") return {};
	let rowValue = params.data?.[col.name];
	if (rowValue === void 0) rowValue = null;
	if (rowValue === null) return {
		component: NullEmptyCellRenderer_default,
		params: { value: NULL_VALUE }
	};
	if (rowValue === "") return {
		component: NullEmptyCellRenderer_default,
		params: { value: EMPTY_VALUE }
	};
};
const createStringValueSetter = (col, isTextEditorOpen) => (params) => {
	let originalValue = params.data[col.name];
	if (originalValue === void 0) originalValue = null;
	let newValue = params.newValue;
	if (!isDataTableValue(newValue)) return false;
	if (originalValue === null && newValue === "") return false;
	if (isTextEditorOpen.value && newValue === null) newValue = "";
	params.data[col.name] = newValue;
	return true;
};
const stringCellEditorParams = (params) => ({
	value: params.value ?? "",
	maxLength: 999999999
});
const dateValueFormatter = (params) => {
	const value = params.value;
	if (value === null || value === void 0) return "";
	return DateTime.fromJSDate(value).toISO() ?? "";
};
var numberWithSpaces = (num) => {
	const parts = num.toString().split(".");
	parts[0] = parts[0].replace(NUMBER_WITH_SPACES_REGEX, " ");
	return parts.join(".");
};
const numberValueFormatter = (params) => {
	const value = params.value;
	if (value === null || value === void 0) return "";
	return numberWithSpaces(value);
};
var createNullFilterOption = (i18n) => ({
	displayKey: "null",
	displayName: i18n.baseText("dataTable.filters.isNull"),
	predicate: () => true,
	numberOfInputs: 0
});
var createNotNullFilterOption = (i18n) => ({
	displayKey: "notNull",
	displayName: i18n.baseText("dataTable.filters.isNotNull"),
	predicate: () => true,
	numberOfInputs: 0
});
var createIsEmptyFilterOption = (i18n) => ({
	displayKey: "isEmpty",
	displayName: i18n.baseText("dataTable.filters.isEmpty"),
	predicate: () => true,
	numberOfInputs: 0
});
var createIsNotEmptyFilterOption = (i18n) => ({
	displayKey: "notEmpty",
	displayName: i18n.baseText("dataTable.filters.isNotEmpty"),
	predicate: () => true,
	numberOfInputs: 0
});
var createBetweenFilterOption = (i18n) => ({
	displayKey: "between",
	displayName: i18n.baseText("dataTable.filters.between"),
	predicate: () => true,
	numberOfInputs: 2
});
var createGreaterThanFilterOption = (i18n) => ({
	displayKey: "greaterThan",
	displayName: i18n.baseText("dataTable.filters.greaterThan"),
	predicate: () => true,
	numberOfInputs: 1
});
var createGreaterThanOrEqualFilterOption = (i18n) => ({
	displayKey: "greaterThanOrEqual",
	displayName: i18n.baseText("dataTable.filters.greaterThanOrEqual"),
	predicate: () => true,
	numberOfInputs: 1
});
var createLessThanFilterOption = (i18n) => ({
	displayKey: "lessThan",
	displayName: i18n.baseText("dataTable.filters.lessThan"),
	predicate: () => true,
	numberOfInputs: 1
});
var createLessThanOrEqualFilterOption = (i18n) => ({
	displayKey: "lessThanOrEqual",
	displayName: i18n.baseText("dataTable.filters.lessThanOrEqual"),
	predicate: () => true,
	numberOfInputs: 1
});
var createInRangeFilterOption = (i18n) => ({
	displayKey: "inRange",
	displayName: i18n.baseText("dataTable.filters.between"),
	predicate: () => true,
	numberOfInputs: 2
});
const getStringColumnFilterOptions = (i18n) => [
	"contains",
	"equals",
	"notEqual",
	createIsEmptyFilterOption(i18n),
	createIsNotEmptyFilterOption(i18n),
	createNullFilterOption(i18n),
	createNotNullFilterOption(i18n)
];
const getDateColumnFilterOptions = (i18n) => [
	"equals",
	"notEqual",
	createLessThanFilterOption(i18n),
	createLessThanOrEqualFilterOption(i18n),
	createGreaterThanFilterOption(i18n),
	createGreaterThanOrEqualFilterOption(i18n),
	createInRangeFilterOption(i18n),
	createNullFilterOption(i18n),
	createNotNullFilterOption(i18n)
];
const getNumberColumnFilterOptions = (i18n) => [
	"equals",
	"notEqual",
	createLessThanFilterOption(i18n),
	createLessThanOrEqualFilterOption(i18n),
	createGreaterThanFilterOption(i18n),
	createGreaterThanOrEqualFilterOption(i18n),
	createBetweenFilterOption(i18n),
	createNullFilterOption(i18n),
	createNotNullFilterOption(i18n)
];
const getBooleanColumnFilterOptions = (i18n) => [
	"empty",
	{
		displayKey: "true",
		displayName: i18n.baseText("dataTable.filters.true"),
		numberOfInputs: 0,
		predicate: () => true
	},
	{
		displayKey: "false",
		displayName: i18n.baseText("dataTable.filters.false"),
		numberOfInputs: 0,
		predicate: () => true
	},
	createNullFilterOption(i18n),
	createNotNullFilterOption(i18n)
];
const GRID_FILTER_CONFIG = {
	defaultColDef: {
		filter: true,
		filterParams: {
			maxNumConditions: 1,
			buttons: ["reset"]
		}
	},
	excludedColumns: [
		"id",
		"add-column",
		"ag-Grid-SelectionColumn"
	]
};
var TEXT_TYPE_TO_BACKEND_MAP = {
	contains: "ilike",
	equals: "eq",
	notEqual: "neq",
	startsWith: "ilike",
	endsWith: "ilike",
	isEmpty: "eq",
	notEmpty: "neq",
	null: "eq",
	notNull: "neq",
	true: "eq",
	false: "eq"
};
var NUMBER_DATE_TYPE_TO_BACKEND_MAP = {
	equals: "eq",
	notEqual: "neq",
	lessThan: "lt",
	lessThanOrEqual: "lte",
	greaterThan: "gt",
	greaterThanOrEqual: "gte",
	null: "eq",
	notNull: "neq"
};
function mapTextTypeToBackend(type) {
	const condition = TEXT_TYPE_TO_BACKEND_MAP[type];
	if (!condition) throw new Error(`Unknown text type: ${type}`);
	return condition;
}
function mapNumberDateTypeToBackend(type) {
	const condition = NUMBER_DATE_TYPE_TO_BACKEND_MAP[type];
	if (!condition) throw new Error(`Unknown number/date type: ${type}`);
	return condition;
}
const useDataTableColumns = ({ onDeleteColumn, onRenameColumn, onAddRowClick, onAddColumn, isTextEditorOpen }) => {
	const colDefs = ref([]);
	const { mapToAGCellType } = useDataTableTypes();
	const i18n = useI18n();
	const createColumnDef = (col, extraProps = {}) => {
		const columnDef = {
			colId: col.id,
			field: col.name,
			filter: !GRID_FILTER_CONFIG.excludedColumns.includes(col.id),
			headerName: col.name,
			sortable: true,
			editable: (params) => params.data?.id !== ADD_ROW_ROW_ID,
			resizable: true,
			lockPinned: true,
			headerComponent: ColumnHeader_default,
			headerComponentParams: {
				onDelete: onDeleteColumn,
				onRename: onRenameColumn,
				allowMenuActions: true
			},
			cellEditorPopup: false,
			cellDataType: mapToAGCellType(col.type),
			cellClass: getCellClass,
			valueGetter: createValueGetter(col),
			cellRendererSelector: createCellRendererSelector(col),
			width: 250
		};
		if (col.type === "string") {
			columnDef.cellEditor = "agLargeTextCellEditor";
			columnDef.cellEditorPopup = true;
			columnDef.cellEditorPopupPosition = "over";
			columnDef.cellEditorParams = stringCellEditorParams;
			columnDef.valueSetter = createStringValueSetter(col, isTextEditorOpen);
			columnDef.filterParams = { filterOptions: getStringColumnFilterOptions(i18n) };
		} else if (col.type === "date") {
			columnDef.cellEditorSelector = () => ({ component: ElDatePickerCellEditor_default });
			columnDef.valueFormatter = dateValueFormatter;
			columnDef.cellEditorPopup = true;
			columnDef.dateComponent = ElDatePickerFilter_default;
			columnDef.filterParams = { filterOptions: getDateColumnFilterOptions(i18n) };
		} else if (col.type === "number") {
			columnDef.valueFormatter = numberValueFormatter;
			columnDef.filterParams = { filterOptions: getNumberColumnFilterOptions(i18n) };
		} else if (col.type === "boolean") columnDef.filterParams = { filterOptions: getBooleanColumnFilterOptions(i18n) };
		return {
			...columnDef,
			...extraProps
		};
	};
	const getColumnDefinitions = (dataTableColumns) => {
		const systemDateColumnOptions = {
			editable: false,
			suppressMovable: true,
			lockPinned: true,
			lockPosition: "right",
			headerComponentParams: { allowMenuActions: false },
			cellClass: (params) => params.data?.id === "__n8n_add_row__" ? "add-row-cell" : "system-cell",
			headerClass: "system-column",
			width: 250
		};
		return [
			createColumnDef({
				index: 0,
				id: "id",
				name: "id",
				type: "string"
			}, {
				editable: false,
				sortable: true,
				suppressMovable: true,
				lockPosition: true,
				minWidth: 60,
				maxWidth: 60,
				resizable: false,
				headerClass: "system-column",
				headerComponentParams: {
					allowMenuActions: false,
					showTypeIcon: false
				},
				cellClass: (params) => params.data?.id === "__n8n_add_row__" ? "add-row-cell" : "id-column",
				cellRendererSelector: (params) => {
					if (params.value === "__n8n_add_row__") return {
						component: AddRowButton_default,
						params: { onClick: onAddRowClick }
					};
				}
			}),
			...(0, import_orderBy.default)(dataTableColumns, "index").map((col) => createColumnDef(col)),
			createColumnDef({
				index: dataTableColumns.length + 1,
				id: "createdAt",
				name: "createdAt",
				type: "date"
			}, systemDateColumnOptions),
			createColumnDef({
				index: dataTableColumns.length + 2,
				id: "updatedAt",
				name: "updatedAt",
				type: "date"
			}, systemDateColumnOptions),
			createColumnDef({
				index: dataTableColumns.length + 3,
				id: "add-column",
				name: "Add Column",
				type: "string"
			}, {
				editable: false,
				suppressMovable: true,
				lockPinned: true,
				lockPosition: "right",
				resizable: false,
				flex: 1,
				headerComponent: AddColumnButton_default,
				headerComponentParams: { onAddColumn }
			})
		];
	};
	const loadColumns = (dataTableColumns) => {
		colDefs.value = getColumnDefinitions(dataTableColumns);
	};
	const deleteColumn = (columnId) => {
		colDefs.value = colDefs.value.filter((col) => col.colId !== columnId);
	};
	const insertColumnAtIndex = (column, index) => {
		colDefs.value.splice(index, 0, column);
	};
	const addColumn = (column) => {
		colDefs.value = [
			...colDefs.value.slice(0, -1),
			createColumnDef(column),
			...colDefs.value.slice(-1)
		];
	};
	const moveColumn = (oldIndex, newIndex) => {
		const fromIndex = oldIndex - 1;
		if (!colDefs.value[fromIndex]) return;
		const reorderedMiddle = reorderItem(colDefs.value.slice(1, -1).map((col, idx) => ({
			column: col,
			index: idx
		})), fromIndex, newIndex).sort((a, b) => a.index - b.index).map(({ column }) => column);
		colDefs.value = [
			colDefs.value[0],
			...reorderedMiddle,
			colDefs.value[colDefs.value.length - 1]
		];
	};
	return {
		colDefs,
		createColumnDef,
		loadColumns,
		deleteColumn,
		insertColumnAtIndex,
		addColumn,
		moveColumn
	};
};
const useDataTableSelection = ({ gridApi }) => {
	const selectedRowIds = ref(/* @__PURE__ */ new Set());
	const selectedCount = computed(() => selectedRowIds.value.size);
	const rowSelection = {
		mode: "multiRow",
		enableClickSelection: false,
		checkboxes: (params) => params.data?.id !== ADD_ROW_ROW_ID,
		isRowSelectable: (params) => params.data?.id !== ADD_ROW_ROW_ID
	};
	const onSelectionChanged = () => {
		const selectedNodes = gridApi.value.getSelectedNodes();
		const newSelectedIds = /* @__PURE__ */ new Set();
		selectedNodes.forEach((node) => {
			if (typeof node.data?.id === "number") newSelectedIds.add(node.data.id);
		});
		selectedRowIds.value = newSelectedIds;
	};
	const handleClearSelection = () => {
		selectedRowIds.value = /* @__PURE__ */ new Set();
		gridApi.value.deselectAll();
	};
	return {
		selectedRowIds,
		selectedCount,
		rowSelection,
		onSelectionChanged,
		handleClearSelection
	};
};
const useDataTableOperations = ({ colDefs, rowData, deleteGridColumn, addGridColumn, setGridData, insertGridColumnAtIndex, moveGridColumn, dataTableId, projectId, gridApi, totalItems, setTotalItems, ensureItemOnPage, focusFirstEditableCell, toggleSave, currentPage, pageSize, currentSortBy, currentSortOrder, currentFilterJSON, searchQuery, handleClearSelection, selectedRowIds, handleCopyFocusedCell }) => {
	const i18n = useI18n();
	const toast = useToast();
	const message = useMessage();
	const dataTableStore = useDataTableStore();
	const contentLoading = ref(false);
	const telemetry$1 = useTelemetry();
	const dataTableTypes = useDataTableTypes();
	const parseColumnOperationError = (error) => {
		const DEFAULT_HTTP_STATUS = 500;
		const DEFAULT_MESSAGE = i18n.baseText("generic.unknownError");
		if (error instanceof ResponseError) return {
			httpStatus: error.httpStatusCode ?? 500,
			message: error.message
		};
		if (error instanceof Error) return {
			httpStatus: DEFAULT_HTTP_STATUS,
			message: error.message
		};
		return {
			httpStatus: DEFAULT_HTTP_STATUS,
			message: DEFAULT_MESSAGE
		};
	};
	async function onDeleteColumn(columnId) {
		const columnToDelete = colDefs.value.find((col) => col.colId === columnId);
		if (!columnToDelete) return;
		if (await message.confirm(i18n.baseText("dataTable.deleteColumn.confirm.message", { interpolate: { name: columnToDelete.headerName ?? "" } }), i18n.baseText("dataTable.deleteColumn.confirm.title"), {
			confirmButtonText: i18n.baseText("generic.delete"),
			cancelButtonText: i18n.baseText("generic.cancel")
		}) !== "confirm") return;
		const columnToDeleteIndex = colDefs.value.findIndex((col) => col.colId === columnId);
		deleteGridColumn(columnId);
		const rowDataOldValue = [...rowData.value];
		rowData.value = rowData.value.map((row) => {
			const { [columnToDelete.field]: _,...rest } = row;
			return rest;
		});
		setGridData({
			colDefs: colDefs.value,
			rowData: rowData.value
		});
		try {
			await dataTableStore.deleteDataTableColumn(dataTableId, projectId, columnId);
			telemetry$1.track("User deleted data table column", {
				column_id: columnId,
				column_type: columnToDelete.cellDataType,
				data_table_id: dataTableId
			});
		} catch (error) {
			toast.showError(error, i18n.baseText("dataTable.deleteColumn.error"));
			insertGridColumnAtIndex(columnToDelete, columnToDeleteIndex);
			rowData.value = rowDataOldValue;
			setGridData({
				colDefs: colDefs.value,
				rowData: rowData.value
			});
		}
	}
	async function onRenameColumn(columnId, newName) {
		const columnToRename = colDefs.value.find((col) => col.colId === columnId);
		if (!columnToRename) return;
		const oldName = columnToRename.headerName;
		const oldField = columnToRename.field;
		if (!oldField) return;
		columnToRename.headerName = newName;
		setGridData({ colDefs: colDefs.value });
		try {
			toggleSave(true);
			await dataTableStore.renameDataTableColumn(dataTableId, projectId, columnId, newName);
			columnToRename.field = newName;
			if (oldField !== newName) rowData.value = rowData.value.map((row) => {
				const newRow = { ...row };
				newRow[newName] = newRow[oldField];
				delete newRow[oldField];
				return newRow;
			});
			setGridData({
				colDefs: colDefs.value,
				rowData: rowData.value
			});
			telemetry$1.track("User renamed data table column", {
				column_id: columnId,
				column_type: columnToRename.cellDataType,
				data_table_id: dataTableId
			});
		} catch (error) {
			columnToRename.headerName = oldName;
			setGridData({ colDefs: colDefs.value });
			const errorDetails = parseColumnOperationError(error);
			if (errorDetails.httpStatus === 409) toast.showError(new Error(errorDetails.message), i18n.baseText("dataTable.column.alreadyExistsError"));
			else toast.showError(error, i18n.baseText("dataTable.renameColumn.error"));
		} finally {
			toggleSave(false);
		}
	}
	async function onAddColumn(column) {
		try {
			const newColumn = await dataTableStore.addDataTableColumn(dataTableId, projectId, column);
			addGridColumn(newColumn);
			rowData.value = rowData.value.map((row) => {
				return {
					...row,
					[newColumn.name]: null
				};
			});
			setGridData({
				colDefs: colDefs.value,
				rowData: rowData.value
			});
			telemetry$1.track("User added data table column", {
				column_id: newColumn.id,
				column_type: newColumn.type,
				data_table_id: dataTableId
			});
			return {
				success: true,
				httpStatus: 200
			};
		} catch (error) {
			const addColumnError = parseColumnOperationError(error);
			return {
				success: false,
				httpStatus: addColumnError.httpStatus,
				errorMessage: addColumnError.message
			};
		}
	}
	const onColumnMoved = async (moveEvent) => {
		if (!moveEvent.finished || moveEvent.source !== "uiColumnMoved" || moveEvent.toIndex === void 0 || !moveEvent.column) return;
		const oldIndex = colDefs.value.findIndex((col) => col.colId === moveEvent.column.getColId());
		const newIndex = moveEvent.toIndex - 2;
		try {
			await dataTableStore.moveDataTableColumn(dataTableId, projectId, moveEvent.column.getColId(), newIndex);
			moveGridColumn(oldIndex, newIndex);
		} catch (error) {
			toast.showError(error, i18n.baseText("dataTable.moveColumn.error"));
			gridApi.value.moveColumnByIndex(moveEvent.toIndex, oldIndex + 1);
		}
	};
	async function onAddRowClick() {
		try {
			await ensureItemOnPage(totalItems.value + 1);
			contentLoading.value = true;
			toggleSave(true);
			const newRow = await dataTableStore.insertEmptyRow(dataTableId, projectId);
			rowData.value.push(newRow);
			setTotalItems(totalItems.value + 1);
			setGridData({ rowData: rowData.value });
			focusFirstEditableCell(newRow.id);
			telemetry$1.track("User added row to data table", { data_table_id: dataTableId });
		} catch (error) {
			toast.showError(error, i18n.baseText("dataTable.addRow.error"));
		} finally {
			toggleSave(false);
			contentLoading.value = false;
		}
	}
	const onCellValueChanged = async (params) => {
		const { data, api, oldValue, colDef } = params;
		const fieldName = String(colDef.field ?? "");
		if (!fieldName) return;
		const value = params.data[fieldName];
		const cellType = isAGGridCellType(colDef.cellDataType) ? dataTableTypes.mapToDataTableColumnType(colDef.cellDataType) : void 0;
		if (value === void 0 || areValuesEqual(oldValue, value, cellType)) return;
		if (typeof data.id !== "number") throw new Error("Expected row id to be a number");
		const id = data.id;
		try {
			toggleSave(true);
			await dataTableStore.updateRow(dataTableId, projectId, id, { [fieldName]: value });
			telemetry$1.track("User edited data table content", {
				data_table_id: dataTableId,
				column_id: colDef.colId,
				column_type: colDef.cellDataType
			});
		} catch (error) {
			const validOldValue = isDataTableValue(oldValue) ? oldValue : null;
			const revertedData = {
				...data,
				[fieldName]: validOldValue
			};
			api.applyTransaction({ update: [revertedData] });
			toast.showError(error, i18n.baseText("dataTable.updateRow.error"));
		} finally {
			toggleSave(false);
		}
	};
	async function fetchDataTableRows() {
		try {
			contentLoading.value = true;
			const fetchedRows = await dataTableStore.fetchDataTableContent(dataTableId, projectId, currentPage.value, pageSize.value, `${currentSortBy.value}:${currentSortOrder.value}`, currentFilterJSON?.value, searchQuery?.value);
			rowData.value = fetchedRows.data;
			setTotalItems(fetchedRows.count);
			setGridData({ rowData: rowData.value });
			handleClearSelection();
		} catch (error) {
			toast.showError(error, i18n.baseText("dataTable.fetchContent.error"));
		} finally {
			contentLoading.value = false;
		}
	}
	const handleDeleteSelected = async () => {
		if (selectedRowIds.value.size === 0) return;
		if (await message.confirm(i18n.baseText("dataTable.deleteRows.confirmation", {
			adjustToNumber: selectedRowIds.value.size,
			interpolate: { count: selectedRowIds.value.size }
		}), i18n.baseText("dataTable.deleteRows.title"), {
			confirmButtonText: i18n.baseText("generic.delete"),
			cancelButtonText: i18n.baseText("generic.cancel")
		}) !== "confirm") return;
		try {
			toggleSave(true);
			const idsToDelete = Array.from(selectedRowIds.value);
			await dataTableStore.deleteRows(dataTableId, projectId, idsToDelete);
			await fetchDataTableRows();
			telemetry$1.track("User deleted rows in data table", {
				data_table_id: dataTableId,
				deleted_row_count: idsToDelete.length
			});
		} catch (error) {
			toast.showError(error, i18n.baseText("dataTable.deleteRows.error"));
		} finally {
			toggleSave(false);
		}
	};
	const onCellKeyDown = async (params) => {
		const event = params.event;
		const target = event.target;
		const isSelectionColumn = params.column.getColId() === "ag-Grid-SelectionColumn";
		if (params.api.getEditingCells().length > 0 || target instanceof HTMLInputElement && !isSelectionColumn) return;
		if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === "c") {
			event.preventDefault();
			await handleCopyFocusedCell(params);
			return;
		}
		if (event.key === "Escape") {
			handleClearSelection();
			return;
		}
		if (event.key !== "Delete" && event.key !== "Backspace" || selectedRowIds.value.size === 0) return;
		event.preventDefault();
		await handleDeleteSelected();
	};
	return {
		onDeleteColumn,
		onRenameColumn,
		onAddColumn,
		onColumnMoved,
		onAddRowClick,
		contentLoading,
		onCellValueChanged,
		fetchDataTableRows,
		handleDeleteSelected,
		onCellKeyDown
	};
};
function processTextFilter(filter, colField) {
	let value = filter.filter ?? null;
	if (typeof filter.filter === "string") {
		if (filter.type === "startsWith") value = `${filter.filter}%`;
		else if (filter.type === "endsWith") value = `%${filter.filter}`;
		else if (filter.type === "contains") value = filter.filter;
	} else if (filter.type === "isEmpty" || filter.type === "notEmpty") value = "";
	else if (filter.type === "null" || filter.type === "notNull") value = null;
	else if (filter.type === "true") value = true;
	else if (filter.type === "false") value = false;
	return {
		columnName: colField,
		condition: mapTextTypeToBackend(filter.type),
		value
	};
}
function processNumberFilter(filter, colField) {
	let value = filter.filter ?? null;
	if (filter.type === "between") return [{
		columnName: colField,
		condition: "gte",
		value: filter.filter ?? null
	}, {
		columnName: colField,
		condition: "lte",
		value: filter.filterTo ?? null
	}];
	if (filter.type === "null" || filter.type === "notNull") value = null;
	return [{
		columnName: colField,
		condition: mapNumberDateTypeToBackend(filter.type),
		value
	}];
}
function processDateFilter(filter, colField) {
	const filters = [];
	let value = filter.filter ?? null;
	if (filter.type === "null" || filter.type === "notNull") {
		value = null;
		filters.push({
			columnName: colField,
			condition: mapNumberDateTypeToBackend(filter.type),
			value
		});
	} else {
		if (filter.dateFrom) value = new Date(String(filter.dateFrom)).toISOString();
		if (filter.type === "inRange") {
			if (filter.dateFrom && filter.dateTo) {
				const fromIso = new Date(String(filter.dateFrom)).toISOString();
				const toIso = new Date(String(filter.dateTo)).toISOString();
				filters.push({
					columnName: colField,
					condition: "gte",
					value: fromIso
				});
				filters.push({
					columnName: colField,
					condition: "lte",
					value: toIso
				});
			}
		} else filters.push({
			columnName: colField,
			condition: mapNumberDateTypeToBackend(filter.type),
			value
		});
	}
	return filters;
}
const useDataTableColumnFilters = ({ gridApi, colDefs }) => {
	const currentFilterJSON = ref(void 0);
	function convertAgModelToBackend(model, defs) {
		const allFilters = [];
		const colIdToField = /* @__PURE__ */ new Map();
		defs.forEach((d) => {
			if (d.colId && d.field) colIdToField.set(d.colId, d.field);
			else if (d.field) colIdToField.set(d.field, d.field);
		});
		for (const [key, filter] of Object.entries(model)) {
			const colField = colIdToField.get(key) ?? key;
			if (!(filter.filterType || filter.type)) continue;
			switch (filter.filterType) {
				case "text":
					allFilters.push(processTextFilter(filter, colField));
					break;
				case "number":
					allFilters.push(...processNumberFilter(filter, colField));
					break;
				case "date":
					allFilters.push(...processDateFilter(filter, colField));
					break;
				default: break;
			}
		}
		if (allFilters.length === 0) return void 0;
		return {
			type: "and",
			filters: allFilters
		};
	}
	const onFilterChanged$1 = () => {
		const backend = convertAgModelToBackend(gridApi.value.getFilterModel(), colDefs.value);
		currentFilterJSON.value = backend ? JSON.stringify(backend) : void 0;
	};
	return {
		onFilterChanged: onFilterChanged$1,
		currentFilterJSON,
		hasActiveFilters: computed(() => Boolean(currentFilterJSON.value))
	};
};
var DataTableTable_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "DataTableTable",
	props: {
		dataTable: {},
		search: {}
	},
	emits: ["toggleSave"],
	setup(__props, { expose: __expose, emit: __emit }) {
		registerAgGridModulesOnce();
		const props = __props;
		const emit = __emit;
		const gridContainerRef = useTemplateRef("gridContainerRef");
		const i18n = useI18n();
		const { debounce } = useDebounce();
		const rowData = ref([]);
		const hasRecords = computed(() => rowData.value.length > 0);
		const agGrid = useAgGrid({
			gridContainerRef,
			defaultSortColumn: "id",
			pinnedBottomRowId: ADD_ROW_ROW_ID,
			defaultColDef: GRID_FILTER_CONFIG.defaultColDef
		});
		const dataTableColumns = useDataTableColumns({
			onDeleteColumn: onDeleteColumnFunction,
			onRenameColumn: onRenameColumnFunction,
			onAddRowClick: onAddRowClickFunction,
			onAddColumn: onAddColumnFunction,
			isTextEditorOpen: agGrid.isTextEditorOpen
		});
		const { onFilterChanged: onFilterChanged$1, currentFilterJSON } = useDataTableColumnFilters({
			gridApi: agGrid.gridApi,
			colDefs: dataTableColumns.colDefs
		});
		const { currentPage, pageSize, totalItems, pageSizeOptions, ensureItemOnPage, setTotalItems, setCurrentPage, setPageSize } = useDataTablePagination({ onChange: fetchDataTableRowsFunction });
		const selection = useDataTableSelection({ gridApi: agGrid.gridApi });
		const dataTableOperations = useDataTableOperations({
			colDefs: dataTableColumns.colDefs,
			rowData,
			deleteGridColumn: dataTableColumns.deleteColumn,
			setGridData: agGrid.setGridData,
			insertGridColumnAtIndex: dataTableColumns.insertColumnAtIndex,
			dataTableId: props.dataTable.id,
			projectId: props.dataTable.projectId,
			addGridColumn: dataTableColumns.addColumn,
			moveGridColumn: dataTableColumns.moveColumn,
			gridApi: agGrid.gridApi,
			totalItems,
			setTotalItems,
			ensureItemOnPage,
			focusFirstEditableCell: agGrid.focusFirstEditableCell,
			toggleSave: emit.bind(null, "toggleSave"),
			currentPage,
			pageSize,
			currentSortBy: agGrid.currentSortBy,
			currentSortOrder: agGrid.currentSortOrder,
			handleClearSelection: selection.handleClearSelection,
			selectedRowIds: selection.selectedRowIds,
			handleCopyFocusedCell: agGrid.handleCopyFocusedCell,
			currentFilterJSON,
			searchQuery: computed(() => props.search)
		});
		async function onDeleteColumnFunction(columnId) {
			await dataTableOperations.onDeleteColumn(columnId);
		}
		async function onRenameColumnFunction(columnId, columnName) {
			await dataTableOperations.onRenameColumn(columnId, columnName);
		}
		async function onAddColumnFunction(column) {
			return await dataTableOperations.onAddColumn(column);
		}
		async function onAddRowClickFunction() {
			await dataTableOperations.onAddRowClick();
		}
		async function fetchDataTableRowsFunction() {
			await dataTableOperations.fetchDataTableRows();
		}
		const initialize = async (params) => {
			agGrid.onGridReady(params);
			dataTableColumns.loadColumns(props.dataTable.columns);
			agGrid.setGridData({ colDefs: dataTableColumns.colDefs.value });
			await dataTableOperations.fetchDataTableRows();
		};
		const customNoRowsOverlay = `<div class="no-rows-overlay ag-overlay-no-rows-center" data-test-id="data-table-no-rows-overlay">${i18n.baseText("dataTable.noRows")}</div>`;
		watch([agGrid.currentSortBy, agGrid.currentSortOrder], async () => {
			await setCurrentPage(1);
		});
		watch(currentFilterJSON, async () => {
			await setCurrentPage(1);
		});
		const onSearchChange = async () => {
			await setCurrentPage(1);
		};
		const debouncedOnSearchChange = debounce(onSearchChange, {
			debounceTime: 250,
			trailing: true
		});
		watch(() => props.search, () => {
			debouncedOnSearchChange();
		});
		__expose({
			addRow: dataTableOperations.onAddRowClick,
			addColumn: dataTableOperations.onAddColumn
		});
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", { class: normalizeClass(_ctx.$style.wrapper) }, [createBaseVNode("div", {
				ref_key: "gridContainerRef",
				ref: gridContainerRef,
				class: normalizeClass([_ctx.$style["grid-container"], { [_ctx.$style["has-records"]]: hasRecords.value }]),
				"data-test-id": "data-table-grid"
			}, [createVNode(unref(Be), {
				style: { "width": "100%" },
				"dom-layout": "autoHeight",
				"row-height": unref(33),
				"header-height": unref(36),
				"animate-rows": false,
				theme: unref(n8nTheme),
				"suppress-drag-leave-hides-columns": true,
				loading: unref(dataTableOperations).contentLoading.value,
				"row-selection": unref(selection).rowSelection,
				"get-row-id": (params) => String(params.data.id),
				"stop-editing-when-cells-lose-focus": true,
				"undo-redo-cell-editing": true,
				"suppress-multi-sort": true,
				"overlay-no-rows-template": customNoRowsOverlay,
				onGridReady: initialize,
				onCellValueChanged: unref(dataTableOperations).onCellValueChanged,
				onColumnMoved: unref(dataTableOperations).onColumnMoved,
				onCellClicked: unref(agGrid).onCellClicked,
				onCellEditingStarted: unref(agGrid).onCellEditingStarted,
				onCellEditingStopped: unref(agGrid).onCellEditingStopped,
				onColumnHeaderClicked: unref(agGrid).resetLastFocusedCell,
				onSelectionChanged: unref(selection).onSelectionChanged,
				onSortChanged: _cache[0] || (_cache[0] = (e) => unref(agGrid).onSortChanged(e, unref(dataTableColumns).colDefs.value)),
				onCellKeyDown: unref(dataTableOperations).onCellKeyDown,
				onFilterChanged: unref(onFilterChanged$1)
			}, null, 8, [
				"row-height",
				"header-height",
				"theme",
				"loading",
				"row-selection",
				"get-row-id",
				"onCellValueChanged",
				"onColumnMoved",
				"onCellClicked",
				"onCellEditingStarted",
				"onCellEditingStopped",
				"onColumnHeaderClicked",
				"onSelectionChanged",
				"onCellKeyDown",
				"onFilterChanged"
			]), createBaseVNode("div", { class: normalizeClass(_ctx.$style.footer) }, [createVNode(unref(ElPagination), {
				"current-page": unref(currentPage),
				"onUpdate:currentPage": [_cache[1] || (_cache[1] = ($event) => isRef(currentPage) ? currentPage.value = $event : null), unref(setCurrentPage)],
				"page-size": unref(pageSize),
				"onUpdate:pageSize": _cache[2] || (_cache[2] = ($event) => isRef(pageSize) ? pageSize.value = $event : null),
				"data-test-id": "data-table-content-pagination",
				background: "",
				total: unref(totalItems),
				"page-sizes": unref(pageSizeOptions),
				layout: "total, prev, pager, next, sizes",
				onSizeChange: _cache[3] || (_cache[3] = (val) => unref(setPageSize)(val))
			}, null, 8, [
				"current-page",
				"page-size",
				"total",
				"page-sizes",
				"onUpdate:currentPage"
			])], 2)], 2), createVNode(SelectedItemsInfo_default, {
				"selected-count": unref(selection).selectedCount.value,
				onDeleteSelected: unref(dataTableOperations).handleDeleteSelected,
				onClearSelection: unref(selection).handleClearSelection
			}, null, 8, [
				"selected-count",
				"onDeleteSelected",
				"onClearSelection"
			])], 2);
		};
	}
});
const wrapper = "_wrapper_5g1dh_123";
const footer = "_footer_5g1dh_276";
var DataTableTable_vue_vue_type_style_index_0_lang_module_default = {
	wrapper,
	"has-records": "_has-records_5g1dh_241",
	"grid-container": "_grid-container_5g1dh_266",
	footer
};
var DataTableTable_default = /* @__PURE__ */ __plugin_vue_export_helper_default(DataTableTable_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": DataTableTable_vue_vue_type_style_index_0_lang_module_default }]]);
var _hoisted_1 = {
	key: 0,
	"data-test-id": "data-table-details-loading"
};
var _hoisted_2 = { key: 1 };
var DataTableDetailsView_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "DataTableDetailsView",
	props: {
		id: {},
		projectId: {}
	},
	setup(__props) {
		const props = __props;
		const toast = useToast();
		const i18n = useI18n();
		const router = useRouter();
		const documentTitle = useDocumentTitle();
		const dataTableStore = useDataTableStore();
		const loading = ref(false);
		const saving$1 = ref(false);
		const dataTable = ref(null);
		const dataTableTableRef = ref();
		const searchQuery = ref("");
		const { debounce } = useDebounce();
		const showErrorAndGoBackToList = async (error) => {
			if (!(error instanceof Error)) error = new Error(String(i18n.baseText("dataTable.getDetails.error")));
			toast.showError(error, i18n.baseText("dataTable.getDetails.error"));
			await router.push({
				name: DATA_TABLE_VIEW,
				params: { projectId: props.projectId }
			});
		};
		const initialize = async () => {
			loading.value = true;
			try {
				const response = await dataTableStore.fetchOrFindDataTable(props.id, props.projectId);
				if (response) {
					dataTable.value = response;
					documentTitle.set(`${i18n.baseText("dataTable.dataTables")} > ${response.name}`);
				} else await showErrorAndGoBackToList(new Error(i18n.baseText("dataTable.notFound")));
			} catch (error) {
				await showErrorAndGoBackToList(error);
			} finally {
				loading.value = false;
			}
		};
		const debouncedSetSaving = debounce((value) => {
			saving$1.value = value;
		}, {
			debounceTime: 50,
			trailing: true
		});
		const debouncedHideSaving = debounce(() => {
			saving$1.value = false;
		}, {
			debounceTime: 500,
			trailing: true
		});
		const onToggleSave = (value) => {
			if (value) debouncedSetSaving(true);
			else debouncedHideSaving();
		};
		const onAddColumn = async (column) => {
			if (!dataTableTableRef.value) return {
				success: false,
				errorMessage: i18n.baseText("dataTable.error.tableNotInitialized")
			};
			return await dataTableTableRef.value.addColumn(column);
		};
		onMounted(async () => {
			documentTitle.set(i18n.baseText("dataTable.dataTables"));
			await initialize();
		});
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", {
				class: normalizeClass(_ctx.$style["data-table-details-view"]),
				"data-test-id": "data-table-details-view"
			}, [loading.value ? (openBlock(), createElementBlock("div", _hoisted_1, [createVNode(unref(N8nLoading_default), {
				variant: "h1",
				loading: true,
				rows: 1,
				"shrink-last": false,
				class: normalizeClass(_ctx.$style["header-loading"])
			}, null, 8, ["class"]), createVNode(unref(N8nLoading_default), {
				loading: true,
				variant: "h1",
				rows: 10,
				"shrink-last": false
			})])) : dataTable.value ? (openBlock(), createElementBlock("div", _hoisted_2, [createBaseVNode("div", { class: normalizeClass(_ctx.$style.header) }, [
				createVNode(DataTableBreadcrumbs_default, { "data-table": dataTable.value }, null, 8, ["data-table"]),
				saving$1.value ? (openBlock(), createElementBlock("div", {
					key: 0,
					class: normalizeClass(_ctx.$style.saving)
				}, [createVNode(unref(N8nSpinner_default)), createVNode(unref(N8nText_default), null, {
					default: withCtx(() => [createTextVNode(toDisplayString(unref(i18n).baseText("generic.saving")) + "...", 1)]),
					_: 1
				})], 2)) : createCommentVNode("", true),
				createBaseVNode("div", { class: normalizeClass(_ctx.$style.actions) }, [
					createVNode(unref(N8nInput_default), {
						modelValue: searchQuery.value,
						"onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => searchQuery.value = $event),
						"data-test-id": "data-table-search-input",
						size: "small",
						class: normalizeClass(_ctx.$style.search),
						placeholder: unref(i18n).baseText("generic.search")
					}, {
						prefix: withCtx(() => [createVNode(unref(N8nIcon_default), { icon: "search" })]),
						suffix: withCtx(() => [createVNode(unref(N8nTooltip_default), { placement: "bottom" }, {
							content: withCtx(() => [createTextVNode(toDisplayString(unref(i18n).baseText("dataTable.search.dateSearchInfo")), 1)]),
							default: withCtx(() => [createBaseVNode("span", { class: normalizeClass(_ctx.$style.infoIcon) }, [createVNode(unref(N8nIcon_default), {
								icon: "info",
								size: "small"
							})], 2)]),
							_: 1
						})]),
						_: 1
					}, 8, [
						"modelValue",
						"class",
						"placeholder"
					]),
					createVNode(unref(N8nButton_default), {
						"data-test-id": "data-table-header-add-row-button",
						onClick: dataTableTableRef.value?.addRow
					}, {
						default: withCtx(() => [createTextVNode(toDisplayString(unref(i18n).baseText("dataTable.addRow.label")), 1)]),
						_: 1
					}, 8, ["onClick"]),
					createVNode(AddColumnButton_default, {
						"use-text-trigger": true,
						"popover-id": "ds-details-add-column-popover",
						params: { onAddColumn }
					}, null, 8, ["params"])
				], 2)
			], 2), createBaseVNode("div", { class: normalizeClass(_ctx.$style.content) }, [createVNode(DataTableTable_default, {
				ref_key: "dataTableTableRef",
				ref: dataTableTableRef,
				"data-table": dataTable.value,
				search: searchQuery.value,
				onToggleSave
			}, null, 8, ["data-table", "search"])], 2)])) : createCommentVNode("", true)], 2);
		};
	}
});
const header = "_header_1jlz8_132";
const saving = "_saving_1jlz8_147";
const actions = "_actions_1jlz8_154";
const search = "_search_1jlz8_160";
const infoIcon = "_infoIcon_1jlz8_164";
var DataTableDetailsView_vue_vue_type_style_index_0_lang_module_default = {
	"data-table-details-view": "_data-table-details-view_1jlz8_123",
	"header-loading": "_header-loading_1jlz8_132",
	header,
	saving,
	actions,
	search,
	infoIcon
};
var DataTableDetailsView_default = /* @__PURE__ */ __plugin_vue_export_helper_default(DataTableDetailsView_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": DataTableDetailsView_vue_vue_type_style_index_0_lang_module_default }]]);
export { DataTableDetailsView_default as default };
